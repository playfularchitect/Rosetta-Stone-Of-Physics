# -*- coding: utf-8 -*-
"""Big Null Time V2 (Full).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xmp8t0_03dy5vmqJLlpyPgfmeNmEU4qL

Copyright 2025 Evan Wesley
                                Licensed under the Apache License, Version 2.0 (the "License");
                                you may not use this file except in compliance with the License.
                                You may obtain a copy of the License at
                                http://www.apache.org/licenses/LICENSE-2.0

                                Unless required by applicable law or agreed to in writing, software
                                distributed under the License is distributed on an "AS IS" BASIS,
                                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                See the License for the specific language governing permissions and
                                limitations under the License.






                                  Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS
"""

# -*- coding: utf-8 -*-
"""Big Null Time V2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kmwPxK9mhWlzT2XupkGROPulkDiCTQCt
"""

# =============================================================================
# Fraction Physics Kernel v4 (FPK v4) — unified MDL + scalar snap null engine
# =============================================================================
# Paste this cell at the TOP of a fresh Colab.
# It will:
#   • Define your 19-parameter registry (with hard-coded rationals).
#   • Compute real MDL bits from denominators (should be 353).
#   • Compile a C++/OpenMP kernel for MDL null + scalar snap null.
#   • Expose helpers:
#       - fpk_mdl_null(...)
#       - fpk_build_rational_family(...)
#       - fpk_snap_null_scalar(...)
#       - fpk_run_big_snap_null_scalar(...)
#
# You can control speed by:
#   • Changing OMP_NUM_THREADS via os.environ['OMP_NUM_THREADS'].
#   • Changing num_universes / total_universes / batch_size in helpers.
# =============================================================================

import os, math, time, ctypes, subprocess, textwrap, random
from fractions import Fraction

try:
    import numpy as np
except ImportError:
    raise RuntimeError("This kernel requires numpy. Install it in Colab with: !pip install numpy")

# -----------------------------------------------------------------------------
# 1. REGISTRY: 19 parameters with their chosen rationals (your ledger)
# -----------------------------------------------------------------------------
# We store: group, name, value (float), p, q
# These p/q are exactly the ones that gave you the 353-bit MDL scoreboard.

REG = [
    # group,          name,                value,                p,       q
    ("CKM",           "CKM_s12",           0.224299998336,       13482,   60107),
    ("CKM",           "CKM_s13",           0.003939999959,       1913,    485533),
    ("CKM",           "CKM_s23",           0.042200001315,       6419,    152109),
    ("CKM",           "CKM_delta_over_pi", 0.381971862314,       6869,    17983),
    ("COUPLINGS",     "alpha",             0.007297352601,       2639,    361638),
    ("COUPLINGS",     "alpha_s_MZ",        0.117899998815,       9953,    84419),
    ("COUPLINGS",     "sin2_thetaW",       0.231220000589,       7852,    33959),
    ("EW",            "MW_over_v",         0.326452417182,       17807,   54547),
    ("EW",            "MZ_over_v",         0.370350617284,       18749,   50625),
    ("HIGGS",         "MH_over_v",         0.508692138982,       22034,   43315),
    ("LEPTON_YUKAWA", "me_over_v",         0.000002075378,       43,      20719113),
    ("LEPTON_YUKAWA", "mmu_over_v",        0.000429122429,       421,     981072),
    ("LEPTON_YUKAWA", "mtau_over_v",       0.007216564566,       2561,    354878),
    ("QUARK_HEAVY",   "mb_over_v",         0.016976711567,       3268,    192499),
    ("QUARK_HEAVY",   "mc_over_v",         0.005157996117,       1687,    327065),
    ("QUARK_HEAVY",   "mt_over_v",         0.701365634918,       24087,   34343),
    ("QUARK_LIGHT",   "md_over_v",         0.000018966805,       111,     5852330),
    ("QUARK_LIGHT",   "ms_over_v",         0.000377711528,       411,     1088132),
    ("QUARK_LIGHT",   "mu_over_v",         0.000008772655,       83,      9461218),
]

FPK_Q_MAX = 2**25  # global denominator cap used in MDL null tests (same scale as before)

# Build arrays for real values and denominators
FPK_X_REAL = np.array([row[2] for row in REG], dtype=np.float64)
FPK_Q_REAL = np.array([row[4] for row in REG], dtype=np.int64)
FPK_BITS_REAL = np.array([math.ceil(math.log2(int(q))) for q in FPK_Q_REAL], dtype=np.int64)
FPK_MDL_REAL = int(FPK_BITS_REAL.sum())

print("===============================================================================")
print("[FPK v4] Registry loaded: {} parameters.".format(len(REG)))
for (g,n,x,p,q,b) in [(g,n,x,p,q,math.ceil(math.log2(q))) for (g,n,x,p,q) in REG]:
    print("    {:15s} {:20s}  value≈{: .12g}   p/q={:d}/{:d}  bits={}".format(g, n, x, p, q, b))
print("-------------------------------------------------------------------------------")
print("[FPK v4] Real-universe MDL (from denominators) = {} bits".format(FPK_MDL_REAL))
print("===============================================================================")

# -----------------------------------------------------------------------------
# 2. C++/OpenMP kernel source (MDL null + scalar snap-null)
# -----------------------------------------------------------------------------
CPP_SRC = r"""
#include <cmath>
#include <cstdint>
#include <limits>
#include <omp.h>

extern "C" {

// Simple SplitMix64 RNG for thread-local use
static inline uint64_t splitmix64(uint64_t &state) {
    uint64_t z = (state += 0x9e3779b97f4a7c15ULL);
    z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9ULL;
    z = (z ^ (z >> 27)) * 0x94d049bb133111ebULL;
    z = z ^ (z >> 31);
    return z;
}

// Uniform double in [0,1)
static inline double rand_uniform_01(uint64_t &state) {
    return (splitmix64(state) >> 11) * (1.0 / 9007199254740992.0);
}

// Approximate double x by p/q with 1 <= q <= max_den using continued fractions.
// Similar to Fraction.limit_denominator, but not guaranteed identical.
void approx_fraction(double x, uint64_t max_den, int64_t* p_out, int64_t* q_out) {
    if (!std::isfinite(x) || x == 0.0) {
        *p_out = 0;
        *q_out = 1;
        return;
    }
    int sign = 1;
    if (x < 0) {
        sign = -1;
        x = -x;
    }

    double floor_x = std::floor(x);
    if (x == floor_x) {
        *p_out = (int64_t)floor_x * sign;
        *q_out = 1;
        return;
    }

    uint64_t n0 = 0, d0 = 1;
    uint64_t n1 = 1, d1 = 0;

    double value = x;
    while (true) {
        double a_d = std::floor(value);
        if (!std::isfinite(a_d)) break;
        uint64_t a = (uint64_t)a_d;

        uint64_t n2 = a * n1 + n0;
        uint64_t d2 = a * d1 + d0;

        if (d2 > max_den) {
            if (d1 == 0) {
                *p_out = (int64_t)(sign * (int64_t)n0);
                *q_out = (int64_t)d0;
                return;
            }
            uint64_t k = (max_den - d0) / d1;
            if (k == 0) {
                *p_out = (int64_t)(sign * (int64_t)n1);
                *q_out = (int64_t)d1;
            } else {
                uint64_t n_c = k * n1 + n0;
                uint64_t d_c = k * d1 + d0;
                double r1 = (double)n1 / (double)d1;
                double r_c = (double)n_c / (double)d_c;
                double err1 = std::fabs(r1 - x);
                double errc = std::fabs(r_c - x);
                if (errc <= err1) {
                    *p_out = (int64_t)(sign * (int64_t)n_c);
                    *q_out = (int64_t)d_c;
                } else {
                    *p_out = (int64_t)(sign * (int64_t)n1);
                    *q_out = (int64_t)d1;
                }
            }
            return;
        }

        n0 = n1; d0 = d1;
        n1 = n2; d1 = d2;

        double frac = value - a_d;
        if (frac == 0.0) {
            *p_out = (int64_t)(sign * (int64_t)n1);
            *q_out = (int64_t)d1;
            return;
        }
        value = 1.0 / frac;
    }
    *p_out = (int64_t)(sign * (int64_t)n1);
    *q_out = (int64_t)d1;
}

// Integer bit-length: ceil(log2(n)) for positive n
static inline int bit_length(uint64_t n) {
    int bits = 0;
    while (n) {
        n >>= 1;
        bits++;
    }
    return bits > 0 ? bits : 1;
}

// MDL null over an n-parameter registry.
// x_real: real parameter values
// n_params: length of x_real
// log_width_decades: sample u ~ Uniform[-log_width, +log_width], x_fake = x_real * 10^u
// max_den: global denominator cap
// seed: RNG seed
// N: number of universes
// real_mdl_bits: MDL of the real universe (for count_le)
// Outputs: mean, std, min, max, count_le
void mdl_null_global(
    const double* x_real,
    int n_params,
    double log_width_decades,
    uint64_t max_den,
    uint64_t seed,
    uint64_t N,
    double real_mdl_bits,
    double* out_mean,
    double* out_std,
    int* out_min,
    int* out_max,
    uint64_t* out_count_le
) {
    double sum = 0.0;
    double sum_sq = 0.0;
    int min_mdl = std::numeric_limits<int>::max();
    int max_mdl = std::numeric_limits<int>::min();
    uint64_t count_le = 0;

    #pragma omp parallel
    {
        uint64_t state = seed + 0x9e3779b97f4a7c15ULL * (uint64_t)omp_get_thread_num();
        double local_sum = 0.0;
        double local_sum_sq = 0.0;
        int local_min = std::numeric_limits<int>::max();
        int local_max = std::numeric_limits<int>::min();
        uint64_t local_count_le = 0;

        #pragma omp for
        for (uint64_t j = 0; j < N; ++j) {
            double mdl_bits = 0.0;
            for (int i = 0; i < n_params; ++i) {
                double u = (rand_uniform_01(state) * 2.0 - 1.0) * log_width_decades;
                double factor = std::pow(10.0, u);
                double x_fake = x_real[i] * factor;
                int64_t p, q;
                approx_fraction(x_fake, max_den, &p, &q);
                uint64_t q_abs = (uint64_t)(q < 0 ? -q : q);
                if (q_abs == 0) q_abs = 1;
                int bits = bit_length(q_abs);
                mdl_bits += (double)bits;
            }
            int mdl_int = (int)llround(mdl_bits);
            local_sum += mdl_bits;
            local_sum_sq += mdl_bits * mdl_bits;
            if (mdl_int < local_min) local_min = mdl_int;
            if (mdl_int > local_max) local_max = mdl_int;
            if (mdl_bits <= real_mdl_bits + 1e-9) {
                local_count_le++;
            }
        }

        #pragma omp critical
        {
            sum += local_sum;
            sum_sq += local_sum_sq;
            if (local_min < min_mdl) min_mdl = local_min;
            if (local_max > max_mdl) max_mdl = local_max;
            count_le += local_count_le;
        }
    }

    double N_d = (double)N;
    double mean = sum / N_d;
    double var = sum_sq / N_d - mean * mean;
    if (var < 0.0) var = 0.0;
    double std = std::sqrt(var);

    *out_mean = mean;
    *out_std = std;
    *out_min = min_mdl;
    *out_max = max_mdl;
    *out_count_le = count_le;
}

// Scalar snap-null test with pre-built rational family.
// Draw x_fake ~ Uniform[band_min, band_max] and compute
//   d_min = min_i |x_fake - rats[i]|,
// where rats[] is sorted ascending.
void snap_null_scalar_uniform(
    double x_real,               // not used inside, kept for symmetry
    double eps_real,
    const double* rats,
    uint64_t n_rats,
    double band_min,
    double band_max,
    uint64_t seed,
    uint64_t N,
    double* out_mean_dmin,
    double* out_min_dmin,
    double* out_max_dmin,
    uint64_t* out_count_le
) {
    double sum = 0.0;
    double sum_sq = 0.0;
    double min_d = std::numeric_limits<double>::infinity();
    double max_d = 0.0;
    uint64_t count_le = 0;

    double width = band_max - band_min;
    if (width <= 0.0) {
        *out_mean_dmin = 0.0;
        *out_min_dmin = 0.0;
        *out_max_dmin = 0.0;
        *out_count_le = 0;
        return;
    }

    #pragma omp parallel
    {
        uint64_t state = seed + 0x9e3779b97f4a7c15ULL * (uint64_t)omp_get_thread_num();
        double local_sum = 0.0;
        double local_sum_sq = 0.0;
        double local_min = std::numeric_limits<double>::infinity();
        double local_max = 0.0;
        uint64_t local_count_le = 0;

        #pragma omp for
        for (uint64_t j = 0; j < N; ++j) {
            double u = rand_uniform_01(state);
            double x = band_min + width * u;

            // binary search in rats[0..n_rats-1] (sorted)
            int lo = 0;
            int hi = (int)n_rats;
            while (lo < hi) {
                int mid = (lo + hi) >> 1;
                double v = rats[mid];
                if (v < x) lo = mid + 1;
                else hi = mid;
            }
            double dmin = std::numeric_limits<double>::infinity();
            if (lo < (int)n_rats) {
                double d = std::fabs(rats[lo] - x);
                if (d < dmin) dmin = d;
            }
            if (lo > 0) {
                double d = std::fabs(rats[lo-1] - x);
                if (d < dmin) dmin = d;
            }
            if (!std::isfinite(dmin)) dmin = 0.0;

            local_sum += dmin;
            local_sum_sq += dmin * dmin;
            if (dmin < local_min) local_min = dmin;
            if (dmin > local_max) local_max = dmin;
            if (dmin <= eps_real) local_count_le++;
        }

        #pragma omp critical
        {
            sum += local_sum;
            sum_sq += local_sum_sq;
            if (local_min < min_d) min_d = local_min;
            if (local_max > max_d) max_d = local_max;
            count_le += local_count_le;
        }
    }

    double N_d = (double)N;
    double mean = sum / N_d;
    double var = sum_sq / N_d - mean * mean;
    if (var < 0.0) var = 0.0;
    double std = std::sqrt(var);
    (void)std; // not currently returned

    *out_mean_dmin = mean;
    *out_min_dmin = min_d;
    *out_max_dmin = max_d;
    *out_count_le = count_le;
}

} // extern "C"
"""

# -----------------------------------------------------------------------------
# 3. Compile & load the C++ kernel as a shared library
# -----------------------------------------------------------------------------
so_path = "/tmp/fpk_v4_kernel.so"
cpp_path = "/tmp/fpk_v4_kernel.cpp"

with open(cpp_path, "w") as f:
    f.write(CPP_SRC)

print("[FPK v4] Compiling C++ kernel (this happens once per runtime)...")
cmd = ["g++", "-O3", "-shared", "-fPIC", "-fopenmp", cpp_path, "-o", so_path]
res = subprocess.run(cmd, capture_output=True, text=True)
if res.returncode != 0:
    print(res.stderr)
    raise RuntimeError("[FPK v4] Compilation failed.")
print("[FPK v4] Compilation OK.")

FPK_LIB = ctypes.cdll.LoadLibrary(so_path)

# Bind argtypes
FPK_LIB.mdl_null_global.argtypes = [
    ctypes.POINTER(ctypes.c_double),  # x_real
    ctypes.c_int,                     # n_params
    ctypes.c_double,                  # log_width_decades
    ctypes.c_uint64,                  # max_den
    ctypes.c_uint64,                  # seed
    ctypes.c_uint64,                  # N
    ctypes.c_double,                  # real_mdl_bits
    ctypes.POINTER(ctypes.c_double),  # out_mean
    ctypes.POINTER(ctypes.c_double),  # out_std
    ctypes.POINTER(ctypes.c_int),     # out_min
    ctypes.POINTER(ctypes.c_int),     # out_max
    ctypes.POINTER(ctypes.c_uint64),  # out_count_le
]

FPK_LIB.snap_null_scalar_uniform.argtypes = [
    ctypes.c_double,                  # x_real (unused inside)
    ctypes.c_double,                  # eps_real
    ctypes.POINTER(ctypes.c_double),  # rats
    ctypes.c_uint64,                  # n_rats
    ctypes.c_double,                  # band_min
    ctypes.c_double,                  # band_max
    ctypes.c_uint64,                  # seed
    ctypes.c_uint64,                  # N
    ctypes.POINTER(ctypes.c_double),  # out_mean_dmin
    ctypes.POINTER(ctypes.c_double),  # out_min_dmin
    ctypes.POINTER(ctypes.c_double),  # out_max_dmin
    ctypes.POINTER(ctypes.c_uint64),  # out_count_le
]

print("===============================================================================")
print("[FPK v4] Kernel loaded and ready.")
print("        • Use fpk_mdl_null(...) for MDL null tests.")
print("        • Use fpk_build_rational_family(...) to build snap families.")
print("        • Use fpk_snap_null_scalar(...) or fpk_run_big_snap_null_scalar(...)")
print("===============================================================================")

# -----------------------------------------------------------------------------
# 4. Python helpers wrapping the kernel
# -----------------------------------------------------------------------------

def fpk_mdl_null(num_universes=100_000, width_decades=1.0, seed=12345, q_max=FPK_Q_MAX, verbose=True):
    """
    Run an MDL null test for the full 19-parameter registry.

    Arguments:
        num_universes  : number of fake universes to sample
        width_decades  : uniform width in log10-space around each real param (±width)
        seed           : RNG seed (uint64)
        q_max          : denominator cap for limit_denominator
        verbose        : print summary

    Returns: dict with keys:
        'mdl_real', 'mean', 'std', 'min', 'max', 'count_le', 'p_le',
        'num_universes', 'width_decades', 'q_max', 'seed', 'elapsed_sec',
        'universes_per_sec'
    """
    x_arr = np.asarray(FPK_X_REAL, dtype=np.float64)
    n_params = x_arr.size

    x_c = (ctypes.c_double * n_params)(*x_arr.tolist())
    out_mean = ctypes.c_double()
    out_std  = ctypes.c_double()
    out_min  = ctypes.c_int()
    out_max  = ctypes.c_int()
    out_count = ctypes.c_uint64()

    t0 = time.time()
    FPK_LIB.mdl_null_global(
        x_c,
        int(n_params),
        float(width_decades),
        int(q_max),
        int(seed),
        int(num_universes),
        float(FPK_MDL_REAL),
        ctypes.byref(out_mean),
        ctypes.byref(out_std),
        ctypes.byref(out_min),
        ctypes.byref(out_max),
        ctypes.byref(out_count),
    )
    t1 = time.time()
    elapsed = t1 - t0
    throughput = num_universes / elapsed if elapsed > 0 else float("inf")

    mean_bits = out_mean.value
    std_bits  = out_std.value
    min_bits  = out_min.value
    max_bits  = out_max.value
    count_le  = out_count.value
    p_le      = count_le / float(num_universes)

    if verbose:
        print("----------------------------------------------------------------")
        print("[FPK v4] MDL null run (global q_max={}, width=±{} decades)".format(q_max, width_decades))
        print("        N_universes        : {:,}".format(num_universes))
        print("        RNG seed           : {}".format(seed))
        print("        Real MDL bits      : {}".format(FPK_MDL_REAL))
        print("        Null mean bits     : {:.3f}".format(mean_bits))
        print("        Null std bits      : {:.3f}".format(std_bits))
        print("        Null min / max     : {} / {}".format(min_bits, max_bits))
        print("        Fraction with MDL ≤ real : {} / {} (p_le ≈ {:.3g})".format(
            count_le, num_universes, p_le))
        print("        Elapsed time       : {:.3f} s".format(elapsed))
        print("        Throughput         : {:,.0f} universes / s".format(throughput))
        print("----------------------------------------------------------------")

    return {
        "mdl_real": FPK_MDL_REAL,
        "mean": mean_bits,
        "std": std_bits,
        "min": int(min_bits),
        "max": int(max_bits),
        "count_le": int(count_le),
        "p_le": p_le,
        "num_universes": int(num_universes),
        "width_decades": float(width_decades),
        "q_max": int(q_max),
        "seed": int(seed),
        "elapsed_sec": float(elapsed),
        "universes_per_sec": float(throughput),
    }

def fpk_build_rational_family(band_min, band_max, q_max=1000, bits_max=20, verbose=True):
    """
    Build a family of rationals p/q in [band_min, band_max] with:
        1 <= q <= q_max
        bits(p/q) = ceil(log2(q)) <= bits_max

    Returns: numpy array of candidate values, sorted ascending.
    """
    vals = []
    band_min = float(band_min)
    band_max = float(band_max)
    if band_min > band_max:
        band_min, band_max = band_max, band_min

    for q in range(1, q_max + 1):
        bits = math.ceil(math.log2(q))
        if bits > bits_max:
            continue
        p_min = math.floor(band_min * q)
        p_max = math.ceil(band_max * q)
        for p in range(p_min, p_max + 1):
            v = p / q
            if v < band_min or v > band_max:
                continue
            vals.append(v)

    if not vals:
        rats = np.empty(0, dtype=np.float64)
    else:
        rats = np.array(sorted(set(vals)), dtype=np.float64)

    if verbose:
        print("----------------------------------------------------------------")
        print("[FPK v4] Built rational family for snap tests:")
        print("        band         : [{:.3g}, {:.3g}]".format(band_min, band_max))
        print("        q_max        : {}".format(q_max))
        print("        bits_max     : {}".format(bits_max))
        print("        # candidates : {:,}".format(rats.size))
        if rats.size > 0:
            first = rats[:10]
            print("        first few    :", first)
        print("----------------------------------------------------------------")
    return rats

def fpk_snap_null_scalar(x_real, eps_real, rats, band_min, band_max,
                         num_universes=200_000, seed=123456, verbose=True):
    """
    Run scalar snap-null test with a pre-built rational family.

    Arguments:
        x_real         : real-world value (only used for labeling)
        eps_real       : real-world residual to the chosen target rational
        rats           : 1D numpy array of rationals (sorted, ascending)
        band_min, band_max : uniform band for null draws
        num_universes  : # of random draws
        seed           : RNG seed
        verbose        : print summary

    Returns: dict with:
        'mean_dmin', 'min_dmin', 'max_dmin', 'count_le', 'p_emp',
        'num_universes', 'seed', 'band_min', 'band_max',
        'elapsed_sec', 'universes_per_sec'
    """
    rats = np.asarray(rats, dtype=np.float64)
    if rats.ndim != 1:
        raise ValueError("rats must be 1D array")
    # make sure sorted
    rats = np.sort(rats)
    n_rats = rats.size
    if n_rats == 0:
        raise ValueError("rational family is empty")

    rats_c = (ctypes.c_double * n_rats)(*rats.tolist())
    out_mean_d = ctypes.c_double()
    out_min_d  = ctypes.c_double()
    out_max_d  = ctypes.c_double()
    out_count  = ctypes.c_uint64()

    t0 = time.time()
    FPK_LIB.snap_null_scalar_uniform(
        float(x_real),
        float(eps_real),
        rats_c,
        int(n_rats),
        float(band_min),
        float(band_max),
        int(seed),
        int(num_universes),
        ctypes.byref(out_mean_d),
        ctypes.byref(out_min_d),
        ctypes.byref(out_max_d),
        ctypes.byref(out_count),
    )
    t1 = time.time()
    elapsed = t1 - t0
    throughput = num_universes / elapsed if elapsed > 0 else float("inf")

    mean_dmin = out_mean_d.value
    min_dmin  = out_min_d.value
    max_dmin  = out_max_d.value
    count_le  = out_count.value
    p_emp     = count_le / float(num_universes)

    if verbose:
        print("----------------------------------------------------------------")
        print("[FPK v4] Scalar snap-null run:")
        print("        x_real          : {:.12g}".format(x_real))
        print("        eps_real        : {:.3e}".format(eps_real))
        print("        band            : [{:.3g}, {:.3g}]".format(band_min, band_max))
        print("        # rationals     : {:,}".format(n_rats))
        print("        N_universes     : {:,}".format(num_universes))
        print("        RNG seed        : {}".format(seed))
        print("        mean d_min      : {:.3e}".format(mean_dmin))
        print("        min / max d_min : {:.3e} / {:.3e}".format(min_dmin, max_dmin))
        print("        count(d ≤ eps)  : {} / {} (p_emp ≈ {:.3g})".format(
            count_le, num_universes, p_emp))
        print("        Elapsed time    : {:.3f} s".format(elapsed))
        print("        Throughput      : {:,.0f} universes / s".format(throughput))
        print("----------------------------------------------------------------")

    return {
        "mean_dmin": mean_dmin,
        "min_dmin": min_dmin,
        "max_dmin": max_dmin,
        "count_le": int(count_le),
        "p_emp": p_emp,
        "num_universes": int(num_universes),
        "seed": int(seed),
        "band_min": float(band_min),
        "band_max": float(band_max),
        "elapsed_sec": float(elapsed),
        "universes_per_sec": float(throughput),
    }

def fpk_run_big_snap_null_scalar(name, x_real, eps_real,
                                 band_min, band_max,
                                 q_max=1000, bits_max=20,
                                 total_universes=2_000_000,
                                 batch_size=50_000,
                                 seed_base=97531,
                                 verbose=True):
    """
    Chunked variant for BIG scalar snap-null runs.

    It:
      • Builds the rational family once.
      • Splits total_universes into chunks of size batch_size.
      • Runs fpk_snap_null_scalar on each chunk with different seeds.
      • Aggregates mean/min/max/count_le and prints per-chunk throughput.

    Returns: dict with global statistics.

    You can tweak total_universes and batch_size to go into the millions.
    """
    if verbose:
        print("===============================================================================")
        print("[FPK v4-big] Running big snap-null for '{}' ...".format(name))
        print("===============================================================================")
        print("  x_real       = {:.12g}".format(x_real))
        print("  eps_real     = {:.3e}".format(eps_real))
        print("  band         = [{:.3g}, {:.3g}]".format(band_min, band_max))
        print("  q_max        = {}".format(q_max))
        print("  bits_max     = {}".format(bits_max))
        print("  total N      = {:,}".format(total_universes))
        print("  batch_size   = {:,}".format(batch_size))
        print("  seed_base    = {}".format(seed_base))
        print("-------------------------------------------------------------------------------")

    rats = fpk_build_rational_family(band_min, band_max, q_max=q_max, bits_max=bits_max, verbose=verbose)
    n_rats = rats.size
    if n_rats == 0:
        raise RuntimeError("No rationals generated in band; adjust band/q_max/bits_max.")

    n_chunks = (total_universes + batch_size - 1) // batch_size
    if verbose:
        print("  Will use {} chunk(s).".format(n_chunks))
        print("-------------------------------------------------------------------------------")

    sum_d = 0.0
    sum_d_sq = 0.0
    global_min = float("inf")
    global_max = 0.0
    global_count_le = 0
    done = 0
    t0_global = time.time()

    for k in range(n_chunks):
        n_this = batch_size if k < n_chunks - 1 else (total_universes - done)
        seed_k = seed_base + k

        t0 = time.time()
        res = fpk_snap_null_scalar(
            x_real=x_real,
            eps_real=eps_real,
            rats=rats,
            band_min=band_min,
            band_max=band_max,
            num_universes=n_this,
            seed=seed_k,
            verbose=False,
        )
        t1 = time.time()
        elapsed = t1 - t0
        thr = n_this / elapsed if elapsed > 0 else float("inf")

        mean_d = res["mean_dmin"]
        min_d  = res["min_dmin"]
        max_d  = res["max_dmin"]
        count_le = res["count_le"]

        sum_d += mean_d * n_this
        sum_d_sq += (res["mean_dmin"]**2 + (res["std"] if "std" in res else 0)**2) * n_this  # not super precise
        if min_d < global_min: global_min = min_d
        if max_d > global_max: global_max = max_d
        global_count_le += count_le
        done += n_this

        if verbose:
            print("[BIG-SNAP] Chunk {}/{}: N={:,}, elapsed={:6.3f} s, throughput={:10.0f} uni/s, "
                  "chunk mean d_min={:.3e}, min={:.3e}, max={:.3e}, count_le={}".format(
                      k+1, n_chunks, n_this, elapsed, thr, mean_d, min_d, max_d, count_le))

    t1_global = time.time()
    elapsed_global = t1_global - t0_global
    mean_global = sum_d / done
    # we don't track std exactly here; it's fine
    p_emp = global_count_le / float(done)
    thr_global = done / elapsed_global if elapsed_global > 0 else float("inf")

    if verbose:
        print("-------------------------------------------------------------------------------")
        print("[BIG-SNAP] GLOBAL SUMMARY for '{}'".format(name))
        print("      Total universes         : {:,}".format(done))
        print("      mean d_min              : {:.3e}".format(mean_global))
        print("      min / max d_min         : {:.3e} / {:.3e}".format(global_min, global_max))
        print("      count(d_min ≤ eps_real) : {} / {:,} (p_emp ≈ {:.3g})".format(
            global_count_le, done, p_emp))
        print("      Total elapsed time      : {:.3f} s".format(elapsed_global))
        print("      Overall throughput      : {:,.0f} universes / s".format(thr_global))
        print("-------------------------------------------------------------------------------")
        print("===============================================================================")

    return {
        "name": name,
        "x_real": float(x_real),
        "eps_real": float(eps_real),
        "band_min": float(band_min),
        "band_max": float(band_max),
        "q_max": int(q_max),
        "bits_max": int(bits_max),
        "total_universes": int(done),
        "mean_d_min": float(mean_global),
        "min_d_min": float(global_min),
        "max_d_min": float(global_max),
        "count_le": int(global_count_le),
        "p_emp": float(p_emp),
        "elapsed_sec": float(elapsed_global),
        "universes_per_sec": float(thr_global),
    }

print("===============================================================================")
print("[FPK v4] Setup complete. This cell defines the kernel + helpers.")
print("         You can now call fpk_mdl_null(...) and the snap helpers.")
print("===============================================================================")

# =============================================================================
# MODULE 1: BIG GLOBAL MDL NULL (10M UNIVERSES, 3 RUNS, CHUNKED, QUIET)
# =============================================================================
import os, time, math, json, hashlib, datetime

MODULE_NAME_1 = "MODULE_1_BIG_GLOBAL_MDL_NULL"

# ------------------ helper: SHA256 for config ------------------
def _sha256_of_config(cfg: dict) -> str:
    s = json.dumps(cfg, sort_keys=True)
    return hashlib.sha256(s.encode("utf-8")).hexdigest(), s

# ------------------ helper: combine chunk stats ------------------
def _combine_stats_chunkwise(chunks, mdl_real):
    """
    chunks: list of dicts with keys:
      'num_universes','mean','std','min','max','count_le'
    mdl_real: real MDL bits (same for all chunks)
    """
    N_total = 0
    mean_global = 0.0
    M2_global = 0.0
    min_global = float("inf")
    max_global = float("-inf")
    count_le_total = 0

    for c in chunks:
        Ni   = int(c["num_universes"])
        mi   = float(c["mean"])
        si   = float(c["std"])
        v_i  = si * si
        mni  = int(c["min"])
        mxi  = int(c["max"])
        cli  = int(c["count_le"])

        if Ni <= 0:
            continue

        if mni < min_global: min_global = mni
        if mxi > max_global: max_global = mxi
        count_le_total += cli

        if N_total == 0:
            N_total = Ni
            mean_global = mi
            M2_global = v_i * (Ni - 1)
        else:
            N_old = N_total
            mean_old = mean_global
            N_total = N_old + Ni
            delta = mi - mean_old
            mean_global = mean_old + delta * Ni / N_total
            M2_global = (
                M2_global
                + v_i * (Ni - 1)
                + delta * delta * (N_old * Ni / N_total)
            )

    if N_total > 1:
        var_global = M2_global / (N_total - 1)
        std_global = math.sqrt(var_global)
    else:
        std_global = float("nan")

    p_le = count_le_total / N_total if N_total > 0 else float("nan")
    z = (mdl_real - mean_global) / std_global if std_global > 0 else float("nan")

    return {
        "N_total": N_total,
        "mean_global": mean_global,
        "std_global": std_global,
        "min_global": min_global,
        "max_global": max_global,
        "count_le_total": count_le_total,
        "p_le": p_le,
        "z_score": z,
    }

# ------------------ helper: one big MDL run (chunked, quiet) ------------------
def run_big_mdl_null_chunked(
    label: str,
    total_universes: int = 10_000_000,
    batch_size: int = 200_000,
    width_decades: float = 1.0,
    seed_base: int = 424242,
    q_max: int = None,
    omp_threads: int | None = None,
):
    """
    Chunked MDL null driver:
      - Uses fpk_mdl_null(...) from FPK v4 kernel
      - Splits total_universes into chunks of batch_size
      - Does NOT spam per-chunk prints; only global summary.
    """
    if q_max is None:
        q_max = int(FPK_Q_MAX)

    # optionally fix OMP threads
    old_omp = os.environ.get("OMP_NUM_THREADS", None)
    if omp_threads is not None:
        os.environ["OMP_NUM_THREADS"] = str(omp_threads)

    # config + hash
    cfg = {
        "module": MODULE_NAME_1,
        "label": label,
        "date_iso": datetime.datetime.utcnow().isoformat() + "Z",
        "total_universes": int(total_universes),
        "batch_size": int(batch_size),
        "width_decades": float(width_decades),
        "seed_base": int(seed_base),
        "q_max": int(q_max),
        "omp_threads": omp_threads,
    }
    sha, cfg_str = _sha256_of_config(cfg)

    print("===============================================================================")
    print(f"[{MODULE_NAME_1}] {label}")
    print("Date (UTC)       :", cfg["date_iso"])
    print("Config JSON      :", cfg_str)
    print("Config SHA256    :", sha)
    print("-------------------------------------------------------------------------------")
    print(f"Using OMP_NUM_THREADS = {('default' if omp_threads is None else omp_threads)}")
    print(f"TOTAL_UNIVERSES       = {total_universes:,}")
    print(f"BATCH_SIZE            = {batch_size:,}")
    print(f"MDL width_decades     = ±{width_decades}")
    print(f"q_max                 = {q_max}")
    print(f"seed_base             = {seed_base}")
    print("-------------------------------------------------------------------------------")

    n_chunks = (total_universes + batch_size - 1) // batch_size
    chunks = []
    t0_global = time.time()
    mdl_real_ref = None

    for i in range(n_chunks):
        n_this = batch_size if (i < n_chunks - 1) else (total_universes - batch_size * (n_chunks - 1))
        seed_i = seed_base + i
        res = fpk_mdl_null(
            num_universes = int(n_this),
            width_decades = float(width_decades),
            seed          = int(seed_i),
            q_max         = int(q_max),
            verbose       = False,
        )
        mdl_real_i = res.get("mdl_real")
        if mdl_real_ref is None:
            mdl_real_ref = mdl_real_i

        chunks.append({
            "num_universes": res.get("num_universes", n_this),
            "mean": res.get("mean"),
            "std": res.get("std"),
            "min": res.get("min"),
            "max": res.get("max"),
            "count_le": res.get("count_le"),
        })

    t1_global = time.time()
    agg = _combine_stats_chunkwise(chunks, mdl_real=mdl_real_ref)
    total_elapsed = t1_global - t0_global
    overall_thr = total_universes / total_elapsed if total_elapsed > 0 else float("inf")

    print("-------------------------------------------------------------------------------")
    print(f"[{MODULE_NAME_1}] GLOBAL MDL NULL SUMMARY ({label})")
    print("     Total universes       :", f"{agg['N_total']:,}")
    print("     Real MDL bits         :", mdl_real_ref)
    print("     Null mean bits        :", f"{agg['mean_global']:.3f}")
    print("     Null std bits         :", f"{agg['std_global']:.3f}")
    print("     Null min / max bits   :", agg['min_global'], "/", agg['max_global'])
    print("     count(MDL <= real)    :", f"{agg['count_le_total']:,}", "/", f"{agg['N_total']:,}")
    print("     Empirical p_emp       :", f"{agg['p_le']:.3e}")
    print("     Z-score (Gaussian)    :", f"{agg['z_score']:.3f} σ")
    print("     Total elapsed time    :", f"{total_elapsed:6.3f} s")
    print("     Overall throughput    :", f"{overall_thr:10.0f} universes / s")
    print("     Config SHA256         :", sha)
    print("-------------------------------------------------------------------------------")

    # restore OMP threads
    if omp_threads is None:
        if old_omp is None:
            os.environ.pop("OMP_NUM_THREADS", None)
        else:
            os.environ["OMP_NUM_THREADS"] = old_omp

    return {
        "config": cfg,
        "config_sha256": sha,
        "agg": agg,
        "mdl_real": mdl_real_ref,
        "elapsed_sec": total_elapsed,
        "universes_per_sec": overall_thr,
    }

# ------------------ RUN 3 × 10M MDL NULLS ------------------
TOTAL_UNI_M1 = 10_000_000
BATCH_M1     = 200_000   # 50 chunks of 200k = 10M
THREADS_M1   = 2         # good default for Colab 2-core

print("===============================================================================")
print(f"{MODULE_NAME_1}: STARTING 3× BIG MDL RUNS (each 10M universes)")
print("===============================================================================")

M1_RUN1 = run_big_mdl_null_chunked(
    label           = "RUN1_main",
    total_universes = TOTAL_UNI_M1,
    batch_size      = BATCH_M1,
    width_decades   = 1.0,
    seed_base       = 101_000_000,
    q_max           = int(FPK_Q_MAX),
    omp_threads     = THREADS_M1,
)

M1_RUN2 = run_big_mdl_null_chunked(
    label           = "RUN2_independent_seed",
    total_universes = TOTAL_UNI_M1,
    batch_size      = BATCH_M1,
    width_decades   = 1.0,
    seed_base       = 202_000_000,
    q_max           = int(FPK_Q_MAX),
    omp_threads     = THREADS_M1,
)

M1_RUN3 = run_big_mdl_null_chunked(
    label           = "RUN3_independent_seed",
    total_universes = TOTAL_UNI_M1,
    batch_size      = BATCH_M1,
    width_decades   = 1.0,
    seed_base       = 303_000_000,
    q_max           = int(FPK_Q_MAX),
    omp_threads     = THREADS_M1,
)

print("===============================================================================")
print(f"{MODULE_NAME_1}: ALL 3 RUNS COMPLETED")
print("  RUN1 config SHA256:", M1_RUN1["config_sha256"])
print("  RUN2 config SHA256:", M1_RUN2["config_sha256"])
print("  RUN3 config SHA256:", M1_RUN3["config_sha256"])
print("===============================================================================")

# =============================================================================
# MODULE 2: BIG SCALAR SNAP NULL FOR ρ² = (M_W/M_Z)² (10M × 3 RUNS)
#          – LOOK-ELSEWHERE OVER SMALL-BIT RATIONALS
# =============================================================================
import os, time, math, json, hashlib, datetime
import numpy as np

MODULE_NAME_2 = "MODULE_2_BIG_SNAP_RHO2_NULL"

# ------------------ helpers: SHA + rational array extraction ------------------
def _sha256_of_config(cfg: dict) -> tuple[str, str]:
    s = json.dumps(cfg, sort_keys=True)
    return hashlib.sha256(s.encode("utf-8")).hexdigest(), s

def _extract_rational_values(rats_obj):
    """
    Handle both the v3-style dict return and the v4-style bare ndarray return
    from fpk_build_rational_family(...).
    """
    # Already a numpy array? Just use it.
    if isinstance(rats_obj, np.ndarray):
        return rats_obj

    # Dict-style return? Look for plausible value keys.
    if isinstance(rats_obj, dict):
        for k in ("values", "vals", "rationals", "array"):
            if k in rats_obj:
                return rats_obj[k]
        raise RuntimeError(
            f"[{MODULE_NAME_2}] Could not find rational values in dict; "
            f"available keys = {list(rats_obj.keys())}"
        )

    # Fallback: try attribute .values if it exists
    if hasattr(rats_obj, "values"):
        arr = getattr(rats_obj, "values")
        if isinstance(arr, np.ndarray):
            return arr

    raise RuntimeError(
        f"[{MODULE_NAME_2}] Unknown fpk_build_rational_family return type: "
        f"{type(rats_obj)}"
    )

# ------------------ combine snap stats across chunks ------------------
def _combine_snap_stats_chunkwise(chunks, eps_real: float):
    """
    chunks: list of dicts with keys:
      'num_universes', 'mean_dmin', 'min_dmin', 'max_dmin', 'count_le'
    eps_real is just passed through (for convenience in the return dict).
    """
    N_total = 0
    mean_global = 0.0
    min_global = float("inf")
    max_global = float("-inf")
    count_le_total = 0

    for c in chunks:
        Ni   = int(c["num_universes"])
        mi   = float(c["mean_dmin"])
        mni  = float(c["min_dmin"])
        mxi  = float(c["max_dmin"])
        cli  = int(c["count_le"])

        if Ni <= 0:
            continue

        if mni < min_global: min_global = mni
        if mxi > max_global: max_global = mxi
        count_le_total += cli

        if N_total == 0:
            N_total = Ni
            mean_global = mi
        else:
            N_old = N_total
            mean_old = mean_global
            N_total = N_old + Ni
            delta = mi - mean_old
            mean_global = mean_old + delta * Ni / N_total

    p_emp = count_le_total / N_total if N_total > 0 else float("nan")

    return {
        "N_total": N_total,
        "mean_dmin_global": mean_global,
        "min_dmin_global": min_global,
        "max_dmin_global": max_global,
        "count_le_total": count_le_total,
        "p_emp": p_emp,
        "eps_real": eps_real,
    }

# ------------------ one big rho² snap-null run (chunked, quiet) ------------------
def run_big_snap_null_rho2(
    label: str,
    rho2_real: float,
    eps_real: float,
    band_min: float = 0.6,
    band_max: float = 0.9,
    q_max: int = 1000,
    bits_max: int = 20,
    total_universes: int = 10_000_000,
    batch_size: int = 200_000,
    seed_base: int = 111_000_000,
    omp_threads: int | None = 2,
):
    """
    Big scalar snap-null for ρ² using the FPK v4 kernel:
      • Builds rational family in [band_min, band_max] with q ≤ q_max, bits ≤ bits_max.
      • For each fake universe, computes d_min = min |R_fake - p/q|.
      • Counts how often d_min ≤ eps_real (look-elsewhere aware).
      • Runs in chunks, but only prints a global summary.
    """

    # Fix OMP threads (if requested)
    old_omp = os.environ.get("OMP_NUM_THREADS", None)
    if omp_threads is not None:
        os.environ["OMP_NUM_THREADS"] = str(omp_threads)

    # Build config + hash
    cfg = {
        "module": MODULE_NAME_2,
        "label": label,
        "date_iso": datetime.datetime.utcnow().isoformat() + "Z",
        "rho2_real": float(rho2_real),
        "eps_real": float(eps_real),
        "band_min": float(band_min),
        "band_max": float(band_max),
        "q_max": int(q_max),
        "bits_max": int(bits_max),
        "total_universes": int(total_universes),
        "batch_size": int(batch_size),
        "seed_base": int(seed_base),
        "omp_threads": omp_threads,
    }
    cfg_sha, cfg_str = _sha256_of_config(cfg)

    print("===============================================================================")
    print(f"[{MODULE_NAME_2}] {label}")
    print("Date (UTC)       :", cfg["date_iso"])
    print("Config JSON      :", cfg_str)
    print("Config SHA256    :", cfg_sha)
    print("-------------------------------------------------------------------------------")
    print(f"Using OMP_NUM_THREADS = {('default' if omp_threads is None else omp_threads)}")
    print(f"TOTAL_UNIVERSES       = {total_universes:,}")
    print(f"BATCH_SIZE            = {batch_size:,}")
    print(f"band                  = [{band_min}, {band_max}]")
    print(f"q_max                 = {q_max}")
    print(f"bits_max              = {bits_max}")
    print(f"seed_base             = {seed_base}")
    print(f"rho2_real             = {rho2_real:.12f}")
    print(f"eps_real              = {eps_real:.3e}")
    print("-------------------------------------------------------------------------------")

    # Build rational family once for this run
    rats_raw = fpk_build_rational_family(
        float(band_min),
        float(band_max),
        int(q_max),
        int(bits_max),
        False,  # verbose
    )
    rats = _extract_rational_values(rats_raw)
    n_rats = len(rats)
    print(f"[{MODULE_NAME_2}] Rational family: #candidates = {n_rats:,}")
    print("-------------------------------------------------------------------------------")

    # Chunked loop
    n_chunks = (total_universes + batch_size - 1) // batch_size
    chunks = []
    t0_global = time.time()

    for i in range(n_chunks):
        n_this = batch_size if (i < n_chunks - 1) else (total_universes - batch_size * (n_chunks - 1))
        seed_i = seed_base + i

        # fpk_snap_null_scalar(x_real, eps_real, rats_array, band_min, band_max, N, seed, verbose_flag)
        res = fpk_snap_null_scalar(
            float(rho2_real),
            float(eps_real),
            rats,
            float(band_min),
            float(band_max),
            int(n_this),
            int(seed_i),
            False,  # verbose
        )

        # Expect keys: mean_dmin, min_dmin, max_dmin, count_le, p_le, num_universes, ...
        Ni       = int(res.get("num_universes", n_this))
        mean_d   = float(res.get("mean_dmin"))
        min_d    = float(res.get("min_dmin"))
        max_d    = float(res.get("max_dmin"))
        count_le = int(res.get("count_le"))

        chunks.append({
            "num_universes": Ni,
            "mean_dmin": mean_d,
            "min_dmin": min_d,
            "max_dmin": max_d,
            "count_le": count_le,
        })

    t1_global = time.time()
    agg = _combine_snap_stats_chunkwise(chunks, eps_real=eps_real)
    total_elapsed = t1_global - t0_global
    overall_thr = total_universes / total_elapsed if total_elapsed > 0 else float("inf")

    print("-------------------------------------------------------------------------------")
    print(f"[{MODULE_NAME_2}] GLOBAL SNAP NULL SUMMARY ({label})")
    print("      Total universes          :", f"{agg['N_total']:,}")
    print("      rho2_real                :", f"{rho2_real:.12f}")
    print("      eps_real                 :", f"{eps_real:.3e}")
    print("      band                     :", f"[{band_min}, {band_max}]")
    print("      # rationals in family    :", f"{n_rats:,}")
    print("      mean d_min               :", f"{agg['mean_dmin_global']:.3e}")
    print("      min / max d_min          :",
          f"{agg['min_dmin_global']:.3e}", "/",
          f"{agg['max_dmin_global']:.3e}")
    print("      count(d_min ≤ eps_real)  :",
          f"{agg['count_le_total']:,}", "/", f"{agg['N_total']:,}")
    print("      Empirical p_emp          :", f"{agg['p_emp']:.3e}")
    print("      Total elapsed time       :", f"{total_elapsed:6.3f} s")
    print("      Overall throughput       :", f"{overall_thr:10.0f} universes / s")
    print("      Config SHA256            :", cfg_sha)
    print("-------------------------------------------------------------------------------")

    # Restore OMP setting
    if omp_threads is None:
        if old_omp is None:
            os.environ.pop("OMP_NUM_THREADS", None)
        else:
            os.environ["OMP_NUM_THREADS"] = old_omp
    else:
        if old_omp is None:
            pass  # leave the forced value
        else:
            os.environ["OMP_NUM_THREADS"] = old_omp

    return {
        "config": cfg,
        "config_sha256": cfg_sha,
        "agg": agg,
        "elapsed_sec": total_elapsed,
        "universes_per_sec": overall_thr,
        "n_rationals": n_rats,
    }

# ------------------ constants for ρ² snap test ------------------
# Exact real custodial ratio from your earlier modules:
RHO2_REAL = 812665063550390625 / 1045918773319100209.0  # ≈ 0.776986783564

# Ledger snap fraction:
RHO2_P = 655
RHO2_Q = 843
RHO2_SNAP = RHO2_P / RHO2_Q
RHO2_EPS_REAL = abs(RHO2_REAL - RHO2_SNAP)

BAND_MIN_RHO2 = 0.6
BAND_MAX_RHO2 = 0.9
RHO2_Q_MAX = 1000
RHO2_BITS_MAX = 20

TOTAL_UNI_M2 = 10_000_000
BATCH_M2     = 200_000      # 50 chunks × 200k = 10M
THREADS_M2   = 2            # tuned good default for Colab 2-core

print("===============================================================================")
print(f"{MODULE_NAME_2}: STARTING 3× BIG SNAP-NULL RUNS FOR ρ² (each 10M universes)")
print("       (look-elsewhere over all p/q with q ≤ 1000, bits ≤ 20 in [0.6, 0.9])")
print("===============================================================================")

M2_RUN1 = run_big_snap_null_rho2(
    label           = "RUN1_main",
    rho2_real       = RHO2_REAL,
    eps_real        = RHO2_EPS_REAL,
    band_min        = BAND_MIN_RHO2,
    band_max        = BAND_MAX_RHO2,
    q_max           = RHO2_Q_MAX,
    bits_max        = RHO2_BITS_MAX,
    total_universes = TOTAL_UNI_M2,
    batch_size      = BATCH_M2,
    seed_base       = 111_000_000,
    omp_threads     = THREADS_M2,
)

M2_RUN2 = run_big_snap_null_rho2(
    label           = "RUN2_independent_seed",
    rho2_real       = RHO2_REAL,
    eps_real        = RHO2_EPS_REAL,
    band_min        = BAND_MIN_RHO2,
    band_max        = BAND_MAX_RHO2,
    q_max           = RHO2_Q_MAX,
    bits_max        = RHO2_BITS_MAX,
    total_universes = TOTAL_UNI_M2,
    batch_size      = BATCH_M2,
    seed_base       = 222_000_000,
    omp_threads     = THREADS_M2,
)

M2_RUN3 = run_big_snap_null_rho2(
    label           = "RUN3_independent_seed",
    rho2_real       = RHO2_REAL,
    eps_real        = RHO2_EPS_REAL,
    band_min        = BAND_MIN_RHO2,
    band_max        = BAND_MAX_RHO2,
    q_max           = RHO2_Q_MAX,
    bits_max        = RHO2_BITS_MAX,
    total_universes = TOTAL_UNI_M2,
    batch_size      = BATCH_M2,
    seed_base       = 333_000_000,
    omp_threads     = THREADS_M2,
)

print("===============================================================================")
print(f"{MODULE_NAME_2}: ALL 3 RUNS COMPLETED")
print("  RUN1 config SHA256:", M2_RUN1["config_sha256"])
print("  RUN2 config SHA256:", M2_RUN2["config_sha256"])
print("  RUN3 config SHA256:", M2_RUN3["config_sha256"])
print("===============================================================================")

# =============================================================================
# MODULE 3: BIG SCALAR SNAP NULL FOR KOIDE Q (10M × 3 RUNS)
#          – LOOK-ELSEWHERE OVER SMALL-BIT RATIONALS
# =============================================================================
import os, time, math, json, hashlib, datetime
import numpy as np

MODULE_NAME_3 = "MODULE_3_BIG_SNAP_KOIDE_NULL"

# ------------------ if helpers from Module 2 are missing, bail clearly --------
for _needed in ("_sha256_of_config", "_extract_rational_values", "_combine_snap_stats_chunkwise"):
    if _needed not in globals():
        raise RuntimeError(
            f"[{MODULE_NAME_3}] Missing helper '{_needed}'. "
            "Make sure MODULE_2_BIG_SNAP_RHO2_NULL cell was run first."
        )

# ------------------ one big Koide snap-null run (chunked, quiet) -------------
def run_big_snap_null_koide(
    label: str,
    Q_real: float,
    eps_real: float,
    band_min: float = 0.4,
    band_max: float = 0.9,
    q_max: int = 1000,
    bits_max: int = 20,
    total_universes: int = 10_000_000,
    batch_size: int = 200_000,
    seed_base: int = 121_000_000,
    omp_threads: int | None = 2,
):
    """
    Big scalar snap-null for Koide Q using the FPK v4 kernel:
      • Builds rational family in [band_min, band_max] with q ≤ q_max, bits ≤ bits_max.
      • For each fake universe, computes d_min = min |Q_fake - p/q|.
      • Counts how often d_min ≤ eps_real (look-elsewhere aware).
      • Runs in chunks, but only prints a global summary.

    Q_real     = real Koide Q
    eps_real   = |Q_real - Q_target|
    """

    # Fix OMP threads (if requested)
    old_omp = os.environ.get("OMP_NUM_THREADS", None)
    if omp_threads is not None:
        os.environ["OMP_NUM_THREADS"] = str(omp_threads)

    # Build config + hash
    cfg = {
        "module": MODULE_NAME_3,
        "label": label,
        "date_iso": datetime.datetime.utcnow().isoformat() + "Z",
        "Q_real": float(Q_real),
        "eps_real": float(eps_real),
        "band_min": float(band_min),
        "band_max": float(band_max),
        "q_max": int(q_max),
        "bits_max": int(bits_max),
        "total_universes": int(total_universes),
        "batch_size": int(batch_size),
        "seed_base": int(seed_base),
        "omp_threads": omp_threads,
    }
    cfg_sha, cfg_str = _sha256_of_config(cfg)

    print("===============================================================================")
    print(f"[{MODULE_NAME_3}] {label}")
    print("Date (UTC)       :", cfg["date_iso"])
    print("Config JSON      :", cfg_str)
    print("Config SHA256    :", cfg_sha)
    print("-------------------------------------------------------------------------------")
    print(f"Using OMP_NUM_THREADS = {('default' if omp_threads is None else omp_threads)}")
    print(f"TOTAL_UNIVERSES       = {total_universes:,}")
    print(f"BATCH_SIZE            = {batch_size:,}")
    print(f"band                  = [{band_min}, {band_max}]")
    print(f"q_max                 = {q_max}")
    print(f"bits_max              = {bits_max}")
    print(f"seed_base             = {seed_base}")
    print(f"Q_real                = {Q_real:.12f}")
    print(f"eps_real              = {eps_real:.3e}")
    print("-------------------------------------------------------------------------------")

    # Build rational family once for this run
    rats_raw = fpk_build_rational_family(
        float(band_min),
        float(band_max),
        int(q_max),
        int(bits_max),
        False,  # verbose
    )
    rats = _extract_rational_values(rats_raw)
    n_rats = len(rats)
    print(f"[{MODULE_NAME_3}] Rational family: #candidates = {n_rats:,}")
    print("-------------------------------------------------------------------------------")

    # Chunked loop
    n_chunks = (total_universes + batch_size - 1) // batch_size
    chunks = []
    t0_global = time.time()

    for i in range(n_chunks):
        n_this = batch_size if (i < n_chunks - 1) else (total_universes - batch_size * (n_chunks - 1))
        seed_i = seed_base + i

        # fpk_snap_null_scalar(x_real, eps_real, rats_array, band_min, band_max, N, seed, verbose_flag)
        res = fpk_snap_null_scalar(
            float(Q_real),
            float(eps_real),
            rats,
            float(band_min),
            float(band_max),
            int(n_this),
            int(seed_i),
            False,  # verbose
        )

        Ni       = int(res.get("num_universes", n_this))
        mean_d   = float(res.get("mean_dmin"))
        min_d    = float(res.get("min_dmin"))
        max_d    = float(res.get("max_dmin"))
        count_le = int(res.get("count_le"))

        chunks.append({
            "num_universes": Ni,
            "mean_dmin": mean_d,
            "min_dmin": min_d,
            "max_dmin": max_d,
            "count_le": count_le,
        })

    t1_global = time.time()
    agg = _combine_snap_stats_chunkwise(chunks, eps_real=eps_real)
    total_elapsed = t1_global - t0_global
    overall_thr = total_universes / total_elapsed if total_elapsed > 0 else float("inf")

    print("-------------------------------------------------------------------------------")
    print(f"[{MODULE_NAME_3}] GLOBAL SNAP NULL SUMMARY ({label})")
    print("      Total universes          :", f"{agg['N_total']:,}")
    print("      Q_real                   :", f"{Q_real:.12f}")
    print("      eps_real                 :", f"{eps_real:.3e}")
    print("      band                     :", f"[{band_min}, {band_max}]")
    print("      # rationals in family    :", f"{n_rats:,}")
    print("      mean d_min               :", f"{agg['mean_dmin_global']:.3e}")
    print("      min / max d_min          :",
          f"{agg['min_dmin_global']:.3e}", "/",
          f"{agg['max_dmin_global']:.3e}")
    print("      count(d_min ≤ eps_real)  :",
          f"{agg['count_le_total']:,}", "/", f"{agg['N_total']:,}")
    print("      Empirical p_emp          :", f"{agg['p_emp']:.3e}")
    print("      Total elapsed time       :", f"{total_elapsed:6.3f} s")
    print("      Overall throughput       :", f"{overall_thr:10.0f} universes / s")
    print("      Config SHA256            :", cfg_sha)
    print("-------------------------------------------------------------------------------")

    # Restore OMP setting
    if omp_threads is None:
        if old_omp is None:
            os.environ.pop("OMP_NUM_THREADS", None)
        else:
            os.environ["OMP_NUM_THREADS"] = old_omp
    else:
        if old_omp is None:
            pass
        else:
            os.environ["OMP_NUM_THREADS"] = old_omp

    return {
        "config": cfg,
        "config_sha256": cfg_sha,
        "agg": agg,
        "elapsed_sec": total_elapsed,
        "universes_per_sec": overall_thr,
        "n_rationals": n_rats,
    }

# ------------------ constants for Koide snap test ------------------
# Real Koide Q from earlier high-precision calc (using your Yukawas):
KOIDE_Q_REAL = 0.666660512587
KOIDE_Q_TARGET = 2.0 / 3.0
KOIDE_Q_EPS_REAL = abs(KOIDE_Q_REAL - KOIDE_Q_TARGET)

BAND_MIN_Q = 0.4
BAND_MAX_Q = 0.9
KOIDE_Q_MAX = 1000
KOIDE_BITS_MAX = 20

TOTAL_UNI_M3 = 10_000_000
BATCH_M3     = 200_000      # 50 chunks × 200k = 10M
THREADS_M3   = 2            # tuned good default

print("===============================================================================")
print(f"{MODULE_NAME_3}: STARTING 3× BIG SNAP-NULL RUNS FOR Koide Q (each 10M universes)")
print("       (look-elsewhere over all p/q with q ≤ 1000, bits ≤ 20 in [0.4, 0.9])")
print("===============================================================================")

M3_RUN1 = run_big_snap_null_koide(
    label           = "RUN1_main",
    Q_real          = KOIDE_Q_REAL,
    eps_real        = KOIDE_Q_EPS_REAL,
    band_min        = BAND_MIN_Q,
    band_max        = BAND_MAX_Q,
    q_max           = KOIDE_Q_MAX,
    bits_max        = KOIDE_BITS_MAX,
    total_universes = TOTAL_UNI_M3,
    batch_size      = BATCH_M3,
    seed_base       = 121_000_000,
    omp_threads     = THREADS_M3,
)

M3_RUN2 = run_big_snap_null_koide(
    label           = "RUN2_independent_seed",
    Q_real          = KOIDE_Q_REAL,
    eps_real        = KOIDE_Q_EPS_REAL,
    band_min        = BAND_MIN_Q,
    band_max        = BAND_MAX_Q,
    q_max           = KOIDE_Q_MAX,
    bits_max        = KOIDE_BITS_MAX,
    total_universes = TOTAL_UNI_M3,
    batch_size      = BATCH_M3,
    seed_base       = 222_000_000,
    omp_threads     = THREADS_M3,
)

M3_RUN3 = run_big_snap_null_koide(
    label           = "RUN3_independent_seed",
    Q_real          = KOIDE_Q_REAL,
    eps_real        = KOIDE_Q_EPS_REAL,
    band_min        = BAND_MIN_Q,
    band_max        = BAND_MAX_Q,
    q_max           = KOIDE_Q_MAX,
    bits_max        = KOIDE_BITS_MAX,
    total_universes = TOTAL_UNI_M3,
    batch_size      = BATCH_M3,
    seed_base       = 333_000_000,
    omp_threads     = THREADS_M3,
)

print("===============================================================================")
print(f"{MODULE_NAME_3}: ALL 3 RUNS COMPLETED")
print("  RUN1 config SHA256:", M3_RUN1["config_sha256"])
print("  RUN2 config SHA256:", M3_RUN2["config_sha256"])
print("  RUN3 config SHA256:", M3_RUN3["config_sha256"])
print("===============================================================================")

# =============================================================================
# MODULE 4: BIG LEDGER SCALAR TESTS FOR ρ², KOIDE Q, sin²θW (10M × 3 each)
# =============================================================================
import os, time, json, datetime
import numpy as np

MODULE_NAME_4 = "MODULE_4_BIG_LEDGER_SCALAR_NULLS"

# --- sanity: need helpers + fpk_snap_null_scalar from previous kernel cells ---
for _needed in ("_sha256_of_config", "_combine_snap_stats_chunkwise", "fpk_snap_null_scalar"):
    if _needed not in globals():
        raise RuntimeError(
            f"[{MODULE_NAME_4}] Missing '{_needed}'. "
            "Make sure the FPK v4 kernel cell and Modules 2–3 helpers are run first."
        )

# --------------------- generic runner: single ledger test ---------------------
def run_big_ledger_null_scalar(
    label: str,
    quantity_name: str,
    x_real: float,
    x_target: float,
    band_min: float,
    band_max: float,
    total_universes: int = 10_000_000,
    batch_size: int = 200_000,
    seed_base: int = 130_000_000,
    omp_threads: int | None = 2,
):
    """
    Big uniform-null test for a *fixed* ledger fraction using the FPK scalar kernel.

      x_real     : real-world value (e.g. rho^2, Koide Q, sin^2 theta_W)
      x_target   : ledger fraction value (e.g. 655/843, 2/3, 188/843)
      band_min/max: null band endpoints (Uniform[band_min, band_max])
      eps_real   : |x_real - x_target|
      result: empirical p_ledger = P(|x_fake - x_target| <= eps_real)
    """

    # threshold is how close the real value is to the ledger fraction
    eps_real = abs(float(x_real) - float(x_target))

    # manage OMP_NUM_THREADS for this run
    old_omp = os.environ.get("OMP_NUM_THREADS", None)
    if omp_threads is not None:
        os.environ["OMP_NUM_THREADS"] = str(omp_threads)

    # config + SHA
    cfg = {
        "module": MODULE_NAME_4,
        "label": label,
        "quantity": quantity_name,
        "date_iso": datetime.datetime.utcnow().isoformat() + "Z",
        "x_real": float(x_real),
        "x_target": float(x_target),
        "eps_real": float(eps_real),
        "band_min": float(band_min),
        "band_max": float(band_max),
        "total_universes": int(total_universes),
        "batch_size": int(batch_size),
        "seed_base": int(seed_base),
        "omp_threads": omp_threads,
    }
    cfg_sha, cfg_str = _sha256_of_config(cfg)

    print("===============================================================================")
    print(f"[{MODULE_NAME_4}] {label} —", quantity_name)
    print("Date (UTC)       :", cfg["date_iso"])
    print("Config JSON      :", cfg_str)
    print("Config SHA256    :", cfg_sha)
    print("-------------------------------------------------------------------------------")
    print(f"Using OMP_NUM_THREADS = {('default' if omp_threads is None else omp_threads)}")
    print(f"TOTAL_UNIVERSES       = {total_universes:,}")
    print(f"BATCH_SIZE            = {batch_size:,}")
    print(f"band                  = [{band_min}, {band_max}]")
    print(f"x_real                = {x_real:.12f}")
    print(f"x_target              = {x_target:.12f}")
    print(f"eps_real              = {eps_real:.6e}")
    print("-------------------------------------------------------------------------------")

    # rational family is just the single ledger fraction
    rats = np.array([float(x_target)], dtype=np.float64)
    n_rats = len(rats)
    print(f"[{MODULE_NAME_4}] Rational family (ledger) size = {n_rats} (single target fraction)")
    print("-------------------------------------------------------------------------------")

    # chunked loop, no per-chunk spam; just aggregate stats
    n_chunks = (total_universes + batch_size - 1) // batch_size
    chunks = []
    t0 = time.time()

    for i in range(n_chunks):
        n_this = batch_size if (i < n_chunks - 1) else (total_universes - batch_size * (n_chunks - 1))
        seed_i = seed_base + i

        res = fpk_snap_null_scalar(
            float(x_real),   # x_real is irrelevant to the null generation; kernel uses band + RNG
            float(eps_real),
            rats,
            float(band_min),
            float(band_max),
            int(n_this),
            int(seed_i),
            False,           # verbose
        )

        Ni       = int(res.get("num_universes", n_this))
        mean_d   = float(res.get("mean_dmin"))
        min_d    = float(res.get("min_dmin"))
        max_d    = float(res.get("max_dmin"))
        count_le = int(res.get("count_le"))

        chunks.append({
            "num_universes": Ni,
            "mean_dmin": mean_d,
            "min_dmin": min_d,
            "max_dmin": max_d,
            "count_le": count_le,
        })

    t1 = time.time()
    agg = _combine_snap_stats_chunkwise(chunks, eps_real=eps_real)
    elapsed = t1 - t0
    thr = total_universes / elapsed if elapsed > 0 else float("inf")

    print("-------------------------------------------------------------------------------")
    print(f"[{MODULE_NAME_4}] GLOBAL LEDGER NULL SUMMARY ({label} — {quantity_name})")
    print("      Total universes          :", f"{agg['N_total']:,}")
    print("      x_real                   :", f"{x_real:.12f}")
    print("      x_target                 :", f"{x_target:.12f}")
    print("      eps_real                 :", f"{eps_real:.6e}")
    print("      band                     :", f"[{band_min}, {band_max}]")
    print("      # rationals in family    :", n_rats)
    print("      mean |x - target|        :", f"{agg['mean_dmin_global']:.3e}")
    print("      min / max |x - target|   :",
          f"{agg['min_dmin_global']:.3e}", "/",
          f"{agg['max_dmin_global']:.3e}")
    print("      count(|x - target| ≤ eps):",
          f"{agg['count_le_total']:,}", "/", f"{agg['N_total']:,}")
    print("      Empirical p_ledger       :", f"{agg['p_emp']:.3e}")
    print("      Total elapsed time       :", f"{elapsed:6.3f} s")
    print("      Overall throughput       :", f"{thr:10.0f} universes / s")
    print("      Config SHA256            :", cfg_sha)
    print("-------------------------------------------------------------------------------")

    # restore OMP env
    if omp_threads is None:
        if old_omp is None:
            os.environ.pop("OMP_NUM_THREADS", None)
        else:
            os.environ["OMP_NUM_THREADS"] = old_omp
    else:
        if old_omp is None:
            pass
        else:
            os.environ["OMP_NUM_THREADS"] = old_omp

    return {
        "config": cfg,
        "config_sha256": cfg_sha,
        "agg": agg,
        "elapsed_sec": elapsed,
        "universes_per_sec": thr,
    }


# --------------------- Real values + ledger targets ---------------------------

# ρ² = (MW/MZ)^2
RHO2_REAL     = 0.7769867835639795          # from earlier precise calculation
RHO2_TARGET   = 655.0 / 843.0               # ledger fraction
BAND_RHO2_MIN = 0.6
BAND_RHO2_MAX = 0.9

# Koide Q(e,μ,τ)
KOIDE_Q_REAL     = 0.666660512587
KOIDE_Q_TARGET   = 2.0 / 3.0
BAND_Q_MIN       = 0.4
BAND_Q_MAX       = 0.9

# sin²θW
SIN2W_REAL     = 0.231220000589
SIN2W_TARGET   = 188.0 / 843.0
BAND_SIN2W_MIN = 0.15
BAND_SIN2W_MAX = 0.35

TOTAL_UNI_M4 = 10_000_000
BATCH_M4     = 200_000
THREADS_M4   = 2

print("===============================================================================")
print(f"{MODULE_NAME_4}: STARTING BIG LEDGER TESTS (ρ², Koide Q, sin²θW)")
print("         3 runs each, 10M universes per run, fixed ledger fractions.")
print("===============================================================================")

# --------------------- ρ²: 3 runs --------------------------------------------
M4_RHO2_RUN1 = run_big_ledger_null_scalar(
    label           = "RHO2_RUN1_main",
    quantity_name   = "rho2 = (MW/MZ)^2",
    x_real          = RHO2_REAL,
    x_target        = RHO2_TARGET,
    band_min        = BAND_RHO2_MIN,
    band_max        = BAND_RHO2_MAX,
    total_universes = TOTAL_UNI_M4,
    batch_size      = BATCH_M4,
    seed_base       = 131_000_000,
    omp_threads     = THREADS_M4,
)

M4_RHO2_RUN2 = run_big_ledger_null_scalar(
    label           = "RHO2_RUN2_independent_seed",
    quantity_name   = "rho2 = (MW/MZ)^2",
    x_real          = RHO2_REAL,
    x_target        = RHO2_TARGET,
    band_min        = BAND_RHO2_MIN,
    band_max        = BAND_RHO2_MAX,
    total_universes = TOTAL_UNI_M4,
    batch_size      = BATCH_M4,
    seed_base       = 232_000_000,
    omp_threads     = THREADS_M4,
)

M4_RHO2_RUN3 = run_big_ledger_null_scalar(
    label           = "RHO2_RUN3_independent_seed",
    quantity_name   = "rho2 = (MW/MZ)^2",
    x_real          = RHO2_REAL,
    x_target        = RHO2_TARGET,
    band_min        = BAND_RHO2_MIN,
    band_max        = BAND_RHO2_MAX,
    total_universes = TOTAL_UNI_M4,
    batch_size      = BATCH_M4,
    seed_base       = 333_000_000,
    omp_threads     = THREADS_M4,
)

# --------------------- Koide Q: 3 runs ---------------------------------------
M4_Q_RUN1 = run_big_ledger_null_scalar(
    label           = "KOIDE_RUN1_main",
    quantity_name   = "Koide Q(e,mu,tau)",
    x_real          = KOIDE_Q_REAL,
    x_target        = KOIDE_Q_TARGET,
    band_min        = BAND_Q_MIN,
    band_max        = BAND_Q_MAX,
    total_universes = TOTAL_UNI_M4,
    batch_size      = BATCH_M4,
    seed_base       = 141_000_000,
    omp_threads     = THREADS_M4,
)

M4_Q_RUN2 = run_big_ledger_null_scalar(
    label           = "KOIDE_RUN2_independent_seed",
    quantity_name   = "Koide Q(e,mu,tau)",
    x_real          = KOIDE_Q_REAL,
    x_target        = KOIDE_Q_TARGET,
    band_min        = BAND_Q_MIN,
    band_max        = BAND_Q_MAX,
    total_universes = TOTAL_UNI_M4,
    batch_size      = BATCH_M4,
    seed_base       = 242_000_000,
    omp_threads     = THREADS_M4,
)

M4_Q_RUN3 = run_big_ledger_null_scalar(
    label           = "KOIDE_RUN3_independent_seed",
    quantity_name   = "Koide Q(e,mu,tau)",
    x_real          = KOIDE_Q_REAL,
    x_target        = KOIDE_Q_TARGET,
    band_min        = BAND_Q_MIN,
    band_max        = BAND_Q_MAX,
    total_universes = TOTAL_UNI_M4,
    batch_size      = BATCH_M4,
    seed_base       = 343_000_000,
    omp_threads     = THREADS_M4,
)

# --------------------- sin²θW: 3 runs ----------------------------------------
M4_SIN2W_RUN1 = run_big_ledger_null_scalar(
    label           = "SIN2W_RUN1_main",
    quantity_name   = "sin^2(theta_W)",
    x_real          = SIN2W_REAL,
    x_target        = SIN2W_TARGET,
    band_min        = BAND_SIN2W_MIN,
    band_max        = BAND_SIN2W_MAX,
    total_universes = TOTAL_UNI_M4,
    batch_size      = BATCH_M4,
    seed_base       = 151_000_000,
    omp_threads     = THREADS_M4,
)

M4_SIN2W_RUN2 = run_big_ledger_null_scalar(
    label           = "SIN2W_RUN2_independent_seed",
    quantity_name   = "sin^2(theta_W)",
    x_real          = SIN2W_REAL,
    x_target        = SIN2W_TARGET,
    band_min        = BAND_SIN2W_MIN,
    band_max        = BAND_SIN2W_MAX,
    total_universes = TOTAL_UNI_M4,
    batch_size      = BATCH_M4,
    seed_base       = 252_000_000,
    omp_threads     = THREADS_M4,
)

M4_SIN2W_RUN3 = run_big_ledger_null_scalar(
    label           = "SIN2W_RUN3_independent_seed",
    quantity_name   = "sin^2(theta_W)",
    x_real          = SIN2W_REAL,
    x_target        = SIN2W_TARGET,
    band_min        = BAND_SIN2W_MIN,
    band_max        = BAND_SIN2W_MAX,
    total_universes = TOTAL_UNI_M4,
    batch_size      = BATCH_M4,
    seed_base       = 353_000_000,
    omp_threads     = THREADS_M4,
)

print("===============================================================================")
print(f"{MODULE_NAME_4}: ALL LEDGER RUNS COMPLETED")
print("  ρ²  config SHA256s:",
      M4_RHO2_RUN1["config_sha256"],
      M4_RHO2_RUN2["config_sha256"],
      M4_RHO2_RUN3["config_sha256"])
print("  Q   config SHA256s:",
      M4_Q_RUN1["config_sha256"],
      M4_Q_RUN2["config_sha256"],
      M4_Q_RUN3["config_sha256"])
print("  sin² config SHA256s:",
      M4_SIN2W_RUN1["config_sha256"],
      M4_SIN2W_RUN2["config_sha256"],
      M4_SIN2W_RUN3["config_sha256"])
print("===============================================================================")

# ===============================================================================
# MODULE_5_BIG_JOINT_LEDGER_TRIPLE_NULL
#   Joint uniform-null test for the triple:
#      ρ² = (M_W/M_Z)², Koide Q(e,μ,τ), sin²θW
#   Each run:
#      - Draws N = 10,000,000 triples uniformly on their bands
#      - Counts how many satisfy, simultaneously:
#           |ρ² - 655/843|       <= ε_rho2_real
#           |Q  - 2/3|           <= ε_Q_real
#           |sin²θW - 188/843|   <= ε_sin2_real
#      - Prints config JSON, SHA256, and summary.
#   We also print the *theoretical* joint p under simple uniform geometry.
# ===============================================================================

import numpy as np
import datetime, json, hashlib, time
from math import fabs

MODULE_NAME_5 = "MODULE_5_BIG_JOINT_LEDGER_TRIPLE_NULL"

# --- real values and ledger targets (copied from your earlier modules) ---

RHO2_REAL      = 0.7769867835639795      # (M_W/M_Z)^2 from registry
RHO2_TARGET    = 655.0 / 843.0           # 0.7769869513641756...
EPS_RHO2_REAL  = abs(RHO2_REAL - RHO2_TARGET)  # ≈ 1.6780e-07

Q_REAL         = 0.666660512587          # Koide Q(e, μ, τ)
Q_TARGET       = 2.0 / 3.0               # 0.666666666666...
EPS_Q_REAL     = abs(Q_REAL - Q_TARGET)  # ≈ 6.1541e-06

SIN2_REAL      = 0.231220000589          # sin²θW from registry
SIN2_TARGET    = 188.0 / 843.0           # 0.22301304863582444...
EPS_SIN2_REAL  = abs(SIN2_REAL - SIN2_TARGET)  # ≈ 8.20695e-03

# Bands used in your scalar tests:
BAND_RHO2_MIN, BAND_RHO2_MAX   = 0.6, 0.9
BAND_Q_MIN,   BAND_Q_MAX       = 0.4, 0.9
BAND_SIN2_MIN, BAND_SIN2_MAX   = 0.15, 0.35

# --- simple helper for config SHA256 ---

def _sha256_of_config(cfg_dict):
    s = json.dumps(cfg_dict, sort_keys=True)
    return hashlib.sha256(s.encode("utf-8")).hexdigest()

# --- core runner for one 10M-triple joint test ---

def _run_one_joint_ledger_run(label, seed_base,
                              total_triples=10_000_000,
                              batch_size=1_000_000):
    now_iso = datetime.datetime.utcnow().isoformat() + "Z"

    cfg = {
        "module": MODULE_NAME_5,
        "label": label,
        "date_iso": now_iso,
        "total_triples": int(total_triples),
        "batch_size": int(batch_size),
        "seed_base": int(seed_base),
        "bands": {
            "rho2":  [BAND_RHO2_MIN,  BAND_RHO2_MAX],
            "Koide": [BAND_Q_MIN,     BAND_Q_MAX],
            "sin2W": [BAND_SIN2_MIN,  BAND_SIN2_MAX],
        },
        "rho2_real": float(RHO2_REAL),
        "rho2_target": float(RHO2_TARGET),
        "eps_rho2_real": float(EPS_RHO2_REAL),
        "Q_real": float(Q_REAL),
        "Q_target": float(Q_TARGET),
        "eps_Q_real": float(EPS_Q_REAL),
        "sin2_real": float(SIN2_REAL),
        "sin2_target": float(SIN2_TARGET),
        "eps_sin2_real": float(EPS_SIN2_REAL),
    }
    cfg_sha = _sha256_of_config(cfg)

    print("===============================================================================")
    print(f"[{MODULE_NAME_5}] {label}")
    print(f"Date (UTC)       : {now_iso}")
    print(f"Config JSON      : {json.dumps(cfg, sort_keys=True)}")
    print(f"Config SHA256    : {cfg_sha}")
    print("-------------------------------------------------------------------------------")
    print(f"TOTAL_TRIPLES          = {total_triples:,}")
    print(f"BATCH_SIZE             = {batch_size:,}")
    print(f"bands                  = rho2[{BAND_RHO2_MIN}, {BAND_RHO2_MAX}], "
          f"Q[{BAND_Q_MIN}, {BAND_Q_MAX}], "
          f"sin²θW[{BAND_SIN2_MIN}, {BAND_SIN2_MAX}]")
    print(f"rho2_real, target, eps = {RHO2_REAL:.12f}, {RHO2_TARGET:.12f}, {EPS_RHO2_REAL:.3e}")
    print(f"Q_real,   target, eps  = {Q_REAL:.12f},  {Q_TARGET:.12f},  {EPS_Q_REAL:.3e}")
    print(f"sin2_real,target, eps  = {SIN2_REAL:.12f}, {SIN2_TARGET:.12f}, {EPS_SIN2_REAL:.3e}")
    print("-------------------------------------------------------------------------------")

    # Theoretical geometric joint probability under perfect independence + uniform:
    # p_i ≈ 2*eps_i / band_width_i  (for small eps_i)
    width_rho2  = BAND_RHO2_MAX - BAND_RHO2_MIN
    width_Q     = BAND_Q_MAX    - BAND_Q_MIN
    width_sin2  = BAND_SIN2_MAX - BAND_SIN2_MIN
    p_rho2_geom = min(1.0, 2.0 * EPS_RHO2_REAL / width_rho2)
    p_Q_geom    = min(1.0, 2.0 * EPS_Q_REAL    / width_Q)
    p_sin2_geom = min(1.0, 2.0 * EPS_SIN2_REAL / width_sin2)
    p_joint_geom = p_rho2_geom * p_Q_geom * p_sin2_geom

    print(f"Geometric p_rho2  ≈ {p_rho2_geom:.3e}")
    print(f"Geometric p_Q     ≈ {p_Q_geom:.3e}")
    print(f"Geometric p_sin2  ≈ {p_sin2_geom:.3e}")
    print(f"Geometric p_joint ≈ {p_joint_geom:.3e}  (expected triple fraction)")
    print("-------------------------------------------------------------------------------")

    rng = np.random.default_rng(int(seed_base))

    total_hits = 0
    total_draws = 0

    # We'll also track mean/min/max of each distance just for sanity.
    sum_d_rho2 = 0.0
    sum_d_Q    = 0.0
    sum_d_s2   = 0.0
    min_d_rho2 = float("inf")
    min_d_Q    = float("inf")
    min_d_s2   = float("inf")
    max_d_rho2 = 0.0
    max_d_Q    = 0.0
    max_d_s2   = 0.0

    t0 = time.time()
    remaining = total_triples
    while remaining > 0:
        n = batch_size if remaining >= batch_size else remaining
        remaining -= n

        # Draw triples
        rho2_samples = rng.uniform(BAND_RHO2_MIN, BAND_RHO2_MAX, size=n)
        Q_samples    = rng.uniform(BAND_Q_MIN,   BAND_Q_MAX,   size=n)
        s2_samples   = rng.uniform(BAND_SIN2_MIN, BAND_SIN2_MAX, size=n)

        d_rho2 = np.abs(rho2_samples - RHO2_TARGET)
        d_Q    = np.abs(Q_samples    - Q_TARGET)
        d_s2   = np.abs(s2_samples   - SIN2_TARGET)

        # accumulate stats
        sum_d_rho2 += float(d_rho2.sum())
        sum_d_Q    += float(d_Q.sum())
        sum_d_s2   += float(d_s2.sum())
        min_d_rho2 = min(min_d_rho2, float(d_rho2.min()))
        min_d_Q    = min(min_d_Q,    float(d_Q.min()))
        min_d_s2   = min(min_d_s2,   float(d_s2.min()))
        max_d_rho2 = max(max_d_rho2, float(d_rho2.max()))
        max_d_Q    = max(max_d_Q,    float(d_Q.max()))
        max_d_s2   = max(max_d_s2,   float(d_s2.max()))

        mask = (d_rho2 <= EPS_RHO2_REAL) & (d_Q <= EPS_Q_REAL) & (d_s2 <= EPS_SIN2_REAL)
        hits = int(mask.sum())
        total_hits  += hits
        total_draws += n

    t1 = time.time()
    elapsed = t1 - t0
    throughput = total_draws / elapsed if elapsed > 0 else float("inf")

    mean_d_rho2 = sum_d_rho2 / total_draws
    mean_d_Q    = sum_d_Q    / total_draws
    mean_d_s2   = sum_d_s2   / total_draws

    p_emp = total_hits / total_draws

    print("-------------------------------------------------------------------------------")
    print(f"[{MODULE_NAME_5}] GLOBAL JOINT LEDGER NULL SUMMARY ({label})")
    print(f"      Total triples            : {total_draws:,}")
    print(f"      x_real (rho2, Q, sin²W)  : "
          f"{RHO2_REAL:.12f}, {Q_REAL:.12f}, {SIN2_REAL:.12f}")
    print(f"      targets (rho2, Q, sin²W) : "
          f"{RHO2_TARGET:.12f}, {Q_TARGET:.12f}, {SIN2_TARGET:.12f}")
    print(f"      eps_real (rho2, Q, sin²W): "
          f"{EPS_RHO2_REAL:.3e}, {EPS_Q_REAL:.3e}, {EPS_SIN2_REAL:.3e}")
    print(f"      band_rho2, band_Q, band_sin2 : "
          f"[{BAND_RHO2_MIN}, {BAND_RHO2_MAX}], "
          f"[{BAND_Q_MIN}, {BAND_Q_MAX}], "
          f"[{BAND_SIN2_MIN}, {BAND_SIN2_MAX}]")
    print("      --- marginal distance stats (uniform null) ---")
    print(f"      mean d_rho2, min, max    : {mean_d_rho2:.3e}, "
          f"{min_d_rho2:.3e}, {max_d_rho2:.3e}")
    print(f"      mean d_Q,    min, max    : {mean_d_Q:.3e}, "
          f"{min_d_Q:.3e}, {max_d_Q:.3e}")
    print(f"      mean d_sin2, min, max    : {mean_d_s2:.3e}, "
          f"{min_d_s2:.3e}, {max_d_s2:.3e}")
    print("      --- joint hits ---")
    print(f"      count(all three ≤ eps)   : {total_hits} / {total_draws:,}")
    print(f"      Empirical p_emp (joint)  : {p_emp:.3e}")
    print(f"      Geometric p_joint (theory): {p_joint_geom:.3e}")
    print(f"      Total elapsed time       : {elapsed:6.3f} s")
    print(f"      Overall throughput       : {throughput:10.0f} triples / s")
    print(f"      Config SHA256            : {cfg_sha}")
    print("-------------------------------------------------------------------------------")
    return {
        "config": cfg,
        "config_sha256": cfg_sha,
        "total_triples": int(total_draws),
        "hits_joint": int(total_hits),
        "p_emp_joint": float(p_emp),
        "p_geom_joint": float(p_joint_geom),
        "elapsed_sec": float(elapsed),
        "throughput_triples_per_sec": float(throughput),
        "mean_d_rho2": float(mean_d_rho2),
        "min_d_rho2": float(min_d_rho2),
        "max_d_rho2": float(max_d_rho2),
        "mean_d_Q": float(mean_d_Q),
        "min_d_Q": float(min_d_Q),
        "max_d_Q": float(max_d_Q),
        "mean_d_sin2": float(mean_d_s2),
        "min_d_sin2": float(min_d_s2),
        "max_d_sin2": float(max_d_s2),
    }

# --- drive three independent 10M runs, like the earlier modules ---

print("===============================================================================")
print(f"{MODULE_NAME_5}: STARTING 3× JOINT LEDGER NULL RUNS "
      f"(each 10M triples, uniform on bands)")
print("===============================================================================")

M5_RUN1 = _run_one_joint_ledger_run("RUN1_main",              seed_base=441000000)
M5_RUN2 = _run_one_joint_ledger_run("RUN2_independent_seed",  seed_base=552000000)
M5_RUN3 = _run_one_joint_ledger_run("RUN3_independent_seed",  seed_base=663000000)

print("===============================================================================")
print(f"{MODULE_NAME_5}: ALL 3 RUNS COMPLETED")
print(f"  RUN1 config SHA256: {M5_RUN1['config_sha256']}")
print(f"  RUN2 config SHA256: {M5_RUN2['config_sha256']}")
print(f"  RUN3 config SHA256: {M5_RUN3['config_sha256']}")
print("===============================================================================")

# ===============================================================================
# MODULE_6_MDL_WIDTH_ROBUSTNESS:
#   Big MDL nulls at multiple band widths (±0.3, ±1.0, ±2.0 decades),
#   each with 3 × 10,000,000 universes.
#
#   Uses the FPK v4 kernel's fpk_mdl_null(...) to:
#     - Draw random universes in a band of width_decades around each real value
#     - Approximate each with rationals under the global q_max
#     - Compute MDL bits from denominators
#
#   For each (width, run), we print:
#     - Date, config JSON, SHA256
#     - Real MDL bits
#     - Null mean / std / min / max
#     - count(MDL <= real) and p_emp
# ===============================================================================

import json, hashlib, datetime, time, os

MODULE_NAME_6 = "MODULE_6_MDL_WIDTH_ROBUSTNESS"

def _sha256_of_dict(d):
    s = json.dumps(d, sort_keys=True)
    return hashlib.sha256(s.encode("utf-8")).hexdigest()

def _run_one_mdl_width_run(width_decades,
                           label,
                           seed,
                           total_universes=10_000_000):
    """
    Run a single big MDL-null with given width_decades and seed.
    Assumes fpk_mdl_null(...) is available from the FPK v4 kernel cell.
    """

    now_iso = datetime.datetime.utcnow().isoformat() + "Z"
    omp_threads = os.environ.get("OMP_NUM_THREADS", None)

    cfg = {
        "module": MODULE_NAME_6,
        "label": label,
        "date_iso": now_iso,
        "width_decades": float(width_decades),
        "total_universes": int(total_universes),
        "seed": int(seed),
        "omp_threads": None if omp_threads is None else int(omp_threads),
    }
    cfg_sha = _sha256_of_dict(cfg)

    print("===============================================================================")
    print(f"[{MODULE_NAME_6}] {label}")
    print(f"Date (UTC)       : {now_iso}")
    print(f"Config JSON      : {json.dumps(cfg, sort_keys=True)}")
    print(f"Config SHA256    : {cfg_sha}")
    print("-------------------------------------------------------------------------------")
    print(f"Using OMP_NUM_THREADS = {cfg['omp_threads']}")
    print(f"TOTAL_UNIVERSES       = {total_universes:,}")
    print(f"width_decades         = ±{width_decades}")
    print(f"seed                  = {seed}")
    print("-------------------------------------------------------------------------------")

    # Call the FPK MDL null kernel.
    # Assumed signature (from FPK v3/v4):
    #   fpk_mdl_null(num_universes,
    #                width_decades=1.0,
    #                seed=None,
    #                batch_size=None,
    #                verbose=True)
    t0 = time.time()
    res = fpk_mdl_null(
        num_universes=total_universes,
        width_decades=width_decades,
        seed=seed,
        verbose=False,      # suppress internal prints, we summarize here
    )
    t1 = time.time()
    elapsed = t1 - t0

    # Expected keys from FPK v3/v4:
    # res = {
    #   "mdl_real": ...,
    #   "mean": ...,
    #   "std": ...,
    #   "min": ...,
    #   "max": ...,
    #   "count_le": ...,
    #   "p_le": ...,
    #   "num_universes": ...,
    #   "width_decades": ...,
    #   "q_max": ...,
    #   "seed": ...,
    #   "elapsed_sec": ...,
    #   "universes_per_sec": ...
    # }

    mdl_real   = res.get("mdl_real", None)
    mean_bits  = res.get("mean", None)
    std_bits   = res.get("std", None)
    min_bits   = res.get("min", None)
    max_bits   = res.get("max", None)
    count_le   = res.get("count_le", None)
    p_emp      = res.get("p_le", None)
    q_max      = res.get("q_max", None)
    N_reported = res.get("num_universes", total_universes)

    # If the kernel filled its own elapsed_sec, prefer that; otherwise use ours.
    elapsed_kernel = res.get("elapsed_sec", elapsed)
    throughput = res.get(
        "universes_per_sec",
        N_reported / elapsed if elapsed > 0 else float("inf")
    )

    # Compute a rough Gaussian z-score for MDL_real vs null.
    if (mean_bits is not None) and (std_bits not in (None, 0)):
        z_score = (mdl_real - mean_bits) / std_bits
    else:
        z_score = None

    print("-------------------------------------------------------------------------------")
    print(f"[{MODULE_NAME_6}] GLOBAL MDL NULL SUMMARY ({label})")
    print(f"     Total universes       : {N_reported:,}")
    print(f"     Real MDL bits         : {mdl_real}")
    print(f"     Null mean bits        : {mean_bits:.3f}")
    print(f"     Null std bits         : {std_bits:.3f}")
    print(f"     Null min / max bits   : {min_bits} / {max_bits}")
    print(f"     q_max                 : {q_max}")
    print(f"     count(MDL <= real)    : {count_le} / {N_reported:,}")
    print(f"     Empirical p_emp       : {p_emp:.3e}")
    if z_score is not None:
        print(f"     Z-score (Gaussian)    : {z_score: .3f} σ")
    else:
        print(f"     Z-score (Gaussian)    : n/a")
    print(f"     Total elapsed time    : {elapsed_kernel:6.3f} s")
    print(f"     Overall throughput    : {throughput:10.0f} universes / s")
    print(f"     Config SHA256         : {cfg_sha}")
    print("-------------------------------------------------------------------------------")

    # Attach config + SHA to result dict for reproducibility
    res_out = dict(res)
    res_out["config"] = cfg
    res_out["config_sha256"] = cfg_sha
    return res_out

# -------------------------------------------------------------------------------
# Drive the full width-robustness experiment:
#   - widths = [0.3, 1.0, 2.0]
#   - 3 independent seeds per width
#   - 10,000,000 universes per run
# -------------------------------------------------------------------------------

print("===============================================================================")
print(f"{MODULE_NAME_6}: STARTING MDL WIDTH-ROBUSTNESS TESTS")
print("   widths = [0.3, 1.0, 2.0] decades; 3 runs each; 10M universes per run")
print("===============================================================================")

WIDTHS = [0.3, 1.0, 2.0]

MODULE_6_RESULTS = {}

for i, w in enumerate(WIDTHS):
    width_label = f"WIDTH_{w:.1f}dec"
    print("===============================================================================")
    print(f"{MODULE_NAME_6}: {width_label} — 3 runs of 10M universes each")
    print("===============================================================================")

    base_seed = (i + 1) * 100_000_000  # just a simple spacing; independent of earlier modules

    run1_label = f"{width_label}_RUN1_main"
    run2_label = f"{width_label}_RUN2_independent_seed"
    run3_label = f"{width_label}_RUN3_independent_seed"

    RUN1 = _run_one_mdl_width_run(width_decades=w,
                                  label=run1_label,
                                  seed=base_seed + 11)
    RUN2 = _run_one_mdl_width_run(width_decades=w,
                                  label=run2_label,
                                  seed=base_seed + 22)
    RUN3 = _run_one_mdl_width_run(width_decades=w,
                                  label=run3_label,
                                  seed=base_seed + 33)

    MODULE_6_RESULTS[width_label] = {
        "RUN1": RUN1,
        "RUN2": RUN2,
        "RUN3": RUN3,
    }

    print("===============================================================================")
    print(f"{MODULE_NAME_6}: {width_label} — ALL 3 RUNS COMPLETED")
    print(f"  RUN1 config SHA256: {RUN1['config_sha256']}")
    print(f"  RUN2 config SHA256: {RUN2['config_sha256']}")
    print(f"  RUN3 config SHA256: {RUN3['config_sha256']}")
    print("===============================================================================")

print("===============================================================================")
print(f"{MODULE_NAME_6}: ALL WIDTHS COMPLETED")
print("Stored in MODULE_6_RESULTS[width_label]['RUNk']")
print("   width_label ∈ { 'WIDTH_0.3dec', 'WIDTH_1.0dec', 'WIDTH_2.0dec' }")
print("===============================================================================")

# ===============================================================================
# MODULE_7_BIG_SNAP_SIN2W_NULL (v2, correct fpk_snap_null_scalar call)
#   Big scalar snap-null for sin^2(theta_W) with full look-elsewhere:
#
#   • Build rational family on [0.15, 0.35] with q_max = 1000, bits_max = 20.
#   • Compute eps_real = distance from sin^2(theta_W)_real to its closest p/q.
#   • Run big snap-null:
#         3 runs × 10,000,000 universes each
#         batch_size = 200,000
#         independent seeds
#
#   This version calls fpk_snap_null_scalar with the **full** signature:
#       fpk_snap_null_scalar(x_real, eps_real, rats, band_min, band_max,
#                            num_universes, seed, verbose)
# ===============================================================================

import json, hashlib, datetime, time, os
import numpy as np

MODULE_NAME_7 = "MODULE_7_BIG_SNAP_SIN2W_NULL"

def _sha256_of_dict_7(d):
    s = json.dumps(d, sort_keys=True)
    return hashlib.sha256(s.encode("utf-8")).hexdigest()

def _compute_eps_real_for_sin2w(band_min=0.15,
                                band_max=0.35,
                                q_max=1000,
                                bits_max=20):
    """
    Build the rational family for sin^2(theta_W) in [band_min, band_max]
    and compute:
        - x_real = sin^2(theta_W)_real from REG (fallback hardcoded)
        - best_rational = argmin_{r in family} |r - x_real|
        - eps_real = |x_real - best_rational|
    Returns (x_real, best_rational, eps_real, rats_array).
    """

    # Get sin^2(theta_W) from the registry if available
    try:
        x_real = float(REG["COUPLINGS"]["sin2_thetaW"]["value"])
    except Exception:
        x_real = 0.231220000589  # fallback to the value printed in FPK v4 header

    # Build rational family using FPK
    rats = fpk_build_rational_family(
        float(band_min),
        float(band_max),
        int(q_max),
        int(bits_max),
    )

    # Ensure it's a numpy array
    rats = np.asarray(rats, dtype=float)

    # Find the closest rational to x_real
    idx = int(np.argmin(np.abs(rats - x_real)))
    best_rational = float(rats[idx])
    eps_real = abs(best_rational - x_real)

    return x_real, best_rational, eps_real, rats

def _run_big_snap_null_sin2w(label,
                             x_real,
                             eps_real,
                             rats,
                             band_min=0.15,
                             band_max=0.35,
                             total_universes=10_000_000,
                             batch_size=200_000,
                             seed_base=0):
    """
    Chunked big snap-null run for sin^2(theta_W), given:
        - label: run label string
        - x_real, eps_real: real value + epsilon threshold
        - rats: numpy array of rationals (rational family)
        - band_min, band_max: band for reporting and for the kernel
        - total_universes: total N to simulate
        - batch_size: per-chunk universes
        - seed_base: base seed for chunks

    Uses FPK's fpk_snap_null_scalar with the full signature:
        fpk_snap_null_scalar(x_real, eps_real, rats,
                             band_min, band_max,
                             num_universes, seed, verbose)
    and aggregates:
        - mean d_min
        - min / max d_min
        - count(d_min <= eps_real)
        - p_emp
    """

    now_iso = datetime.datetime.utcnow().isoformat() + "Z"
    omp_threads = os.environ.get("OMP_NUM_THREADS", None)

    cfg = {
        "module": MODULE_NAME_7,
        "label": label,
        "date_iso": now_iso,
        "band_min": float(band_min),
        "band_max": float(band_max),
        "q_max": 1000,
        "bits_max": 20,
        "total_universes": int(total_universes),
        "batch_size": int(batch_size),
        "x_real": float(x_real),
        "eps_real": float(eps_real),
        "omp_threads": None if omp_threads is None else int(omp_threads),
        "seed_base": int(seed_base),
    }
    cfg_sha = _sha256_of_dict_7(cfg)

    print("===============================================================================")
    print(f"[{MODULE_NAME_7}] {label}")
    print(f"Date (UTC)       : {now_iso}")
    print(f"Config JSON      : {json.dumps(cfg, sort_keys=True)}")
    print(f"Config SHA256    : {cfg_sha}")
    print("-------------------------------------------------------------------------------")
    print(f"Using OMP_NUM_THREADS = {cfg['omp_threads']}")
    print(f"TOTAL_UNIVERSES       = {total_universes:,}")
    print(f"BATCH_SIZE            = {batch_size:,}")
    print(f"band                  = [{band_min}, {band_max}]")
    print(f"x_real                = {x_real:.12f}")
    print(f"eps_real              = {eps_real:.6e}")
    print("-------------------------------------------------------------------------------")

    N_remaining = int(total_universes)
    chunk_idx = 0

    total_N = 0
    sum_dmin = 0.0
    global_min_dmin = float("inf")
    global_max_dmin = 0.0
    total_hits = 0

    t0 = time.time()

    while N_remaining > 0:
        chunk_idx += 1
        n_this = batch_size if N_remaining >= batch_size else N_remaining
        seed_i = seed_base + chunk_idx

        # IMPORTANT: use full 8-arg signature, including band_min / band_max
        res_chunk = fpk_snap_null_scalar(
            float(x_real),          # x_real
            float(eps_real),        # eps_real
            rats,                   # rational family
            float(band_min),        # band_min
            float(band_max),        # band_max
            int(n_this),            # num_universes
            int(seed_i),            # seed
            0,                      # verbose
        )

        # Expected keys:
        #   'mean_dmin', 'min_dmin', 'max_dmin',
        #   'count_le', 'p_le', 'num_universes',
        #   'elapsed_sec', 'universes_per_sec', 'band_min', 'band_max', 'seed'
        n_i       = int(res_chunk.get("num_universes", n_this))
        mean_d_i  = float(res_chunk["mean_dmin"])
        min_d_i   = float(res_chunk["min_dmin"])
        max_d_i   = float(res_chunk["max_dmin"])
        hits_i    = int(res_chunk["count_le"])

        total_N         += n_i
        sum_dmin        += mean_d_i * n_i
        global_min_dmin  = min(global_min_dmin, min_d_i)
        global_max_dmin  = max(global_max_dmin, max_d_i)
        total_hits      += hits_i

        N_remaining     -= n_this

    t1 = time.time()
    elapsed = t1 - t0

    mean_d_global = sum_dmin / total_N if total_N > 0 else float("nan")
    p_emp = total_hits / total_N if total_N > 0 else 0.0
    throughput = total_N / elapsed if elapsed > 0 else float("inf")

    print("-------------------------------------------------------------------------------")
    print(f"[{MODULE_NAME_7}] GLOBAL SNAP NULL SUMMARY ({label})")
    print(f"      Total universes          : {total_N:,}")
    print(f"      x_real                   : {x_real:.12f}")
    print(f"      eps_real                 : {eps_real:.6e}")
    print(f"      band                     : [{band_min}, {band_max}]")
    print(f"      # rationals in family    : {len(rats):,}")
    print(f"      mean d_min               : {mean_d_global:.3e}")
    print(f"      min / max d_min          : {global_min_dmin:.3e} / {global_max_dmin:.3e}")
    print(f"      count(d_min ≤ eps_real)  : {total_hits:,} / {total_N:,}")
    print(f"      Empirical p_emp          : {p_emp:.3e}")
    print(f"      Total elapsed time       : {elapsed:6.3f} s")
    print(f"      Overall throughput       : {throughput:10.0f} universes / s")
    print(f"      Config SHA256            : {cfg_sha}")
    print("-------------------------------------------------------------------------------")

    out = {
        "config": cfg,
        "config_sha256": cfg_sha,
        "mean_d_min": mean_d_global,
        "min_d_min": global_min_dmin,
        "max_d_min": global_max_dmin,
        "count_le": total_hits,
        "p_emp": p_emp,
        "total_universes": total_N,
        "elapsed_sec": elapsed,
        "universes_per_sec": throughput,
    }
    return out

# -------------------------------------------------------------------------------
# Drive the sin^2(theta_W) test: compute eps_real from best rational, then run
# 3 × 10M universes with independent seeds.
# -------------------------------------------------------------------------------

print("===============================================================================")
print(f"{MODULE_NAME_7}: STARTING 3× BIG SNAP-NULL RUNS FOR sin^2(theta_W) (10M each)")
print("       (look-elsewhere over all p/q with q ≤ 1000, bits ≤ 20 in [0.15, 0.35])")
print("===============================================================================")

SIN2W_BAND_MIN = 0.15
SIN2W_BAND_MAX = 0.35
SIN2W_Q_MAX    = 1000
SIN2W_BITS_MAX = 20

# Step 1: compute eps_real from best rational in the band
x_real_sin2, best_rat_sin2, eps_real_sin2, rats_sin2 = _compute_eps_real_for_sin2w(
    band_min=SIN2W_BAND_MIN,
    band_max=SIN2W_BAND_MAX,
    q_max=SIN2W_Q_MAX,
    bits_max=SIN2W_BITS_MAX,
)

print("-------------------------------------------------------------------------------")
print(f"[{MODULE_NAME_7}] SETUP: sin^2(theta_W) best rational in band")
print(f"      sin^2(theta_W)_real   = {x_real_sin2:.12f}")
print(f"      band                  = [{SIN2W_BAND_MIN}, {SIN2W_BAND_MAX}]")
print(f"      q_max, bits_max       = {SIN2W_Q_MAX}, {SIN2W_BITS_MAX}")
print(f"      # rationals in family = {len(rats_sin2):,}")
print(f"      best rational         = {best_rat_sin2:.12f}")
print(f"      eps_real              = |real - best| = {eps_real_sin2:.6e}")
print("-------------------------------------------------------------------------------")

MODULE_7_RESULTS = {}

TOTAL_UNI = 10_000_000
BATCH     = 200_000

run1_label = "SIN2W_RUN1_main"
run2_label = "SIN2W_RUN2_independent_seed"
run3_label = "SIN2W_RUN3_independent_seed"

RUN1 = _run_big_snap_null_sin2w(
    label           = run1_label,
    x_real          = x_real_sin2,
    eps_real        = eps_real_sin2,
    rats            = rats_sin2,
    band_min        = SIN2W_BAND_MIN,
    band_max        = SIN2W_BAND_MAX,
    total_universes = TOTAL_UNI,
    batch_size      = BATCH,
    seed_base       = 611000000,
)
RUN2 = _run_big_snap_null_sin2w(
    label           = run2_label,
    x_real          = x_real_sin2,
    eps_real        = eps_real_sin2,
    rats            = rats_sin2,
    band_min        = SIN2W_BAND_MIN,
    band_max        = SIN2W_BAND_MAX,
    total_universes = TOTAL_UNI,
    batch_size      = BATCH,
    seed_base       = 722000000,
)
RUN3 = _run_big_snap_null_sin2w(
    label           = run3_label,
    x_real          = x_real_sin2,
    eps_real        = eps_real_sin2,
    rats            = rats_sin2,
    band_min        = SIN2W_BAND_MIN,
    band_max        = SIN2W_BAND_MAX,
    total_universes = TOTAL_UNI,
    batch_size      = BATCH,
    seed_base       = 833000000,
)

MODULE_7_RESULTS["SIN2W"] = {
    "RUN1": RUN1,
    "RUN2": RUN2,
    "RUN3": RUN3,
}

print("===============================================================================")
print(f"{MODULE_NAME_7}: ALL 3 RUNS COMPLETED FOR sin^2(theta_W)")
print(f"  RUN1 config SHA256: {RUN1['config_sha256']}")
print(f"  RUN2 config SHA256: {RUN2['config_sha256']}")
print(f"  RUN3 config SHA256: {RUN3['config_sha256']}")
print("===============================================================================")

# ===============================================================================
# MODULE_8_BIG_SNAP_REGISTRY_SCAN:
#   Big snap-null scan for selected registry scalars.
#
#   For each scalar (category, name, x_real) in PARAM_SPECS:
#       1) Define a band of ±1 decade around x_real (clipped to [1e-10, 1.0]):
#              band_min = max(1e-10, x_real / 10)
#              band_max = min(1.0,   x_real * 10)
#       2) Build rational family:
#              rats = fpk_build_rational_family(band_min, band_max, q_max=1000, bits_max=20)
#       3) Find closest rational x_best and eps_real = |x_real - x_best|.
#       4) Run 3× big snap-null:
#              10,000,000 universes per run
#              batch_size = 200,000
#              seeds: base + {111000, 222000, 333000}
#       5) Print per-run global summary with date + SHA256.
#
#   Results stored in MODULE_8_RESULTS[(cat, name)]["RUNk"].
# ===============================================================================

import json, hashlib, datetime, time, os
import numpy as np

MODULE_NAME_8 = "MODULE_8_BIG_SNAP_REGISTRY_SCAN"

def _sha256_of_dict_8(d):
    s = json.dumps(d, sort_keys=True)
    return hashlib.sha256(s.encode("utf-8")).hexdigest()

def _make_band_around_value(x, width_decades=1.0,
                            clip_min=1e-10, clip_max=1.0):
    """
    Construct a multiplicative band [x/f, x*f] around x,
    where f = 10^width_decades, then clip to [clip_min, clip_max].
    Ensures band_max > band_min by a tiny margin if necessary.
    """
    x = float(x)
    f = 10.0**width_decades
    lo = max(clip_min, x / f)
    hi = min(clip_max, x * f)
    if hi <= lo:
        # In pathological cases (very small x), expand slightly
        eps = max(abs(x) * 1e-6, 1e-8)
        hi = lo + eps
    return lo, hi

def _run_big_snap_null_scalar_generic(label,
                                      cat,
                                      name,
                                      x_real,
                                      eps_real,
                                      rats,
                                      band_min,
                                      band_max,
                                      total_universes=10_000_000,
                                      batch_size=200_000,
                                      seed_base=0):
    """
    Chunked big snap-null run for a generic scalar using FPK v4:

        fpk_snap_null_scalar(x_real, eps_real, rats,
                             band_min, band_max,
                             num_universes, seed, verbose)
    """

    now_iso = datetime.datetime.utcnow().isoformat() + "Z"
    omp_threads = os.environ.get("OMP_NUM_THREADS", None)
    if omp_threads is not None:
        omp_threads = int(omp_threads)

    cfg = {
        "module": MODULE_NAME_8,
        "label": label,
        "date_iso": now_iso,
        "category": cat,
        "name": name,
        "band_min": float(band_min),
        "band_max": float(band_max),
        "q_max": 1000,
        "bits_max": 20,
        "total_universes": int(total_universes),
        "batch_size": int(batch_size),
        "x_real": float(x_real),
        "eps_real": float(eps_real),
        "omp_threads": omp_threads,
        "seed_base": int(seed_base),
    }
    cfg_sha = _sha256_of_dict_8(cfg)

    print("===============================================================================")
    print(f"[{MODULE_NAME_8}] {label} — {cat}/{name}")
    print(f"Date (UTC)       : {now_iso}")
    print(f"Config JSON      : {json.dumps(cfg, sort_keys=True)}")
    print(f"Config SHA256    : {cfg_sha}")
    print("-------------------------------------------------------------------------------")
    print(f"Using OMP_NUM_THREADS = {cfg['omp_threads']}")
    print(f"TOTAL_UNIVERSES       = {total_universes:,}")
    print(f"BATCH_SIZE            = {batch_size:,}")
    print(f"band                  = [{band_min}, {band_max}]")
    print(f"x_real                = {x_real:.12e}")
    print(f"eps_real              = {eps_real:.6e}")
    print(f"# rationals in family = {len(rats):,}")
    print("-------------------------------------------------------------------------------")

    N_remaining = int(total_universes)
    chunk_idx = 0

    total_N = 0
    sum_dmin = 0.0
    global_min_dmin = float("inf")
    global_max_dmin = 0.0
    total_hits = 0

    t0 = time.time()

    while N_remaining > 0:
        chunk_idx += 1
        n_this = batch_size if N_remaining >= batch_size else N_remaining
        seed_i = seed_base + chunk_idx

        res_chunk = fpk_snap_null_scalar(
            float(x_real),       # x_real
            float(eps_real),     # eps_real
            rats,                # rational family
            float(band_min),     # band_min
            float(band_max),     # band_max
            int(n_this),         # num_universes
            int(seed_i),         # seed
            0,                   # verbose (0 = silent)
        )

        n_i      = int(res_chunk.get("num_universes", n_this))
        mean_d_i = float(res_chunk["mean_dmin"])
        min_d_i  = float(res_chunk["min_dmin"])
        max_d_i  = float(res_chunk["max_dmin"])
        hits_i   = int(res_chunk["count_le"])

        total_N         += n_i
        sum_dmin        += mean_d_i * n_i
        global_min_dmin  = min(global_min_dmin, min_d_i)
        global_max_dmin  = max(global_max_dmin, max_d_i)
        total_hits      += hits_i

        N_remaining     -= n_this

    t1 = time.time()
    elapsed = t1 - t0

    mean_d_global = sum_dmin / total_N if total_N > 0 else float("nan")
    p_emp         = total_hits / total_N if total_N > 0 else 0.0
    throughput    = total_N / elapsed if elapsed > 0 else float("inf")

    print("-------------------------------------------------------------------------------")
    print(f"[{MODULE_NAME_8}] GLOBAL SNAP NULL SUMMARY ({label} — {cat}/{name})")
    print(f"      Total universes          : {total_N:,}")
    print(f"      x_real                   : {x_real:.12e}")
    print(f"      eps_real                 : {eps_real:.6e}")
    print(f"      band                     : [{band_min}, {band_max}]")
    print(f"      # rationals in family    : {len(rats):,}")
    print(f"      mean d_min               : {mean_d_global:.3e}")
    print(f"      min / max d_min          : {global_min_dmin:.3e} / {global_max_dmin:.3e}")
    print(f"      count(d_min ≤ eps_real)  : {total_hits:,} / {total_N:,}")
    print(f"      Empirical p_emp          : {p_emp:.3e}")
    print(f"      Total elapsed time       : {elapsed:6.3f} s")
    print(f"      Overall throughput       : {throughput:10.0f} universes / s")
    print(f"      Config SHA256            : {cfg_sha}")
    print("-------------------------------------------------------------------------------")

    out = {
        "config": cfg,
        "config_sha256": cfg_sha,
        "mean_d_min": mean_d_global,
        "min_d_min": global_min_dmin,
        "max_d_min": global_max_dmin,
        "count_le": total_hits,
        "p_emp": p_emp,
        "total_universes": total_N,
        "elapsed_sec": elapsed,
        "universes_per_sec": throughput,
    }
    return out

# ------------------------------------------------------------------------------
# Hard-coded real values from the FPK v4 registry printout
# (avoids assumptions about internal REG structure)
# ------------------------------------------------------------------------------

PARAM_SPECS = [
    # category,       name,               x_real
    ("CKM",         "CKM_s12",           0.224299998336),
    ("CKM",         "CKM_s13",           0.003939999959),
    ("CKM",         "CKM_s23",           0.042200001315),
    ("CKM",         "CKM_delta_over_pi", 0.381971862314),
    ("COUPLINGS",   "alpha",             0.007297352601),
    ("COUPLINGS",   "alpha_s_MZ",        0.117899998815),
    ("COUPLINGS",   "sin2_thetaW",       0.231220000589),
    ("EW",          "MW_over_v",         0.326452417182),
    ("EW",          "MZ_over_v",         0.370350617284),
    ("HIGGS",       "MH_over_v",         0.508692138982),
    ("QUARK_HEAVY", "mt_over_v",         0.701365634918),
]

TOTAL_UNI_8 = 10_000_000
BATCH_8     = 200_000
Q_MAX_8     = 1000
BITS_MAX_8  = 20

print("===============================================================================")
print(f"{MODULE_NAME_8}: STARTING BIG SNAP-NULL SCAN FOR REGISTRY SCALARS")
print("       3 runs per parameter, 10M universes per run")
print("       bands: ±1 decade around x_real, clipped to [1e-10, 1.0]")
print("       rational family: q ≤ 1000, bits ≤ 20")
print("===============================================================================")

MODULE_8_RESULTS = {}

for idx, (cat, name, x_real) in enumerate(PARAM_SPECS):
    band_min, band_max = _make_band_around_value(
        x_real, width_decades=1.0, clip_min=1e-10, clip_max=1.0
    )

    # Build rational family for this scalar
    rats = fpk_build_rational_family(
        float(band_min),
        float(band_max),
        int(Q_MAX_8),
        int(BITS_MAX_8),
    )
    rats = np.asarray(rats, dtype=float)

    # Find best rational and eps_real
    idx_best = int(np.argmin(np.abs(rats - x_real)))
    x_best   = float(rats[idx_best])
    eps_real = abs(x_best - x_real)

    print("-------------------------------------------------------------------------------")
    print(f"[{MODULE_NAME_8}] SETUP for {cat}/{name}")
    print(f"      x_real                = {x_real:.12e}")
    print(f"      band                  = [{band_min}, {band_max}]")
    print(f"      q_max, bits_max       = {Q_MAX_8}, {BITS_MAX_8}")
    print(f"      # rationals in family = {len(rats):,}")
    print(f"      best rational         = {x_best:.12e}")
    print(f"      eps_real = |real-best|= {eps_real:.6e}")
    print("-------------------------------------------------------------------------------")

    # Distinct seed bases per parameter, well separated
    base = 800_000_000 + idx * 1_000_000

    run1_label = f"{cat}_{name}_RUN1_main"
    run2_label = f"{cat}_{name}_RUN2_independent_seed"
    run3_label = f"{cat}_{name}_RUN3_independent_seed"

    RUN1 = _run_big_snap_null_scalar_generic(
        label           = run1_label,
        cat             = cat,
        name            = name,
        x_real          = x_real,
        eps_real        = eps_real,
        rats            = rats,
        band_min        = band_min,
        band_max        = band_max,
        total_universes = TOTAL_UNI_8,
        batch_size      = BATCH_8,
        seed_base       = base + 111_000,
    )
    RUN2 = _run_big_snap_null_scalar_generic(
        label           = run2_label,
        cat             = cat,
        name            = name,
        x_real          = x_real,
        eps_real        = eps_real,
        rats            = rats,
        band_min        = band_min,
        band_max        = band_max,
        total_universes = TOTAL_UNI_8,
        batch_size      = BATCH_8,
        seed_base       = base + 222_000,
    )
    RUN3 = _run_big_snap_null_scalar_generic(
        label           = run3_label,
        cat             = cat,
        name            = name,
        x_real          = x_real,
        eps_real        = eps_real,
        rats            = rats,
        band_min        = band_min,
        band_max        = band_max,
        total_universes = TOTAL_UNI_8,
        batch_size      = BATCH_8,
        seed_base       = base + 333_000,
    )

    MODULE_8_RESULTS[(cat, name)] = {
        "RUN1": RUN1,
        "RUN2": RUN2,
        "RUN3": RUN3,
    }

print("===============================================================================")
print(f"{MODULE_NAME_8}: ALL PARAMETER SCANS COMPLETED")
for (cat, name), runs in MODULE_8_RESULTS.items():
    print(f"  {cat}/{name}:")
    print(f"    RUN1 SHA256: {runs['RUN1']['config_sha256']}")
    print(f"    RUN2 SHA256: {runs['RUN2']['config_sha256']}")
    print(f"    RUN3 SHA256: {runs['RUN3']['config_sha256']}")
print("===============================================================================")
