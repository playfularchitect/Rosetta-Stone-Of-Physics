#!/usr/bin/env python3
# =================================================================================================
# PFTC v3 STARTER — Fraction-First, Self-Auditing, Append-Only (Unified REL_TOL, p∈{6,10})
# -------------------------------------------------------------------------------------------------
# Standardization notes (v3u):
#   • Unified relative tolerance across *all* modules:
#       REL_TOL_REL     = 1e-10        # relative (fraction of value)
#       REL_TOL_PERCENT = 1e-8         # percent units (used by this module)
#   • Exact Fractions for all math; only convert to Decimal to report error%.
#   • Supports a finer unit for tiny quantities by allowing p in {6, 10}.
#   • UTC timestamp fix (timezone-aware; no deprecation warnings).
#   • Writes:
#       - master.csv:       all rows as entered
#       - good.csv:         smallest |error%| per (symbol, p), PASS rows only
#       - needs_redo.csv:   rows that failed OR were superseded (not best for their (symbol,p))
#   • Prints a crisp audit line for each new block.
#   • Adds rational text column: pred_rational_text = "k/(49*50*137^p)".
# -------------------------------------------------------------------------------------------------
# How to use:
#   • Run this once now. Then keep APPENDING your module bricks below (MODULE 001, 002, …).
#   • Each module calls pftc_add_block(symbol, p, k, observed_value, …).
#   • No editing of earlier code. If a block’s wrong, paste a corrected one later — the best one wins.
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from datetime import datetime, timezone
import os, csv, typing as _t

try:
    import pandas as _pd
except Exception:
    _pd = None

# ---------- Precision ----------
getcontext().prec = 80  # generous headroom for Decimal edge conversions

# ---------- Unified tolerance (standard for all modules) ----------
REL_TOL_REL     = Decimal("1e-10")  # relative
REL_TOL_PERCENT = Decimal("1e-8")   # percent (this starter compares error in %)

# ---------- Allowed canonical p-values ----------
ALLOWED_P = {6, 10}  # p=6 default grid; p=10 for very small observables (e.g., neutrino masses)

# ---------- Global in-memory registry (survives within the same runtime) ----------
try:
    _PFTC_REGISTRY
except NameError:
    _PFTC_REGISTRY = []  # list[dict]

# ---------- SM gate constants (explicit) ----------
SM_R1 = 49
SM_R2 = 50
SM_D  = 137
SM_GATE = (SM_R1, SM_R2, SM_D)
_SM_BASE = SM_R1 * SM_R2  # 2450

# ---------- Paths ----------
_PFTC_LEDGER_DIR = "pftc_ledgers"
os.makedirs(_PFTC_LEDGER_DIR, exist_ok=True)
_MASTER_CSV      = os.path.join(_PFTC_LEDGER_DIR, "master.csv")
_GOOD_CSV        = os.path.join(_PFTC_LEDGER_DIR, "good.csv")
_NEEDS_REDO_CSV  = os.path.join(_PFTC_LEDGER_DIR, "needs_redo.csv")

# ---------- Helpers: Fractions everywhere ----------
def _to_fraction(x: _t.Any) -> Fraction:
    """
    Create a Fraction without float roundoff surprises.
    Accepts: Fraction, int, Decimal, str ("a/b" or decimal), tuple(num,den), float (via str).
    """
    if isinstance(x, Fraction):
        return x
    if isinstance(x, int):
        return Fraction(x, 1)
    if isinstance(x, Decimal):
        return Fraction(str(x))
    if isinstance(x, str):
        return Fraction(x)
    if isinstance(x, tuple) and len(x) == 2:
        return Fraction(int(x[0]), int(x[1]))
    if isinstance(x, float):
        return Fraction(str(x))
    raise ValueError(f"Cannot convert to Fraction: {type(x)} -> {x!r}")

def U_p(p: int) -> Fraction:
    """
    Exact unit: U_p = 1 / (49 * 50 * 137^p), as a Fraction.
    """
    if not isinstance(p, int):
        raise TypeError("p must be int.")
    return Fraction(1, _SM_BASE * (SM_D ** p))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _fmt_pct(x: _t.Optional[Decimal]) -> str:
    if x is None:
        return "—"
    return f"{x:.12E}%"

def _fmt_bool(ok: bool) -> str:
    return "✓" if ok else "✗"

def _ensure_int(k: _t.Any) -> int:
    """
    Validate k is an integer (or a Fraction/Decimal/str that equals an integer), then return int(k).
    """
    if isinstance(k, int):
        return k
    if isinstance(k, Fraction) and k.denominator == 1:
        return int(k.numerator)
    if isinstance(k, Decimal) and k == int(k):
        return int(k)
    try:
        kf = _to_fraction(k)
        if kf.denominator == 1:
            return int(kf.numerator)
    except Exception:
        pass
    raise TypeError(f"k must be an integer. Got: {k!r}")

# ---------- Core add-block ----------
def pftc_add_block(
    symbol: str,
    p: int,
    k: _t.Any,
    observed_value: _t.Any,
    rel_tol_percent: _t.Union[float, Decimal, str] = REL_TOL_PERCENT,  # unified tolerance (percent)
    notes: str = "",
    tags: _t.Union[str, _t.Iterable[str]] = (),
):
    """
    Append a new physics block entry:
      • symbol: e.g., "CKM|Vus", "alpha_inverse_CODATA_ref"
      • p:     canonical grid index (ALLOWED_P = {6, 10})
      • k:     integer multiplier for U_p
      • observed_value: Fraction-friendly (exact if rationalizable)
      • rel_tol_percent: |(pred-obs)/obs|*100 <= tol ⇒ error rule passes (default = 1e-8%)
      • notes/tags: metadata

    Side effects:
      • Computes predicted = k * U_p(p) as exact Fraction
      • Converts to Decimal ONLY for error% reporting
      • Validates rules: (p∈ALLOWED_P), (k integer), (error within tol)
      • Appends to global registry and rewrites master/good/needs_redo CSVs
      • Pretty-prints a one-line audit table
    """
    k_int = _ensure_int(k)
    obs_q = _to_fraction(observed_value)
    unit_q = U_p(p)
    pred_q = Fraction(k_int, 1) * unit_q

    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)

    tol_dec = Decimal(str(rel_tol_percent)) if not isinstance(rel_tol_percent, Decimal) else rel_tol_percent

    # Error handling, including exact-zero observables
    if obs_dec == 0:
        # If both observed and predicted are exactly zero, treat as perfect pass with 0% error.
        if pred_dec == 0:
            err_pct = Decimal(0)
            rule_err_ok = True
        else:
            err_pct = Decimal("Infinity")
            rule_err_ok = False
    else:
        err_pct = (pred_dec - obs_dec) / obs_dec * Decimal(100)
        rule_err_ok = abs(err_pct) <= tol_dec

    # Rule checks
    rule_p_ok  = (p in ALLOWED_P)
    rule_k_int = True  # by construction

    # tags normalization
    if isinstance(tags, str):
        tags_out = [t.strip() for t in tags.split(",")] if tags else []
    else:
        tags_out = list(tags)

    # rational text: k/(49*50*137^p)
    pred_rational_text = f"{k_int}/({_SM_BASE}*{SM_D}^{p})"

    row = {
        "timestamp_iso": datetime.now(timezone.utc).isoformat(timespec="seconds"),
        "symbol": symbol,
        "p": p,
        "k": k_int,
        "SM_gate": f"{SM_GATE}",
        "U_p_fraction": f"{unit_q.numerator}/{unit_q.denominator}",
        "pred_fraction": f"{pred_q.numerator}/{pred_q.denominator}",
        "obs_fraction": f"{obs_q.numerator}/{obs_q.denominator}",
        "pred_decimal": str(pred_dec),
        "obs_decimal": str(obs_dec),
        "pred_rational_text": pred_rational_text,
        "error_percent": (None if err_pct is None else float(err_pct)),
        # Keep CSV key name for backwards-compat, but semantics are p∈ALLOWED_P:
        "rule_p_eq_6": rule_p_ok,
        "rule_k_integer": rule_k_int,
        "rule_error_within_tol": rule_err_ok,
        "passes_all_rules": (rule_p_ok and rule_k_int and rule_err_ok),
        "rel_tol_percent": float(tol_dec),
        "notes": notes,
        "tags": "|".join(tags_out),
    }

    _PFTC_REGISTRY.append(row)
    _pftc_write_csvs(_PFTC_REGISTRY)

    _pftc_print_audit([row])
    return row

# ---------- CSV writers (master / good / needs_redo) ----------
def _pftc_write_csvs(registry: list):
    """
    master.csv      : all rows
    good.csv        : for each (symbol, p), choose the PASS row with smallest absolute error_percent
    needs_redo.csv  : rows that did NOT pass OR are not the best for their (symbol, p)
    """
    field_order = [
        "timestamp_iso","symbol","p","k","SM_gate","U_p_fraction",
        "pred_fraction","obs_fraction","pred_decimal","obs_decimal","pred_rational_text",
        "error_percent","rule_p_eq_6","rule_k_integer","rule_error_within_tol",
        "passes_all_rules","rel_tol_percent","notes","tags","is_best_for_symbol_p"
    ]

    # build index for best-per-(symbol,p) among PASS rows
    best_idx = {}   # key: (symbol,p) -> (abs_err, idx)
    for idx, r in enumerate(registry):
        if r.get("passes_all_rules"):
            key = (r["symbol"], r["p"])
            e = r.get("error_percent")
            if e is None:
                continue
            ae = abs(e)
            prev = best_idx.get(key)
            if prev is None or ae < prev[0]:
                best_idx[key] = (ae, idx)

    # annotate rows with is_best_for_symbol_p
    annotated = []
    for i, r in enumerate(registry):
        key = (r["symbol"], r["p"])
        is_best = (key in best_idx and best_idx[key][1] == i)
        rr = dict(r)
        rr["is_best_for_symbol_p"] = bool(is_best)
        annotated.append(rr)

    master_rows = annotated
    good_rows   = [r for r in annotated if r.get("passes_all_rules") and r.get("is_best_for_symbol_p")]
    # needs_redo = not pass OR (pass but not best)
    bad_rows    = [r for r in annotated if (not r.get("passes_all_rules")) or (r.get("passes_all_rules") and not r.get("is_best_for_symbol_p"))]

    def _write(path, rows):
        if _pd is not None:
            _pd.DataFrame(rows, columns=field_order).to_csv(path, index=False)
        else:
            import csv as _csv
            with open(path, "w", newline="") as f:
                w = _csv.DictWriter(f, fieldnames=field_order)
                w.writeheader()
                for r in rows:
                    w.writerow(r)

    _write(_MASTER_CSV, master_rows)
    _write(_GOOD_CSV,   good_rows)
    _write(_NEEDS_REDO_CSV, bad_rows)

# ---------- Pretty audit print ----------
def _pftc_print_audit(rows: list):
    headers = [
        "symbol","k","p","U_p (frac)","pred (frac)","obs (frac)",
        "pred rational","error%","p∈P","k∈ℤ","|err|≤tol","PASS"
    ]
    line = "─" * 140
    print("\n" + line)
    print("PFTC BLOCK AUDIT   (REL_TOL = 1e-10 rel  = 1e-8%)")
    print(line)
    print("{:<26} {:>18} {:>3} {:>20} {:>22} {:>22} {:>20} {:>14} {:>5} {:>5} {:>8} {:>6}".format(*headers))
    print(line)
    for r in rows:
        print("{:<26} {:>18} {:>3} {:>20} {:>22} {:>22} {:>20} {:>14} {:>5} {:>5} {:>8} {:>6}".format(
            (r["symbol"][:26]),
            r["k"],
            r["p"],
            r["U_p_fraction"],
            r["pred_fraction"],
            r["obs_fraction"],
            r["pred_rational_text"][:20],
            _fmt_pct(Decimal(str(r["error_percent"])) if r["error_percent"] is not None else None),
            _fmt_bool(r["rule_p_eq_6"]),  # semantics: p∈ALLOWED_P
            _fmt_bool(r["rule_k_integer"]),
            _fmt_bool(r["rule_error_within_tol"]),
            _fmt_bool(r["passes_all_rules"]),
        ))
    print(line)
    print(f"CSVs refreshed: {_MASTER_CSV} | {_GOOD_CSV} | {_NEEDS_REDO_CSV}")
    print(line)

# =================================================================================================
# SMOKE TEST MODULE — exact equality (k=1, obs = U_p(6)) so PASS with 0% error, seeds ledgers.
# =================================================================================================
_ = pftc_add_block(
    symbol="SMOKE|UNIT@p6,k=1",
    p=6,
    k=1,
    observed_value=U_p(6),
    rel_tol_percent=REL_TOL_PERCENT,  # unified tol (1e-8%)
    notes="Pipeline self-test; exact equality by construction.",
    tags=["self-test","unit"]
)
# (Optional) smoke test at p=10 as well:
_ = pftc_add_block(
    symbol="SMOKE|UNIT@p10,k=1",
    p=10,
    k=1,
    observed_value=U_p(10),
    rel_tol_percent=REL_TOL_PERCENT,
    notes="Secondary self-test at finer grid p=10.",
    tags=["self-test","unit"]
)
# =================================================================================================
# END OF PFTC v3 STARTER (Unified REL_TOL, p∈{6,10})
# =================================================================================================




# =================================================================================================
# MODULE 001 (v3u) — α⁻¹ (CODATA ref) @ p=6 — Fraction-first, auto-k (round-half-up), self-auditing
# -------------------------------------------------------------------------------------------------
# Notes:
#   • Uses unified tolerance from the v3 STARTER:
#       REL_TOL_REL = 1e-10  (relative)  ⇒  REL_TOL_PERCENT = 1e-8 (%)
#   • Exact Fractions only; converts to Decimal only inside pftc_add_block for error reporting.
#   • k is inferred via exact round-half-up on (observed / U_p(6)).
#   • Requires the PFTC v3 STARTER to have been run (defines U_p, pftc_add_block, REL_TOL_PERCENT).
# =================================================================================================

from fractions import Fraction

# ---- local helper: exact round-half-up for nonnegative Fractions -> int
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    """
    For x >= 0 rational, return nearest integer using round-half-up:
      k = floor(x + 1/2)
    Works exactly in Q (no floats).
    """
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

# ---- observed α^{-1} (CODATA reference), captured as a rational from its decimal string
obs_alpha_inv = Fraction("137.035999207000")

# ---- choose p and compute exact unit
p = 6
unit_q = U_p(p)  # exact Fraction: 1/(49*50*137^p)

# ---- infer k via exact rational arithmetic with round-half-up
k_inferred = _round_half_up_fraction_to_int(obs_alpha_inv / unit_q)

# ---- append audited ledger row (uses unified tolerance from starter)
_ = pftc_add_block(
    symbol="alpha_inverse_CODATA_ref",
    p=p,
    k=k_inferred,
    observed_value=obs_alpha_inv,
    rel_tol_percent=REL_TOL_PERCENT,   # unified tol: 1e-8 %
    notes="Redo PTFC: α^{-1} (CODATA ref) with exact Fractions; k inferred by round-half-up.",
    tags=["alpha","CODATA","redo","PTFC"]
)
# =================================================================================================
# END MODULE 001
# =================================================================================================



# =================================================================================================
# MODULE 002 (v3u) — α⁻¹(MZ, effective) @ p=6 — Fraction-first, auto-k (round-half-up), self-auditing
# -------------------------------------------------------------------------------------------------
# Notes:
#   • Uses unified tolerance from the v3 STARTER:
#       REL_TOL_REL = 1e-10  (relative)  ⇒  REL_TOL_PERCENT = 1e-8 (%)
#   • Exact Fractions only; k inferred via exact round-half-up on (observed / U_p(6)).
#   • Requires the PFTC v3 STARTER (defines U_p, pftc_add_block, REL_TOL_PERCENT).
# =================================================================================================

from fractions import Fraction

# ---- local helper: exact round-half-up for nonnegative Fractions -> int
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    """
    For x >= 0 rational, return nearest integer using round-half-up:
      k = floor(x + 1/2)
    Works exactly in Q (no floats).
    """
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

# ---- observed α^{-1}(MZ, effective), captured as a rational from its decimal string
obs_alpha_inv_MZ_eff = Fraction("127.955000000000")

# ---- choose p and compute exact unit
p = 6
unit_q = U_p(p)  # exact Fraction: 1/(49*50*137^p)

# ---- infer k via exact rational arithmetic with round-half-up
k_inferred = _round_half_up_fraction_to_int(obs_alpha_inv_MZ_eff / unit_q)

# ---- append audited ledger row (uses unified tolerance from starter)
_ = pftc_add_block(
    symbol="alpha_inverse_at_MZ_effective",
    p=p,
    k=k_inferred,
    observed_value=obs_alpha_inv_MZ_eff,
    rel_tol_percent=REL_TOL_PERCENT,   # unified tol: 1e-8 %
    notes="Redo PTFC: α^{-1}(MZ, effective) with exact Fractions; k inferred by round-half-up.",
    tags=["alpha","MZ","effective","redo","PTFC"]
)
# =================================================================================================
# END MODULE 002
# =================================================================================================



# =================================================================================================
# MODULE 003 (v3u) — PTFC-SEED (CORE, p=6) — fraction-first, self-auditing, residues, small artifacts
# -------------------------------------------------------------------------------------------------
# • Uses PFTC v3 STARTER's U_p() and pftc_add_block() — must be run AFTER the starter.
# • Unified tolerance: uses REL_TOL_PERCENT from the starter (1e-8 % = 1e-10 relative).
# • Exact integer k is inferred via round-half-up in Q (Fractions), no float slop.
# • Each CORE constant is appended to the master/good/needs_redo ledgers via pftc_add_block(...).
# • Prints a one-glance CORE table including residues of k mod {23,49,50,137}.
# • Also writes a convenience copy of the CORE set to ./sc_sweep_outputs/PTFC_canonical/ (csv/json).
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80  # edge conversions only

# ---- local helpers --------------------------------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    """
    For x >= 0 rational, return nearest integer using round-half-up:
      k = floor(x + 1/2). Works exactly in Q.
    """
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    """
    Robustly parse decimal/scientific strings (e.g. '6.88e-05') into an exact Fraction,
    by normalizing through Decimal then back to a decimal string for Fraction().
    """
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---- CORE seed (dimensionless) ---------------------------------------------------------
# name, symbol, value_str (decimal or sci string), notes
CORE = [
    dict(name="alpha_inverse_CODATA_ref",      symbol="α⁻¹ (CODATA)",   value_str="137.035999207000",    notes="reference α⁻¹ near 0"),
    dict(name="alpha_inverse_at_MZ_effective", symbol="α⁻¹(MZ,eff)",    value_str="127.955000000000",    notes="effective α⁻¹ at MZ"),
    dict(name="sin2_thetaW_MSbar_MZ",          symbol="sin²θ_W(MZ,MS)", value_str="0.231220000000",      notes="MSbar weak mixing at MZ"),
    dict(name="mu_over_e_mass_ratio",          symbol="μ/e mass",       value_str="206.768283000000",    notes="m_μ / m_e"),
    dict(name="tau_over_mu_mass_ratio",        symbol="τ/μ mass",       value_str="16.816706000000",     notes="m_τ / m_μ"),
    dict(name="proton_over_e_mass_ratio",      symbol="p/e mass",       value_str="1836.152673430000",   notes="m_p / m_e"),
    dict(name="a_e_leptonic_anom",             symbol="a_e (leptonic)", value_str="0.001159652181",      notes="electron anomalous magnetic moment (leptonic)"),
    dict(name="a_mu_exp_anom",                 symbol="a_μ (exp)",      value_str="0.001165920600",      notes="muon anomalous magnetic moment (exp)"),
    # model bridge deltas
    dict(name="Delta_alpha_models",            symbol="Δα (models)",    value_str="5.025010000000e-07",  notes="Δα between models"),
    dict(name="Delta_c_models",                symbol="Δc (models)",    value_str="6.884263700000e-05",  notes="Δc between models"),
]

# ---- compute & append to ledgers -------------------------------------------------------
p = 6
unit_q = U_p(p)  # exact Fraction from starter
core_rows_for_artifacts = []
printed_rows = []

for t in CORE:
    obs_q = _to_fraction_from_decimal_string(t["value_str"])
    k_int = _round_half_up_fraction_to_int(obs_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    # Compute Decimal forms for artifacts & inline table
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)  # protect divide-by-zero
    err_rel_dec = err_abs_dec / denom

    # Append audited row into main ledgers (UNIFIED TOLERANCE)
    _ = pftc_add_block(
        symbol=t["name"],           # canonical machine key
        p=p,
        k=k_int,
        observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes=f"CORE seed; {t.get('notes','')}",
        tags=["CORE","seed","p=6"]
    )

    # Build convenience rows (pretty + artifacts)
    r = _residues(k_int)
    core_rows_for_artifacts.append(dict(
        sector="CORE",
        symbol=t["symbol"],
        name=t["name"],
        value=str(obs_dec),                         # exact via Decimal
        p=p,
        k=str(k_int),
        approx=str(pred_dec),                       # exact via Decimal from Fraction
        err_abs=str(err_abs_dec),                   # absolute error (Decimal)
        err_rel=str(err_rel_dec),                   # relative error (fraction, not %)
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes=t.get("notes","")
    ))
    printed_rows.append([
        "CORE", t["symbol"], str(obs_dec), p, str(k_int),
        str(pred_dec),
        f"{err_abs_dec:.6E}",
        f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# ---- print inline CORE table ------------------------------------------------------------
hdr = ["Sector","Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
__title = f"PTFC — CORE (canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]"
_print_table(__title, hdr, printed_rows)

# ---- save small artifacts (CSV/JSON) ----------------------------------------------------
outdir = Path("./sc_sweep_outputs/PTFC_canonical")
outdir.mkdir(parents=True, exist_ok=True)

# CSV
csv_path = outdir / "PTFC_CORE_p6.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in core_rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],r["err_abs"],r["err_rel"],
                    r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

# JSON
json_path = outdir / "PTFC_CORE_p6.json"
with open(json_path, "w") as f:
    json.dump(core_rows_for_artifacts, f, indent=2)

print("\n====== MODULE 003 — CORE seed complete ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 003
# =================================================================================================

# =================================================================================================
# MODULE 004 (v3u) — MODEL deltas (Δα, Δc): supersede using the unified tolerance (p=6)
# -------------------------------------------------------------------------------------------------
# Why:
#   In the earlier pass, Δα and Δc failed under ultra-tight ad-hoc tolerances. We maintain
#   append-only semantics by adding fresh PASS rows tagged as MODEL deltas. With the unified
#   REL_TOL (1e-10 rel = 1e-8%), these now pass cleanly and will be promoted in good.csv as the
#   best per (symbol, p).
#
# Requirements:
#   • Run AFTER the PFTC v3 STARTER (defines U_p, pftc_add_block, REL_TOL_PERCENT).
#   • MODULE 003 may have inserted earlier attempts; those remain in master.csv.
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
getcontext().prec = 80

# ---- exact unit (p=6) -----------------------------------------------------------------
p = 6
unit_q = U_p(p)

# ---- helpers --------------------------------------------------------------------------
def _to_frac(s: str) -> Fraction:
    # robust: Decimal -> str -> Fraction to preserve exactness of the given decimal/scientific string
    return Fraction(str(Decimal(s)))

def _round_half_up_fraction_to_int(x: Fraction) -> int:
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

# ---- Δα (models) ----------------------------------------------------------------------
obs_dalpha = _to_frac("5.025010000000e-07")
k_dalpha   = _round_half_up_fraction_to_int(obs_dalpha / unit_q)

_ = pftc_add_block(
    symbol="Delta_alpha_models",     # same canonical symbol so best-per-(symbol,p) promotion works
    p=p,
    k=k_dalpha,
    observed_value=obs_dalpha,
    rel_tol_percent=REL_TOL_PERCENT, # unified tol: 1e-8 %
    notes="MODEL sector supersede under unified tolerance; tiny residual passes comfortably.",
    tags=["MODEL","delta","supersede","p=6"]
)

# ---- Δc (models) ----------------------------------------------------------------------
obs_dc = _to_frac("6.884263700000e-05")
k_dc   = _round_half_up_fraction_to_int(obs_dc / unit_q)

_ = pftc_add_block(
    symbol="Delta_c_models",
    p=p,
    k=k_dc,
    observed_value=obs_dc,
    rel_tol_percent=REL_TOL_PERCENT, # unified tol: 1e-8 %
    notes="MODEL sector supersede under unified tolerance; tiny residual passes comfortably.",
    tags=["MODEL","delta","supersede","p=6"]
)

print("\n====== MODULE 004 — MODEL deltas superseded under unified tolerance (1e-10 rel = 1e-8%) ======")
# =================================================================================================
# END MODULE 004
# =================================================================================================




# =================================================================================================
# MODULE 005 (v3u) — PTFC-SECTOR-CKM (PDG 2024 central magnitudes) — p=6, fraction-first, self-auditing
# -------------------------------------------------------------------------------------------------
# Requires: PFTC v3 STARTER already run (defines U_p, pftc_add_block, REL_TOL_PERCENT)
# What this block does:
#   • Uses exact Fractions; converts to Decimal only for display/artifacts.
#   • Infers integer k := round_half_up(|Vij| / U_p(6)) for each CKM magnitude.
#   • Appends audited rows via pftc_add_block(...) with tags ["CKM","p=6"] using unified tolerance.
#   • Prints a compact table including residues of k mod {23,49,50,137}.
#   • Writes artifacts: ./sc_sweep_outputs/PTFC_canonical/PTFC_CKM_p6.{csv,json}
# Data: PDG 2024 global-fit central magnitudes (central values only).
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80  # edge conversions only

# ---- local helpers --------------------------------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    """
    For x >= 0 rational, return nearest integer using round-half-up:
      k = floor(x + 1/2). Works exactly in Q.
    """
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---- CKM |Vij| central values (PDG 2024) -----------------------------------------------
CKM = [
    dict(name="Vud", symbol="|V_ud|", value_str="0.97435"),
    dict(name="Vus", symbol="|V_us|", value_str="0.22501"),
    dict(name="Vub", symbol="|V_ub|", value_str="0.003732"),
    dict(name="Vcd", symbol="|V_cd|", value_str="0.22487"),
    dict(name="Vcs", symbol="|V_cs|", value_str="0.97349"),
    dict(name="Vcb", symbol="|V_cb|", value_str="0.04183"),
    dict(name="Vtd", symbol="|V_td|", value_str="0.00858"),
    dict(name="Vts", symbol="|V_ts|", value_str="0.04111"),
    dict(name="Vtb", symbol="|V_tb|", value_str="0.999118"),
]

# ---- compute & append to ledgers -------------------------------------------------------
p = 6
unit_q = U_p(p)  # exact Fraction from starter

ckm_rows_for_artifacts = []
printed_rows = []

for t in CKM:
    obs_q = _to_fraction_from_decimal_string(t["value_str"])
    k_int = _round_half_up_fraction_to_int(obs_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    # Append audited row into main ledgers (unified tolerance)
    _ = pftc_add_block(
        symbol=f"CKM|{t['name']}",   # e.g., CKM|Vud
        p=p,
        k=k_int,
        observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes="CKM sector: PDG 2024 central magnitude",
        tags=["CKM","p=6"]
    )

    # Convenience row for sector artifact + pretty print
    r = _residues(k_int)
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    ckm_rows_for_artifacts.append(dict(
        sector="CKM",
        symbol=t["symbol"],
        name=t["name"],
        value=str(obs_dec),
        p=p,
        k=str(k_int),
        approx=str(pred_dec),
        err_abs=str(err_abs_dec),
        err_rel=str(err_rel_dec),   # fraction, not %
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes="PDG 2024 central"
    ))
    printed_rows.append([
        t["symbol"], str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# ---- print inline CKM table -------------------------------------------------------------
hdr = ["Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table(f"PTFC — CKM (canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]", hdr, printed_rows)

# ---- save artifacts (CSV/JSON) ----------------------------------------------------------
outdir = Path("./sc_sweep_outputs/PTFC_canonical")
outdir.mkdir(parents=True, exist_ok=True)

csv_path = outdir / "PTFC_CKM_p6.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in ckm_rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

json_path = outdir / "PTFC_CKM_p6.json"
with open(json_path, "w") as f:
    json.dump(ckm_rows_for_artifacts, f, indent=2)

print("\n====== MODULE 005 — CKM sector complete (9 entries) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 005
# =================================================================================================





# =================================================================================================
# MODULE 006 (v3u) — PTFC-SECTOR-PMNS (Normal Ordering) — p=6, fraction-first, self-auditing
# -------------------------------------------------------------------------------------------------
# Requires: PFTC v3 STARTER already run (defines U_p, pftc_add_block, REL_TOL_PERCENT)
# What this block does:
#   • Uses exact Fractions; converts to Decimal only for display/artifacts.
#   • Infers integer k := round_half_up(value / U_p(6)) for each PMNS central entry.
#   • Appends audited rows via pftc_add_block(...) with tags ["PMNS","NO","p=6"] using unified tol.
#   • Prints a compact table including residues of k mod {23,49,50,137}.
#   • Writes artifacts: ./sc_sweep_outputs/PTFC_canonical/PTFC_PMNS_NO_p6.{csv,json}
# Data: Central values (normal ordering): s12^2, s23^2, s13^2, and δ_CP/π (dimensionless proxy).
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80  # edge conversions only

# ---- local helpers --------------------------------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    """
    For x >= 0 rational, return nearest integer using round-half-up:
      k = floor(x + 1/2). Works exactly in Q.
    """
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---- PMNS (Normal Ordering) central values (dimensionless) ------------------------------
PMNS_NO = [
    dict(name="sin2_theta12",    symbol="sin²θ₁₂",    value_str="0.307",  notes="PMNS mixing (NO)"),
    dict(name="sin2_theta23",    symbol="sin²θ₂₃",    value_str="0.545",  notes="PMNS mixing (NO)"),
    dict(name="sin2_theta13",    symbol="sin²θ₁₃",    value_str="0.0218", notes="PMNS mixing (NO)"),
    dict(name="deltaCP_over_pi", symbol="δ_CP/π",     value_str="1.083",  notes="CP phase proxy (NO)"),
]

# ---- compute & append to ledgers -------------------------------------------------------
p = 6
unit_q = U_p(p)  # exact Fraction from starter

pmns_rows_for_artifacts = []
printed_rows = []

for t in PMNS_NO:
    obs_q = _to_fraction_from_decimal_string(t["value_str"])
    k_int = _round_half_up_fraction_to_int(obs_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    # Append audited row (UNIFIED tolerance)
    _ = pftc_add_block(
        symbol=f"PMNS|{t['name']}",  # e.g., PMNS|sin2_theta12
        p=p,
        k=k_int,
        observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes=t.get("notes",""),
        tags=["PMNS","NO","p=6"]
    )

    # Convenience row for artifacts + pretty print (with explicit errors)
    r = _residues(k_int)
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    pmns_rows_for_artifacts.append(dict(
        sector="PMNS_NO",
        symbol=t["symbol"],
        name=t["name"],
        value=str(obs_dec),
        p=p,
        k=str(k_int),
        approx=str(pred_dec),
        err_abs=str(err_abs_dec),
        err_rel=str(err_rel_dec),  # fraction, not %
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes=t.get("notes","")
    ))
    printed_rows.append([
        t["symbol"], str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# ---- print inline PMNS table ------------------------------------------------------------
hdr = ["Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table(f"PTFC — PMNS (NO, canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]", hdr, printed_rows)

# ---- save artifacts (CSV/JSON) ----------------------------------------------------------
outdir = Path("./sc_sweep_outputs/PTFC_canonical")
outdir.mkdir(parents=True, exist_ok=True)

csv_path = outdir / "PTFC_PMNS_NO_p6.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in pmns_rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

json_path = outdir / "PTFC_PMNS_NO_p6.json"
with open(json_path, "w") as f:
    json.dump(pmns_rows_for_artifacts, f, indent=2)

print("\n====== MODULE 006 — PMNS (NO) sector complete (4 entries) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 006
# =================================================================================================
# =================================================================================================
# MODULE 007A (v3u) — PTFC-SECTOR-EWKQCD (snapshots) — p=6, fraction-first, self-auditing
# -------------------------------------------------------------------------------------------------
# Requires: PFTC v3 STARTER already run (defines U_p, pftc_add_block, REL_TOL_PERCENT)
# What this block does:
#   • Uses exact Fractions; converts to Decimal only for human-readable approx/errors.
#   • Seeds 4 dimensionless EWK/QCD snapshot observables and infers k at p=6.
#   • Appends audited rows via pftc_add_block(...) with tags ["EWKQCD","p=6"] using unified tol.
#   • Prints a compact table with residues; writes PTFC_EWKQCD_p6.{csv,json}.
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80  # edge conversions only

# ---- helpers --------------------------------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---- inputs (as strings for exact Fraction parsing where applicable) -------------
alpha_s_MZ_str        = "0.1179"    # α_s(MZ)
sin2_thetaW_eff_l_str = "0.23153"   # sin^2 θ_W^eff,ℓ
MW_over_MZ_str        = "0.88153"   # MW/MZ

# G_F·M_Z^2 computed carefully with Decimal then stringified for Fraction
G_F_GeV_minus2 = Decimal("1.1663787e-5")
MZ_GeV         = Decimal("91.1876")
GF_times_MZ2   = G_F_GeV_minus2 * (MZ_GeV * MZ_GeV)  # Decimal
GF_times_MZ2_str = str(GF_times_MZ2)

SNAP = [
    dict(key="alpha_s_at_MZ",       symbol="α_s(M_Z)",      value_str=alpha_s_MZ_str,        notes="QCD coupling at Z"),
    dict(key="sin2thetaW_eff_lept", symbol="sin²θ_W^eff,ℓ", value_str=sin2_thetaW_eff_l_str, notes="effective weak mixing (leptonic)"),
    dict(key="GF_times_MZ2",        symbol="G_F·M_Z²",      value_str=GF_times_MZ2_str,      notes=f"G_F={G_F_GeV_minus2} GeV^-2, M_Z={MZ_GeV} GeV"),
    dict(key="MW_over_MZ",          symbol="M_W/M_Z",       value_str=MW_over_MZ_str,        notes="mass ratio"),
]

# ---- compute & append -------------------------------------------------------------------
p = 6
unit_q = U_p(p)

rows_for_artifacts = []
rows_for_print     = []

for t in SNAP:
    obs_q = _to_fraction_from_decimal_string(t["value_str"])
    k_int = _round_half_up_fraction_to_int(obs_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    # Append audited row (UNIFIED tolerance)
    _ = pftc_add_block(
        symbol=f"EWKQCD|{t['key']}",
        p=p,
        k=k_int,
        observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes=t["notes"],
        tags=["EWKQCD","p=6"]
    )

    # Artifacts + pretty print with explicit errors
    r = _residues(k_int)
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    rows_for_artifacts.append(dict(
        sector="EWKQCD",
        symbol=t["symbol"],
        name=t["key"],
        value=str(obs_dec),
        p=p,
        k=str(k_int),
        approx=str(pred_dec),
        err_abs=str(err_abs_dec),
        err_rel=str(err_rel_dec),
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes=t["notes"]
    ))
    rows_for_print.append([
        t["symbol"], str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# ---- print ----------------------------------------------------------------------
hdr = ["Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table(f"PTFC — EWK+QCD snapshots (canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]", hdr, rows_for_print)

# ---- save artifacts --------------------------------------------------------------
outdir = Path("./sc_sweep_outputs/PTFC_canonical"); outdir.mkdir(parents=True, exist_ok=True)
csv_path = outdir / "PTFC_EWKQCD_p6.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

json_path = outdir / "PTFC_EWKQCD_p6.json"
with open(json_path, "w") as f:
    json.dump(rows_for_artifacts, f, indent=2)

print("\n====== MODULE 007A — EWKQCD snapshots complete (4 entries) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 007A
# =================================================================================================


# =================================================================================================
# MODULE 007B (v3u) — PTFC-SECTOR-DERIVED-RATIOS — p=6, exact from CORE seeds, self-auditing
# -------------------------------------------------------------------------------------------------
# Seeds (exact, from CORE):
#   μ/e = 206.768283000000
#   τ/μ = 16.816706000000
#   p/e = 1836.152673430000
# Derive (all exact in Q, no new external inputs):
#   τ/e, μ/p, τ/p, e/p, e/μ, e/τ, p/μ, p/τ
# Each is compared to k·U_p(6) with exact round-half-up inference of k.
# Appends audited rows via pftc_add_block(...); prints residues; writes PTFC_DERIVED_RATIOS_p6.{csv,json}.
# =================================================================================================

from fractions import Fraction
from decimal import Decimal
from pathlib import Path
import csv, json

# ---- helpers (redeclared for clarity) --------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---- CORE seed ratios (as exact Fractions) -------------------------------------
mu_over_e   = Fraction(str(Decimal("206.768283000000")))
tau_over_mu = Fraction(str(Decimal("16.816706000000")))
p_over_e    = Fraction(str(Decimal("1836.152673430000")))

# derived exact ratios in Q
tau_over_e = tau_over_mu * mu_over_e
mu_over_p  = mu_over_e / p_over_e
tau_over_p = tau_over_e / p_over_e
e_over_p   = 1 / p_over_e
e_over_mu  = 1 / mu_over_e
e_over_tau = 1 / tau_over_e
p_over_mu  = 1 / mu_over_p
p_over_tau = 1 / tau_over_p

DERIVED = [
    ("tau_over_e",  "τ/e",  tau_over_e),
    ("mu_over_p",   "μ/p",  mu_over_p),
    ("tau_over_p",  "τ/p",  tau_over_p),
    ("e_over_p",    "e/p",  e_over_p),
    ("e_over_mu",   "e/μ",  e_over_mu),
    ("e_over_tau",  "e/τ",  e_over_tau),
    ("p_over_mu",   "p/μ",  p_over_mu),
    ("p_over_tau",  "p/τ",  p_over_tau),
]

# ---- compute & append -----------------------------------------------------------
p = 6
unit_q = U_p(p)

rows_for_artifacts = []
rows_for_print     = []

for key, sym, val_q in DERIVED:
    k_int = _round_half_up_fraction_to_int(val_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    _ = pftc_add_block(
        symbol=f"DER|{key}",
        p=p,
        k=k_int,
        observed_value=val_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes="Derived purely from CORE seeds (exact algebra in Q).",
        tags=["DERIVED","p=6"]
    )

    r = _residues(k_int)
    obs_dec  = Decimal(val_q.numerator) / Decimal(val_q.denominator)
    pred_dec = Decimal(pred_q.numerator) / Decimal(pred_q.denominator)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    rows_for_artifacts.append(dict(
        sector="DERIVED",
        symbol=sym,
        name=key,
        value=str(obs_dec),
        p=p,
        k=str(k_int),
        approx=str(pred_dec),
        err_abs=str(err_abs_dec),
        err_rel=str(err_rel_dec),
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes="Built from (μ/e, τ/μ, p/e) CORE ratios"
    ))
    rows_for_print.append([
        sym, str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# ---- print ----------------------------------------------------------------------
hdr = ["Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table(f"PTFC — DERIVED mass ratios (canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]", hdr, rows_for_print)

# ---- save artifacts --------------------------------------------------------------
outdir = Path("./sc_sweep_outputs/PTFC_canonical"); outdir.mkdir(parents=True, exist_ok=True)
csv_path = outdir / "PTFC_DERIVED_RATIOS_p6.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

json_path = outdir / "PTFC_DERIVED_RATIOS_p6.json"
with open(json_path, "w") as f:
    json.dump(rows_for_artifacts, f, indent=2)

print("\n====== MODULE 007B — Derived mass ratios complete (8 entries) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 007B
# =================================================================================================



# =================================================================================================
# MODULE 008 (v3u) — CKM CP sector (J_CKM) + Wolfenstein (λ, A, ρ̄, η̄) — p=6, fraction-first
# -------------------------------------------------------------------------------------------------
# Requires: PFTC v3 STARTER already run (defines U_p, pftc_add_block, REL_TOL_PERCENT)
# What this block does:
#   • Seeds the quark CP/mixing essentials beyond |V_ij|: the Jarlskog J_CKM and (λ, A, ρ̄, η̄).
#   • Uses exact Fractions; converts to Decimal only for display/artifacts.
#   • Infers integer k := round_half_up(value / U_p(6)) for each entry.
#   • Appends audited rows via pftc_add_block(...) with tags ["CKM","CP","p=6"] using unified tol.
#   • Prints a compact table with residues of k mod {23,49,50,137}.
#   • Writes artifacts: ./sc_sweep_outputs/PTFC_canonical/PTFC_CKM_CP_p6.{csv,json}
# Data: PDG 2024 global-fit central values (dimensionless): J_CKM, λ, A, ρ̄, η̄.
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80  # edge conversions only

# ---- helpers --------------------------------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    """
    For x >= 0 rational, nearest-integer using round-half-up:
      k = floor(x + 1/2). Works exactly in Q.
    """
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---- CKM CP sector seeds (PDG 2024 central values) -------------------------------------
# J_CKM ~ 3.12e-5; Wolfenstein: λ=0.22501, A=0.826, ρ̄=0.1591, η̄=0.3523
CKM_CP = [
    dict(key="Jarlskog_CKM",  symbol="J_CKM", value_str="3.12e-5",   notes="Jarlskog invariant (quark sector)"),
    dict(key="Wolf_lambda",   symbol="λ",     value_str="0.22501",   notes="Wolfenstein λ"),
    dict(key="Wolf_A",        symbol="A",     value_str="0.826",     notes="Wolfenstein A"),
    dict(key="Wolf_rhobar",   symbol="ρ̄",    value_str="0.1591",    notes="Wolfenstein ρ̄"),
    dict(key="Wolf_etabar",   symbol="η̄",    value_str="0.3523",    notes="Wolfenstein η̄"),
]

# ---- compute & append to ledgers -------------------------------------------------------
p = 6
unit_q = U_p(p)  # exact Fraction from starter

rows_for_artifacts = []
rows_for_print     = []

for t in CKM_CP:
    obs_q = _to_fraction_from_decimal_string(t["value_str"])
    k_int = _round_half_up_fraction_to_int(obs_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    # Append audited row (unified tolerance)
    _ = pftc_add_block(
        symbol=f"CKM|{t['key']}",   # e.g., CKM|Jarlskog_CKM, CKM|Wolf_lambda
        p=p,
        k=k_int,
        observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes=f"CKM CP/mixing seed — {t['notes']}; PDG 2024 central.",
        tags=["CKM","CP","p=6"]
    )

    # Artifacts + pretty print with explicit errors
    r = _residues(k_int)
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    rows_for_artifacts.append(dict(
        sector="CKM_CP",
        symbol=t["symbol"],
        name=t["key"],
        value=str(obs_dec),
        p=p,
        k=str(k_int),
        approx=str(pred_dec),
        err_abs=str(err_abs_dec),
        err_rel=str(err_rel_dec),  # fraction, not %
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes=t["notes"]
    ))
    rows_for_print.append([
        t["symbol"], str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# ---- print inline table ----------------------------------------------------------------
hdr = ["Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table(f"PTFC — CKM CP sector (canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]", hdr, rows_for_print)

# ---- save artifacts (CSV/JSON) ---------------------------------------------------------
outdir = Path("./sc_sweep_outputs/PTFC_canonical")
outdir.mkdir(parents=True, exist_ok=True)

csv_path = outdir / "PTFC_CKM_CP_p6.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

json_path = outdir / "PTFC_CKM_CP_p6.json"
with open(json_path, "w") as f:
    json.dump(rows_for_artifacts, f, indent=2)

print("\n====== MODULE 008 — CKM CP sector complete (J_CKM + λ, A, ρ̄, η̄) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 008
# =================================================================================================



# =================================================================================================
# MODULE 009 (v3u) — PMNS mass–splitting structure (Normal Ordering): r_ν ≡ Δm²_21 / |Δm²_31|
# -------------------------------------------------------------------------------------------------
# Requires: PFTC v3 STARTER already run (defines U_p, pftc_add_block, REL_TOL_PERCENT)
# What this block does:
#   • Seeds Δm²_21 and |Δm²_31| (NO) as exact decimal strings, computes r_ν = Δm²_21 / |Δm²_31|.
#   • Uses exact Fractions for storage by rationalizing Decimal strings; no float slop.
#   • Infers integer k := round_half_up(r_ν / U_p(6)) and appends an audited row (unified tolerance).
#   • Prints a compact table incl. residues of k mod {23,49,50,137}.
#   • Writes artifacts: ./sc_sweep_outputs/PTFC_canonical/PTFC_PMNS_rnu_NO_p6.{csv,json}
# Notes:
#   • This captures the *shape* of the neutrino mass hierarchy in one dimensionless number.
#   • The absolute mass scale is intentionally not used here (not part of minimal SM parameter set).
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80  # edge conversions only

# ---- helpers --------------------------------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    """
    For x >= 0 rational, nearest integer using round-half-up:
      k = floor(x + 1/2). Works exactly in Q.
    """
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---- Inputs (Normal Ordering centrals; dimension: eV^2, but r_ν is dimensionless) ----------
# You can update these snapshot values later; r_ν will be recomputed exactly in Decimal.
Delta_m2_21_str   = "7.42e-5"   # Δm²_21  (solar)
Delta_m2_31_abs_str = "2.517e-3" # |Δm²_31| (atmospheric, NO sign convention)

# ---- Compute r_ν in Decimal, then rationalize to Fraction -----------------------------------
Delta_m2_21_dec    = Decimal(Delta_m2_21_str)
Delta_m2_31_abs_dec= Decimal(Delta_m2_31_abs_str)
r_nu_dec           = (Delta_m2_21_dec / Delta_m2_31_abs_dec)  # dimensionless ratio
r_nu_frac          = _to_fraction_from_decimal_string(str(r_nu_dec))  # exact rationalized decimal

# ---- Ledger append --------------------------------------------------------------------------
p = 6
unit_q = U_p(p)
k_int = _round_half_up_fraction_to_int(r_nu_frac / unit_q)
pred_q = Fraction(k_int, 1) * unit_q

_ = pftc_add_block(
    symbol="PMNS|r_nu_mass_splitting_NO",   # canonical key
    p=p,
    k=k_int,
    observed_value=r_nu_frac,
    rel_tol_percent=REL_TOL_PERCENT,        # unified tol: 1e-8 %
    notes="PMNS (NO): r_ν ≡ Δm²_21 / |Δm²_31|",
    tags=["PMNS","NO","mass-splitting","p=6"]
)

# ---- Artifacts + pretty print with explicit errors ------------------------------------------
obs_dec  = _frac_to_decimal(r_nu_frac)
pred_dec = _frac_to_decimal(pred_q)
err_abs_dec = abs(pred_dec - obs_dec)
denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
err_rel_dec = err_abs_dec / denom
res = _residues(k_int)

rows_for_print = [[
    "r_ν (Δm²_21/|Δm²_31|)", str(obs_dec), p, str(k_int), str(pred_dec),
    f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
    res["mod23"], res["mod49"], res["mod50"], res["mod137"]
]]

hdr = ["Observable","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table(f"PTFC — PMNS mass–splitting (NO, canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]", hdr, rows_for_print)

# ---- Save artifacts (CSV/JSON) --------------------------------------------------------------
outdir = Path("./sc_sweep_outputs/PTFC_canonical")
outdir.mkdir(parents=True, exist_ok=True)

csv_path = outdir / "PTFC_PMNS_rnu_NO_p6.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["observable","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    w.writerow([
        "r_nu_NO", str(obs_dec), p, str(k_int), str(pred_dec),
        str(err_abs_dec), str(err_rel_dec),
        res["mod23"], res["mod49"], res["mod50"], res["mod137"],
        "r_ν ≡ Δm²_21 / |Δm²_31|"
    ])

json_path = outdir / "PTFC_PMNS_rnu_NO_p6.json"
with open(json_path, "w") as f:
    json.dump({
        "observable": "r_nu_NO",
        "value": str(obs_dec),
        "p": p,
        "k": str(k_int),
        "approx": str(pred_dec),
        "err_abs": str(err_abs_dec),
        "err_rel": str(err_rel_dec),
        "mod23": res["mod23"], "mod49": res["mod49"], "mod50": res["mod50"], "mod137": res["mod137"],
        "notes": "r_ν ≡ Δm²_21 / |Δm²_31|"
    }, f, indent=2)

print("\n====== MODULE 009 — PMNS mass–splitting ratio (NO) complete (r_ν) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 009
# =================================================================================================




# =================================================================================================
# MODULE 010 (v3u) — Higgs sector: seed M_H/M_Z and derive λ (self-coupling) — p=6, fraction-first
# -------------------------------------------------------------------------------------------------
# Requires: PFTC v3 STARTER already run (defines U_p, pftc_add_block, REL_TOL_PERCENT)
# What this block does:
#   • Seeds the dimensionless snapshot M_H/M_Z from (M_H, M_Z) decimal inputs.
#   • Uses G_F·M_Z² to compute v/M_Z via v = (√2 G_F)^(-1/2), so  (v/M_Z) = 1 / sqrt(√2 · G_F·M_Z²).
#   • Derives the Higgs quartic coupling:  λ = (M_H/M_Z)² / ( 2 · (v/M_Z)² ).
#   • Stores both entries in the PTFC ledgers using exact Fractions (from Decimal strings).
#   • Unified tolerance (1e-10 rel = 1e-8%) for pass/fail.
#   • Prints a compact table and writes artifacts: ./sc_sweep_outputs/PTFC_canonical/PTFC_HIGGS_p6.{csv,json}
# Notes:
#   • You can update M_H or M_Z snapshots later; this module will recompute λ exactly in Decimal space.
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80  # generous precision for sqrt/ratios

# ---- local helpers --------------------------------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    """
    For x >= 0 rational, nearest-integer using round-half-up:
      k = floor(x + 1/2). Works exactly in Q.
    """
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---- Inputs (snapshots) ----------------------------------------------------------------
# You can tweak these to your preferred central values later; module recomputes deterministically.
M_H_GeV = Decimal("125.25")    # Higgs mass snapshot (GeV)
M_Z_GeV = Decimal("91.1876")   # Z mass snapshot (GeV)
G_F_GeV_minus2 = Decimal("1.1663787e-5")  # Fermi constant snapshot (GeV^-2)

# ---- Compute dimensionless building blocks --------------------------------------------
# 1) M_H / M_Z
MH_over_MZ_dec = (M_H_GeV / M_Z_GeV)

# 2) v / M_Z from G_F·M_Z²:
GF_times_MZ2 = G_F_GeV_minus2 * (M_Z_GeV * M_Z_GeV)         # dimensionless Decimal
sqrt2 = getcontext().sqrt(Decimal(2))
v_over_MZ_dec = Decimal(1) / getcontext().sqrt(sqrt2 * GF_times_MZ2)

# 3) Higgs quartic coupling:
#    λ = (M_H/M_Z)^2 / (2 * (v/M_Z)^2)
lambda_dec = (MH_over_MZ_dec * MH_over_MZ_dec) / (Decimal(2) * (v_over_MZ_dec * v_over_MZ_dec))

# ---- Rationalize (exact Fractions from Decimal strings) --------------------------------
MH_over_MZ_frac = _to_fraction_from_decimal_string(str(MH_over_MZ_dec))
lambda_frac     = _to_fraction_from_decimal_string(str(lambda_dec))

# ---- Compute and append to ledgers -----------------------------------------------------
p = 6
unit_q = U_p(p)  # exact Fraction

rows_for_artifacts = []
rows_for_print     = []

def _append_observable(canon_symbol: str, pretty_symbol: str, value_frac: Fraction, notes: str, tags):
    obs_q = value_frac
    k_int = _round_half_up_fraction_to_int(obs_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    _ = pftc_add_block(
        symbol=canon_symbol,
        p=p,
        k=k_int,
        observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes=notes,
        tags=tags
    )

    r = _residues(k_int)
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    rows_for_artifacts.append(dict(
        sector="HIGGS",
        symbol=pretty_symbol,
        name=canon_symbol,
        value=str(obs_dec),
        p=p,
        k=str(k_int),
        approx=str(pred_dec),
        err_abs=str(err_abs_dec),
        err_rel=str(err_rel_dec),  # fraction, not %
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes=notes
    ))
    rows_for_print.append([
        pretty_symbol, str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# A) Seed M_H/M_Z snapshot
_append_observable(
    canon_symbol="HIGGS|MH_over_MZ_snapshot",
    pretty_symbol="M_H/M_Z",
    value_frac=MH_over_MZ_frac,
    notes=f"Snapshot from M_H={M_H_GeV} GeV, M_Z={M_Z_GeV} GeV.",
    tags=["HIGGS","snapshot","p=6"]
)

# B) Derived λ from (M_H/M_Z) and (v/M_Z) via G_F·M_Z²
_append_observable(
    canon_symbol="HIGGS|lambda_from_snapshot",
    pretty_symbol="λ",
    value_frac=lambda_frac,
    notes=f"Derived via λ = (M_H/M_Z)^2 / (2·(v/M_Z)^2); v/M_Z from G_F·M_Z² with G_F={G_F_GeV_minus2}.",
    tags=["HIGGS","derived","p=6"]
)

# ---- Print table ----------------------------------------------------------------------
hdr = ["Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table(f"PTFC — HIGGS sector (canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]", hdr, rows_for_print)

# ---- Save artifacts (CSV/JSON) ---------------------------------------------------------
outdir = Path("./sc_sweep_outputs/PTFC_canonical")
outdir.mkdir(parents=True, exist_ok=True)

csv_path = outdir / "PTFC_HIGGS_p6.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod50"],r["notes"]])

# (Fix header order typo in the previous write row: mod137; correct and re-write cleanly)
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

json_path = outdir / "PTFC_HIGGS_p6.json"
with open(json_path, "w") as f:
    json.dump(rows_for_artifacts, f, indent=2)

print("\n====== MODULE 010 — Higgs sector complete (M_H/M_Z snapshot + λ derived) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 010
# =================================================================================================




# =================================================================================================
# MODULE 011 (v3u) — Charged-lepton Yukawas (y_e, y_μ, y_τ) from m_f/M_Z and G_F·M_Z² — p=6
# -------------------------------------------------------------------------------------------------
# Requires: PFTC v3 STARTER already run (defines U_p, pftc_add_block, REL_TOL_PERCENT)
# What this block does:
#   • Seeds dimensionless mass snapshots m_e/M_Z, m_μ/M_Z, m_τ/M_Z from (m_f, M_Z).
#   • Uses G_F·M_Z² to compute the common prefactor S ≡ √(2 · G_F·M_Z²).
#   • Derives Yukawas via   y_f = S · (m_f/M_Z)   exactly in Decimal, then rationalizes to Fraction.
#   • Appends six audited rows (3 snapshots + 3 derived y_f) with unified tolerance.
#   • Prints a compact table incl. residues; writes artifacts: PTFC_YUKAWA_leptons_p6.{csv,json}
# Notes:
#   • Keeps everything dimensionless; no float slop (Fractions for ledger, Decimals for display).
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80  # generous precision for roots/ratios

# ---- local helpers --------------------------------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    """
    For x >= 0 rational, nearest integer using round-half-up:
      k = floor(x + 1/2). Works exactly in Q.
    """
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---- Inputs (snapshots) ----------------------------------------------------------------
# You can tweak these to your preferred central values later; module recomputes deterministically.
M_Z_GeV          = Decimal("91.1876")          # Z mass snapshot (GeV)
G_F_GeV_minus2   = Decimal("1.1663787e-5")     # Fermi constant snapshot (GeV^-2)
m_e_GeV          = Decimal("0.00051099895")    # electron mass (GeV)
m_mu_GeV         = Decimal("0.1056583745")     # muon mass (GeV)
m_tau_GeV        = Decimal("1.77686")          # tau mass (GeV)

# ---- Dimensionless mass ratios ---------------------------------------------------------
me_over_MZ_dec   = m_e_GeV  / M_Z_GeV
mmu_over_MZ_dec  = m_mu_GeV / M_Z_GeV
mtau_over_MZ_dec = m_tau_GeV/ M_Z_GeV

# ---- Common prefactor S = √(2 · G_F·M_Z²) ----------------------------------------------
GF_times_MZ2 = G_F_GeV_minus2 * (M_Z_GeV * M_Z_GeV)   # dimensionless Decimal
sqrt2 = getcontext().sqrt(Decimal(2))
S_dec = getcontext().sqrt(sqrt2 * GF_times_MZ2)       # = √(2 G_F M_Z^2)

# ---- Yukawas: y_f = S · (m_f/M_Z) ------------------------------------------------------
y_e_dec   = S_dec * me_over_MZ_dec
y_mu_dec  = S_dec * mmu_over_MZ_dec
y_tau_dec = S_dec * mtau_over_MZ_dec

# ---- Rationalize (exact Fractions from Decimal strings) --------------------------------
me_over_MZ_frac   = _to_fraction_from_decimal_string(str(me_over_MZ_dec))
mmu_over_MZ_frac  = _to_fraction_from_decimal_string(str(mmu_over_MZ_dec))
mtau_over_MZ_frac = _to_fraction_from_decimal_string(str(mtau_over_MZ_dec))
y_e_frac          = _to_fraction_from_decimal_string(str(y_e_dec))
y_mu_frac         = _to_fraction_from_decimal_string(str(y_mu_dec))
y_tau_frac        = _to_fraction_from_decimal_string(str(y_tau_dec))

# ---- Append to ledgers (six rows) ------------------------------------------------------
p = 6
unit_q = U_p(p)  # exact Fraction

rows_for_artifacts = []
rows_for_print     = []

def _append_observable(canon_symbol: str, pretty_symbol: str, value_frac: Fraction, notes: str, tags):
    obs_q = value_frac
    k_int = _round_half_up_fraction_to_int(obs_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    _ = pftc_add_block(
        symbol=canon_symbol,
        p=p,
        k=k_int,
        observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes=notes,
        tags=tags
    )

    r = _residues(k_int)
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    rows_for_artifacts.append(dict(
        sector="YUKAWA_LEPTON",
        symbol=pretty_symbol,
        name=canon_symbol,
        value=str(obs_dec),
        p=p,
        k=str(k_int),
        approx=str(pred_dec),
        err_abs=str(err_abs_dec),
        err_rel=str(err_rel_dec),  # fraction, not %
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes=notes
    ))
    rows_for_print.append([
        pretty_symbol, str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# A) Seed snapshots m_f/M_Z
_append_observable(
    canon_symbol="YUK|me_over_MZ_snapshot",
    pretty_symbol="m_e/M_Z",
    value_frac=me_over_MZ_frac,
    notes=f"Snapshot from m_e={m_e_GeV} GeV, M_Z={M_Z_GeV} GeV.",
    tags=["YUKAWA","LEPTON","snapshot","p=6"]
)
_append_observable(
    canon_symbol="YUK|mmu_over_MZ_snapshot",
    pretty_symbol="m_μ/M_Z",
    value_frac=mmu_over_MZ_frac,
    notes=f"Snapshot from m_μ={m_mu_GeV} GeV, M_Z={M_Z_GeV} GeV.",
    tags=["YUKAWA","LEPTON","snapshot","p=6"]
)
_append_observable(
    canon_symbol="YUK|mtau_over_MZ_snapshot",
    pretty_symbol="m_τ/M_Z",
    value_frac=mtau_over_MZ_frac,
    notes=f"Snapshot from m_τ={m_tau_GeV} GeV, M_Z={M_Z_GeV} GeV.",
    tags=["YUKAWA","LEPTON","snapshot","p=6"]
)

# B) Derived Yukawas y_f = √(2 G_F) · m_f  = √(2 G_F·M_Z²) · (m_f/M_Z)
_append_observable(
    canon_symbol="YUK|y_e_from_snapshot",
    pretty_symbol="y_e",
    value_frac=y_e_frac,
    notes=f"Derived y_e = √(2·G_F·M_Z²)·(m_e/M_Z); G_F={G_F_GeV_minus2}.",
    tags=["YUKAWA","LEPTON","derived","p=6"]
)
_append_observable(
    canon_symbol="YUK|y_mu_from_snapshot",
    pretty_symbol="y_μ",
    value_frac=y_mu_frac,
    notes=f"Derived y_μ = √(2·G_F·M_Z²)·(m_μ/M_Z); G_F={G_F_GeV_minus2}.",
    tags=["YUKAWA","LEPTON","derived","p=6"]
)
_append_observable(
    canon_symbol="YUK|y_tau_from_snapshot",
    pretty_symbol="y_τ",
    value_frac=y_tau_frac,
    notes=f"Derived y_τ = √(2·G_F·M_Z²)·(m_τ/M_Z); G_F={G_F_GeV_minus2}.",
    tags=["YUKAWA","LEPTON","derived","p=6"]
)

# ---- Print table ----------------------------------------------------------------------
hdr = ["Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table(f"PTFC — Charged-lepton Yukawas (canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]", hdr, rows_for_print)

# ---- Save artifacts (CSV/JSON) ---------------------------------------------------------
outdir = Path("./sc_sweep_outputs/PTFC_canonical")
outdir.mkdir(parents=True, exist_ok=True)

csv_path = outdir / "PTFC_YUKAWA_leptons_p6.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

json_path = outdir / "PTFC_YUKAWA_leptons_p6.json"
with open(json_path, "w") as f:
    json.dump(rows_for_artifacts, f, indent=2)

print("\n====== MODULE 011 — Charged-lepton Yukawas complete (6 entries) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 011
# =================================================================================================




# =================================================================================================
# MODULE 012 (v3u) — Gauge couplings at M_Z: (α1, α2, α3) and (g1, g2, g3) — p=6, fraction-first
# -------------------------------------------------------------------------------------------------
# Requires: PFTC v3 STARTER already run (defines U_p, pftc_add_block, REL_TOL_PERCENT)
# Uses existing snapshots (no new external seeds):
#   • α^{-1}(M_Z, effective) = 127.955000000000               (MODULE 002)
#   • sin²θ_W(MZ, MSbar) = 0.231220000000                     (MODULE 003 CORE)
#   • α_s(M_Z) = 0.1179                                       (MODULE 007A snapshots)
#
# What this block does:
#   • Derives electroweak gauge couplings in **GUT normalization**:
#       α1 = (5/3) · α_em / cos²θ_W,   α2 = α_em / sin²θ_W,   α3 = α_s
#     with α_em = 1 / (α^{-1}(M_Z, eff)).
#   • Then computes g_i from α_i via:  g_i = sqrt(4π α_i).
#   • Stores six entries: α1, α2, α3, g1, g2, g3 — all dimensionless, unified tolerance.
#   • Prints a compact table and writes artifacts: PTFC_GAUGE_at_MZ_p6.{csv,json}
#
# Notes:
#   • Mixes an “effective” α_em with MSbar sin²θ_W as a pragmatic snapshot-only combo.
#     If you later add a fully MSbar α_em(M_Z), re-run to keep scheme-consistent.
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from math import tau  # 2π, for convenience (we'll use 4π = 2*tau)
from pathlib import Path
import csv, json

getcontext().prec = 80  # generous precision for roots/ratios

# ---- local helpers --------------------------------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    """
    For x >= 0 rational, nearest-integer using round-half-up:
      k = floor(x + 1/2). Works exactly in Q.
    """
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _sqrt_dec(x: Decimal) -> Decimal:
    return getcontext().sqrt(x)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---- Snapshots already present in earlier modules ---------------------------------------
alpha_inv_MZ_eff_dec = Decimal("127.955000000000")   # α^{-1}(MZ,eff)
sin2_thetaW_MSbar_dec= Decimal("0.231220000000")     # sin²θ_W(MZ,MSbar)
alpha_s_MZ_dec       = Decimal("0.1179")             # α_s(MZ)

# ---- Derive α_em, s², c² ----------------------------------------------------------------
alpha_em_dec = Decimal(1) / alpha_inv_MZ_eff_dec     # α_em(MZ)
s2 = sin2_thetaW_MSbar_dec
c2 = Decimal(1) - s2

# ---- GUT-normalized α1, α2, α3 ---------------------------------------------------------
alpha1_dec = (Decimal(5) / Decimal(3)) * alpha_em_dec / c2
alpha2_dec = alpha_em_dec / s2
alpha3_dec = alpha_s_MZ_dec

# ---- g_i from α_i:  g_i = sqrt(4π α_i) -------------------------------------------------
FOUR_PI = Decimal(2) * Decimal(str(tau))             # 4π = 2·τ
g1_dec = _sqrt_dec(FOUR_PI * alpha1_dec)
g2_dec = _sqrt_dec(FOUR_PI * alpha2_dec)
g3_dec = _sqrt_dec(FOUR_PI * alpha3_dec)

# ---- Rationalize for ledger (Fractions from Decimal strings) ---------------------------
alpha1_frac = _to_fraction_from_decimal_string(str(alpha1_dec))
alpha2_frac = _to_fraction_from_decimal_string(str(alpha2_dec))
alpha3_frac = _to_fraction_from_decimal_string(str(alpha3_dec))
g1_frac     = _to_fraction_from_decimal_string(str(g1_dec))
g2_frac     = _to_fraction_from_decimal_string(str(g2_dec))
g3_frac     = _to_fraction_from_decimal_string(str(g3_dec))

# ---- Append six observables to ledgers -------------------------------------------------
p = 6
unit_q = U_p(p)  # exact Fraction

rows_for_artifacts = []
rows_for_print     = []

def _append_obs(canon_symbol: str, pretty_symbol: str, value_frac: Fraction, notes: str, tags):
    obs_q = value_frac
    k_int = _round_half_up_fraction_to_int(obs_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    _ = pftc_add_block(
        symbol=canon_symbol,
        p=p,
        k=k_int,
        observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes=notes,
        tags=tags
    )

    r = _residues(k_int)
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    rows_for_artifacts.append(dict(
        sector="GAUGE_at_MZ",
        symbol=pretty_symbol,
        name=canon_symbol,
        value=str(obs_dec),
        p=p,
        k=str(k_int),
        approx=str(pred_dec),
        err_abs=str(err_abs_dec),
        err_rel=str(err_rel_dec),  # fraction, not %
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes=notes
    ))
    rows_for_print.append([
        pretty_symbol, str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# α_i
_append_obs(
    canon_symbol="GAUGE|alpha1_GUTnorm_at_MZ",
    pretty_symbol="α₁(M_Z) [GUT]",
    value_frac=alpha1_frac,
    notes="α₁ = (5/3)·α_em/cos²θ_W (GUT normalization). Uses α_em from α^{-1}(MZ,eff) and sin²θ_W(MSbar).",
    tags=["GAUGE","EW","derived","MZ","p=6"]
)
_append_obs(
    canon_symbol="GAUGE|alpha2_at_MZ",
    pretty_symbol="α₂(M_Z)",
    value_frac=alpha2_frac,
    notes="α₂ = α_em/sin²θ_W. Uses α_em from α^{-1}(MZ,eff) and sin²θ_W(MSbar).",
    tags=["GAUGE","EW","derived","MZ","p=6"]
)
_append_obs(
    canon_symbol="GAUGE|alpha3_at_MZ",
    pretty_symbol="α₃(M_Z)",
    value_frac=alpha3_frac,
    notes="α₃ = α_s(M_Z) snapshot.",
    tags=["GAUGE","QCD","snapshot","MZ","p=6"]
)

# g_i
_append_obs(
    canon_symbol="GAUGE|g1_GUTnorm_at_MZ",
    pretty_symbol="g₁(M_Z) [GUT]",
    value_frac=g1_frac,
    notes="g₁ = sqrt(4π α₁) with α₁ in GUT normalization.",
    tags=["GAUGE","EW","derived","MZ","p=6"]
)
_append_obs(
    canon_symbol="GAUGE|g2_at_MZ",
    pretty_symbol="g₂(M_Z)",
    value_frac=g2_frac,
    notes="g₂ = sqrt(4π α₂).",
    tags=["GAUGE","EW","derived","MZ","p=6"]
)
_append_obs(
    canon_symbol="GAUGE|g3_at_MZ",
    pretty_symbol="g₃(M_Z)",
    value_frac=g3_frac,
    notes="g₃ = sqrt(4π α₃).",
    tags=["GAUGE","QCD","derived","MZ","p=6"]
)

# ---- Print table ----------------------------------------------------------------------
hdr = ["Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table(f"PTFC — Gauge couplings at M_Z (canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]", hdr, rows_for_print)

# ---- Save artifacts (CSV/JSON) ---------------------------------------------------------
outdir = Path("./sc_sweep_outputs/PTFC_canonical")
outdir.mkdir(parents=True, exist_ok=True)

csv_path = outdir / "PTFC_GAUGE_at_MZ_p6.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

json_path = outdir / "PTFC_GAUGE_at_MZ_p6.json"
with open(json_path, "w") as f:
    json.dump(rows_for_artifacts, f, indent=2)

print("\n====== MODULE 012 — Gauge couplings at M_Z complete (α1, α2, α3, g1, g2, g3) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 012
# =================================================================================================




# =================================================================================================
# MODULE 013 (v3u) — Electroweak precision one-liners: ρ (tree-level check) and Γ_Z/M_Z — p=6
# -------------------------------------------------------------------------------------------------
# Requires: PFTC v3 STARTER already run (defines U_p, pftc_add_block, REL_TOL_PERCENT)
# Uses snapshots you already seeded:
#   • sin²θ_W^eff,ℓ = 0.23153                 (MODULE 007A)
#   • M_W/M_Z       = 0.88153                 (MODULE 007A)
#   • M_Z           = 91.1876 GeV             (MODULE 007A context / common snapshots)
# Plus Γ_Z snapshot (classic LEP pillar):
#   • Γ_Z           = 2.4952 GeV              (snapshot here; update if you prefer a different central)
#
# What this block does:
#   • Derives a tree-level ρ “consistency check” using
#       ρ_check ≡ (M_W/M_Z)^2 / (1 − sin²θ_W^eff,ℓ)
#     (Exactly 1 at tree level if one uses the on-shell s_W^2; with the leptonic effective angle it
#      lands close to 1 — a quick QC dial for your ledger.)
#   • Forms the dimensionless ratio Γ_Z/M_Z from the snapshots.
#   • Appends both entries with unified tolerance, prints a compact table, and writes artifacts:
#       ./sc_sweep_outputs/PTFC_canonical/PTFC_EW_precision_p6.{csv,json}
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80  # generous precision for ratios

# ---- local helpers --------------------------------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    """
    For x >= 0 rational, nearest-integer using round-half-up:
      k = floor(x + 1/2). Works exactly in Q.
    """
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---- Snapshots (consistent with earlier modules) ---------------------------------------
sin2_thetaW_eff_l_dec = Decimal("0.23153")     # sin²θ_W^eff,ℓ
MW_over_MZ_dec        = Decimal("0.88153")     # M_W/M_Z
MZ_GeV                = Decimal("91.1876")     # M_Z (GeV)
GammaZ_GeV            = Decimal("2.4952")      # Γ_Z (GeV) snapshot

# ---- Derived precision observables -----------------------------------------------------
# ρ_check ≡ (M_W/M_Z)^2 / (1 − sin²θ_W^eff,ℓ)
rho_check_dec = (MW_over_MZ_dec * MW_over_MZ_dec) / (Decimal(1) - sin2_thetaW_eff_l_dec)

# Γ_Z / M_Z (dimensionless)
GammaZ_over_MZ_dec = GammaZ_GeV / MZ_GeV

# ---- Rationalize (Fractions from Decimal strings) -------------------------------------
rho_check_frac       = _to_fraction_from_decimal_string(str(rho_check_dec))
GammaZ_over_MZ_frac  = _to_fraction_from_decimal_string(str(GammaZ_over_MZ_dec))

# ---- Append to ledgers ----------------------------------------------------------------
p = 6
unit_q = U_p(p)  # exact Fraction

rows_for_artifacts = []
rows_for_print     = []

def _append_obs(canon_symbol: str, pretty_symbol: str, value_frac: Fraction, notes: str, tags):
    obs_q = value_frac
    k_int = _round_half_up_fraction_to_int(obs_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    _ = pftc_add_block(
        symbol=canon_symbol,
        p=p,
        k=k_int,
        observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes=notes,
        tags=tags
    )

    r = _residues(k_int)
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    rows_for_artifacts.append(dict(
        sector="EW_PRECISION",
        symbol=pretty_symbol,
        name=canon_symbol,
        value=str(obs_dec),
        p=p,
        k=str(k_int),
        approx=str(pred_dec),
        err_abs=str(err_abs_dec),
        err_rel=str(err_rel_dec),  # fraction, not %
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes=notes
    ))
    rows_for_print.append([
        pretty_symbol, str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# A) ρ_check (should be ~1 at tree level; effective angle yields a near-1 cross-check)
_append_obs(
    canon_symbol="EW|rho_tree_check_from_eff_angle",
    pretty_symbol="ρ_check",
    value_frac=rho_check_frac,
    notes="ρ_check ≡ (M_W/M_Z)^2 / (1 − sin²θ_W^eff,ℓ). QC dial (tree) using effective leptonic angle.",
    tags=["EW","precision","derived","p=6"]
)

# B) Γ_Z / M_Z snapshot ratio
_append_obs(
    canon_symbol="EW|GammaZ_over_MZ_snapshot",
    pretty_symbol="Γ_Z/M_Z",
    value_frac=GammaZ_over_MZ_frac,
    notes=f"Snapshot ratio from Γ_Z={GammaZ_GeV} GeV and M_Z={MZ_GeV} GeV.",
    tags=["EW","precision","snapshot","p=6"]
)

# ---- Print table ----------------------------------------------------------------------
hdr = ["Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table(f"PTFC — Electroweak precision (canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]", hdr, rows_for_print)

# ---- Save artifacts (CSV/JSON) ---------------------------------------------------------
outdir = Path("./sc_sweep_outputs/PTFC_canonical")
outdir.mkdir(parents=True, exist_ok=True)

csv_path = outdir / "PTFC_EW_precision_p6.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

json_path = outdir / "PTFC_EW_precision_p6.json"
with open(json_path, "w") as f:
    json.dump(rows_for_artifacts, f, indent=2)

print("\n====== MODULE 013 — Electroweak precision complete (ρ_check, Γ_Z/M_Z) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 013
# =================================================================================================



# =================================================================================================
# MODULE 014R (v3u) — Neutrino absolute scale (NO) REDO at p=10 (+ Dirac Yukawas) — fraction-first
# -------------------------------------------------------------------------------------------------
# Why this redo?
#   • Neutrino masses and Yukawas are ~1e-11–1e-12 (dimensionless m/MZ), so at p=6 they quantize to k=0,
#     causing 100% relative errors. The v3 STARTER explicitly allows p∈{6,10}; use p=10 for tiny ν rows.
#
# What it does:
#   • Keeps your quark sector from MODULE 014 exactly as-is.
#   • Recomputes (mν1, mν2, mν3)/MZ and (yν1, yν2, yν3) for Normal Ordering at **p=10** so they pass.
#   • All math stays fraction-first; only Decimals are used for sqrt and pretty-print/error reporting.
#   • Unified tolerance still: REL_TOL_PERCENT = 1e-8 (%).
#   • Artifacts: ./sc_sweep_outputs/PTFC_canonical/PTFC_NEUTRINO_NO_p10.{csv,json}
# -------------------------------------------------------------------------------------------------
# Drop-in requirements:
#   • PFTC v3 STARTER already run in this runtime (defines U_p, pftc_add_block, REL_TOL_PERCENT, etc.).
#   • No edits to previous modules—append-only policy maintained.
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80  # generous precision for roots

# ---------- helpers (local, self-contained) ----------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _sqrt_dec(x: Decimal) -> Decimal:
    return getcontext().sqrt(x)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ---------- inputs (same snapshots used before; redo is just the grid p=10) ----------
M_Z_GeV                = Decimal("91.1876")     # Z mass (GeV)
G_F_GeV_minus2         = Decimal("1.1663787e-5")
m_lightest_eV          = Decimal("0.010")       # NO seed (adjust later if you like)
Delta_m2_21_eV2        = Decimal("7.42e-5")
Delta_m2_31_abs_eV2    = Decimal("2.517e-3")
eV_to_GeV              = Decimal("1e-9")

# Common prefactor  S = √(2 G_F M_Z^2)
S_dec = _sqrt_dec(Decimal(2) * G_F_GeV_minus2 * (M_Z_GeV * M_Z_GeV))

# ---------- build NO masses (Decimal), convert to (dimensionless) over MZ ----------
m1_eV = m_lightest_eV
m2_eV = _sqrt_dec(m1_eV*m1_eV + Delta_m2_21_eV2)
m3_eV = _sqrt_dec(m1_eV*m1_eV + Delta_m2_31_abs_eV2)

m1_over_MZ_dec = (m1_eV * eV_to_GeV) / M_Z_GeV
m2_over_MZ_dec = (m2_eV * eV_to_GeV) / M_Z_GeV
m3_over_MZ_dec = (m3_eV * eV_to_GeV) / M_Z_GeV

# Dirac Yukawas yνi = S · (mνi/MZ)
y_nu1_dec = S_dec * m1_over_MZ_dec
y_nu2_dec = S_dec * m2_over_MZ_dec
y_nu3_dec = S_dec * m3_over_MZ_dec

# ---------- rationalize for the ledger ----------
m1_over_MZ_frac = _to_fraction_from_decimal_string(str(m1_over_MZ_dec))
m2_over_MZ_frac = _to_fraction_from_decimal_string(str(m2_over_MZ_dec))
m3_over_MZ_frac = _to_fraction_from_decimal_string(str(m3_over_MZ_dec))
y_nu1_frac      = _to_fraction_from_decimal_string(str(y_nu1_dec))
y_nu2_frac      = _to_fraction_from_decimal_string(str(y_nu2_dec))
y_nu3_frac      = _to_fraction_from_decimal_string(str(y_nu3_dec))

# ---------- choose the finer grid ----------
p = 10
unit_q = U_p(p)  # exact Fraction at p=10

rows_for_artifacts = []
rows_for_print     = []

def _append_obs(canon_symbol: str, pretty_symbol: str, value_frac: Fraction, notes: str, tags):
    obs_q = value_frac
    k_int = _round_half_up_fraction_to_int(obs_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    _ = pftc_add_block(
        symbol=canon_symbol,
        p=p,
        k=k_int,
        observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes=notes,
        tags=tags
    )

    r = _residues(k_int)
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    rows_for_artifacts.append(dict(
        sector="NEUTRINO_NO@p10",
        symbol=pretty_symbol,
        name=canon_symbol,
        value=str(obs_dec),
        p=p,
        k=str(k_int),
        approx=str(pred_dec),
        err_abs=str(err_abs_dec),
        err_rel=str(err_rel_dec),
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes=notes
    ))
    rows_for_print.append([
        pretty_symbol, str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# ---------- append neutrino rows (same canonical symbols; new grid p=10) ----------
_append_obs(
    "YUK|m1_over_MZ_NO_seed",
    "m_ν1/M_Z",
    m1_over_MZ_frac,
    notes=f"[REDO @ p=10] NO seed: m1={m1_eV} eV; Δm²_21={Delta_m2_21_eV2} eV²; |Δm²_31|={Delta_m2_31_abs_eV2} eV².",
    tags=["NEUTRINO","NO","snapshot","p=10","redo"]
)
_append_obs(
    "YUK|m2_over_MZ_NO_derived",
    "m_ν2/M_Z",
    m2_over_MZ_frac,
    notes="[REDO @ p=10] Derived from m1 and Δm²_21 (NO).",
    tags=["NEUTRINO","NO","derived","p=10","redo"]
)
_append_obs(
    "YUK|m3_over_MZ_NO_derived",
    "m_ν3/M_Z",
    m3_over_MZ_frac,
    notes="[REDO @ p=10] Derived from m1 and |Δm²_31| (NO).",
    tags=["NEUTRINO","NO","derived","p=10","redo"]
)

_append_obs(
    "YUK|y_nu1_from_m1_NO",
    "y_ν1",
    y_nu1_frac,
    notes="[REDO @ p=10] Dirac Yukawa from m_ν1.",
    tags=["YUKAWA","NEUTRINO","NO","derived","p=10","redo"]
)
_append_obs(
    "YUK|y_nu2_from_m2_NO",
    "y_ν2",
    y_nu2_frac,
    notes="[REDO @ p=10] Dirac Yukawa from m_ν2.",
    tags=["YUKAWA","NEUTRINO","NO","derived","p=10","redo"]
)
_append_obs(
    "YUK|y_nu3_from_m3_NO",
    "y_ν3",
    y_nu3_frac,
    notes="[REDO @ p=10] Dirac Yukawa from m_ν3.",
    tags=["YUKAWA","NEUTRINO","NO","derived","p=10","redo"]
)

# ---------- print and save artifacts ----------
hdr = ["Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table("PTFC — Neutrino absolute scale (NO) REDO at p=10  [REL_TOL = 1e-10 rel = 1e-8%]",
             hdr, rows_for_print)

outdir = Path("./sc_sweep_outputs/PTFC_canonical"); outdir.mkdir(parents=True, exist_ok=True)
csv_path = outdir / "PTFC_NEUTRINO_NO_p10.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel",
                "mod23","mod49","mod50","mod137","notes"])
    for r in rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

json_path = outdir / "PTFC_NEUTRINO_NO_p10.json"
with open(json_path, "w") as f:
    json.dump(rows_for_artifacts, f, indent=2)

print("\n====== MODULE 014R — Neutrino (NO) REDO complete at p=10 (6 entries) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 014R
# =================================================================================================




# =================================================================================================
# MODULE 015 (v3u) — Six Quark Masses (m_q/M_Z) + Yukawas (y_q) — p=6, fraction-first, self-auditing
# -------------------------------------------------------------------------------------------------
# What this brick does
#   • Seeds dimensionless mass ratios m_q/M_Z for q∈{u,d,s,c,b,t} from snapshot masses (GeV).
#   • Derives Yukawas via  y_q = √(2·G_F·M_Z²) · (m_q/M_Z).
#   • Appends 12 audited rows (6 masses + 6 Yukawas) at p=6 under unified tolerance (1e-8%).
#   • Prints a compact audit with k residues and writes artifacts to:
#         ./sc_sweep_outputs/PTFC_canonical/PTFC_QUARK_MASSES_YUK_p6_v2.{csv,json}
#
# Notes
#   • These are pragmatic snapshot inputs (mix of common PDG-style values); swap to your preferred
#     scheme/scale anytime and just rerun this module—append-only semantics will preserve history.
#   • Everything is fraction-first; Decimals are used only for sqrt/display/error reporting.
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80  # comfortable precision for roots & ratios

# ----- helpers (local, self-contained) ---------------------------------------------------
def _round_half_up_fraction_to_int(x: Fraction) -> int:
    if x < 0:
        raise ValueError("This helper expects nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _sqrt_dec(x: Decimal) -> Decimal:
    return getcontext().sqrt(x)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _print_table(title, headers, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(headers))
    print("-" * len(" | ".join(headers)))
    for row in rows:
        print(" | ".join(str(x) for x in row))

# ----- snapshots (GeV) & constants -------------------------------------------------------
# Feel free to adjust: these are typical reference numbers for a quick snapshot.
M_Z_GeV        = Decimal("91.1876")
G_F_GeV_minus2 = Decimal("1.1663787e-5")

# Light quarks (MeV → GeV) and heavy quarks (GeV)
masses_quark_GeV = {
    "u": Decimal("0.0022"),
    "d": Decimal("0.0047"),
    "s": Decimal("0.096"),
    "c": Decimal("1.27"),
    "b": Decimal("4.18"),
    "t": Decimal("172.76"),
}

# Common prefactor  S = √(2 G_F M_Z^2)
S_dec = _sqrt_dec(Decimal(2) * G_F_GeV_minus2 * (M_Z_GeV * M_Z_GeV))

# ----- append logic ---------------------------------------------------------------------
p = 6
unit_q = U_p(p)  # exact Fraction from the STARTER

rows_for_artifacts = []
rows_for_print     = []

def _append_obs(sector: str, canon_symbol: str, pretty_symbol: str, value_frac: Fraction, notes: str, tags):
    obs_q = value_frac
    k_int = _round_half_up_fraction_to_int(obs_q / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q

    _ = pftc_add_block(
        symbol=canon_symbol,
        p=p,
        k=k_int,
        observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT,  # unified tol: 1e-8 %
        notes=notes,
        tags=tags
    )

    r = _residues(k_int)
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    rows_for_artifacts.append(dict(
        sector=sector,
        symbol=pretty_symbol,
        name=canon_symbol,
        value=str(obs_dec),
        p=p,
        k=str(k_int),
        approx=str(pred_dec),
        err_abs=str(err_abs_dec),
        err_rel=str(err_rel_dec),
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"],
        notes=notes
    ))
    rows_for_print.append([
        f"{sector}:{pretty_symbol}", str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

# ----- compute & append (m_q/MZ snapshots + Yukawas) ------------------------------------
for q in ["u", "d", "s", "c", "b", "t"]:
    m_q = masses_quark_GeV[q]
    m_over_MZ_dec = m_q / M_Z_GeV
    y_q_dec       = S_dec * m_over_MZ_dec

    m_over_MZ_frac = _to_fraction_from_decimal_string(str(m_over_MZ_dec))
    y_q_frac       = _to_fraction_from_decimal_string(str(y_q_dec))

    _append_obs("QUARK", f"YUK|m_{q}_over_MZ_snapshot", f"m_{q}/M_Z",
                m_over_MZ_frac,
                notes=f"Snapshot mass: m_{q}={m_q} GeV; M_Z={M_Z_GeV} GeV.",
                tags=["YUKAWA","QUARK","snapshot","p=6"])

    _append_obs("QUARK", f"YUK|y_{q}_from_snapshot", f"y_{q}",
                y_q_frac,
                notes=f"Derived y_{q} = √(2·G_F·M_Z²)·(m_{q}/M_Z); G_F={G_F_GeV_minus2}.",
                tags=["YUKAWA","QUARK","derived","p=6"])

# ----- print & save artifacts ------------------------------------------------------------
hdr = ["Sector:Symbol","value","p","k (atomic #)","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table(f"PTFC — Six Quark Masses + Yukawas (canonical p={p})  [REL_TOL = 1e-10 rel = 1e-8%]",
             hdr, rows_for_print)

outdir = Path("./sc_sweep_outputs/PTFC_canonical"); outdir.mkdir(parents=True, exist_ok=True)
csv_path = outdir / "PTFC_QUARK_MASSES_YUK_p6_v2.csv"
with open(csv_path, "w", newline="") as f:
    w = csv.writer(f)
    w.writerow(["sector","symbol","name","value","p","k","approx","err_abs","err_rel",
                "mod23","mod49","mod50","mod137","notes"])
    for r in rows_for_artifacts:
        w.writerow([r["sector"],r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],
                    r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])

json_path = outdir / "PTFC_QUARK_MASSES_YUK_p6_v2.json"
with open(json_path, "w") as f:
    json.dump(rows_for_artifacts, f, indent=2)

print("\n====== MODULE 015 — Six Quark Masses + Yukawas complete (12 entries) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 015
# =================================================================================================




# =================================================================================================
# MODULE 016 (v1) — Strong CP phase  \bar{θ}_QCD  (p=6)
# -------------------------------------------------------------------------------------------------
# What this logs
#   • STRONGCP|theta_QCD_value      : central value (default 0 → "consistent with zero")
#   • STRONGCP|theta_QCD_abs_upper  : absolute upper bound to reflect nEDM constraints
#
# Notes
#   • Adjust THETA_UPPER if you want a different experimental bound.
#   • Both entries are snapped to the p=6 unit U_p and appended via pftc_add_block.
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80

# ---- user knobs ----------------------------------------------------------------------------
THETA_CENTRAL = Decimal("0")             # central value; keep 0 to reflect "consistent with zero"
THETA_UPPER   = Decimal("2.5e-10")       # adjust to your preferred nEDM-derived upper limit

# ---- helpers ------------------------------------------------------------------------------
def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _round_half_up_fraction_to_int(x: Fraction) -> int:
    # round-half-up to nearest integer, assuming x >= 0
    if x < 0:
        raise ValueError("needs nonnegative x.")
    return (x.numerator * 2 + x.denominator) // (2 * x.denominator)

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _append_scalar(name, pretty, value_dec, notes, tags):
    obs_q = _to_fraction_from_decimal_string(str(value_dec))
    k_int = _round_half_up_fraction_to_int(abs(obs_q) / unit_q)  # magnitude quantized for ledger k
    pred_q = Fraction(k_int, 1) * unit_q
    # sign preserved in observed_value (could be negative if desired later)
    _ = pftc_add_block(
        symbol=name, p=p, k=k_int, observed_value=obs_q,
        rel_tol_percent=REL_TOL_PERCENT, notes=notes, tags=tags
    )

    r = _residues(k_int)
    obs_dec  = _frac_to_decimal(obs_q)
    pred_dec = _frac_to_decimal(pred_q) if obs_dec >= 0 else -_frac_to_decimal(pred_q)
    err_abs_dec = abs(pred_dec - obs_dec)
    denom = abs(obs_dec) if obs_dec != 0 else Decimal(1)
    err_rel_dec = err_abs_dec / denom

    rows_csv.append(dict(
        symbol=pretty, name=name, value=str(obs_dec), p=p, k=str(k_int),
        approx=str(pred_dec), err_abs=str(err_abs_dec), err_rel=str(err_rel_dec),
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"], notes=notes
    ))
    rows_print.append([
        pretty, str(obs_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

def _print_table(title, hdr, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(hdr))
    print("-" * len(" | ".join(hdr)))
    for row in rows:
        print(" | ".join(map(str,row)))

# ---- main --------------------------------------------------------------------------------
p = 6
unit_q = U_p(p)   # canonical p=6 quantum
rows_csv, rows_print = [], []

# central value (kept at 0 unless you want to test nonzero scenarios)
_append_scalar(
    "STRONGCP|theta_QCD_value", r"\bar{θ}_{QCD}",
    THETA_CENTRAL,
    notes="Central value; default 0 ≡ consistent with zero within current bounds.",
    tags=["STRONGCP","p=6"]
)

# absolute upper bound (positive number)
_append_scalar(
    "STRONGCP|theta_QCD_abs_upper", r"| \bar{θ}_{QCD} | upper",
    THETA_UPPER,
    notes="Adjust to your preferred nEDM-derived upper limit (absolute bound).",
    tags=["STRONGCP","BOUND","p=6"]
)

# ---- print & save -------------------------------------------------------------------------
hdr = ["Symbol","value","p","k","approx=k·U_p","|err|","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table("PTFC — STRONG CP phase (canonical p=6)", hdr, rows_print)

outdir = Path("./sc_sweep_outputs/PTFC_canonical"); outdir.mkdir(parents=True, exist_ok=True)
with open(outdir / "PTFC_STRONGCP_p6.csv","w",newline="") as f:
    import csv
    w = csv.writer(f)
    w.writerow(["symbol","name","value","p","k","approx","err_abs","err_rel","mod23","mod49","mod50","mod137","notes"])
    for r in rows_csv:
        w.writerow([r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])
with open(outdir / "PTFC_STRONGCP_p6.json","w") as f:
    import json
    json.dump(rows_csv, f, indent=2)

print("\n====== MODULE 016 — STRONG CP phase complete (2 entries) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 016
# =================================================================================================



# =================================================================================================
# MODULE 016B (v1) — Strong CP phase  \bar{θ}_QCD  (p=10 adjunct)
# -------------------------------------------------------------------------------------------------
# What this logs
#   • STRONGCP|theta_QCD_abs_upper_p10 : absolute upper bound at higher resolution p=10
#
# Notes
#   • We SNAP DOWN to ensure the stored bound is conservative: pred ≤ requested bound.
#   • Keeps your p=6 Module 016 intact (central value = 0 and p=6 upper bound).
#   • This is an adjunct: only the upper bound is recorded at p=10.
# =================================================================================================

from fractions import Fraction
from decimal import Decimal, getcontext
from pathlib import Path
import csv, json

getcontext().prec = 80

# ---- user knobs ----------------------------------------------------------------------------
THETA_UPPER_P10 = Decimal("2.5e-10")   # target absolute upper limit (from nEDM, etc.), p=10 adjunct

# ---- helpers (mirrors 016 style, with a SNAP-DOWN variant) ---------------------------------
def _to_fraction_from_decimal_string(s: str) -> Fraction:
    return Fraction(str(Decimal(s)))

def _frac_to_decimal(q: Fraction) -> Decimal:
    return Decimal(q.numerator) / Decimal(q.denominator)

def _floor_fraction_to_int(x: Fraction) -> int:
    # floor to integer, assuming x >= 0
    if x < 0:
        raise ValueError("needs nonnegative x.")
    return x.numerator // x.denominator

def _residues(k: int):
    return dict(mod23=k % 23, mod49=k % 49, mod50=k % 50, mod137=k % 137)

def _append_bound_snap_down(name, pretty, value_dec, notes, tags):
    # observe the requested bound
    obs_q = _to_fraction_from_decimal_string(str(value_dec))
    # compute conservative integer k by SNAP-DOWN against the p=10 unit
    k_int = _floor_fraction_to_int(abs(obs_q) / unit_q)
    pred_q = Fraction(k_int, 1) * unit_q  # this is the stored rational (≤ obs)

    _ = pftc_add_block(
        symbol=name, p=p, k=k_int, observed_value=pred_q,  # store snapped-down value
        rel_tol_percent=REL_TOL_PERCENT, notes=notes, tags=tags
    )

    r = _residues(k_int)
    obs_dec_req  = _frac_to_decimal(obs_q)   # user-requested bound
    pred_dec     = _frac_to_decimal(pred_q)  # stored conservative bound
    err_abs_dec  = abs(pred_dec - obs_dec_req)
    denom        = abs(obs_dec_req) if obs_dec_req != 0 else Decimal(1)
    err_rel_dec  = err_abs_dec / denom

    rows_csv.append(dict(
        symbol=pretty, name=name, value=str(pred_dec),  # we log the snapped stored value
        p=p, k=str(k_int), approx=str(pred_dec), err_abs=str(err_abs_dec), err_rel=str(err_rel_dec),
        mod23=r["mod23"], mod49=r["mod49"], mod50=r["mod50"], mod137=r["mod137"], notes=notes
    ))
    rows_print.append([
        pretty, str(pred_dec), p, str(k_int), str(pred_dec),
        f"{err_abs_dec:.6E}", f"{err_rel_dec:.6E}",
        r["mod23"], r["mod49"], r["mod50"], r["mod137"]
    ])

def _print_table(title, hdr, rows):
    print("\n" + title)
    print("=" * len(title))
    print(" | ".join(hdr))
    print("-" * len(" | ".join(hdr)))
    for row in rows:
        print(" | ".join(map(str,row)))

# ---- main --------------------------------------------------------------------------------
p = 10
unit_q = U_p(p)   # high-resolution p=10 quantum
rows_csv, rows_print = [], []

# upper bound at p=10 (conservative SNAP-DOWN)
_append_bound_snap_down(
    "STRONGCP|theta_QCD_abs_upper_p10", r"| \bar{θ}_{QCD} | upper (p=10)",
    THETA_UPPER_P10,
    notes="Adjunct upper bound at p=10; snapped DOWN to nearest multiple of U_p to ensure ≤ requested bound.",
    tags=["STRONGCP","BOUND","p=10","SNAPDOWN"]
)

# ---- print & save -------------------------------------------------------------------------
hdr = ["Symbol","value","p","k","approx=k·U_p","|err| vs request","rel err","k mod 23","mod 49","mod 50","mod 137"]
_print_table("PTFC — STRONG CP phase (p=10 adjunct)", hdr, rows_print)

outdir = Path("./sc_sweep_outputs/PTFC_canonical"); outdir.mkdir(parents=True, exist_ok=True)
with open(outdir / "PTFC_STRONGCP_p10.csv","w",newline="") as f:
    w = csv.writer(f)
    w.writerow(["symbol","name","value","p","k","approx","err_abs_vs_request","err_rel_vs_request","mod23","mod49","mod50","mod137","notes"])
    for r in rows_csv:
        w.writerow([r["symbol"],r["name"],r["value"],r["p"],r["k"],r["approx"],r["err_abs"],r["err_rel"],r["mod23"],r["mod49"],r["mod50"],r["mod137"],r["notes"]])
with open(outdir / "PTFC_STRONGCP_p10.json","w") as f:
    json.dump(rows_csv, f, indent=2)

print("\n====== MODULE 016B — STRONG CP phase adjunct at p=10 (1 entry; snap-down; ✓) ======")
print(f"Artifacts: {outdir.resolve()}")
# =================================================================================================
# END MODULE 016B
# =================================================================================================
