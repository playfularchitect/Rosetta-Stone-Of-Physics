# -*- coding: utf-8 -*-
"""dnafree2playV1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jVDa3C_TpTI0D_k65gz9ubNpDrx1UXHv
"""

#==================================================================================================
# MODULE QL-1 — WARPFRAC QUANTLAB (CPU vs GPU Exact GEMM, Speed + Correctness)
#
# What this does:
#   • Picks two matrix sizes: M=N=K=256 and M=N=K=512.
#   • Fills A,B with random INT8 values.
#   • CPU:
#       - Computes C_cpu = A·B with an int64 accumulator (mathematically exact for these K).
#       - Stores output as int32.
#       - Times the CPU GEMM.
#   • GPU:
#       - Computes C_gpu = A·B via cublasGemmEx INT8×INT8→INT32 (Tensor Cores).
#       - Times the GPU GEMM with CUDA events.
#   • Compares:
#       - max |C_cpu - C_gpu| (should be 0).
#       - CPU vs GPU time (ms).
#       - CPU vs GPU GMAC/s.
#       - Speedup factor.
#
# You only need to copy-paste and run this. It reuses the same style as FL-* modules.
#==================================================================================================
import subprocess, textwrap

print("\n" + "="*118)
print("MODULE QL-1 — WARPFRAC QUANTLAB (CPU vs GPU Exact GEMM)")
print("="*118)

CUDA_SRC_PATH = "/content/warpfrac_quantlab_gemm.cu"
EXE_PATH      = "/content/warpfrac_quantlab_gemm"

cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <random>
#include <chrono>
#include <cuda_runtime.h>
#include <cublas_v2.h>

static void ck(cudaError_t e, const char* m){
    if(e != cudaSuccess){
        std::fprintf(stderr, "CUDA %s: %s\n", m, cudaGetErrorString(e));
        std::exit(1);
    }
}
static void bk(cublasStatus_t s, const char* m){
    if(s != CUBLAS_STATUS_SUCCESS){
        std::fprintf(stderr, "cuBLAS %s: %d\n", m, (int)s);
        std::exit(1);
    }
}

int main(){
    std::printf("\n====================================================================================\n");
    std::printf("WARPFRAC QUANTLAB — CPU vs GPU Exact GEMM (INT8xINT8->INT32)\n");
    std::printf("====================================================================================\n");
    std::printf("We compare CPU int64 GEMM vs GPU INT8xINT8->INT32 GEMM (cublasGemmEx) on a few sizes.\n");
    std::printf("CPU int64 is mathematically exact for these K, so it serves as our ground truth.\n");

    // Create cuBLAS handle once
    cublasHandle_t handle;
    bk(cublasCreate(&handle), "cublasCreate");

    // Shapes to test
    const int sizes[] = {256, 512};
    const int num_sizes = sizeof(sizes)/sizeof(sizes[0]);

    // RNG
    std::mt19937 rng(123456);
    std::uniform_int_distribution<int> dist(-128, 127);

    for(int si = 0; si < num_sizes; ++si){
        int M = sizes[si];
        int N = sizes[si];
        int K = sizes[si];

        std::printf("\n--------------------------------------------------------------------------------\n");
        std::printf("Test %d: M=N=K=%d (INT8xINT8->INT32)\n", si, M);
        std::printf("--------------------------------------------------------------------------------\n");

        size_t bytesA = (size_t)M * (size_t)K;
        size_t bytesB = (size_t)K * (size_t)N;
        size_t bytesC = (size_t)M * (size_t)N * sizeof(int32_t);

        // Host buffers (column-major: leading dim = M for A and C, K for B)
        std::vector<int8_t>  hA(bytesA);
        std::vector<int8_t>  hB(bytesB);
        std::vector<int32_t> hC_cpu((size_t)M * (size_t)N);
        std::vector<int32_t> hC_gpu((size_t)M * (size_t)N);

        for(size_t i = 0; i < bytesA; ++i){
            hA[i] = (int8_t)dist(rng);
        }
        for(size_t i = 0; i < bytesB; ++i){
            hB[i] = (int8_t)dist(rng);
        }

        // -------------------------
        // CPU GEMM (int64 accumulator)
        // C_cpu(i,j) = sum_k A(i,k)*B(k,j), column-major
        // -------------------------
        std::printf("Running CPU int64 GEMM...\n");
        auto t0 = std::chrono::high_resolution_clock::now();
        for(int j = 0; j < N; ++j){
            for(int i = 0; i < M; ++i){
                long long acc = 0;
                for(int k = 0; k < K; ++k){
                    int8_t a = hA[(size_t)i + (size_t)k * M];
                    int8_t b = hB[(size_t)k + (size_t)j * K];
                    acc += (long long)a * (long long)b;
                }
                hC_cpu[(size_t)i + (size_t)j * M] = (int32_t)acc;
            }
        }
        auto t1 = std::chrono::high_resolution_clock::now();
        double cpu_ms = std::chrono::duration<double, std::milli>(t1 - t0).count();
        std::printf("CPU GEMM time: %.3f ms\n", cpu_ms);

        // -------------------------
        // GPU GEMM via cublasGemmEx (INT8xINT8->INT32 TensorOp)
        // -------------------------
        std::printf("Running GPU cublasGemmEx (INT8xINT8->INT32, TensorOp)...\n");
        int8_t*  dA = nullptr;
        int8_t*  dB = nullptr;
        int32_t* dC = nullptr;
        ck(cudaMalloc(&dA, bytesA), "malloc dA");
        ck(cudaMalloc(&dB, bytesB), "malloc dB");
        ck(cudaMalloc(&dC, bytesC), "malloc dC");
        ck(cudaMemcpy(dA, hA.data(), bytesA, cudaMemcpyHostToDevice), "cpy A");
        ck(cudaMemcpy(dB, hB.data(), bytesB, cudaMemcpyHostToDevice), "cpy B");
        ck(cudaMemset(dC, 0, bytesC), "zero C");

        int32_t alpha = 1;
        int32_t beta  = 0;

        cudaEvent_t e0, e1;
        ck(cudaEventCreate(&e0), "event e0");
        ck(cudaEventCreate(&e1), "event e1");
        ck(cudaEventRecord(e0), "record e0");

        bk(
            cublasGemmEx(
                handle,
                CUBLAS_OP_N, CUBLAS_OP_N,
                M, N, K,
                &alpha,
                dA, CUDA_R_8I,  M,
                dB, CUDA_R_8I,  K,
                &beta,
                dC, CUDA_R_32I, M,
                CUDA_R_32I,
                CUBLAS_GEMM_DEFAULT_TENSOR_OP
            ),
            "cublasGemmEx"
        );

        ck(cudaEventRecord(e1), "record e1");
        ck(cudaEventSynchronize(e1), "sync e1");
        float gpu_ms = 0.0f;
        ck(cudaEventElapsedTime(&gpu_ms, e0, e1), "elapsed");
        cudaEventDestroy(e0);
        cudaEventDestroy(e1);
        std::printf("GPU GEMM time: %.3f ms\n", gpu_ms);

        ck(cudaMemcpy(hC_gpu.data(), dC, bytesC, cudaMemcpyDeviceToHost), "cpy C");

        cudaFree(dA);
        cudaFree(dB);
        cudaFree(dC);

        // -------------------------
        // Correctness check: max |CPU - GPU|
        // -------------------------
        long long max_diff = 0;
        int mismatches = 0;
        for(int j = 0; j < N; ++j){
            for(int i = 0; i < M; ++i){
                size_t idx = (size_t)i + (size_t)j * M;
                long long cpu_v = (long long)hC_cpu[idx];
                long long gpu_v = (long long)hC_gpu[idx];
                long long diff = cpu_v - gpu_v;
                if(diff < 0) diff = -diff;
                if(diff > max_diff) max_diff = diff;
                if(diff != 0 && mismatches < 5){
                    std::printf("  mismatch (i=%d,j=%d): cpu=%d gpu=%d diff=%lld\n",
                                i, j, (int)hC_cpu[idx], (int)hC_gpu[idx], diff);
                    ++mismatches;
                }
            }
        }
        std::printf("Max |CPU - GPU| = %lld\n", max_diff);
        if(mismatches == 0){
            std::printf("Check: all entries match exactly.\n");
        }

        // -------------------------
        // Throughput and speedup
        // -------------------------
        double macs = (double)M * (double)N * (double)K;
        double cpu_sec = cpu_ms / 1000.0;
        double gpu_sec = gpu_ms / 1000.0;

        double cpu_gmac_s = (macs / cpu_sec) / 1e9;
        double gpu_gmac_s = (macs / gpu_sec) / 1e9;

        std::printf("\nThroughput summary (M=N=K=%d):\n", M);
        std::printf("  MACs = %.0f\n", macs);
        std::printf("  CPU: %.3f ms, %.3f G-MAC/s\n", cpu_ms, cpu_gmac_s);
        std::printf("  GPU: %.3f ms, %.3f G-MAC/s\n", gpu_ms, gpu_gmac_s);
        if(gpu_sec > 0.0 && cpu_sec > 0.0){
            std::printf("  Speedup (CPU / GPU) = %.2fx\n", cpu_sec / gpu_sec);
        }
    }

    cublasDestroy(handle);

    std::printf("\nWARPFRAC QUANTLAB run finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"\n[QL-1] Writing CUDA QuantLab source -> {CUDA_SRC_PATH}")
with open(CUDA_SRC_PATH, "w") as f:
    f.write(cuda_src)

#---------------------------------------------------------------------------------------------------
# Compile for A100 (sm_80)
#---------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC_PATH,
    "-lcublas",
    "-o",
    EXE_PATH,
]

print("[QL-1] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[QL-1] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[QL-1] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[QL-1] Compile OK -> {EXE_PATH}")

#---------------------------------------------------------------------------------------------------
# Run the QuantLab benchmark
#---------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING WARPFRAC QUANTLAB (CPU vs GPU Exact GEMM)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[QL-1] WARNING: QuantLab exited with code {run_res.returncode}")
else:
    print("[QL-1] QuantLab completed successfully.")

print("\n" + "="*118)
print("MODULE QL-1 — DONE (WARPFRAC QUANTLAB CPU vs GPU)")
print("="*118)

#==================================================================================================
# MODULE DNA-1 — WARPFRAC DNA BLOCKSIM (Exact Match Counts via INT8 GEMM)
#
# What this does:
#   • Treats DNA as A/C/G/T.
#   • Encodes each sequence as a big INT8 one-hot vector of length 4*L (4 channels per base).
#   • Uses a single INT8×INT8->INT32 GEMM to compute:
#         C_gpu[i,j] = # of matching positions between sequence i and sequence j (exact Hamming matches).
#   • CPU does the same thing with int64 loops as ground truth:
#         C_cpu[i,j] = exact match count.
#   • Checks max |C_cpu - C_gpu| (should be 0).
#   • Prints throughput: GMAC/s on CPU and GPU, and speedup.
#
# This is a real, exact integer computation that:
#   • Actually uses the same kind of INT8 GEMM your Fastlane kernel uses.
#   • Sets us up to plug in real DNA later (and then build more complex alignment logic on top).
#==================================================================================================
import subprocess, textwrap

print("\n" + "="*118)
print("MODULE DNA-1 — WARPFRAC DNA BLOCKSIM (Exact Match Counts via INT8 GEMM)")
print("="*118)

CUDA_SRC_PATH = "/content/warpfrac_dna_blocksim.cu"
EXE_PATH      = "/content/warpfrac_dna_blocksim"

cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <string>
#include <random>
#include <chrono>
#include <cuda_runtime.h>
#include <cublas_v2.h>

// Simple CUDA / cuBLAS error helpers
static void ck(cudaError_t e, const char* m){
    if(e != cudaSuccess){
        std::fprintf(stderr, "CUDA %s: %s\n", m, cudaGetErrorString(e));
        std::exit(1);
    }
}
static void bk(cublasStatus_t s, const char* m){
    if(s != CUBLAS_STATUS_SUCCESS){
        std::fprintf(stderr, "cuBLAS %s: %d\n", m, (int)s);
        std::exit(1);
    }
}

// Map DNA char -> 0..3 (A,C,G,T), return -1 on invalid
int base_to_idx(char c){
    switch(c){
        case 'A': case 'a': return 0;
        case 'C': case 'c': return 1;
        case 'G': case 'g': return 2;
        case 'T': case 't': return 3;
        default: return -1;
    }
}

int main(){
    std::printf("\n====================================================================================\n");
    std::printf("WARPFRAC DNA BLOCKSIM — Exact Match Counts via INT8 GEMM\n");
    std::printf("====================================================================================\n");
    std::printf("We encode DNA sequences as one-hot INT8 vectors and use a single GEMM to compute\n");
    std::printf("exact Hamming match counts between many sequences in one shot.\n");
    std::printf("CPU int64 is our ground-truth; GPU INT8 GEMM must match it bit-for-bit.\n\n");

    // Problem setup: Q query sequences, R reference sequences, each length L
    const int Q = 32;   // number of query sequences (rows of A)
    const int R = 32;   // number of reference sequences (rows of B)
    const int L = 128;  // sequence length (bases)
    const int K = 4 * L; // one-hot length (4 channels per base)

    std::printf("Config:\n");
    std::printf("  Q (queries)   = %d\n", Q);
    std::printf("  R (references)= %d\n", R);
    std::printf("  L (length)    = %d bases\n", L);
    std::printf("  K (4 * L)     = %d one-hot channels\n\n", K);

    // Generate random DNA sequences for this demo.
    // Later we can plug in real sequences from files.
    std::mt19937 rng(123456);
    const char alphabet[4] = {'A','C','G','T'};
    std::uniform_int_distribution<int> dist_base(0,3);

    std::vector<std::string> queries(Q), refs(R);
    for(int i = 0; i < Q; ++i){
        queries[i].resize(L);
        for(int j = 0; j < L; ++j){
            queries[i][j] = alphabet[dist_base(rng)];
        }
    }
    for(int i = 0; i < R; ++i){
        refs[i].resize(L);
        for(int j = 0; j < L; ++j){
            refs[i][j] = alphabet[dist_base(rng)];
        }
    }

    std::printf("Example query[0]: ");
    for(int j = 0; j < L && j < 60; ++j) std::printf("%c", queries[0][j]);
    if(L > 60) std::printf("...");
    std::printf("\n");
    std::printf("Example ref[0]:   ");
    for(int j = 0; j < L && j < 60; ++j) std::printf("%c", refs[0][j]);
    if(L > 60) std::printf("...");
    std::printf("\n\n");

    // Build one-hot encodings:
    // A: Q x K (row-major)  => A[q, 4*pos+chan] = 1 if base=chan else 0
    // B: R x K (row-major)
    std::vector<int8_t> A(Q * K, 0), B(R * K, 0);

    auto encode_seq_row = [&](const std::string& s, int row, std::vector<int8_t>& M){
        for(int pos = 0; pos < L; ++pos){
            int idx = base_to_idx(s[pos]);
            if(idx < 0) continue; // skip anything weird
            int col = 4 * pos + idx;
            M[row * K + col] = (int8_t)1;
        }
    };

    for(int q = 0; q < Q; ++q){
        encode_seq_row(queries[q], q, A);
    }
    for(int r = 0; r < R; ++r){
        encode_seq_row(refs[r], r, B);
    }

    std::printf("One-hot encoding done. A is %d x %d, B is %d x %d (row-major).\n", Q, K, R, K);
    std::printf("We will compute C = A * B^T, so C has shape Q x R.\n");
    std::printf("Each C[q,r] equals the exact number of matching bases between query q and ref r.\n\n");

    //================================================================================
    // CPU ground truth: exact match counts (int64)
    //================================================================================
    std::vector<int32_t> C_cpu(Q * R, 0);

    std::printf("--- CPU ground truth (int64) ---\n");
    auto t0 = std::chrono::high_resolution_clock::now();
    for(int q = 0; q < Q; ++q){
        for(int r = 0; r < R; ++r){
            long long matches = 0;
            // Compare queries[q] and refs[r] base-by-base
            for(int pos = 0; pos < L; ++pos){
                if(queries[q][pos] == refs[r][pos]) matches++;
            }
            C_cpu[q * R + r] = (int32_t)matches;
        }
    }
    auto t1 = std::chrono::high_resolution_clock::now();
    double cpu_ms = std::chrono::duration<double, std::milli>(t1 - t0).count();
    std::printf("CPU match-count time: %.3f ms\n", cpu_ms);

    //================================================================================
    // GPU INT8 GEMM: C_gpu = A * B^T
    //================================================================================
    std::printf("\n--- GPU INT8 GEMM (cublasGemmEx) ---\n");

    int8_t*  dA = nullptr;
    int8_t*  dB = nullptr;
    int32_t* dC = nullptr;

    size_t bytesA = (size_t)Q * (size_t)K;
    size_t bytesB = (size_t)R * (size_t)K;
    size_t bytesC = (size_t)Q * (size_t)R * sizeof(int32_t);

    ck(cudaMalloc(&dA, bytesA), "malloc dA");
    ck(cudaMalloc(&dB, bytesB), "malloc dB");
    ck(cudaMalloc(&dC, bytesC), "malloc dC");

    ck(cudaMemcpy(dA, A.data(), bytesA, cudaMemcpyHostToDevice), "cpy A");
    ck(cudaMemcpy(dB, B.data(), bytesB, cudaMemcpyHostToDevice), "cpy B");
    ck(cudaMemset(dC, 0, bytesC), "zero C");

    cublasHandle_t handle;
    bk(cublasCreate(&handle), "cublasCreate");

    int32_t alpha = 1;
    int32_t beta  = 0;

    // We treat A as (M=Q, K) row-major with lda=K.
    // We treat B as (N=R, K) row-major but use B^T in GEMM:
    //   C = A * B^T  =>  (M x K)*(K x N) = M x N  (M=Q, N=R, K=K)
    // In cublasGemmEx terms:
    //   opA = N, opB = T
    //   lda = K, ldb = K, ldc = Q
    int M = Q;
    int N = R;
    int Kdim = K;

    cudaEvent_t e0, e1;
    ck(cudaEventCreate(&e0), "event e0");
    ck(cudaEventCreate(&e1), "event e1");
    ck(cudaEventRecord(e0), "record e0");

    bk(
        cublasGemmEx(
            handle,
            CUBLAS_OP_N, CUBLAS_OP_T,
            M, N, Kdim,
            &alpha,
            dA, CUDA_R_8I,  M,    // A: (M x Kdim) row-major, lda = M? No: we arranged A as row-major (row stride = Kdim).
                                  // BUT cuBLAS assumes column-major by default. Trick: we are treating rows as "columns".
                                  // To keep it simple here, we instead store A,B in column-major with leading dims set accordingly.
                                  // => We'll fix layout below instead of fighting row-major here.
            dB, CUDA_R_8I,  N,
            &beta,
            dC, CUDA_R_32I, M,
            CUDA_R_32I,
            CUBLAS_GEMM_DEFAULT_TENSOR_OP
        ),
        "cublasGemmEx initial"
    );

    // The above call is likely wrong if we treat A,B as row-major. Let's cleanly re-do the logic
    // by storing A,B in column-major form that matches cuBLAS' assumptions.
    // For clarity and correctness, we redo the upload + GEMM with explicit column-major layout.

    // Clean up previous attempt's events & handle error state (we won't check results from that call).
    ck(cudaEventRecord(e1), "record e1 dummy");
    ck(cudaEventSynchronize(e1), "sync e1 dummy");
    cudaEventDestroy(e0);
    cudaEventDestroy(e1);
    cublasDestroy(handle);

    //--------------------------------------------------------------------------------
    // Re-do with column-major layouts (simpler and exact).
    //--------------------------------------------------------------------------------
    std::printf("Re-initializing for clean column-major GEMM...\n");

    // Free device buffers and re-allocate
    cudaFree(dA);
    cudaFree(dB);
    cudaFree(dC);

    // For column-major:
    //   A_cm: Kdim x M  (so that A_cm^T is M x Kdim with column-major layout)
    //   B_cm: Kdim x N
    //   We want C = A_row * B_row^T (Q x Kdim)*(R x Kdim)^T.
    //   If we store A_cm = (Kdim x M) with A_cm(k,q) = A_row(q,k),
    //   and B_cm = (Kdim x N) with B_cm(k,r) = B_row(r,k),
    //   then:
    //       C = A_row * B_row^T  <=>  C^T = B_row * A_row^T
    //   We can compute C^T via cuBLAS and then transpose indices when reading, but
    //   for this small demo we'll just compute C directly with a careful layout:
    //
    //   We want C_cm: M x N in column-major with C_cm(q,r) = sum_k A_row(q,k)*B_row(r,k).
    //
    //   Define:
    //     A_cm:  Kdim x M, with   A_cm(k,q) = A_row(q,k)
    //     B_cm:  Kdim x N, with   B_cm(k,r) = B_row(r,k)
    //
    //   Then GEMM:
    //     C_cm^T = (B_cm^T) * (A_cm^T)  =>  (N x Kdim)*(Kdim x M) = N x M
    //   and C_cm^T(r,q) = sum_k B_cm^T(r,k)*A_cm^T(k,q) = sum_k B_row(r,k)*A_row(q,k),
    //   so C_cm^T(r,q) = C_row(q,r). So C_cm is just C_row^T.
    //
    //   For checking against CPU, we'll just compare C_cm^T to C_cpu.

    // Build column-major A_cm and B_cm
    std::vector<int8_t> A_cm(Kdim * M, 0);
    std::vector<int8_t> B_cm(Kdim * N, 0);

    // A_row(q,k) is stored at A[q*K + k]
    for(int q = 0; q < Q; ++q){
        for(int k = 0; k < Kdim; ++k){
            int8_t v = A[q * Kdim + k];
            A_cm[k + q * Kdim] = v;  // (k,q) with leading dim Kdim
        }
    }
    for(int r = 0; r < R; ++r){
        for(int k = 0; k < Kdim; ++k){
            int8_t v = B[r * Kdim + k];
            B_cm[k + r * Kdim] = v;  // (k,r)
        }
    }

    // Allocate device buffers for new layouts
    size_t bytesA_cm = (size_t)Kdim * (size_t)M;
    size_t bytesB_cm = (size_t)Kdim * (size_t)N;
    size_t bytesC_cm = (size_t)M    * (size_t)N * sizeof(int32_t);

    ck(cudaMalloc(&dA, bytesA_cm), "malloc dA_cm");
    ck(cudaMalloc(&dB, bytesB_cm), "malloc dB_cm");
    ck(cudaMalloc(&dC, bytesC_cm), "malloc dC_cm");

    ck(cudaMemcpy(dA, A_cm.data(), bytesA_cm, cudaMemcpyHostToDevice), "cpy A_cm");
    ck(cudaMemcpy(dB, B_cm.data(), bytesB_cm, cudaMemcpyHostToDevice), "cpy B_cm");
    ck(cudaMemset(dC, 0, bytesC_cm), "zero C_cm");

    bk(cublasCreate(&handle), "cublasCreate2");

    alpha = 1;
    beta  = 0;

    // Compute C_cm^T = B_cm^T * A_cm^T  => (N x Kdim)*(Kdim x M) = N x M
    // In cuBLAS terms:
    //   opA = T on B_cm (Kdim x N)
    //   opB = T on A_cm (Kdim x M)
    //   So:
    //     A = B_cm (Kdim x N), opA=T => (N x Kdim)
    //     B = A_cm (Kdim x M), opB=T => (M x Kdim)
    //     C = C_cm^T (N x M)
    //
    // We'll store C_cm^T in dC (ldc = N).
    //
    int lda = Kdim; // leading dim of B_cm
    int ldb = Kdim; // leading dim of A_cm
    int ldc = N;    // leading dim of C_cm^T (N x M)

    cudaEvent_t g0, g1;
    ck(cudaEventCreate(&g0), "event g0");
    ck(cudaEventCreate(&g1), "event g1");
    ck(cudaEventRecord(g0), "record g0");

    bk(
        cublasGemmEx(
            handle,
            CUBLAS_OP_T, CUBLAS_OP_T,
            N,        // m (rows of op(A))  => N
            M,        // n (cols of op(B))  => M
            Kdim,     // k
            &alpha,
            dB, CUDA_R_8I, lda,  // A = B_cm
            dA, CUDA_R_8I, ldb,  // B = A_cm
            &beta,
            dC, CUDA_R_32I, ldc, // C = C_cm^T (N x M)
            CUDA_R_32I,
            CUBLAS_GEMM_DEFAULT_TENSOR_OP
        ),
        "cublasGemmEx (DNA)"
    );

    ck(cudaEventRecord(g1), "record g1");
    ck(cudaEventSynchronize(g1), "sync g1");
    float gpu_ms = 0.0f;
    ck(cudaEventElapsedTime(&gpu_ms, g0, g1), "elapsed g0->g1");
    cudaEventDestroy(g0);
    cudaEventDestroy(g1);

    std::vector<int32_t> C_cm_T(N * M);
    ck(cudaMemcpy(C_cm_T.data(), dC, bytesC_cm, cudaMemcpyDeviceToHost), "cpy C_cm^T");

    cudaFree(dA);
    cudaFree(dB);
    cudaFree(dC);
    cublasDestroy(handle);

    std::printf("GPU GEMM time: %.3f ms\n", gpu_ms);
    std::printf("Note: C_cm^T has shape N x M (r x q). We'll compare it against CPU C[q,r].\n");

    //================================================================================
    // Correctness check: C_cm^T(r,q) vs C_cpu(q,r)
    //================================================================================
    long long max_diff = 0;
    int mismatches = 0;

    for(int q = 0; q < Q; ++q){
        for(int r = 0; r < R; ++r){
            // C_cm^T is N x M with leading dim N:
            // index (r,q) => C_cm_T[r + q * N]
            size_t idx_gpu = (size_t)r + (size_t)q * (size_t)N;
            size_t idx_cpu = (size_t)q * (size_t)R + (size_t)r;
            long long cpu_v = (long long)C_cpu[idx_cpu];
            long long gpu_v = (long long)C_cm_T[idx_gpu];
            long long diff = cpu_v - gpu_v;
            if(diff < 0) diff = -diff;
            if(diff > max_diff) max_diff = diff;
            if(diff != 0 && mismatches < 5){
                std::printf("  mismatch (q=%d,r=%d): cpu=%lld gpu=%lld diff=%lld\n",
                            q, r, cpu_v, gpu_v, diff);
                ++mismatches;
            }
        }
    }

    std::printf("\nCorrectness check:\n");
    std::printf("  Max |CPU - GPU| = %lld\n", max_diff);
    if(mismatches == 0){
        std::printf("  All entries match exactly.\n");
    }

    //================================================================================
    // Throughput summary: GMAC/s & speedup
    // Each C[q,r] = sum over Kdim one-hot channels => Kdim MACs per pair
    // Total MACs = Q * R * Kdim.
    //================================================================================
    double macs = (double)Q * (double)R * (double)Kdim;
    double cpu_sec = cpu_ms / 1000.0;
    double gpu_sec = gpu_ms / 1000.0;

    double cpu_gmac_s = (macs / cpu_sec) / 1e9;
    double gpu_gmac_s = (macs / gpu_sec) / 1e9;

    std::printf("\nThroughput summary:\n");
    std::printf("  MACs total = %.0f  (Q * R * K = %d * %d * %d)\n", macs, Q, R, Kdim);
    std::printf("  CPU: %.3f ms, %.3f G-MAC/s\n", cpu_ms, cpu_gmac_s);
    std::printf("  GPU: %.3f ms, %.3f G-MAC/s\n", gpu_ms, gpu_gmac_s);
    if(gpu_sec > 0.0 && cpu_sec > 0.0){
        std::printf("  Speedup (CPU / GPU) = %.2fx\n", cpu_sec / gpu_sec);
    }

    // Show a tiny 4x4 slice of the match-count matrix
    std::printf("\nExample C[q,r] match counts (top-left 4x4):\n");
    for(int q = 0; q < 4 && q < Q; ++q){
        std::printf("  q=%d: ", q);
        for(int r = 0; r < 4 && r < R; ++r){
            size_t idx = (size_t)q * (size_t)R + (size_t)r;
            std::printf("%3d ", C_cpu[idx]);
        }
        std::printf("\n");
    }

    std::printf("\nWARPFRAC DNA BLOCKSIM run finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"\n[DNA-1] Writing CUDA DNA BlockSim source -> {CUDA_SRC_PATH}")
with open(CUDA_SRC_PATH, "w") as f:
    f.write(cuda_src)

#---------------------------------------------------------------------------------------------------
# Compile for A100 (sm_80)
#---------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC_PATH,
    "-lcublas",
    "-o",
    EXE_PATH,
]

print("[DNA-1] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[DNA-1] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[DNA-1] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[DNA-1] Compile OK -> {EXE_PATH}")

#---------------------------------------------------------------------------------------------------
# Run the DNA BlockSim benchmark
#---------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING WARPFRAC DNA BLOCKSIM (Exact Match Counts via INT8 GEMM)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[DNA-1] WARNING: DNA BlockSim exited with code {run_res.returncode}")
else:
    print("[DNA-1] DNA BlockSim completed successfully.")

print("\n" + "="*118)
print("MODULE DNA-1 — DONE (WARPFRAC DNA BLOCKSIM)")
print("="*118)

#==================================================================================================
# MODULE DNA-FL-1 — FASTLANE DNA HAMMING ENGINE (cuBLASLt, INT8×INT8→INT32)
#
# What this does:
#   • Uses the SAME cuBLASLt style as fastlane_best_rr_allinone:
#       - A: ROW, B: ROW (math uses B^T), C: ROW
#       - cuBLASLt heuristics to pick algo
#       - REPLAYS loop for stable timing
#   • Encodes DNA sequences as INT8 one-hot ROW-MAJOR matrices A (Q x K), B (R x K).
#   • Runs a single INT8×INT8→INT32 matmul via cuBLASLt:
#       C[q,r] = exact count of matching bases between query q and ref r.
#   • CPU does the same thing with int64 loops (ground truth).
#   • Checks max |CPU - GPU| = 0 (exactness).
#   • Prints RAW GMAC/s and speedup vs CPU.
#
# This is now wired into a Fastlane-style engine, not the toy cublasGemmEx path.
#==================================================================================================
import subprocess, textwrap

print("\n" + "="*118)
print("MODULE DNA-FL-1 — FASTLANE DNA HAMMING ENGINE (cuBLASLt, INT8×INT8→INT32)")
print("="*118)

CUDA_SRC_PATH = "/content/warpfrac_dna_fastlane.cu"
EXE_PATH      = "/content/warpfrac_dna_fastlane"

cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <string>
#include <random>
#include <chrono>

#include <cuda_runtime.h>
#include <cublasLt.h>

//------------------ Error helpers -------------------------------------------------
static void ck(cudaError_t e, const char* m){
    if(e != cudaSuccess){
        std::fprintf(stderr, "CUDA %s: %s\n", m, cudaGetErrorString(e));
        std::exit(1);
    }
}
static bool ok(cublasStatus_t s, const char* m){
    if(s != CUBLAS_STATUS_SUCCESS){
        std::fprintf(stderr, "(skip) cuBLAS %s: %d\n", m, (int)s);
        return false;
    }
    return true;
}
static void bk(cublasStatus_t s, const char* m){
    if(s != CUBLAS_STATUS_SUCCESS){
        std::fprintf(stderr, "cuBLAS %s: %d\n", m, (int)s);
        std::exit(1);
    }
}

//------------------ DNA helpers ---------------------------------------------------
int base_to_idx(char c){
    switch(c){
        case 'A': case 'a': return 0;
        case 'C': case 'c': return 1;
        case 'G': case 'g': return 2;
        case 'T': case 't': return 3;
        default: return -1;
    }
}

//------------------ Probe function (Fastlane-style) -------------------------------
static double probe_ms(cublasLtHandle_t lt, const cublasLtMatmulAlgo_t& algo,
                       int M,int N,int K,
                       cublasLtMatrixLayout_t Ad,
                       cublasLtMatrixLayout_t Bd,
                       cublasLtMatrixLayout_t Cd,
                       int8_t* dA,int8_t* dB,int32_t* dC,
                       size_t ws_bytes, void* ws_buf, int iters, bool* ran_ok)
{
    *ran_ok = false;
    cublasOperation_t tA = CUBLAS_OP_N;
    cublasOperation_t tB = CUBLAS_OP_T; // B:ROW, math uses B^T

    cublasLtMatmulDesc_t desc;
    if(!ok(cublasLtMatmulDescCreate(&desc, CUBLAS_COMPUTE_32I, CUDA_R_32I),"desc")) return 1e30;
    ok(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSA,&tA,sizeof(tA)),"TA");
    ok(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSB,&tB,sizeof(tB)),"TB");

    int32_t alpha = 1, beta = 0;
    cudaStream_t s; ck(cudaStreamCreate(&s),"stream");

    // warmup
    if(!ok(cublasLtMatmul(lt, desc,
                          &alpha,
                          dA, Ad,
                          dB, Bd,
                          &beta,
                          dC, Cd,
                          dC, Cd,
                          &algo,
                          ws_buf, ws_bytes, s),
           "warm")){
        cudaStreamDestroy(s);
        cublasLtMatmulDescDestroy(desc);
        return 1e30;
    }
    ck(cudaStreamSynchronize(s),"warm sync");

    // timed
    cudaEvent_t t0,t1;
    ck(cudaEventCreate(&t0),"t0");
    ck(cudaEventCreate(&t1),"t1");
    ck(cudaEventRecord(t0, s),"rec t0");
    for(int i=0;i<iters;i++){
        if(!ok(cublasLtMatmul(lt, desc,
                              &alpha,
                              dA, Ad,
                              dB, Bd,
                              &beta,
                              dC, Cd,
                              dC, Cd,
                              &algo,
                              ws_buf, ws_bytes, s),
               "run")){
            ck(cudaEventDestroy(t0),"dt0");
            ck(cudaEventDestroy(t1),"dt1");
            cudaStreamDestroy(s);
            cublasLtMatmulDescDestroy(desc);
            return 1e30;
        }
    }
    ck(cudaEventRecord(t1, s),"rec t1");
    ck(cudaEventSynchronize(t1),"sync t1");
    float ms=0.f;
    ck(cudaEventElapsedTime(&ms,t0,t1),"elapsed");

    ck(cudaEventDestroy(t0),"dt0");
    ck(cudaEventDestroy(t1),"dt1");
    ck(cudaStreamDestroy(s),"ds");
    cublasLtMatmulDescDestroy(desc);

    *ran_ok = true;
    return double(ms)/double(iters);
}

//------------------ main ----------------------------------------------------------
int main(){
    std::printf("\n====================================================================================\n");
    std::printf("FASTLANE DNA HAMMING ENGINE — INT8xINT8->INT32 via cuBLASLt\n");
    std::printf("====================================================================================\n");
    std::printf("We use a Fastlane-style cuBLASLt matmul (A:ROW, B:ROW, math uses B^T)\n");
    std::printf("to compute exact Hamming match counts between many DNA sequences.\n");
    std::printf("CPU int64 is ground truth; GPU int8 GEMM must match it bit-for-bit.\n\n");

    //------------------ Problem sizes --------------------------------------------
    const int Q = 256;   // queries   -> M
    const int R = 256;   // references-> N
    const int L = 256;   // length (bases)
    const int K = 4 * L; // one-hot channels per base

    const int REPLAYS = 50;    // fewer replays than Fastlane macro to keep run time reasonable
    const int PROBE_RUNS = 8;  // few runs for algo probe
    const int MAX_H = 32;
    const int WS_CAP_MB = 0;

    std::printf("Config (DNA):\n");
    std::printf("  Q (queries)   = %d\n", Q);
    std::printf("  R (references)= %d\n", R);
    std::printf("  L (length)    = %d bases\n", L);
    std::printf("  K (4*L)       = %d one-hot channels\n", K);
    std::printf("  GEMM dims: M=Q=%d, N=R=%d, K=%d\n\n", Q, R, K);

    //------------------ Make random DNA sequences --------------------------------
    std::mt19937 rng(123456);
    const char alphabet[4] = {'A','C','G','T'};
    std::uniform_int_distribution<int> dist_base(0,3);

    std::vector<std::string> queries(Q), refs(R);
    for(int i=0;i<Q;i++){
        queries[i].resize(L);
        for(int j=0;j<L;j++){
            queries[i][j] = alphabet[dist_base(rng)];
        }
    }
    for(int i=0;i<R;i++){
        refs[i].resize(L);
        for(int j=0;j<L;j++){
            refs[i][j] = alphabet[dist_base(rng)];
        }
    }

    std::printf("Example query[0]: ");
    for(int j=0;j<L && j<60;j++) std::printf("%c", queries[0][j]);
    if(L>60) std::printf("...");
    std::printf("\n");
    std::printf("Example ref[0]:   ");
    for(int j=0;j<L && j<60;j++) std::printf("%c", refs[0][j]);
    if(L>60) std::printf("...");
    std::printf("\n\n");

    //------------------ CPU ground truth: Hamming match counts -------------------
    std::vector<int32_t> C_cpu((size_t)Q*(size_t)R, 0);
    std::printf("--- CPU ground truth (int64) ---\n");
    auto cpu_t0 = std::chrono::high_resolution_clock::now();
    for(int q=0;q<Q;q++){
        for(int r=0;r<R;r++){
            long long matches = 0;
            for(int pos=0;pos<L;pos++){
                if(queries[q][pos] == refs[r][pos]) matches++;
            }
            C_cpu[(size_t)q*(size_t)R + (size_t)r] = (int32_t)matches;
        }
    }
    auto cpu_t1 = std::chrono::high_resolution_clock::now();
    double cpu_ms = std::chrono::duration<double,std::milli>(cpu_t1 - cpu_t0).count();
    std::printf("CPU match-count time: %.3f ms\n\n", cpu_ms);

    //------------------ Build ROW-MAJOR one-hot A (Q x K) and B (R x K) ----------
    // Layout: row-major
    //   A_row[q,k] = 1 if query[q] has that base/channel, else 0.
    //   B_row[r,k] = 1 if ref[r] has that base/channel, else 0.
    std::printf("Encoding DNA into ROW-MAJOR one-hot matrices A (Q x K), B (R x K)...\n");
    std::vector<int8_t> A_row((size_t)Q*(size_t)K, 0);
    std::vector<int8_t> B_row((size_t)R*(size_t)K, 0);

    auto encode_row = [&](const std::string& seq, int row, std::vector<int8_t>& M){
        for(int pos=0;pos<L;pos++){
            int idx = base_to_idx(seq[pos]);
            if(idx < 0) continue;
            int k = 4*pos + idx;
            size_t offset = (size_t)row*(size_t)K + (size_t)k;
            M[offset] = (int8_t)1;
        }
    };

    for(int q=0;q<Q;q++) encode_row(queries[q], q, A_row);
    for(int r=0;r<R;r++) encode_row(refs[r],   r, B_row);

    std::printf("One-hot encoding done.\n");
    std::printf("  A_row: %d x %d (Q x K), row-major\n", Q, K);
    std::printf("  B_row: %d x %d (R x K), row-major\n", R, K);
    std::printf("We will compute C_row = A_row * B_row^T via cuBLASLt.\n");
    std::printf("Each C_row(q,r) = exact # of matching bases between query q and ref r.\n\n");

    //------------------ Device buffers ------------------------------------------
    int8_t*  dA = nullptr;
    int8_t*  dB = nullptr;
    int32_t* dC = nullptr;

    size_t bytesA = (size_t)Q*(size_t)K;
    size_t bytesB = (size_t)R*(size_t)K;
    size_t bytesC = (size_t)Q*(size_t)R*sizeof(int32_t);

    ck(cudaMalloc(&dA, bytesA), "malloc dA");
    ck(cudaMalloc(&dB, bytesB), "malloc dB");
    ck(cudaMalloc(&dC, bytesC), "malloc dC");

    ck(cudaMemcpy(dA, A_row.data(), bytesA, cudaMemcpyHostToDevice), "cpy A_row");
    ck(cudaMemcpy(dB, B_row.data(), bytesB, cudaMemcpyHostToDevice), "cpy B_row");
    ck(cudaMemset(dC, 0, bytesC), "zero C");

    //------------------ cuBLASLt setup ------------------------------------------
    cublasLtHandle_t lt;
    bk(cublasLtCreate(&lt),"ltCreate");

    // Matrix layouts: A:ROW, B:ROW, C:ROW (like your Fastlane kernel)
    int lda = K;   // row-major: ld = number of columns
    int ldb = K;
    int ldc = R;   // C: M x N row-major; row stride = N

    cublasLtMatrixLayout_t Ad,Bd,Cd;
    bk(cublasLtMatrixLayoutCreate(&Ad, CUDA_R_8I,  Q, K, lda),"Ad");
    bk(cublasLtMatrixLayoutCreate(&Bd, CUDA_R_8I,  R, K, ldb),"Bd");
    bk(cublasLtMatrixLayoutCreate(&Cd, CUDA_R_32I, Q, R, ldc),"Cd");

    cublasLtOrder_t row_order = CUBLASLT_ORDER_ROW;
    bk(cublasLtMatrixLayoutSetAttribute(Ad, CUBLASLT_MATRIX_LAYOUT_ORDER,&row_order,sizeof(row_order)),"Arow");
    bk(cublasLtMatrixLayoutSetAttribute(Bd, CUBLASLT_MATRIX_LAYOUT_ORDER,&row_order,sizeof(row_order)),"Brow");
    bk(cublasLtMatrixLayoutSetAttribute(Cd, CUBLASLT_MATRIX_LAYOUT_ORDER,&row_order,sizeof(row_order)),"Crow");

    // Heuristics
    cublasLtMatmulDesc_t hdesc;
    bk(cublasLtMatmulDescCreate(&hdesc, CUBLAS_COMPUTE_32I, CUDA_R_32I),"hdesc");
    cublasOperation_t tA = CUBLAS_OP_N;
    cublasOperation_t tB = CUBLAS_OP_T; // B:ROW, math uses B^T
    bk(cublasLtMatmulDescSetAttribute(hdesc, CUBLASLT_MATMUL_DESC_TRANSA,&tA,sizeof(tA)),"TA");
    bk(cublasLtMatmulDescSetAttribute(hdesc, CUBLASLT_MATMUL_DESC_TRANSB,&tB,sizeof(tB)),"TB");

    cublasLtMatmulPreference_t pref;
    bk(cublasLtMatmulPreferenceCreate(&pref),"pref");
    size_t ws_cap = (size_t)WS_CAP_MB * 1024ull * 1024ull;
    bk(cublasLtMatmulPreferenceSetAttribute(
           pref,
           CUBLASLT_MATMUL_PREF_MAX_WORKSPACE_BYTES,
           &ws_cap, sizeof(ws_cap)),
       "prefWS");

    std::vector<cublasLtMatmulHeuristicResult_t> H(MAX_H);
    int found = 0;
    bk(cublasLtMatmulAlgoGetHeuristic(
           lt, hdesc, Ad, Bd, Cd, Cd, pref,
           MAX_H, H.data(), &found),
       "heur");

    std::printf("cuBLASLt heuristics found %d candidates.\n", found);
    cublasLtMatmulPreferenceDestroy(pref);
    cublasLtMatmulDescDestroy(hdesc);

    if(found <= 0){
        std::fprintf(stderr,"No cuBLASLt algos found for this layout.\n");
        cublasLtMatrixLayoutDestroy(Ad);
        cublasLtMatrixLayoutDestroy(Bd);
        cublasLtMatrixLayoutDestroy(Cd);
        cublasLtDestroy(lt);
        cudaFree(dA); cudaFree(dB); cudaFree(dC);
        return 1;
    }

    //------------------ Probe algos to pick fastest ------------------------------
    double best_ms = 1e30;
    size_t best_ws = 0;
    cublasLtMatmulAlgo_t best_algo{};

    void* ws_buf = nullptr;
    if(ws_cap > 0) ck(cudaMalloc(&ws_buf, ws_cap),"ws");

    for(int i=0;i<found;i++){
        if(H[i].workspaceSize > ws_cap) continue;
        bool ran_ok = false;
        double ms = probe_ms(lt, H[i].algo,
                             Q,R,K,
                             Ad,Bd,Cd,
                             dA,dB,dC,
                             H[i].workspaceSize, ws_buf, PROBE_RUNS, &ran_ok);
        if(ran_ok && ms < best_ms){
            best_ms = ms;
            best_algo = H[i].algo;
            best_ws = H[i].workspaceSize;
        }
    }

    if(best_ms >= 1e29){
        std::fprintf(stderr,"No runnable algo under workspace cap. Exiting.\n");
        if(ws_buf) cudaFree(ws_buf);
        cublasLtMatrixLayoutDestroy(Ad);
        cublasLtMatrixLayoutDestroy(Bd);
        cublasLtMatrixLayoutDestroy(Cd);
        cublasLtDestroy(lt);
        cudaFree(dA); cudaFree(dB); cudaFree(dC);
        return 2;
    }

    std::printf("FASTLANE DNA autopick — picked_ws=%.2f MB, probe_best_ms=%.3f\n",
                best_ws/1048576.0, best_ms);

    //------------------ Final timed loop (REPLAYS) -------------------------------
    cublasLtMatmulDesc_t desc;
    bk(cublasLtMatmulDescCreate(&desc, CUBLAS_COMPUTE_32I, CUDA_R_32I),"desc");
    bk(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSA,&tA,sizeof(tA)),"TA2");
    bk(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSB,&tB,sizeof(tB)),"TB2");

    int32_t alpha = 1, beta = 0;

    cudaStream_t s;
    ck(cudaStreamCreate(&s),"stream2");

    // warm
    bk(cublasLtMatmul(lt, desc,
                      &alpha,
                      dA, Ad,
                      dB, Bd,
                      &beta,
                      dC, Cd,
                      dC, Cd,
                      &best_algo,
                      ws_buf, best_ws, s),
       "warm final");
    ck(cudaStreamSynchronize(s),"warm sync final");

    cudaEvent_t e0,e1;
    ck(cudaEventCreate(&e0),"e0");
    ck(cudaEventCreate(&e1),"e1");

    ck(cudaEventRecord(e0, s),"rec e0");
    for(int r=0;r<REPLAYS;r++){
        bk(cublasLtMatmul(lt, desc,
                          &alpha,
                          dA, Ad,
                          dB, Bd,
                          &beta,
                          dC, Cd,
                          dC, Cd,
                          &best_algo,
                          ws_buf, best_ws, s),
           "run final");
    }
    ck(cudaEventRecord(e1, s),"rec e1");
    ck(cudaEventSynchronize(e1),"sync e1");
    float gpu_ms = 0.f;
    ck(cudaEventElapsedTime(&gpu_ms, e0, e1),"elapsed final");

    ck(cudaEventDestroy(e0),"de0");
    ck(cudaEventDestroy(e1),"de1");
    ck(cudaStreamDestroy(s),"ds2");
    cublasLtMatmulDescDestroy(desc);

    // copy one result back (after last GEMM)
    std::vector<int32_t> C_gpu((size_t)Q*(size_t)R);
    ck(cudaMemcpy(C_gpu.data(), dC, bytesC, cudaMemcpyDeviceToHost), "cpy C_gpu");

    if(ws_buf) cudaFree(ws_buf);
    cublasLtMatrixLayoutDestroy(Ad);
    cublasLtMatrixLayoutDestroy(Bd);
    cublasLtMatrixLayoutDestroy(Cd);
    cublasLtDestroy(lt);
    cudaFree(dA); cudaFree(dB); cudaFree(dC);

    //------------------ Correctness check ----------------------------------------
    long long max_diff = 0;
    int mismatches = 0;
    for(int q=0;q<Q;q++){
        for(int r=0;r<R;r++){
            size_t idx = (size_t)q*(size_t)R + (size_t)r;
            long long cpu_v = (long long)C_cpu[idx];
            long long gpu_v = (long long)C_gpu[idx];
            long long diff = cpu_v - gpu_v;
            if(diff < 0) diff = -diff;
            if(diff > max_diff) max_diff = diff;
            if(diff != 0 && mismatches < 5){
                std::printf("  mismatch (q=%d,r=%d): cpu=%lld gpu=%lld diff=%lld\n",
                            q,r,cpu_v,gpu_v,diff);
                mismatches++;
            }
        }
    }

    std::printf("\nCorrectness check:\n");
    std::printf("  Max |CPU - GPU| = %lld\n", max_diff);
    if(mismatches == 0) std::printf("  All entries match exactly.\n");

    //------------------ Throughput summary ---------------------------------------
    double macs_per = (double)Q * (double)R * (double)K;
    double macs_tot = macs_per * (double)REPLAYS;
    double cpu_sec = cpu_ms / 1000.0;
    double gpu_sec = gpu_ms / 1000.0;

    double cpu_gmac_s = (macs_per / cpu_sec) / 1e9;
    double gpu_gmac_s = (macs_tot / gpu_sec) / 1e9;

    std::printf("\nThroughput summary:\n");
    std::printf("  MACs per GEMM  = %.0f  (Q * R * K = %d * %d * %d)\n", macs_per, Q, R, K);
    std::printf("  MACs total     = %.0f  (per GEMM * REPLAYS=%d)\n", macs_tot, REPLAYS);
    std::printf("  CPU: %.3f ms (one-shot), %.3f G-MAC/s (one GEMM equivalent)\n", cpu_ms, cpu_gmac_s);
    std::printf("  GPU: %.3f ms over %d GEMMs, %.3f G-MAC/s (amortized)\n",
                gpu_ms, REPLAYS, gpu_gmac_s);
    if(gpu_sec > 0.0 && cpu_sec > 0.0){
        std::printf("  Speedup (CPU / GPU, per-op) ~ %.2fx\n",
                    (cpu_gmac_s > 0.0 ? gpu_gmac_s / cpu_gmac_s : 0.0));
    }

    std::printf("\nExample C[q,r] match counts (top-left 4x4):\n");
    for(int q=0;q<4 && q<Q;q++){
        std::printf("  q=%d: ", q);
        for(int r=0;r<4 && r<R;r++){
            size_t idx = (size_t)q*(size_t)R + (size_t)r;
            std::printf("%3d ", C_cpu[idx]);
        }
        std::printf("\n");
    }

    std::printf("\nFASTLANE DNA HAMMING ENGINE run finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"\n[DNA-FL-1] Writing Fastlane DNA source -> {CUDA_SRC_PATH}")
with open(CUDA_SRC_PATH, "w") as f:
    f.write(cuda_src)

#---------------------------------------------------------------------------------------------------
# Compile for A100 (sm_80) with cuBLASLt
#---------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC_PATH,
    "-lcublasLt",
    "-lcublas",
    "-o",
    EXE_PATH,
]

print("[DNA-FL-1] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[DNA-FL-1] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[DNA-FL-1] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[DNA-FL-1] Compile OK -> {EXE_PATH}")

#---------------------------------------------------------------------------------------------------
# Run the Fastlane DNA benchmark
#---------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING FASTLANE DNA HAMMING ENGINE (cuBLASLt, INT8×INT8→INT32)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[DNA-FL-1] WARNING: Fastlane DNA exited with code {run_res.returncode}")
else:
    print("[DNA-FL-1] Fastlane DNA completed successfully.")

print("\n" + "="*118)
print("MODULE DNA-FL-1 — DONE (FASTLANE DNA HAMMING ENGINE)")
print("="*118)

#==================================================================================================
# MODULE DNA-FL-2 — REAL GENOME FASTLANE DNA MAPPER (E. coli K-12 MG1655)
#
# What this does (no bullshit version):
#   • Downloads a REAL genome: E. coli K-12 MG1655 complete chromosome (FASTA from NCBI).
#   • Parses the FASTA, gets the actual ~4.6Mbp sequence.
#   • Picks R reference windows of length L from the real genome.
#   • For each reference window, builds a query window = same window + random point mutations
#       → This mimics sequencing reads with SNPs.
#   • Encodes queries & refs as INT8 one-hot ROW-MAJOR matrices, same layout as DNA-FL-1.
#   • Runs a cuBLASLt INT8×INT8→INT32 GEMM (Fastlane-style, heuristics + REPLAYS).
#       C[q,r] = exact number of matching bases between query q and reference r.
#   • CPU does the same thing with int64 loops (ground truth).
#   • Checks max |CPU - GPU| = 0 (exact).
#   • Prints:
#       - Real genome name + length.
#       - Throughput (G-MAC/s) for CPU + GPU.
#       - Speedup.
#       - A small 4x4 block of the match matrix.
#
# All math is INTEGER-EXACT: INT8×INT8→INT32, no floating point, no “effective ops”.
#==================================================================================================
import subprocess, textwrap, os

print("\n" + "="*118)
print("MODULE DNA-FL-2 — REAL GENOME FASTLANE DNA MAPPER (E. coli K-12 MG1655)")
print("="*118)

FASTA_PATH = "/content/ecoli_U00096_3.fna"
CUDA_SRC_PATH = "/content/warpfrac_dna_fastlane_real.cu"
EXE_PATH      = "/content/warpfrac_dna_fastlane_real"

#--------------------------------------------------------------------------------------------------
# Step 1: Download real genome (FASTA) from NCBI
#--------------------------------------------------------------------------------------------------
print("\n[DNA-FL-2] Downloading E. coli K-12 MG1655 genome (FASTA) from NCBI...")

wget_cmd = [
    "bash", "-lc",
    textwrap.dedent(f"""
    set -euo pipefail
    if [ ! -f "{FASTA_PATH}" ]; then
      echo "  -> fetching NC_000913.3 / U00096.3 FASTA..."
      wget -q -O "{FASTA_PATH}" "https://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?db=nuccore&id=545778205&report=fasta&retmode=text"
      echo "  -> download complete."
    else
      echo "  -> FASTA already exists at {FASTA_PATH}, reusing."
    fi
    """)
]
res = subprocess.run(wget_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(res.stdout)
if res.returncode != 0:
    print("[DNA-FL-2] FATAL: FASTA download failed, aborting.")
    raise SystemExit(1)

#--------------------------------------------------------------------------------------------------
# Step 2: Write CUDA source that:
#   • Reads FASTA.
#   • Builds real DNA windows.
#   • Runs Fastlane-style INT8 GEMM with CPU witness.
#--------------------------------------------------------------------------------------------------
cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <string>
#include <random>
#include <chrono>
#include <fstream>
#include <algorithm>

#include <cuda_runtime.h>
#include <cublasLt.h>

//------------------ Error helpers -------------------------------------------------
static void ck(cudaError_t e, const char* m){
    if(e != cudaSuccess){
        std::fprintf(stderr, "CUDA %s: %s\n", m, cudaGetErrorString(e));
        std::exit(1);
    }
}
static bool ok(cublasStatus_t s, const char* m){
    if(s != CUBLAS_STATUS_SUCCESS){
        std::fprintf(stderr, "(skip) cuBLAS %s: %d\n", m, (int)s);
        return false;
    }
    return true;
}
static void bk(cublasStatus_t s, const char* m){
    if(s != CUBLAS_STATUS_SUCCESS){
        std::fprintf(stderr, "cuBLAS %s: %d\n", m, (int)s);
        std::exit(1);
    }
}

//------------------ DNA helpers ---------------------------------------------------
int base_to_idx(char c){
    switch(c){
        case 'A': case 'a': return 0;
        case 'C': case 'c': return 1;
        case 'G': case 'g': return 2;
        case 'T': case 't': return 3;
        default:            return -1; // we will normalize Ns later
    }
}

// Normalize any non-ACGT to 'A'
char norm_base(char c){
    switch(c){
        case 'A': case 'a': return 'A';
        case 'C': case 'c': return 'C';
        case 'G': case 'g': return 'G';
        case 'T': case 't': return 'T';
        default:            return 'A';
    }
}

// Load FASTA sequence from file: returns plain A/C/G/T string, sets header_out to first header line
std::string load_fasta_sequence(const char* path, std::string& header_out){
    std::ifstream in(path);
    if(!in){
        std::fprintf(stderr,"ERROR: Cannot open FASTA file: %s\n", path);
        std::exit(1);
    }
    std::string line;
    std::string seq;
    header_out.clear();
    while(std::getline(in, line)){
        if(line.empty()) continue;
        if(line[0] == '>'){
            if(header_out.empty()){
                header_out = line.substr(1); // drop '>'
            }
            continue;
        }
        for(char c : line){
            if(c == '\n' || c == '\r') continue;
            char nc = norm_base(c);
            seq.push_back(nc);
        }
    }
    return seq;
}

//------------------ Probe function (Fastlane-style) -------------------------------
static double probe_ms(cublasLtHandle_t lt, const cublasLtMatmulAlgo_t& algo,
                       int M,int N,int K,
                       cublasLtMatrixLayout_t Ad,
                       cublasLtMatrixLayout_t Bd,
                       cublasLtMatrixLayout_t Cd,
                       int8_t* dA,int8_t* dB,int32_t* dC,
                       size_t ws_bytes, void* ws_buf, int iters, bool* ran_ok)
{
    *ran_ok = false;
    cublasOperation_t tA = CUBLAS_OP_N;
    cublasOperation_t tB = CUBLAS_OP_T; // B:ROW, math uses B^T

    cublasLtMatmulDesc_t desc;
    if(!ok(cublasLtMatmulDescCreate(&desc, CUBLAS_COMPUTE_32I, CUDA_R_32I),"desc")) return 1e30;
    ok(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSA,&tA,sizeof(tA)),"TA");
    ok(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSB,&tB,sizeof(tB)),"TB");

    int32_t alpha = 1, beta = 0;
    cudaStream_t s; ck(cudaStreamCreate(&s),"stream");

    // warmup
    if(!ok(cublasLtMatmul(lt, desc,
                          &alpha,
                          dA, Ad,
                          dB, Bd,
                          &beta,
                          dC, Cd,
                          dC, Cd,
                          &algo,
                          ws_buf, ws_bytes, s),
           "warm")){
        cudaStreamDestroy(s);
        cublasLtMatmulDescDestroy(desc);
        return 1e30;
    }
    ck(cudaStreamSynchronize(s),"warm sync");

    // timed
    cudaEvent_t t0,t1;
    ck(cudaEventCreate(&t0),"t0");
    ck(cudaEventCreate(&t1),"t1");
    ck(cudaEventRecord(t0, s),"rec t0");
    for(int i=0;i<iters;i++){
        if(!ok(cublasLtMatmul(lt, desc,
                              &alpha,
                              dA, Ad,
                              dB, Bd,
                              &beta,
                              dC, Cd,
                              dC, Cd,
                              &algo,
                              ws_buf, ws_bytes, s),
               "run")){
            ck(cudaEventDestroy(t0),"dt0");
            ck(cudaEventDestroy(t1),"dt1");
            cudaStreamDestroy(s);
            cublasLtMatmulDescDestroy(desc);
            return 1e30;
        }
    }
    ck(cudaEventRecord(t1, s),"rec t1");
    ck(cudaEventSynchronize(t1),"sync t1");
    float ms=0.f;
    ck(cudaEventElapsedTime(&ms,t0,t1),"elapsed");

    ck(cudaEventDestroy(t0),"dt0");
    ck(cudaEventDestroy(t1),"dt1");
    ck(cudaStreamDestroy(s),"ds");
    cublasLtMatmulDescDestroy(desc);

    *ran_ok = true;
    return double(ms)/double(iters);
}

//------------------ main ----------------------------------------------------------
int main(){
    std::printf("\n====================================================================================\n");
    std::printf("REAL GENOME FASTLANE DNA MAPPER — E. coli K-12 MG1655\n");
    std::printf("====================================================================================\n");
    std::printf("We load a real genome (E. coli MG1655), cut real windows, simulate mutated reads,\n");
    std::printf("and compute exact Hamming match counts via INT8xINT8->INT32 GEMM (cuBLASLt).\n");
    std::printf("CPU int64 is ground truth; GPU int8 GEMM must match it bit-for-bit.\n\n");

    //------------------ Load FASTA ------------------------------------------------
    const char* fasta_path = "/content/ecoli_U00096_3.fna";
    std::string header;
    std::string genome = load_fasta_sequence(fasta_path, header);
    if(genome.size() < 1000){
        std::fprintf(stderr,"ERROR: Genome too small or FASTA parse failed (len=%zu).\n", genome.size());
        return 1;
    }

    std::printf("Loaded FASTA: %s\n", fasta_path);
    if(!header.empty())
        std::printf("FASTA header: %s\n", header.c_str());
    std::printf("Genome length: %zu bases\n\n", genome.size());

    //------------------ Problem sizes --------------------------------------------
    const int R = 256;   // reference windows
    const int Q = 256;   // queries (one per reference)
    const int L = 256;   // window length (bases)
    const int K = 4 * L; // one-hot channels

    const int REPLAYS    = 50;   // number of GEMMs for amortized timing
    const int PROBE_RUNS = 8;    // for algo probe
    const int MAX_H      = 32;
    const int WS_CAP_MB  = 0;

    std::printf("Config (DNA real genome):\n");
    std::printf("  Q (queries)    = %d\n", Q);
    std::printf("  R (references) = %d\n", R);
    std::printf("  L (length)     = %d bases\n", L);
    std::printf("  K (4*L)        = %d one-hot channels\n", K);
    std::printf("  GEMM dims: M=Q=%d, N=R=%d, K=%d\n\n", Q, R, K);

    if(genome.size() < (size_t)L + 10){
        std::fprintf(stderr,"ERROR: Genome shorter than L.\n");
        return 1;
    }

    //------------------ Build reference windows & mutated query windows ----------
    std::mt19937_64 rng(123456789);
    std::uniform_int_distribution<long long> dist_pos(0, (long long)genome.size() - L - 1);
    std::uniform_real_distribution<double> dist01(0.0,1.0);
    std::uniform_int_distribution<int> dist_base(0,3);
    const char alphabet[4] = {'A','C','G','T'};

    std::vector<std::string> refs(R), queries(Q);

    double mutation_rate = 0.05; // 5% of bases mutated in each query, on average

    for(int r=0;r<R;r++){
        long long pos = dist_pos(rng);
        refs[r] = genome.substr((size_t)pos, (size_t)L);

        // query = ref with random point mutations (~5%)
        std::string q = refs[r];
        for(int i=0;i<L;i++){
            if(dist01(rng) < mutation_rate){
                char orig = q[i];
                // pick a different base
                int orig_idx = base_to_idx(orig);
                int new_idx = orig_idx;
                // ensure different
                for(int tries=0;tries<4 && new_idx == orig_idx;tries++){
                    new_idx = dist_base(rng);
                }
                if(new_idx < 0 || new_idx > 3) new_idx = 0;
                q[i] = alphabet[new_idx];
            }
        }
        queries[r] = q;
    }

    std::printf("Example ref[0]:   ");
    for(int j=0;j<L && j<60;j++) std::printf("%c", refs[0][j]);
    if(L>60) std::printf("...");
    std::printf("\n");
    std::printf("Example query[0]: ");
    for(int j=0;j<L && j<60;j++) std::printf("%c", queries[0][j]);
    if(L>60) std::printf("...");
    std::printf("\n\n");

    //------------------ CPU ground truth: Hamming match counts -------------------
    std::vector<int32_t> C_cpu((size_t)Q*(size_t)R, 0);
    std::printf("--- CPU ground truth (int64) ---\n");
    auto cpu_t0 = std::chrono::high_resolution_clock::now();
    for(int q=0;q<Q;q++){
        for(int r=0;r<R;r++){
            long long matches = 0;
            const std::string& qs = queries[q];
            const std::string& rs = refs[r];
            for(int pos=0;pos<L;pos++){
                if(qs[pos] == rs[pos]) matches++;
            }
            C_cpu[(size_t)q*(size_t)R + (size_t)r] = (int32_t)matches;
        }
    }
    auto cpu_t1 = std::chrono::high_resolution_clock::now();
    double cpu_ms = std::chrono::duration<double,std::milli>(cpu_t1 - cpu_t0).count();
    std::printf("CPU match-count time: %.3f ms\n\n", cpu_ms);

    //------------------ Build ROW-MAJOR one-hot A (Q x K) and B (R x K) ----------
    std::printf("Encoding DNA into ROW-MAJOR one-hot matrices A (Q x K), B (R x K)...\n");
    std::vector<int8_t> A_row((size_t)Q*(size_t)K, 0);
    std::vector<int8_t> B_row((size_t)R*(size_t)K, 0);

    auto encode_row = [&](const std::string& seq, int row, std::vector<int8_t>& M){
        for(int pos=0;pos<L;pos++){
            int idx = base_to_idx(seq[pos]);
            if(idx < 0) continue;
            int k = 4*pos + idx;
            size_t offset = (size_t)row*(size_t)K + (size_t)k;
            M[offset] = (int8_t)1;
        }
    };

    for(int q=0;q<Q;q++) encode_row(queries[q], q, A_row);
    for(int r=0;r<R;r++) encode_row(refs[r],    r, B_row);

    std::printf("One-hot encoding done.\n");
    std::printf("  A_row: %d x %d (Q x K), row-major\n", Q, K);
    std::printf("  B_row: %d x %d (R x K), row-major\n", R, K);
    std::printf("We will compute C_row = A_row * B_row^T via cuBLASLt.\n");
    std::printf("Each C_row(q,r) = exact # of matching bases between query q and ref r.\n\n");

    //------------------ Device buffers ------------------------------------------
    int8_t*  dA = nullptr;
    int8_t*  dB = nullptr;
    int32_t* dC = nullptr;

    size_t bytesA = (size_t)Q*(size_t)K;
    size_t bytesB = (size_t)R*(size_t)K;
    size_t bytesC = (size_t)Q*(size_t)R*sizeof(int32_t);

    ck(cudaMalloc(&dA, bytesA), "malloc dA");
    ck(cudaMalloc(&dB, bytesB), "malloc dB");
    ck(cudaMalloc(&dC, bytesC), "malloc dC");

    ck(cudaMemcpy(dA, A_row.data(), bytesA, cudaMemcpyHostToDevice), "cpy A_row");
    ck(cudaMemcpy(dB, B_row.data(), bytesB, cudaMemcpyHostToDevice), "cpy B_row");
    ck(cudaMemset(dC, 0, bytesC), "zero C");

    //------------------ cuBLASLt setup ------------------------------------------
    cublasLtHandle_t lt;
    bk(cublasLtCreate(&lt),"ltCreate");

    int lda = K;   // row-major: ld = number of columns
    int ldb = K;
    int ldc = R;   // C: Q x R row-major; ld = N=R

    cublasLtMatrixLayout_t Ad,Bd,Cd;
    bk(cublasLtMatrixLayoutCreate(&Ad, CUDA_R_8I,  Q, K, lda),"Ad");
    bk(cublasLtMatrixLayoutCreate(&Bd, CUDA_R_8I,  R, K, ldb),"Bd");
    bk(cublasLtMatrixLayoutCreate(&Cd, CUDA_R_32I, Q, R, ldc),"Cd");

    cublasLtOrder_t row_order = CUBLASLT_ORDER_ROW;
    bk(cublasLtMatrixLayoutSetAttribute(Ad, CUBLASLT_MATRIX_LAYOUT_ORDER,&row_order,sizeof(row_order)),"Arow");
    bk(cublasLtMatrixLayoutSetAttribute(Bd, CUBLASLT_MATRIX_LAYOUT_ORDER,&row_order,sizeof(row_order)),"Brow");
    bk(cublasLtMatrixLayoutSetAttribute(Cd, CUBLASLT_MATRIX_LAYOUT_ORDER,&row_order,sizeof(row_order)),"Crow");

    // Heuristics
    cublasLtMatmulDesc_t hdesc;
    bk(cublasLtMatmulDescCreate(&hdesc, CUBLAS_COMPUTE_32I, CUDA_R_32I),"hdesc");
    cublasOperation_t tA = CUBLAS_OP_N;
    cublasOperation_t tB = CUBLAS_OP_T;
    bk(cublasLtMatmulDescSetAttribute(hdesc, CUBLASLT_MATMUL_DESC_TRANSA,&tA,sizeof(tA)),"TA");
    bk(cublasLtMatmulDescSetAttribute(hdesc, CUBLASLT_MATMUL_DESC_TRANSB,&tB,sizeof(tB)),"TB");

    cublasLtMatmulPreference_t pref;
    bk(cublasLtMatmulPreferenceCreate(&pref),"pref");
    size_t ws_cap = (size_t)WS_CAP_MB * 1024ull * 1024ull;
    bk(cublasLtMatmulPreferenceSetAttribute(
           pref,
           CUBLASLT_MATMUL_PREF_MAX_WORKSPACE_BYTES,
           &ws_cap, sizeof(ws_cap)),
       "prefWS");

    std::vector<cublasLtMatmulHeuristicResult_t> H(MAX_H);
    int found = 0;
    bk(cublasLtMatmulAlgoGetHeuristic(
           lt, hdesc, Ad, Bd, Cd, Cd, pref,
           MAX_H, H.data(), &found),
       "heur");

    std::printf("cuBLASLt heuristics found %d candidates.\n", found);
    cublasLtMatmulPreferenceDestroy(pref);
    cublasLtMatmulDescDestroy(hdesc);

    if(found <= 0){
        std::fprintf(stderr,"No cuBLASLt algos found for this layout.\n");
        cublasLtMatrixLayoutDestroy(Ad);
        cublasLtMatrixLayoutDestroy(Bd);
        cublasLtMatrixLayoutDestroy(Cd);
        cublasLtDestroy(lt);
        cudaFree(dA); cudaFree(dB); cudaFree(dC);
        return 1;
    }

    //------------------ Probe algos to pick fastest ------------------------------
    double best_ms = 1e30;
    size_t best_ws = 0;
    cublasLtMatmulAlgo_t best_algo{};

    void* ws_buf = nullptr;
    if(ws_cap > 0) ck(cudaMalloc(&ws_buf, ws_cap),"ws");

    for(int i=0;i<found;i++){
        if(H[i].workspaceSize > ws_cap) continue;
        bool ran_ok = false;
        double ms = probe_ms(lt, H[i].algo,
                             Q,R,K,
                             Ad,Bd,Cd,
                             dA,dB,dC,
                             H[i].workspaceSize, ws_buf, PROBE_RUNS, &ran_ok);
        if(ran_ok && ms < best_ms){
            best_ms   = ms;
            best_algo = H[i].algo;
            best_ws   = H[i].workspaceSize;
        }
    }

    if(best_ms >= 1e29){
        std::fprintf(stderr,"No runnable algo under workspace cap. Exiting.\n");
        if(ws_buf) cudaFree(ws_buf);
        cublasLtMatrixLayoutDestroy(Ad);
        cublasLtMatrixLayoutDestroy(Bd);
        cublasLtMatrixLayoutDestroy(Cd);
        cublasLtDestroy(lt);
        cudaFree(dA); cudaFree(dB); cudaFree(dC);
        return 2;
    }

    std::printf("FASTLANE DNA (real genome) autopick — picked_ws=%.2f MB, probe_best_ms=%.3f\n",
                best_ws/1048576.0, best_ms);

    //------------------ Final timed loop (REPLAYS) -------------------------------
    cublasLtMatmulDesc_t desc;
    bk(cublasLtMatmulDescCreate(&desc, CUBLAS_COMPUTE_32I, CUDA_R_32I),"desc");
    bk(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSA,&tA,sizeof(tA)),"TA2");
    bk(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSB,&tB,sizeof(tB)),"TB2");

    int32_t alpha = 1, beta = 0;

    cudaStream_t s;
    ck(cudaStreamCreate(&s),"stream2");

    // warm
    bk(cublasLtMatmul(lt, desc,
                      &alpha,
                      dA, Ad,
                      dB, Bd,
                      &beta,
                      dC, Cd,
                      dC, Cd,
                      &best_algo,
                      ws_buf, best_ws, s),
       "warm final");
    ck(cudaStreamSynchronize(s),"warm sync final");

    cudaEvent_t e0,e1;
    ck(cudaEventCreate(&e0),"e0");
    ck(cudaEventCreate(&e1),"e1");

    ck(cudaEventRecord(e0, s),"rec e0");
    for(int r=0;r<REPLAYS;r++){
        bk(cublasLtMatmul(lt, desc,
                          &alpha,
                          dA, Ad,
                          dB, Bd,
                          &beta,
                          dC, Cd,
                          dC, Cd,
                          &best_algo,
                          ws_buf, best_ws, s),
           "run final");
    }
    ck(cudaEventRecord(e1, s),"rec e1");
    ck(cudaEventSynchronize(e1),"sync e1");
    float gpu_ms = 0.f;
    ck(cudaEventElapsedTime(&gpu_ms, e0, e1),"elapsed final");

    ck(cudaEventDestroy(e0),"de0");
    ck(cudaEventDestroy(e1),"de1");
    ck(cudaStreamDestroy(s),"ds2");
    cublasLtMatmulDescDestroy(desc);

    // copy back one result (after last GEMM)
    std::vector<int32_t> C_gpu((size_t)Q*(size_t)R);
    ck(cudaMemcpy(C_gpu.data(), dC, bytesC, cudaMemcpyDeviceToHost), "cpy C_gpu");

    if(ws_buf) cudaFree(ws_buf);
    cublasLtMatrixLayoutDestroy(Ad);
    cublasLtMatrixLayoutDestroy(Bd);
    cublasLtMatrixLayoutDestroy(Cd);
    cublasLtDestroy(lt);
    cudaFree(dA); cudaFree(dB); cudaFree(dC);

    //------------------ Correctness check ----------------------------------------
    long long max_diff = 0;
    int mismatches = 0;
    for(int q=0;q<Q;q++){
        for(int r=0;r<R;r++){
            size_t idx = (size_t)q*(size_t)R + (size_t)r;
            long long cpu_v = (long long)C_cpu[idx];
            long long gpu_v = (long long)C_gpu[idx];
            long long diff  = cpu_v - gpu_v;
            if(diff < 0) diff = -diff;
            if(diff > max_diff) max_diff = diff;
            if(diff != 0 && mismatches < 5){
                std::printf("  mismatch (q=%d,r=%d): cpu=%lld gpu=%lld diff=%lld\n",
                            q,r,cpu_v,gpu_v,diff);
                mismatches++;
            }
        }
    }

    std::printf("\nCorrectness check:\n");
    std::printf("  Max |CPU - GPU| = %lld\n", max_diff);
    if(mismatches == 0) std::printf("  All entries match exactly.\n");

    //------------------ Throughput summary ---------------------------------------
    double macs_per = (double)Q * (double)R * (double)K;
    double macs_tot = macs_per * (double)REPLAYS;
    double cpu_sec  = cpu_ms / 1000.0;
    double gpu_sec  = gpu_ms / 1000.0;

    double cpu_gmac_s = (macs_per / cpu_sec) / 1e9;
    double gpu_gmac_s = (macs_tot / gpu_sec) / 1e9;

    std::printf("\nThroughput summary:\n");
    std::printf("  MACs per GEMM  = %.0f  (Q * R * K = %d * %d * %d)\n", macs_per, Q, R, K);
    std::printf("  MACs total     = %.0f  (per GEMM * REPLAYS=%d)\n", macs_tot, REPLAYS);
    std::printf("  CPU: %.3f ms (one-shot), %.3f G-MAC/s (one GEMM equivalent)\n", cpu_ms, cpu_gmac_s);
    std::printf("  GPU: %.3f ms over %d GEMMs, %.3f G-MAC/s (amortized)\n",
                gpu_ms, REPLAYS, gpu_gmac_s);
    if(gpu_sec > 0.0 && cpu_sec > 0.0){
        std::printf("  Speedup (CPU / GPU, per-op) ~ %.2fx\n",
                    (cpu_gmac_s > 0.0 ? gpu_gmac_s / cpu_gmac_s : 0.0));
    }

    std::printf("\nExample C[q,r] match counts (top-left 4x4):\n");
    for(int q=0;q<4 && q<Q;q++){
        std::printf("  q=%d: ", q);
        for(int r=0;r<4 && r<R;r++){
            size_t idx = (size_t)q*(size_t)R + (size_t)r;
            std::printf("%3d ", C_cpu[idx]);
        }
        std::printf("\n");
    }

    std::printf("\nREAL GENOME FASTLANE DNA MAPPER run finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"[DNA-FL-2] Writing real-genome Fastlane DNA source -> {CUDA_SRC_PATH}")
with open(CUDA_SRC_PATH, "w") as f:
    f.write(cuda_src)

#--------------------------------------------------------------------------------------------------
# Step 3: Compile with nvcc (sm_80, cuBLASLt)
#--------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC_PATH,
    "-lcublasLt",
    "-lcublas",
    "-o",
    EXE_PATH,
]

print("[DNA-FL-2] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[DNA-FL-2] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[DNA-FL-2] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[DNA-FL-2] Compile OK -> {EXE_PATH}")

#--------------------------------------------------------------------------------------------------
# Step 4: Run the real-genome Fastlane DNA mapper
#--------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING REAL GENOME FASTLANE DNA MAPPER (E. coli MG1655, INT8×INT8→INT32)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[DNA-FL-2] WARNING: real-genome Fastlane DNA mapper exited with code {run_res.returncode}")
else:
    print("[DNA-FL-2] Real-genome Fastlane DNA mapper completed successfully.")

print("\n" + "="*118)
print("MODULE DNA-FL-2 — DONE (REAL GENOME FASTLANE DNA MAPPER)")
print("="*118)

#==================================================================================================
# MODULE DNA-FL-3 — REAL GENOME HAMMING UNIQUENESS SURVEY (E. coli K-12 MG1655)
#
# What this does:
#   • Uses the SAME setup as DNA-FL-2 (real E. coli genome, L=256, Q=R=256).
#   • For each ref window, builds a query = ref + ~5% random point mutations (simulated noisy read).
#   • Computes exact Hamming match matrix C[q,r] using INT8×INT8→INT32 GEMM via cuBLASLt.
#   • CPU re-computes the same C[q,r] with plain char compares (int64 accumulator).
#   • Verifies max |CPU - GPU| = 0 (exactness).
#   • THEN actually “solves something”:
#       - For each query q:
#           diag      = C[q,q]       (true origin matches)
#           best_off  = max_{r!=q} C[q,r]  (best wrong hit)
#           gap       = diag - best_off
#           mismatches= L - diag
#       - Computes stats over all q:
#           * mean/min/max diag matches & mismatches
#           * mean/min/max best_off
#           * gap distribution and how many reads have gap ≥ 5, 10, 20, 30
#           * how often the true origin is the unique best hit
#   • Prints a small 4×4 corner of C[q,r] and some example rows.
#   • At the very end, computes SHA-256 of the C++ program’s stdout and prints it.
#
# Math is 100% integer-exact: INT8×INT8→INT32 accumulate, no floating point rounding.
#==================================================================================================
import subprocess, textwrap, hashlib

print("\n" + "="*118)
print("MODULE DNA-FL-3 — REAL GENOME HAMMING UNIQUENESS SURVEY (E. coli K-12 MG1655)")
print("="*118)

CUDA_SRC_PATH = "/content/warpfrac_dna_fastlane_real_stats.cu"
EXE_PATH      = "/content/warpfrac_dna_fastlane_real_stats"
FASTA_PATH    = "/content/ecoli_U00096_3.fna"

#--------------------------------------------------------------------------------------------------
# Ensure FASTA exists (reuse from DNA-FL-2 or download if missing)
#--------------------------------------------------------------------------------------------------
print("\n[DNA-FL-3] Checking for E. coli FASTA at", FASTA_PATH)
ensure_fasta_cmd = [
    "bash", "-lc",
    textwrap.dedent(f"""
    set -euo pipefail
    if [ ! -f "{FASTA_PATH}" ]; then
      echo "  -> FASTA not found, fetching NC_000913.3 / U00096.3..."
      wget -q -O "{FASTA_PATH}" "https://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?db=nuccore&id=545778205&report=fasta&retmode=text"
      echo "  -> download complete."
    else
      echo "  -> FASTA found, reusing existing file."
    fi
    """)
]
res = subprocess.run(ensure_fasta_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(res.stdout)
if res.returncode != 0:
    print("[DNA-FL-3] FATAL: FASTA preparation failed.")
    raise SystemExit(1)

#--------------------------------------------------------------------------------------------------
# Write CUDA source that:
#   • Loads FASTA
#   • Builds refs / queries as before
#   • Runs cuBLASLt INT8 GEMM
#   • Verifies exactness
#   • Computes uniqueness stats (diag vs best_off gap) and mismatch stats
#--------------------------------------------------------------------------------------------------
cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <string>
#include <random>
#include <chrono>
#include <fstream>
#include <algorithm>

#include <cuda_runtime.h>
#include <cublasLt.h>

//------------------ Error helpers -------------------------------------------------
static void ck(cudaError_t e, const char* m){
    if(e != cudaSuccess){
        std::fprintf(stderr, "CUDA %s: %s\n", m, cudaGetErrorString(e));
        std::exit(1);
    }
}
static bool ok(cublasStatus_t s, const char* m){
    if(s != CUBLAS_STATUS_SUCCESS){
        std::fprintf(stderr, "(skip) cuBLAS %s: %d\n", m, (int)s);
        return false;
    }
    return true;
}
static void bk(cublasStatus_t s, const char* m){
    if(s != CUBLAS_STATUS_SUCCESS){
        std::fprintf(stderr, "cuBLAS %s: %d\n", m, (int)s);
        std::exit(1);
    }
}

//------------------ DNA helpers ---------------------------------------------------
int base_to_idx(char c){
    switch(c){
        case 'A': case 'a': return 0;
        case 'C': case 'c': return 1;
        case 'G': case 'g': return 2;
        case 'T': case 't': return 3;
        default:            return -1;
    }
}

// Normalize any non-ACGT to 'A'
char norm_base(char c){
    switch(c){
        case 'A': case 'a': return 'A';
        case 'C': case 'c': return 'C';
        case 'G': case 'g': return 'G';
        case 'T': case 't': return 'T';
        default:            return 'A';
    }
}

// Load FASTA sequence from file: returns A/C/G/T string, sets header_out to first header line
std::string load_fasta_sequence(const char* path, std::string& header_out){
    std::ifstream in(path);
    if(!in){
        std::fprintf(stderr,"ERROR: Cannot open FASTA file: %s\n", path);
        std::exit(1);
    }
    std::string line;
    std::string seq;
    header_out.clear();
    while(std::getline(in, line)){
        if(line.empty()) continue;
        if(line[0] == '>'){
            if(header_out.empty()){
                header_out = line.substr(1); // drop '>'
            }
            continue;
        }
        for(char c : line){
            if(c == '\n' || c == '\r') continue;
            char nc = norm_base(c);
            seq.push_back(nc);
        }
    }
    return seq;
}

// Probe given algo, return avg ms/GEMM or big number on failure
static double probe_ms(cublasLtHandle_t lt, const cublasLtMatmulAlgo_t& algo,
                       int M,int N,int K,
                       cublasLtMatrixLayout_t Ad,
                       cublasLtMatrixLayout_t Bd,
                       cublasLtMatrixLayout_t Cd,
                       int8_t* dA,int8_t* dB,int32_t* dC,
                       size_t ws_bytes, void* ws_buf, int iters, bool* ran_ok)
{
    *ran_ok = false;
    cublasOperation_t tA = CUBLAS_OP_N;
    cublasOperation_t tB = CUBLAS_OP_T; // B:ROW, math uses B^T

    cublasLtMatmulDesc_t desc;
    if(!ok(cublasLtMatmulDescCreate(&desc, CUBLAS_COMPUTE_32I, CUDA_R_32I),"desc")) return 1e30;
    ok(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSA,&tA,sizeof(tA)),"TA");
    ok(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSB,&tB,sizeof(tB)),"TB");

    int32_t alpha = 1, beta = 0;
    cudaStream_t s; ck(cudaStreamCreate(&s),"stream");

    // warmup
    if(!ok(cublasLtMatmul(lt, desc,
                          &alpha,
                          dA, Ad,
                          dB, Bd,
                          &beta,
                          dC, Cd,
                          dC, Cd,
                          &algo,
                          ws_buf, ws_bytes, s),
           "warm")){
        cudaStreamDestroy(s);
        cublasLtMatmulDescDestroy(desc);
        return 1e30;
    }
    ck(cudaStreamSynchronize(s),"warm sync");

    // timed
    cudaEvent_t t0,t1;
    ck(cudaEventCreate(&t0),"t0");
    ck(cudaEventCreate(&t1),"t1");
    ck(cudaEventRecord(t0, s),"rec t0");
    for(int i=0;i<iters;i++){
        if(!ok(cublasLtMatmul(lt, desc,
                              &alpha,
                              dA, Ad,
                              dB, Bd,
                              &beta,
                              dC, Cd,
                              dC, Cd,
                              &algo,
                              ws_buf, ws_bytes, s),
               "run")){
            ck(cudaEventDestroy(t0),"dt0");
            ck(cudaEventDestroy(t1),"dt1");
            cudaStreamDestroy(s);
            cublasLtMatmulDescDestroy(desc);
            return 1e30;
        }
    }
    ck(cudaEventRecord(t1, s),"rec t1");
    ck(cudaEventSynchronize(t1),"sync t1");
    float ms=0.f;
    ck(cudaEventElapsedTime(&ms,t0,t1),"elapsed");

    ck(cudaEventDestroy(t0),"dt0");
    ck(cudaEventDestroy(t1),"dt1");
    ck(cudaStreamDestroy(s),"ds");
    cublasLtMatmulDescDestroy(desc);

    *ran_ok = true;
    return double(ms)/double(iters);
}

//------------------ main ----------------------------------------------------------
int main(){
    std::printf("\n====================================================================================\n");
    std::printf("REAL GENOME HAMMING UNIQUENESS SURVEY — E. coli K-12 MG1655\n");
    std::printf("====================================================================================\n");
    std::printf("We load the real E. coli MG1655 genome, cut windows, simulate noisy reads,\n");
    std::printf("and measure how uniquely reads map back using exact Hamming match counts.\n");
    std::printf("All math is INT8xINT8->INT32 (cublasLt), verified against CPU int64.\n\n");

    //------------------ Load FASTA ------------------------------------------------
    const char* fasta_path = "/content/ecoli_U00096_3.fna";
    std::string header;
    std::string genome = load_fasta_sequence(fasta_path, header);
    if(genome.size() < 1000){
        std::fprintf(stderr,"ERROR: Genome too small or FASTA parse failed (len=%zu).\n", genome.size());
        return 1;
    }

    std::printf("Loaded FASTA: %s\n", fasta_path);
    if(!header.empty())
        std::printf("FASTA header: %s\n", header.c_str());
    std::printf("Genome length: %zu bases\n\n", genome.size());

    //------------------ Problem sizes --------------------------------------------
    const int R = 256;   // reference windows
    const int Q = 256;   // queries (one per reference)
    const int L = 256;   // window length (bases)
    const int K = 4 * L; // one-hot channels

    const int REPLAYS    = 50;   // GEMMs for amortized timing
    const int PROBE_RUNS = 8;    // for algo probe
    const int MAX_H      = 32;
    const int WS_CAP_MB  = 0;

    std::printf("Config (uniqueness survey):\n");
    std::printf("  Q (queries / reads)      = %d\n", Q);
    std::printf("  R (reference windows)    = %d\n", R);
    std::printf("  L (read length)          = %d bases\n", L);
    std::printf("  Mutations per read       ≈ %.1f%% (random SNPs)\n", 5.0);
    std::printf("  K (4*L one-hot channels) = %d\n", K);
    std::printf("  GEMM dims: M=Q=%d, N=R=%d, K=%d\n\n", Q, R, K);

    if(genome.size() < (size_t)L + 10){
        std::fprintf(stderr,"ERROR: Genome shorter than L.\n");
        return 1;
    }

    //------------------ Build reference windows & noisy query windows ------------
    std::mt19937_64 rng(987654321);
    std::uniform_int_distribution<long long> dist_pos(0, (long long)genome.size() - L - 1);
    std::uniform_real_distribution<double>   dist01(0.0,1.0);
    std::uniform_int_distribution<int>       dist_base(0,3);
    const char alphabet[4] = {'A','C','G','T'};
    double mutation_rate = 0.05; // 5% SNPs

    std::vector<std::string> refs(R), queries(Q);

    for(int r=0;r<R;r++){
        long long pos = dist_pos(rng);
        refs[r] = genome.substr((size_t)pos, (size_t)L);

        // query = ref with random SNPs
        std::string q = refs[r];
        for(int i=0;i<L;i++){
            if(dist01(rng) < mutation_rate){
                char orig = q[i];
                int orig_idx = base_to_idx(orig);
                int new_idx = orig_idx;
                for(int tries=0;tries<4 && new_idx == orig_idx;tries++){
                    new_idx = dist_base(rng);
                }
                if(new_idx < 0 || new_idx > 3) new_idx = 0;
                q[i] = alphabet[new_idx];
            }
        }
        queries[r] = q;
    }

    std::printf("Example reference window [0] (length %d):\n  ", L);
    for(int j=0;j<L && j<80;j++) std::printf("%c", refs[0][j]);
    if(L>80) std::printf("...");
    std::printf("\n");
    std::printf("Example query/read [0] (with ~5%% SNPs):\n  ");
    for(int j=0;j<L && j<80;j++) std::printf("%c", queries[0][j]);
    if(L>80) std::printf("...");
    std::printf("\n\n");

    //------------------ CPU ground truth: full Hamming match matrix --------------
    std::vector<int32_t> C_cpu((size_t)Q*(size_t)R, 0);
    std::printf("--- CPU Hamming matrix (int64 accumulator) ---\n");
    auto cpu_t0 = std::chrono::high_resolution_clock::now();
    for(int q=0;q<Q;q++){
        for(int r=0;r<R;r++){
            long long matches = 0;
            const std::string& qs = queries[q];
            const std::string& rs = refs[r];
            for(int pos=0;pos<L;pos++){
                if(qs[pos] == rs[pos]) matches++;
            }
            C_cpu[(size_t)q*(size_t)R + (size_t)r] = (int32_t)matches;
        }
    }
    auto cpu_t1 = std::chrono::high_resolution_clock::now();
    double cpu_ms = std::chrono::duration<double,std::milli>(cpu_t1 - cpu_t0).count();
    std::printf("CPU match-matrix time: %.3f ms\n\n", cpu_ms);

    //------------------ Build ROW-MAJOR one-hot A (Q x K) and B (R x K) ----------
    std::printf("Encoding DNA into ROW-MAJOR one-hot A (Q x K) and B (R x K)...\n");
    std::vector<int8_t> A_row((size_t)Q*(size_t)K, 0);
    std::vector<int8_t> B_row((size_t)R*(size_t)K, 0);

    auto encode_row = [&](const std::string& seq, int row, std::vector<int8_t>& M){
        for(int pos=0;pos<L;pos++){
            int idx = base_to_idx(seq[pos]);
            if(idx < 0) continue;
            int k = 4*pos + idx;
            size_t offset = (size_t)row*(size_t)K + (size_t)k;
            M[offset] = (int8_t)1;
        }
    };

    for(int q=0;q<Q;q++) encode_row(queries[q], q, A_row);
    for(int r=0;r<R;r++) encode_row(refs[r],    r, B_row);

    std::printf("One-hot encoding done.\n");
    std::printf("  A_row: %d x %d (Q x K), row-major\n", Q, K);
    std::printf("  B_row: %d x %d (R x K), row-major\n\n", R, K);

    //------------------ Device buffers ------------------------------------------
    int8_t*  dA = nullptr;
    int8_t*  dB = nullptr;
    int32_t* dC = nullptr;

    size_t bytesA = (size_t)Q*(size_t)K;
    size_t bytesB = (size_t)R*(size_t)K;
    size_t bytesC = (size_t)Q*(size_t)R*sizeof(int32_t);

    ck(cudaMalloc(&dA, bytesA), "malloc dA");
    ck(cudaMalloc(&dB, bytesB), "malloc dB");
    ck(cudaMalloc(&dC, bytesC), "malloc dC");

    ck(cudaMemcpy(dA, A_row.data(), bytesA, cudaMemcpyHostToDevice), "cpy A_row");
    ck(cudaMemcpy(dB, B_row.data(), bytesB, cudaMemcpyHostToDevice), "cpy B_row");
    ck(cudaMemset(dC, 0, bytesC), "zero C");

    //------------------ cuBLASLt setup ------------------------------------------
    cublasLtHandle_t lt;
    bk(cublasLtCreate(&lt),"ltCreate");

    int lda = K;   // row-major: ld = #cols
    int ldb = K;
    int ldc = R;   // C: Q x R row-major; ld = N

    cublasLtMatrixLayout_t Ad,Bd,Cd;
    bk(cublasLtMatrixLayoutCreate(&Ad, CUDA_R_8I,  Q, K, lda),"Ad");
    bk(cublasLtMatrixLayoutCreate(&Bd, CUDA_R_8I,  R, K, ldb),"Bd");
    bk(cublasLtMatrixLayoutCreate(&Cd, CUDA_R_32I, Q, R, ldc),"Cd");

    cublasLtOrder_t row_order = CUBLASLT_ORDER_ROW;
    bk(cublasLtMatrixLayoutSetAttribute(Ad, CUBLASLT_MATRIX_LAYOUT_ORDER,&row_order,sizeof(row_order)),"Arow");
    bk(cublasLtMatrixLayoutSetAttribute(Bd, CUBLASLT_MATRIX_LAYOUT_ORDER,&row_order,sizeof(row_order)),"Brow");
    bk(cublasLtMatrixLayoutSetAttribute(Cd, CUBLASLT_MATRIX_LAYOUT_ORDER,&row_order,sizeof(row_order)),"Crow");

    // Heuristics
    cublasLtMatmulDesc_t hdesc;
    bk(cublasLtMatmulDescCreate(&hdesc, CUBLAS_COMPUTE_32I, CUDA_R_32I),"hdesc");
    cublasOperation_t tA = CUBLAS_OP_N;
    cublasOperation_t tB = CUBLAS_OP_T;
    bk(cublasLtMatmulDescSetAttribute(hdesc, CUBLASLT_MATMUL_DESC_TRANSA,&tA,sizeof(tA)),"TA");
    bk(cublasLtMatmulDescSetAttribute(hdesc, CUBLASLT_MATMUL_DESC_TRANSB,&tB,sizeof(tB)),"TB");

    cublasLtMatmulPreference_t pref;
    bk(cublasLtMatmulPreferenceCreate(&pref),"pref");
    size_t ws_cap = (size_t)WS_CAP_MB * 1024ull * 1024ull;
    bk(cublasLtMatmulPreferenceSetAttribute(
           pref,
           CUBLASLT_MATMUL_PREF_MAX_WORKSPACE_BYTES,
           &ws_cap, sizeof(ws_cap)),
       "prefWS");

    std::vector<cublasLtMatmulHeuristicResult_t> H(MAX_H);
    int found = 0;
    bk(cublasLtMatmulAlgoGetHeuristic(
           lt, hdesc, Ad, Bd, Cd, Cd, pref,
           MAX_H, H.data(), &found),
       "heur");

    std::printf("cuBLASLt heuristics found %d candidates.\n", found);
    cublasLtMatmulPreferenceDestroy(pref);
    cublasLtMatmulDescDestroy(hdesc);

    if(found <= 0){
        std::fprintf(stderr,"No cuBLASLt algos found for this layout.\n");
        cublasLtMatrixLayoutDestroy(Ad);
        cublasLtMatrixLayoutDestroy(Bd);
        cublasLtMatrixLayoutDestroy(Cd);
        cublasLtDestroy(lt);
        cudaFree(dA); cudaFree(dB); cudaFree(dC);
        return 1;
    }

    //------------------ Probe algos ----------------------------------------------
    double best_ms = 1e30;
    size_t best_ws = 0;
    cublasLtMatmulAlgo_t best_algo{};

    void* ws_buf = nullptr;
    if(ws_cap > 0) ck(cudaMalloc(&ws_buf, ws_cap),"ws");

    for(int i=0;i<found;i++){
        if(H[i].workspaceSize > ws_cap) continue;
        bool ran_ok = false;
        double ms = probe_ms(lt, H[i].algo,
                             Q,R,K,
                             Ad,Bd,Cd,
                             dA,dB,dC,
                             H[i].workspaceSize, ws_buf, PROBE_RUNS, &ran_ok);
        if(ran_ok && ms < best_ms){
            best_ms   = ms;
            best_algo = H[i].algo;
            best_ws   = H[i].workspaceSize;
        }
    }

    if(best_ms >= 1e29){
        std::fprintf(stderr,"No runnable algo under workspace cap. Exiting.\n");
        if(ws_buf) cudaFree(ws_buf);
        cublasLtMatrixLayoutDestroy(Ad);
        cublasLtMatrixLayoutDestroy(Bd);
        cublasLtMatrixLayoutDestroy(Cd);
        cublasLtDestroy(lt);
        cudaFree(dA); cudaFree(dB); cudaFree(dC);
        return 2;
    }

    std::printf("FASTLANE DNA (uniqueness) autopick — picked_ws=%.2f MB, probe_best_ms=%.3f\n\n",
                best_ws/1048576.0, best_ms);

    //------------------ Final timed loop -----------------------------------------
    cublasLtMatmulDesc_t desc;
    bk(cublasLtMatmulDescCreate(&desc, CUBLAS_COMPUTE_32I, CUDA_R_32I),"desc");
    bk(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSA,&tA,sizeof(tA)),"TA2");
    bk(cublasLtMatmulDescSetAttribute(desc, CUBLASLT_MATMUL_DESC_TRANSB,&tB,sizeof(tB)),"TB2");

    int32_t alpha = 1, beta = 0;
    cudaStream_t s;
    ck(cudaStreamCreate(&s),"stream2");

    // warm
    bk(cublasLtMatmul(lt, desc,
                      &alpha,
                      dA, Ad,
                      dB, Bd,
                      &beta,
                      dC, Cd,
                      dC, Cd,
                      &best_algo,
                      ws_buf, best_ws, s),
       "warm final");
    ck(cudaStreamSynchronize(s),"warm sync final");

    cudaEvent_t e0,e1;
    ck(cudaEventCreate(&e0),"e0");
    ck(cudaEventCreate(&e1),"e1");
    ck(cudaEventRecord(e0, s),"rec e0");
    for(int r=0;r<REPLAYS;r++){
        bk(cublasLtMatmul(lt, desc,
                          &alpha,
                          dA, Ad,
                          dB, Bd,
                          &beta,
                          dC, Cd,
                          dC, Cd,
                          &best_algo,
                          ws_buf, best_ws, s),
           "run final");
    }
    ck(cudaEventRecord(e1, s),"rec e1");
    ck(cudaEventSynchronize(e1),"sync e1");
    float gpu_ms = 0.f;
    ck(cudaEventElapsedTime(&gpu_ms, e0, e1),"elapsed final");

    ck(cudaEventDestroy(e0),"de0");
    ck(cudaEventDestroy(e1),"de1");
    ck(cudaStreamDestroy(s),"ds2");
    cublasLtMatmulDescDestroy(desc);

    // copy one result back (after last GEMM)
    std::vector<int32_t> C_gpu((size_t)Q*(size_t)R);
    ck(cudaMemcpy(C_gpu.data(), dC, bytesC, cudaMemcpyDeviceToHost), "cpy C_gpu");

    if(ws_buf) cudaFree(ws_buf);
    cublasLtMatrixLayoutDestroy(Ad);
    cublasLtMatrixLayoutDestroy(Bd);
    cublasLtMatrixLayoutDestroy(Cd);
    cublasLtDestroy(lt);
    cudaFree(dA); cudaFree(dB); cudaFree(dC);

    //------------------ Correctness check: CPU vs GPU ----------------------------
    long long max_diff = 0;
    int mismatches = 0;
    for(int q=0;q<Q;q++){
        for(int r=0;r<R;r++){
            size_t idx = (size_t)q*(size_t)R + (size_t)r;
            long long cpu_v = (long long)C_cpu[idx];
            long long gpu_v = (long long)C_gpu[idx];
            long long diff  = cpu_v - gpu_v;
            if(diff < 0) diff = -diff;
            if(diff > max_diff) max_diff = diff;
            if(diff != 0 && mismatches < 5){
                std::printf("  mismatch (q=%d,r=%d): cpu=%lld gpu=%lld diff=%lld\n",
                            q,r,cpu_v,gpu_v,diff);
                mismatches++;
            }
        }
    }

    std::printf("Correctness check (CPU vs GPU Hamming matrix):\n");
    std::printf("  Max |CPU - GPU| = %lld\n", max_diff);
    if(mismatches == 0) std::printf("  All entries match exactly.\n\n");

    //------------------ Throughput summary ---------------------------------------
    double macs_per = (double)Q * (double)R * (double)K;
    double macs_tot = macs_per * (double)REPLAYS;
    double cpu_sec  = cpu_ms / 1000.0;
    double gpu_sec  = gpu_ms / 1000.0;

    double cpu_gmac_s = (macs_per / cpu_sec) / 1e9;
    double gpu_gmac_s = (macs_tot / gpu_sec) / 1e9;

    std::printf("Throughput summary:\n");
    std::printf("  MACs per GEMM  = %.0f  (Q * R * K = %d * %d * %d)\n", macs_per, Q, R, K);
    std::printf("  MACs total     = %.0f  (per GEMM * REPLAYS=%d)\n", macs_tot, REPLAYS);
    std::printf("  CPU: %.3f ms (one-shot), %.3f G-MAC/s (one GEMM equivalent)\n", cpu_ms, cpu_gmac_s);
    std::printf("  GPU: %.3f ms over %d GEMMs, %.3f G-MAC/s (amortized)\n",
                gpu_ms, REPLAYS, gpu_gmac_s);
    if(gpu_sec > 0.0 && cpu_sec > 0.0){
        std::printf("  Speedup (CPU / GPU, per-op) ~ %.2fx\n\n",
                    (cpu_gmac_s > 0.0 ? gpu_gmac_s / cpu_gmac_s : 0.0));
    }

    //------------------ Hamming uniqueness stats ---------------------------------
    std::printf("--- Hamming uniqueness stats (using CPU matrix, but GPU=CPU exactly) ---\n");
    double sum_diag = 0.0, min_diag = 1e9, max_diag = -1e9;
    double sum_off  = 0.0, min_off  = 1e9, max_off  = -1e9;
    double sum_gap  = 0.0, min_gap  = 1e9, max_gap  = -1e9;
    double sum_mm   = 0.0, min_mm   = 1e9, max_mm   = -1e9;

    int count_gap_ge_5  = 0;
    int count_gap_ge_10 = 0;
    int count_gap_ge_20 = 0;
    int count_gap_ge_30 = 0;
    int count_true_top  = 0; // true origin strictly best

    for(int q=0;q<Q;q++){
        int diag = C_cpu[(size_t)q*(size_t)R + (size_t)q];
        int best_off = -1;
        for(int r=0;r<R;r++){
            if(r == q) continue;
            int v = C_cpu[(size_t)q*(size_t)R + (size_t)r];
            if(v > best_off) best_off = v;
        }
        int gap = diag - best_off;
        int mism = L - diag;

        sum_diag += diag;
        if(diag < min_diag) min_diag = diag;
        if(diag > max_diag) max_diag = diag;

        sum_off += best_off;
        if(best_off < min_off) min_off = best_off;
        if(best_off > max_off) max_off = best_off;

        sum_gap += gap;
        if(gap < min_gap) min_gap = gap;
        if(gap > max_gap) max_gap = gap;

        sum_mm += mism;
        if(mism < min_mm) min_mm = mism;
        if(mism > max_mm) max_mm = mism;

        if(diag > best_off) count_true_top++;
        if(gap >= 5)  count_gap_ge_5++;
        if(gap >= 10) count_gap_ge_10++;
        if(gap >= 20) count_gap_ge_20++;
        if(gap >= 30) count_gap_ge_30++;
    }

    double mean_diag = sum_diag / Q;
    double mean_off  = sum_off  / Q;
    double mean_gap  = sum_gap  / Q;
    double mean_mm   = sum_mm   / Q;

    std::printf("Reads (Q=%d), refs (R=%d), read length L=%d\n", Q, R, L);
    std::printf("Diagonal matches (true origin):\n");
    std::printf("  mean = %.2f, min = %.0f, max = %.0f\n", mean_diag, min_diag, max_diag);
    std::printf("  mean mismatches per read = %.2f (min=%.0f, max=%.0f)\n",
                mean_mm, min_mm, max_mm);
    std::printf("Best off-diagonal matches (best wrong hit):\n");
    std::printf("  mean = %.2f, min = %.0f, max = %.0f\n", mean_off, min_off, max_off);
    std::printf("Gap (diag - best_off):\n");
    std::printf("  mean = %.2f, min = %.0f, max = %.0f\n", mean_gap, min_gap, max_gap);

    std::printf("\nUniqueness summary:\n");
    std::printf("  True origin strictly best hit (diag > best_off): %d / %d (%.1f%%)\n",
                count_true_top, Q, 100.0 * (double)count_true_top / (double)Q);
    std::printf("  Gap >= 5  : %d / %d (%.1f%%)\n",
                count_gap_ge_5, Q, 100.0 * (double)count_gap_ge_5 / (double)Q);
    std::printf("  Gap >= 10 : %d / %d (%.1f%%)\n",
                count_gap_ge_10, Q, 100.0 * (double)count_gap_ge_10 / (double)Q);
    std::printf("  Gap >= 20 : %d / %d (%.1f%%)\n",
                count_gap_ge_20, Q, 100.0 * (double)count_gap_ge_20 / (double)Q);
    std::printf("  Gap >= 30 : %d / %d (%.1f%%)\n",
                count_gap_ge_30, Q, 100.0 * (double)count_gap_ge_30 / (double)Q);

    //------------------ Show small matrix corner + a couple example rows ---------
    std::printf("\nExample C[q,r] match counts (top-left 4x4 block, using CPU matrix):\n");
    for(int q=0;q<4 && q<Q;q++){
        std::printf("  q=%d: ", q);
        for(int r=0;r<4 && r<R;r++){
            size_t idx = (size_t)q*(size_t)R + (size_t)r;
            std::printf("%3d ", C_cpu[idx]);
        }
        std::printf("\n");
    }

    // Show a couple example rows with diag vs best_off vs gap
    std::printf("\nExample per-read stats (first 4 reads):\n");
    for(int q=0;q<4 && q<Q;q++){
        int diag = C_cpu[(size_t)q*(size_t)R + (size_t)q];
        int best_off = -1, best_r = -1;
        for(int r=0;r<R;r++){
            if(r==q) continue;
            int v = C_cpu[(size_t)q*(size_t)R + (size_t)r];
            if(v > best_off){
                best_off = v;
                best_r   = r;
            }
        }
        int gap  = diag - best_off;
        int mism = L - diag;
        std::printf("  q=%d: diag=%d (mism=%d), best_off=%d at r=%d, gap=%d\n",
                    q, diag, mism, best_off, best_r, gap);
    }

    std::printf("\nREAL GENOME HAMMING UNIQUENESS SURVEY finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"[DNA-FL-3] Writing real-genome uniqueness CUDA source -> {CUDA_SRC_PATH}")
with open(CUDA_SRC_PATH, "w") as f:
    f.write(cuda_src)

#--------------------------------------------------------------------------------------------------
# Compile with nvcc (sm_80, cuBLASLt)
#--------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC_PATH,
    "-lcublasLt",
    "-lcublas",
    "-o",
    EXE_PATH,
]

print("[DNA-FL-3] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[DNA-FL-3] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[DNA-FL-3] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[DNA-FL-3] Compile OK -> {EXE_PATH}")

#--------------------------------------------------------------------------------------------------
# Run the uniqueness survey and capture stdout for SHA-256
#--------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING REAL GENOME HAMMING UNIQUENESS SURVEY (E. coli, INT8×INT8→INT32)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[DNA-FL-3] WARNING: uniqueness survey exited with code {run_res.returncode}")
else:
    print("[DNA-FL-3] Uniqueness survey completed successfully.")

# Compute SHA-256 of the C++ program's stdout (for reproducibility)
stdout_bytes = run_res.stdout.encode("utf-8", errors="replace")
digest = hashlib.sha256(stdout_bytes).hexdigest()
print(f"\n[DNA-FL-3] SHA256(stdout) = {digest}")

print("\n" + "="*118)
print("MODULE DNA-FL-3 — DONE (REAL GENOME HAMMING UNIQUENESS SURVEY)")
print("="*118)

#======================================================================================================================
# MODULE DNA-L1 — BASE COUNT FRACTION LOCK SCAN (E. coli MG1655, L=256)
#
# What this does:
#   • Uses the real E. coli MG1655 genome FASTA you already have.
#   • Randomly samples many windows of length L=256 from across the genome.
#   • For each window, counts A,C,G,T exactly.
#   • Computes exact fractions:
#       - GC_frac  = (G + C) / 256  → reduced to num_gc/den_gc via gcd.
#       - AT_frac  = (A + T) / 256  → reduced to num_at/den_at via gcd.
#   • Builds statistics:
#       - Global base frequencies across all sampled windows.
#       - GC and AT fraction stats (mean/min/max).
#       - Top 10 most common reduced GC fractions and AT fractions.
#       - How often GC and AT fractions have *small denominators* (<= 2,4,8,16,32).
#   • All math is exact integer arithmetic (no floating point until final print).
#   • At the end, computes SHA-256 of this module's stdout and prints it.
#
# This is a first "Fraction Physics lock" probe in DNA: do certain exact rational
# base-count fractions show up more than you'd naively expect?
#======================================================================================================================
import subprocess, textwrap, hashlib

print("\n" + "="*118)
print("MODULE DNA-L1 — BASE COUNT FRACTION LOCK SCAN (E. coli MG1655, L=256)")
print("="*118)

CUDA_SRC_PATH = "/content/warpfrac_dna_fraction_lock_scan.cu"
EXE_PATH      = "/content/warpfrac_dna_fraction_lock_scan"
FASTA_PATH    = "/content/ecoli_U00096_3.fna"

#----------------------------------------------------------------------------------------------------------------------
# Ensure FASTA exists (reuse from earlier modules or download if missing)
#----------------------------------------------------------------------------------------------------------------------
print("\n[DNA-L1] Checking for E. coli FASTA at", FASTA_PATH)
ensure_fasta_cmd = [
    "bash", "-lc",
    textwrap.dedent(f"""
    set -euo pipefail
    if [ ! -f "{FASTA_PATH}" ]; then
      echo "  -> FASTA not found, fetching NC_000913.3 / U00096.3..."
      wget -q -O "{FASTA_PATH}" "https://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?db=nuccore&id=545778205&report=fasta&retmode=text"
      echo "  -> download complete."
    else
      echo "  -> FASTA found, reusing existing file."
    fi
    """)
]
res = subprocess.run(ensure_fasta_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(res.stdout)
if res.returncode != 0:
    print("[DNA-L1] FATAL: FASTA preparation failed.")
    raise SystemExit(1)

#----------------------------------------------------------------------------------------------------------------------
# Write C++/CUDA host program to:
#   • Load FASTA
#   • Sample many 256-bp windows
#   • Count A,C,G,T and build exact fraction stats
#----------------------------------------------------------------------------------------------------------------------
cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <string>
#include <random>
#include <chrono>
#include <fstream>
#include <algorithm>
#include <map>

// We don't actually use GPU here; we compile with nvcc but run on CPU.
// All math is exact integer arithmetic.

//------------------ DNA helpers ---------------------------------------------------
int base_to_idx(char c){
    switch(c){
        case 'A': case 'a': return 0;
        case 'C': case 'c': return 1;
        case 'G': case 'g': return 2;
        case 'T': case 't': return 3;
        default:            return -1;
    }
}

// Normalize any non-ACGT to 'A'
char norm_base(char c){
    switch(c){
        case 'A': case 'a': return 'A';
        case 'C': case 'c': return 'C';
        case 'G': case 'g': return 'G';
        case 'T': case 't': return 'T';
        default:            return 'A';
    }
}

// Load FASTA sequence from file: returns A/C/G/T string, sets header_out
std::string load_fasta_sequence(const char* path, std::string& header_out){
    std::ifstream in(path);
    if(!in){
        std::fprintf(stderr,"ERROR: Cannot open FASTA file: %s\n", path);
        std::exit(1);
    }
    std::string line;
    std::string seq;
    header_out.clear();
    while(std::getline(in, line)){
        if(line.empty()) continue;
        if(line[0] == '>'){
            if(header_out.empty()){
                header_out = line.substr(1); // drop '>'
            }
            continue;
        }
        for(char c : line){
            if(c == '\n' || c == '\r') continue;
            char nc = norm_base(c);
            seq.push_back(nc);
        }
    }
    return seq;
}

int igcd(int a, int b){
    if(a < 0) a = -a;
    if(b < 0) b = -b;
    if(a == 0) return b;
    if(b == 0) return a;
    while(b != 0){
        int r = a % b;
        a = b;
        b = r;
    }
    return (a < 0) ? -a : a;
}

//------------------ main ----------------------------------------------------------
int main(){
    std::printf("\n====================================================================================\n");
    std::printf("BASE COUNT FRACTION LOCK SCAN — E. coli K-12 MG1655, L=256\n");
    std::printf("====================================================================================\n");
    std::printf("We sample many 256-bp windows from the real E. coli MG1655 genome.\n");
    std::printf("For each window we count A,C,G,T exactly and compute exact fractions:\n");
    std::printf("  GC_frac = (G+C)/256, AT_frac = (A+T)/256 (reduced to lowest terms).\n");
    std::printf("We then look at how often \"clean\" rational values (small denominators)\n");
    std::printf("show up, and list the most common reduced fractions.\n\n");

    const char* fasta_path = "/content/ecoli_U00096_3.fna";
    std::string header;
    std::string genome = load_fasta_sequence(fasta_path, header);
    if(genome.size() < 1000){
        std::fprintf(stderr,"ERROR: Genome too small or FASTA parse failed (len=%zu).\n", genome.size());
        return 1;
    }

    std::printf("Loaded FASTA: %s\n", fasta_path);
    if(!header.empty())
        std::printf("FASTA header: %s\n", header.c_str());
    std::printf("Genome length: %zu bases\n\n", genome.size());

    //------------------ Config ---------------------------------------------------
    const int L = 256;                 // window length
    const int N_WINDOWS = 100000;      // how many random windows to sample

    if(genome.size() < (size_t)L + 10){
        std::fprintf(stderr,"ERROR: Genome shorter than L.\n");
        return 1;
    }

    std::printf("Config:\n");
    std::printf("  Window length L        = %d bases\n", L);
    std::printf("  Number of windows      = %d\n", N_WINDOWS);
    std::printf("  Total bases examined   ≈ %.1f million\n\n",
                (double)L * (double)N_WINDOWS / 1e6);

    //------------------ Random window sampling -----------------------------------
    std::mt19937_64 rng(123456789);
    std::uniform_int_distribution<long long> dist_pos(
        0, (long long)genome.size() - L - 1
    );

    // Global counts over all windows
    long long total_A = 0, total_C = 0, total_G = 0, total_T = 0;

    // Histograms of raw counts
    std::vector<long long> hist_gc(L+1, 0), hist_at(L+1, 0);

    // Map from reduced fraction (num,den) to count
    struct PairKey {
        int num;
        int den;
        bool operator<(const PairKey& o) const {
            if(den != o.den) return den < o.den;
            return num < o.num;
        }
    };
    std::map<PairKey, long long> gc_frac_counts;
    std::map<PairKey, long long> at_frac_counts;

    // Counters for small denominators
    long long gc_den_le_2  = 0, gc_den_le_4  = 0, gc_den_le_8  = 0;
    long long gc_den_le_16 = 0, gc_den_le_32 = 0;
    long long at_den_le_2  = 0, at_den_le_4  = 0, at_den_le_8  = 0;
    long long at_den_le_16 = 0, at_den_le_32 = 0;

    // For mean/min/max stats
    double sum_gc_frac = 0.0, min_gc_frac = 1e9, max_gc_frac = -1e9;
    double sum_at_frac = 0.0, min_at_frac = 1e9, max_at_frac = -1e9;

    auto t0 = std::chrono::high_resolution_clock::now();
    for(int w = 0; w < N_WINDOWS; ++w){
        long long pos = dist_pos(rng);
        long long nA = 0, nC = 0, nG = 0, nT = 0;
        for(int i=0;i<L;i++){
            char b = genome[(size_t)pos + (size_t)i];
            switch(b){
                case 'A': nA++; break;
                case 'C': nC++; break;
                case 'G': nG++; break;
                case 'T': nT++; break;
                default:
                    // Should not happen after norm, but just in case
                    nA++;
                    break;
            }
        }

        total_A += nA;
        total_C += nC;
        total_G += nG;
        total_T += nT;

        int gc = (int)(nG + nC);
        int at = (int)(nA + nT);
        if(gc < 0) gc = 0; if(gc > L) gc = L;
        if(at < 0) at = 0; if(at > L) at = L;

        hist_gc[gc]++;
        hist_at[at]++;

        // Reduced GC fraction
        int g_gc = igcd(gc, L);
        if(g_gc == 0) g_gc = 1;
        int num_gc = gc / g_gc;
        int den_gc = L  / g_gc;

        // Reduced AT fraction
        int g_at = igcd(at, L);
        if(g_at == 0) g_at = 1;
        int num_at = at / g_at;
        int den_at = L  / g_at;

        gc_frac_counts[{num_gc, den_gc}]++;
        at_frac_counts[{num_at, den_at}]++;

        double gc_frac = (double)gc / (double)L;
        double at_frac = (double)at / (double)L;

        sum_gc_frac += gc_frac;
        if(gc_frac < min_gc_frac) min_gc_frac = gc_frac;
        if(gc_frac > max_gc_frac) max_gc_frac = gc_frac;

        sum_at_frac += at_frac;
        if(at_frac < min_at_frac) min_at_frac = at_frac;
        if(at_frac > max_at_frac) max_at_frac = at_frac;

        // Small denominator counts (GC)
        if(den_gc <= 2)  gc_den_le_2++;
        if(den_gc <= 4)  gc_den_le_4++;
        if(den_gc <= 8)  gc_den_le_8++;
        if(den_gc <= 16) gc_den_le_16++;
        if(den_gc <= 32) gc_den_le_32++;
        // Small denominator counts (AT)
        if(den_at <= 2)  at_den_le_2++;
        if(den_at <= 4)  at_den_le_4++;
        if(den_at <= 8)  at_den_le_8++;
        if(den_at <= 16) at_den_le_16++;
        if(den_at <= 32) at_den_le_32++;
    }
    auto t1 = std::chrono::high_resolution_clock::now();
    double scan_ms = std::chrono::duration<double,std::milli>(t1 - t0).count();

    double mean_gc_frac = sum_gc_frac / (double)N_WINDOWS;
    double mean_at_frac = sum_at_frac / (double)N_WINDOWS;

    std::printf("--- Global base counts across all sampled windows ---\n");
    long long total_bases = (long long)L * (long long)N_WINDOWS;
    std::printf("  Total bases (L * N_WINDOWS) = %lld\n", total_bases);
    std::printf("  A: %lld  (%.3f%%)\n", total_A, 100.0 * (double)total_A / (double)total_bases);
    std::printf("  C: %lld  (%.3f%%)\n", total_C, 100.0 * (double)total_C / (double)total_bases);
    std::printf("  G: %lld  (%.3f%%)\n", total_G, 100.0 * (double)total_G / (double)total_bases);
    std::printf("  T: %lld  (%.3f%%)\n", total_T, 100.0 * (double)total_T / (double)total_bases);
    std::printf("\n");

    std::printf("GC fraction stats over windows (GC = G+C):\n");
    std::printf("  mean = %.4f, min = %.4f, max = %.4f\n", mean_gc_frac, min_gc_frac, max_gc_frac);
    std::printf("AT fraction stats over windows (AT = A+T):\n");
    std::printf("  mean = %.4f, min = %.4f, max = %.4f\n\n", mean_at_frac, min_at_frac, max_at_frac);

    std::printf("Small denominator frequencies (reduced fractions):\n");
    std::printf("  GC: den<=2  : %lld (%.2f%%)\n", gc_den_le_2,
                100.0 * (double)gc_den_le_2 / (double)N_WINDOWS);
    std::printf("      den<=4  : %lld (%.2f%%)\n", gc_den_le_4,
                100.0 * (double)gc_den_le_4 / (double)N_WINDOWS);
    std::printf("      den<=8  : %lld (%.2f%%)\n", gc_den_le_8,
                100.0 * (double)gc_den_le_8 / (double)N_WINDOWS);
    std::printf("      den<=16 : %lld (%.2f%%)\n", gc_den_le_16,
                100.0 * (double)gc_den_le_16 / (double)N_WINDOWS);
    std::printf("      den<=32 : %lld (%.2f%%)\n", gc_den_le_32,
                100.0 * (double)gc_den_le_32 / (double)N_WINDOWS);
    std::printf("  AT: den<=2  : %lld (%.2f%%)\n", at_den_le_2,
                100.0 * (double)at_den_le_2 / (double)N_WINDOWS);
    std::printf("      den<=4  : %lld (%.2f%%)\n", at_den_le_4,
                100.0 * (double)at_den_le_4 / (double)N_WINDOWS);
    std::printf("      den<=8  : %lld (%.2f%%)\n", at_den_le_8,
                100.0 * (double)at_den_le_8 / (double)N_WINDOWS);
    std::printf("      den<=16 : %lld (%.2f%%)\n", at_den_le_16,
                100.0 * (double)at_den_le_16 / (double)N_WINDOWS);
    std::printf("      den<=32 : %lld (%.2f%%)\n\n", at_den_le_32,
                100.0 * (double)at_den_le_32 / (double)N_WINDOWS);

    // Collect top-K fractions by frequency
    auto top_k = [&](const std::map<PairKey,long long>& mp, int Ktop){
        std::vector<std::pair<PairKey,long long>> v(mp.begin(), mp.end());
        std::sort(v.begin(), v.end(),
                  [](auto& a, auto& b){ return a.second > b.second; });
        if((int)v.size() > Ktop) v.resize(Ktop);
        return v;
    };

    auto top_gc = top_k(gc_frac_counts, 10);
    auto top_at = top_k(at_frac_counts, 10);

    std::printf("Top 10 most common reduced GC fractions (num/den):\n");
    for(size_t i=0;i<top_gc.size();i++){
        const auto& k = top_gc[i].first;
        long long cnt = top_gc[i].second;
        double frac = (double)k.num / (double)k.den;
        std::printf("  %2zu) %3d/%-3d ≈ %.4f  | count=%lld (%.2f%%)\n",
                    i+1, k.num, k.den, frac,
                    cnt, 100.0 * (double)cnt / (double)N_WINDOWS);
    }
    std::printf("\n");

    std::printf("Top 10 most common reduced AT fractions (num/den):\n");
    for(size_t i=0;i<top_at.size();i++){
        const auto& k = top_at[i].first;
        long long cnt = top_at[i].second;
        double frac = (double)k.num / (double)k.den;
        std::printf("  %2zu) %3d/%-3d ≈ %.4f  | count=%lld (%.2f%%)\n",
                    i+1, k.num, k.den, frac,
                    cnt, 100.0 * (double)cnt / (double)N_WINDOWS);
    }
    std::printf("\n");

    std::printf("Fraction-lock scan timing:\n");
    std::printf("  Windows scanned: %d\n", N_WINDOWS);
    std::printf("  Elapsed time   : %.3f ms\n", scan_ms);
    std::printf("  Windows / sec  : %.1f kWindows/s\n",
                (scan_ms > 0.0 ? 1e3 * (double)N_WINDOWS / scan_ms : 0.0));
    std::printf("\n");

    std::printf("BASE COUNT FRACTION LOCK SCAN finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"[DNA-L1] Writing fraction-lock CUDA source -> {CUDA_SRC_PATH}")
with open(CUDA_SRC_PATH, "w") as f:
    f.write(cuda_src)

#----------------------------------------------------------------------------------------------------------------------
# Compile with nvcc (host-only logic, but we still use nvcc for consistency)
#----------------------------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC_PATH,
    "-o",
    EXE_PATH,
]

print("[DNA-L1] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[DNA-L1] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[DNA-L1] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[DNA-L1] Compile OK -> {EXE_PATH}")

#----------------------------------------------------------------------------------------------------------------------
# Run the fraction-lock scan and capture stdout for SHA-256
#----------------------------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING BASE COUNT FRACTION LOCK SCAN (E. coli, L=256)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[DNA-L1] WARNING: fraction-lock scan exited with code {run_res.returncode}")
else:
    print("[DNA-L1] Fraction-lock scan completed successfully.")

stdout_bytes = run_res.stdout.encode("utf-8", errors="replace")
digest = hashlib.sha256(stdout_bytes).hexdigest()
print(f"\n[DNA-L1] SHA256(stdout) = {digest}")

print("\n" + "="*118)
print("MODULE DNA-L1 — DONE (BASE COUNT FRACTION LOCK SCAN)")
print("="*118)

#======================================================================================================================
# MODULE DNA-L2 — REAL vs SHUFFLED FRACTION LOCK COMPARATOR (E. coli MG1655, L=256)
#
# What this does:
#   • Loads the real E. coli MG1655 genome (same FASTA as before).
#   • Constructs a shuffled genome with EXACTLY the same A/C/G/T counts (full permutation).
#   • Samples the SAME random window positions for both genomes.
#   • For each 256-bp window in each genome:
#       - Counts A, C, G, T exactly.
#       - Computes GC_frac = (G+C)/256 and AT_frac = (A+T)/256, reduced to lowest terms.
#   • Builds stats for REAL and SHUFFLED separately:
#       - Global base frequencies.
#       - GC and AT fraction stats (mean/min/max).
#       - Small denominator frequencies (den <= 2,4,8,16,32).
#       - Top 10 most common reduced GC fractions and AT fractions.
#   • Prints REAL vs SHUFFLED side-by-side so we can see if the real genome
#     shows "fraction physics" locks beyond what we'd expect from a random permutation.
#   • All math is exact integer arithmetic.
#   • At the end, computes SHA-256 of stdout and prints it.
#======================================================================================================================
import subprocess, textwrap, hashlib

print("\n" + "="*118)
print("MODULE DNA-L2 — REAL vs SHUFFLED FRACTION LOCK COMPARATOR (E. coli MG1655, L=256)")
print("="*118)

CUDA_SRC_PATH = "/content/warpfrac_dna_fraction_lock_compare.cu"
EXE_PATH      = "/content/warpfrac_dna_fraction_lock_compare"
FASTA_PATH    = "/content/ecoli_U00096_3.fna"

#----------------------------------------------------------------------------------------------------------------------
# Ensure FASTA exists (reuse from earlier modules or download if missing)
#----------------------------------------------------------------------------------------------------------------------
print("\n[DNA-L2] Checking for E. coli FASTA at", FASTA_PATH)
ensure_fasta_cmd = [
    "bash", "-lc",
    textwrap.dedent(f"""
    set -euo pipefail
    if [ ! -f "{FASTA_PATH}" ]; then
      echo "  -> FASTA not found, fetching NC_000913.3 / U00096.3..."
      wget -q -O "{FASTA_PATH}" "https://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?db=nuccore&id=545778205&report=fasta&retmode=text"
      echo "  -> download complete."
    else
      echo "  -> FASTA found, reusing existing file."
    fi
    """)
]
res = subprocess.run(ensure_fasta_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(res.stdout)
if res.returncode != 0:
    print("[DNA-L2] FATAL: FASTA preparation failed.")
    raise SystemExit(1)

#----------------------------------------------------------------------------------------------------------------------
# Write C++/CUDA host program for real vs shuffled fraction comparison
#----------------------------------------------------------------------------------------------------------------------
cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <string>
#include <random>
#include <chrono>
#include <fstream>
#include <algorithm>
#include <map>

// We don't use the GPU here; we just compile with nvcc and run on CPU.
// All math is exact integer arithmetic (no float in the core logic).

//------------------ DNA helpers ---------------------------------------------------
char norm_base(char c){
    switch(c){
        case 'A': case 'a': return 'A';
        case 'C': case 'c': return 'C';
        case 'G': case 'g': return 'G';
        case 'T': case 't': return 'T';
        default:            return 'A';  // normalize non-ACGT to A
    }
}

// Load FASTA sequence from file: returns A/C/G/T string, sets header_out
std::string load_fasta_sequence(const char* path, std::string& header_out){
    std::ifstream in(path);
    if(!in){
        std::fprintf(stderr,"ERROR: Cannot open FASTA file: %s\n", path);
        std::exit(1);
    }
    std::string line;
    std::string seq;
    header_out.clear();
    while(std::getline(in, line)){
        if(line.empty()) continue;
        if(line[0] == '>'){
            if(header_out.empty()){
                header_out = line.substr(1); // drop '>'
            }
            continue;
        }
        for(char c : line){
            if(c == '\n' || c == '\r') continue;
            char nc = norm_base(c);
            seq.push_back(nc);
        }
    }
    return seq;
}

int igcd(int a, int b){
    if(a < 0) a = -a;
    if(b < 0) b = -b;
    if(a == 0) return b;
    if(b == 0) return a;
    while(b != 0){
        int r = a % b;
        a = b;
        b = r;
    }
    return (a < 0) ? -a : a;
}

//------------------ Stats struct --------------------------------------------------
struct PairKey {
    int num;
    int den;
    bool operator<(const PairKey& o) const {
        if(den != o.den) return den < o.den;
        return num < o.num;
    }
};

struct LockStats {
    // Global A/C/G/T
    long long total_A = 0, total_C = 0, total_G = 0, total_T = 0;
    // Histograms of GC/AT counts
    std::vector<long long> hist_gc;
    std::vector<long long> hist_at;
    // Fraction counts
    std::map<PairKey, long long> gc_frac_counts;
    std::map<PairKey, long long> at_frac_counts;
    // Small denominator counts
    long long gc_den_le_2  = 0, gc_den_le_4  = 0, gc_den_le_8  = 0;
    long long gc_den_le_16 = 0, gc_den_le_32 = 0;
    long long at_den_le_2  = 0, at_den_le_4  = 0, at_den_le_8  = 0;
    long long at_den_le_16 = 0, at_den_le_32 = 0;
    // Fraction stats
    double sum_gc_frac = 0.0, min_gc_frac = 1e9, max_gc_frac = -1e9;
    double sum_at_frac = 0.0, min_at_frac = 1e9, max_at_frac = -1e9;
};

// Scan a set of windows in a given sequence, fill stats
void scan_windows(const std::string& seq,
                  const std::vector<long long>& positions,
                  int L,
                  LockStats& st)
{
    int N_WINDOWS = (int)positions.size();
    st.hist_gc.assign(L+1, 0);
    st.hist_at.assign(L+1, 0);

    for(int idx = 0; idx < N_WINDOWS; ++idx){
        long long pos = positions[idx];
        long long nA = 0, nC = 0, nG = 0, nT = 0;
        for(int i = 0; i < L; ++i){
            char b = seq[(size_t)pos + (size_t)i];
            switch(b){
                case 'A': nA++; break;
                case 'C': nC++; break;
                case 'G': nG++; break;
                case 'T': nT++; break;
                default:
                    nA++; // should not happen after norm
                    break;
            }
        }

        st.total_A += nA;
        st.total_C += nC;
        st.total_G += nG;
        st.total_T += nT;

        int gc = (int)(nG + nC);
        int at = (int)(nA + nT);
        if(gc < 0) gc = 0; if(gc > L) gc = L;
        if(at < 0) at = 0; if(at > L) at = L;

        st.hist_gc[gc]++;
        st.hist_at[at]++;

        // Reduced GC fraction
        int g_gc = igcd(gc, L);
        if(g_gc == 0) g_gc = 1;
        int num_gc = gc / g_gc;
        int den_gc = L  / g_gc;

        // Reduced AT fraction
        int g_at = igcd(at, L);
        if(g_at == 0) g_at = 1;
        int num_at = at / g_at;
        int den_at = L  / g_at;

        st.gc_frac_counts[{num_gc, den_gc}]++;
        st.at_frac_counts[{num_at, den_at}]++;

        double gc_frac = (double)gc / (double)L;
        double at_frac = (double)at / (double)L;

        st.sum_gc_frac += gc_frac;
        st.sum_at_frac += at_frac;

        if(gc_frac < st.min_gc_frac) st.min_gc_frac = gc_frac;
        if(gc_frac > st.max_gc_frac) st.max_gc_frac = gc_frac;

        if(at_frac < st.min_at_frac) st.min_at_frac = at_frac;
        if(at_frac > st.max_at_frac) st.max_at_frac = at_frac;

        // Small denominator counters
        if(den_gc <= 2)  st.gc_den_le_2++;
        if(den_gc <= 4)  st.gc_den_le_4++;
        if(den_gc <= 8)  st.gc_den_le_8++;
        if(den_gc <= 16) st.gc_den_le_16++;
        if(den_gc <= 32) st.gc_den_le_32++;

        if(den_at <= 2)  st.at_den_le_2++;
        if(den_at <= 4)  st.at_den_le_4++;
        if(den_at <= 8)  st.at_den_le_8++;
        if(den_at <= 16) st.at_den_le_16++;
        if(den_at <= 32) st.at_den_le_32++;
    }
}

// Helper to pick top-K fractions
std::vector<std::pair<PairKey,long long>> top_k(const std::map<PairKey,long long>& mp, int Ktop){
    std::vector<std::pair<PairKey,long long>> v(mp.begin(), mp.end());
    std::sort(v.begin(), v.end(),
              [](auto& a, auto& b){ return a.second > b.second; });
    if((int)v.size() > Ktop) v.resize(Ktop);
    return v;
}

//------------------ main ----------------------------------------------------------
int main(){
    std::printf("\n====================================================================================\n");
    std::printf("REAL vs SHUFFLED FRACTION LOCK COMPARATOR — E. coli K-12 MG1655, L=256\n");
    std::printf("====================================================================================\n");
    std::printf("We compare the real E. coli MG1655 genome to a shuffled version with\n");
    std::printf("the same A/C/G/T counts. For each, we sample the SAME windows and\n");
    std::printf("compute exact GC and AT fractions in reduced form. Then we compare:\n");
    std::printf("  • Global base composition.\n");
    std::printf("  • GC/AT stats (mean/min/max across windows).\n");
    std::printf("  • Frequencies of small denominators in reduced fractions.\n");
    std::printf("  • Top 10 most common GC and AT fractions.\n\n");

    const char* fasta_path = "/content/ecoli_U00096_3.fna";
    std::string header;
    std::string genome = load_fasta_sequence(fasta_path, header);
    if(genome.size() < 1000){
        std::fprintf(stderr,"ERROR: Genome too small or FASTA parse failed (len=%zu).\n", genome.size());
        return 1;
    }

    std::printf("Loaded FASTA: %s\n", fasta_path);
    if(!header.empty())
        std::printf("FASTA header: %s\n", header.c_str());
    std::printf("Genome length: %zu bases\n\n", genome.size());

    //------------------ Config ---------------------------------------------------
    const int L = 256;                 // window length
    const int N_WINDOWS = 100000;      // number of sampled windows

    if(genome.size() < (size_t)L + 10){
        std::fprintf(stderr,"ERROR: Genome shorter than L.\n");
        return 1;
    }

    std::printf("Config:\n");
    std::printf("  Window length L        = %d bases\n", L);
    std::printf("  Number of windows      = %d\n", N_WINDOWS);
    std::printf("  Total bases examined   ≈ %.1f million (per genome)\n\n",
                (double)L * (double)N_WINDOWS / 1e6);

    //------------------ Build shuffled genome with same base multiset ------------
    std::printf("Building shuffled genome with identical A/C/G/T counts...\n");
    std::string shuffled = genome; // copy
    std::mt19937_64 rng_shuffle(987654321ull);
    for (size_t i = shuffled.size() - 1; i > 0; --i) {
        std::uniform_int_distribution<size_t> dist(0, i);
        size_t j = dist(rng_shuffle);
        std::swap(shuffled[i], shuffled[j]);
    }
    std::printf("Shuffled genome built.\n\n");

    //------------------ Sample window positions (shared by both genomes) ---------
    std::mt19937_64 rng_pos(123456789ull);
    std::uniform_int_distribution<long long> dist_pos(
        0, (long long)genome.size() - L - 1
    );
    std::vector<long long> positions(N_WINDOWS);
    for(int i=0;i<N_WINDOWS;i++){
        positions[i] = dist_pos(rng_pos);
    }

    //------------------ Scan REAL genome ----------------------------------------
    LockStats real_stats;
    auto t0_real = std::chrono::high_resolution_clock::now();
    scan_windows(genome, positions, L, real_stats);
    auto t1_real = std::chrono::high_resolution_clock::now();
    double real_ms = std::chrono::duration<double,std::milli>(t1_real - t0_real).count();

    //------------------ Scan SHUFFLED genome ------------------------------------
    LockStats shuf_stats;
    auto t0_shuf = std::chrono::high_resolution_clock::now();
    scan_windows(shuffled, positions, L, shuf_stats);
    auto t1_shuf = std::chrono::high_resolution_clock::now();
    double shuf_ms = std::chrono::duration<double,std::milli>(t1_shuf - t0_shuf).count();

    long long total_bases = (long long)L * (long long)N_WINDOWS;

    auto print_base_comp = [&](const char* label, const LockStats& st){
        std::printf("%s base counts:\n", label);
        std::printf("  Total bases = %lld\n", total_bases);
        std::printf("  A: %lld  (%.3f%%)\n", st.total_A, 100.0 * (double)st.total_A / (double)total_bases);
        std::printf("  C: %lld  (%.3f%%)\n", st.total_C, 100.0 * (double)st.total_C / (double)total_bases);
        std::printf("  G: %lld  (%.3f%%)\n", st.total_G, 100.0 * (double)st.total_G / (double)total_bases);
        std::printf("  T: %lld  (%.3f%%)\n", st.total_T, 100.0 * (double)st.total_T / (double)total_bases);
    };

    auto print_gc_at_stats = [&](const char* label, const LockStats& st){
        double mean_gc = st.sum_gc_frac / (double)N_WINDOWS;
        double mean_at = st.sum_at_frac / (double)N_WINDOWS;
        std::printf("%s GC/AT fraction stats over windows:\n", label);
        std::printf("  GC: mean = %.4f, min = %.4f, max = %.4f\n",
                    mean_gc, st.min_gc_frac, st.max_gc_frac);
        std::printf("  AT: mean = %.4f, min = %.4f, max = %.4f\n\n",
                    mean_at, st.min_at_frac, st.max_at_frac);
    };

    auto print_small_den = [&](const char* label, const LockStats& st){
        std::printf("%s small denominator frequencies (reduced fractions):\n", label);
        auto pct = [&](long long x){ return 100.0 * (double)x / (double)N_WINDOWS; };
        std::printf("  GC: den<=2  : %lld (%.2f%%)\n", st.gc_den_le_2,  pct(st.gc_den_le_2));
        std::printf("      den<=4  : %lld (%.2f%%)\n", st.gc_den_le_4,  pct(st.gc_den_le_4));
        std::printf("      den<=8  : %lld (%.2f%%)\n", st.gc_den_le_8,  pct(st.gc_den_le_8));
        std::printf("      den<=16 : %lld (%.2f%%)\n", st.gc_den_le_16, pct(st.gc_den_le_16));
        std::printf("      den<=32 : %lld (%.2f%%)\n", st.gc_den_le_32, pct(st.gc_den_le_32));
        std::printf("  AT: den<=2  : %lld (%.2f%%)\n", st.at_den_le_2,  pct(st.at_den_le_2));
        std::printf("      den<=4  : %lld (%.2f%%)\n", st.at_den_le_4,  pct(st.at_den_le_4));
        std::printf("      den<=8  : %lld (%.2f%%)\n", st.at_den_le_8,  pct(st.at_den_le_8));
        std::printf("      den<=16 : %lld (%.2f%%)\n", st.at_den_le_16, pct(st.at_den_le_16));
        std::printf("      den<=32 : %lld (%.2f%%)\n\n", st.at_den_le_32, pct(st.at_den_le_32));
    };

    // Print results
    std::printf("--- Global base composition (REAL vs SHUFFLED) ---\n");
    print_base_comp("REAL     ", real_stats);
    std::printf("\n");
    print_base_comp("SHUFFLED ", shuf_stats);
    std::printf("\n");

    std::printf("--- GC/AT fraction stats (REAL vs SHUFFLED) ---\n");
    print_gc_at_stats("REAL     ", real_stats);
    print_gc_at_stats("SHUFFLED ", shuf_stats);

    std::printf("--- Small denominator frequencies (REAL vs SHUFFLED) ---\n");
    print_small_den("REAL     ", real_stats);
    print_small_den("SHUFFLED ", shuf_stats);

    // Top-K fractions
    auto real_top_gc = top_k(real_stats.gc_frac_counts, 10);
    auto real_top_at = top_k(real_stats.at_frac_counts, 10);
    auto shuf_top_gc = top_k(shuf_stats.gc_frac_counts, 10);
    auto shuf_top_at = top_k(shuf_stats.at_frac_counts, 10);

    auto print_top = [&](const char* label,
                         const std::vector<std::pair<PairKey,long long>>& v){
        std::printf("%s\n", label);
        for(size_t i=0;i<v.size();i++){
            const auto& k = v[i].first;
            long long cnt = v[i].second;
            double frac = (double)k.num / (double)k.den;
            std::printf("  %2zu) %3d/%-3d ≈ %.4f  | count=%lld (%.2f%%)\n",
                        i+1, k.num, k.den, frac,
                        cnt, 100.0 * (double)cnt / (double)N_WINDOWS);
        }
        std::printf("\n");
    };

    std::printf("--- Top 10 reduced GC fractions (REAL) ---\n");
    print_top("REAL GC fractions:", real_top_gc);
    std::printf("--- Top 10 reduced GC fractions (SHUFFLED) ---\n");
    print_top("SHUFFLED GC fractions:", shuf_top_gc);

    std::printf("--- Top 10 reduced AT fractions (REAL) ---\n");
    print_top("REAL AT fractions:", real_top_at);
    std::printf("--- Top 10 reduced AT fractions (SHUFFLED) ---\n");
    print_top("SHUFFLED AT fractions:", shuf_top_at);

    std::printf("Timing:\n");
    std::printf("  REAL scan   : %.3f ms\n", real_ms);
    std::printf("  SHUFFLED scan: %.3f ms\n", shuf_ms);
    std::printf("  Windows     : %d\n", N_WINDOWS);
    std::printf("\n");

    std::printf("REAL vs SHUFFLED FRACTION LOCK COMPARATOR finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"[DNA-L2] Writing fraction-lock compare CUDA source -> {CUDA_SRC_PATH}")
with open(CUDA_SRC_PATH, "w") as f:
    f.write(cuda_src)

#----------------------------------------------------------------------------------------------------------------------
# Compile with nvcc
#----------------------------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC_PATH,
    "-o",
    EXE_PATH,
]

print("[DNA-L2] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[DNA-L2] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[DNA-L2] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[DNA-L2] Compile OK -> {EXE_PATH}")

#----------------------------------------------------------------------------------------------------------------------
# Run the comparator and capture stdout for SHA-256
#----------------------------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING REAL vs SHUFFLED FRACTION LOCK COMPARATOR (E. coli, L=256)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[DNA-L2] WARNING: fraction-lock comparator exited with code {run_res.returncode}")
else:
    print("[DNA-L2] Fraction-lock comparator completed successfully.")

stdout_bytes = run_res.stdout.encode("utf-8", errors="replace")
digest = hashlib.sha256(stdout_bytes).hexdigest()
print(f"\n[DNA-L2] SHA256(stdout) = {digest}")

print("\n" + "="*118)
print("MODULE DNA-L2 — DONE (REAL vs SHUFFLED FRACTION LOCK COMPARATOR)")
print("="*118)

#======================================================================================================================
# MODULE DNA-L3 — REAL vs SHUFFLED CpG FRACTION LOCK COMPARATOR (E. coli MG1655, L=256)
#
# What this does:
#   • Loads the real E. coli MG1655 genome FASTA (same file as earlier modules).
#   • Builds a shuffled genome with the SAME A/C/G/T counts (full permutation).
#   • Samples the SAME random window positions in both genomes.
#   • For each 256-bp window:
#       - Counts how many "CG" dinucleotides appear (C followed by G).
#       - Computes CpG_frac = (#CG) / (L-1) and reduces it to lowest terms (exact integer gcd).
#   • Builds stats for REAL and SHUFFLED:
#       - Global CpG counts across sampled windows.
#       - CpG fraction stats (mean / min / max across windows).
#       - Small denominator frequencies (den <= 2,4,8,16,32).
#       - Top 10 most common reduced CpG fractions.
#   • Prints REAL vs SHUFFLED side-by-side so we can see if CpG structure is more "locked in"
#     than we’d expect from a random permutation with the same base composition.
#   • All math is exact integer arithmetic.
#   • At the end, computes SHA-256(stdout) and prints it for reproducibility.
#======================================================================================================================
import subprocess, textwrap, hashlib

print("\n" + "="*118)
print("MODULE DNA-L3 — REAL vs SHUFFLED CpG FRACTION LOCK COMPARATOR (E. coli MG1655, L=256)")
print("="*118)

CUDA_SRC_PATH = "/content/warpfrac_dna_cpg_lock_compare.cu"
EXE_PATH      = "/content/warpfrac_dna_cpg_lock_compare"
FASTA_PATH    = "/content/ecoli_U00096_3.fna"

#----------------------------------------------------------------------------------------------------------------------
# Ensure FASTA exists (reuse or download)
#----------------------------------------------------------------------------------------------------------------------
print("\n[DNA-L3] Checking for E. coli FASTA at", FASTA_PATH)
ensure_fasta_cmd = [
    "bash", "-lc",
    textwrap.dedent(f"""
    set -euo pipefail
    if [ ! -f "{FASTA_PATH}" ]; then
      echo "  -> FASTA not found, fetching NC_000913.3 / U00096.3..."
      wget -q -O "{FASTA_PATH}" "https://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?db=nuccore&id=545778205&report=fasta&retmode=text"
      echo "  -> download complete."
    else
      echo "  -> FASTA found, reusing existing file."
    fi
    """)
]
res = subprocess.run(ensure_fasta_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(res.stdout)
if res.returncode != 0:
    print("[DNA-L3] FATAL: FASTA preparation failed.")
    raise SystemExit(1)

#----------------------------------------------------------------------------------------------------------------------
# Write C++ host program (compiled with nvcc, but CPU-only logic)
#----------------------------------------------------------------------------------------------------------------------
cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <string>
#include <random>
#include <chrono>
#include <fstream>
#include <algorithm>
#include <map>

// We do everything on CPU here. nvcc just compiles this C++.
// All math is exact integers; no floating point in the core counting logic.

//------------------ DNA helpers ---------------------------------------------------
char norm_base(char c){
    switch(c){
        case 'A': case 'a': return 'A';
        case 'C': case 'c': return 'C';
        case 'G': case 'g': return 'G';
        case 'T': case 't': return 'T';
        default:            return 'A';  // normalize non-ACGT to A
    }
}

// Load FASTA sequence from file: returns A/C/G/T string, sets header_out
std::string load_fasta_sequence(const char* path, std::string& header_out){
    std::ifstream in(path);
    if(!in){
        std::fprintf(stderr,"ERROR: Cannot open FASTA file: %s\n", path);
        std::exit(1);
    }
    std::string line;
    std::string seq;
    header_out.clear();
    while(std::getline(in, line)){
        if(line.empty()) continue;
        if(line[0] == '>'){
            if(header_out.empty()){
                header_out = line.substr(1); // drop '>'
            }
            continue;
        }
        for(char c : line){
            if(c == '\n' || c == '\r') continue;
            char nc = norm_base(c);
            seq.push_back(nc);
        }
    }
    return seq;
}

int igcd(int a, int b){
    if(a < 0) a = -a;
    if(b < 0) b = -b;
    if(a == 0) return b;
    if(b == 0) return a;
    while(b != 0){
        int r = a % b;
        a = b;
        b = r;
    }
    return (a < 0) ? -a : a;
}

//------------------ Stats struct --------------------------------------------------
struct CpGStats {
    long long total_cpg = 0;     // total "CG" dinucleotides across all windows
    long long window_cpg_nonzero = 0; // how many windows have at least one CG
    long long windows = 0;

    // Fraction stats: CpG_frac = (#CG)/(L-1)
    double sum_frac = 0.0;
    double min_frac = 1e9;
    double max_frac = -1e9;

    // Reduced fraction counts
    std::map<std::pair<int,int>, long long> frac_counts;

    // Small denominator counts
    long long den_le_2  = 0;
    long long den_le_4  = 0;
    long long den_le_8  = 0;
    long long den_le_16 = 0;
    long long den_le_32 = 0;
};

// Scan CpG in windows, fill stats
void scan_cpg_windows(const std::string& seq,
                      const std::vector<long long>& positions,
                      int L,
                      CpGStats& st)
{
    int N_WINDOWS = (int)positions.size();
    const int denom_full = L - 1; // number of dinucleotide positions per window

    st.windows = N_WINDOWS;

    for(int idx = 0; idx < N_WINDOWS; ++idx){
        long long pos = positions[idx];
        int cpg = 0;
        for(int i = 0; i < L-1; ++i){
            char b1 = seq[(size_t)pos + (size_t)i];
            char b2 = seq[(size_t)pos + (size_t)i + 1];
            if(b1 == 'C' && b2 == 'G') cpg++;
        }

        st.total_cpg += cpg;
        if(cpg > 0) st.window_cpg_nonzero++;

        // Fraction stats
        double frac = (double)cpg / (double)denom_full;
        st.sum_frac += frac;
        if(frac < st.min_frac) st.min_frac = frac;
        if(frac > st.max_frac) st.max_frac = frac;

        // Reduced fraction
        int num = cpg;
        int den = denom_full;
        int g = igcd(num, den);
        if(g == 0) g = 1;
        num /= g;
        den /= g;

        st.frac_counts[{num, den}]++;

        // Small denominator tallies
        if(den <= 2)  st.den_le_2++;
        if(den <= 4)  st.den_le_4++;
        if(den <= 8)  st.den_le_8++;
        if(den <= 16) st.den_le_16++;
        if(den <= 32) st.den_le_32++;
    }
}

// Helper to pick top-K fractions
std::vector<std::pair<std::pair<int,int>, long long>>
top_k(const std::map<std::pair<int,int>, long long>& mp, int Ktop)
{
    std::vector<std::pair<std::pair<int,int>, long long>> v(mp.begin(), mp.end());
    std::sort(v.begin(), v.end(),
              [](auto& a, auto& b){ return a.second > b.second; });
    if((int)v.size() > Ktop) v.resize(Ktop);
    return v;
}

//------------------ main ----------------------------------------------------------
int main(){
    std::printf("\n====================================================================================\n");
    std::printf("REAL vs SHUFFLED CpG FRACTION LOCK COMPARATOR — E. coli K-12 MG1655, L=256\n");
    std::printf("====================================================================================\n");
    std::printf("We look at \"CG\" dinucleotides (CpG) in real E. coli vs a shuffled genome.\n");
    std::printf("For each 256-bp window we count how many CG pairs appear and compute the\n");
    std::printf("exact fraction CpG_frac = (#CG) / (L-1), reduced to lowest terms.\n");
    std::printf("Then we compare REAL vs SHUFFLED:\n");
    std::printf("  • total CpG counts and how many windows carry at least one CpG.\n");
    std::printf("  • CpG fraction stats (mean / min / max across windows).\n");
    std::printf("  • small-denominator frequencies in the reduced fractions.\n");
    std::printf("  • top 10 most common CpG fractions.\n\n");

    const char* fasta_path = "/content/ecoli_U00096_3.fna";
    std::string header;
    std::string genome = load_fasta_sequence(fasta_path, header);
    if(genome.size() < 1000){
        std::fprintf(stderr,"ERROR: Genome too small or FASTA parse failed (len=%zu).\n", genome.size());
        return 1;
    }

    std::printf("Loaded FASTA: %s\n", fasta_path);
    if(!header.empty())
        std::printf("FASTA header: %s\n", header.c_str());
    std::printf("Genome length: %zu bases\n\n", genome.size());

    //------------------ Config ---------------------------------------------------
    const int L = 256;                 // window length
    const int N_WINDOWS = 100000;      // number of sampled windows
    const int denom_full = L - 1;      // dinucleotide positions per window

    if(genome.size() < (size_t)L + 10){
        std::fprintf(stderr,"ERROR: Genome shorter than L.\n");
        return 1;
    }

    std::printf("Config:\n");
    std::printf("  Window length L        = %d bases\n", L);
    std::printf("  Dinucleotide slots     = %d (L-1)\n", denom_full);
    std::printf("  Number of windows      = %d\n", N_WINDOWS);
    std::printf("  Total bases examined   ≈ %.1f million (per genome)\n\n",
                (double)L * (double)N_WINDOWS / 1e6);

    //------------------ Shuffled genome (same A/C/G/T multiset) ------------------
    std::printf("Building shuffled genome with identical A/C/G/T counts...\n");
    std::string shuffled = genome;
    std::mt19937_64 rng_shuffle(987654321ull);
    for(size_t i = shuffled.size() - 1; i > 0; --i){
        std::uniform_int_distribution<size_t> dist(0, i);
        size_t j = dist(rng_shuffle);
        std::swap(shuffled[i], shuffled[j]);
    }
    std::printf("Shuffled genome built.\n\n");

    //------------------ Shared window positions ----------------------------------
    std::mt19937_64 rng_pos(123456789ull);
    std::uniform_int_distribution<long long> dist_pos(
        0, (long long)genome.size() - L - 1
    );
    std::vector<long long> positions(N_WINDOWS);
    for(int i=0;i<N_WINDOWS;i++){
        positions[i] = dist_pos(rng_pos);
    }

    //------------------ Scan REAL CpG -------------------------------------------
    CpGStats real;
    auto t0_real = std::chrono::high_resolution_clock::now();
    scan_cpg_windows(genome, positions, L, real);
    auto t1_real = std::chrono::high_resolution_clock::now();
    double real_ms = std::chrono::duration<double,std::milli>(t1_real - t0_real).count();

    //------------------ Scan SHUFFLED CpG ---------------------------------------
    CpGStats shuf;
    auto t0_shuf = std::chrono::high_resolution_clock::now();
    scan_cpg_windows(shuffled, positions, L, shuf);
    auto t1_shuf = std::chrono::high_resolution_clock::now();
    double shuf_ms = std::chrono::duration<double,std::milli>(t1_shuf - t0_shuf).count();

    auto print_cpg = [&](const char* label, const CpGStats& st){
        double mean_frac = st.sum_frac / (double)st.windows;
        double nonzero_pct = 100.0 * (double)st.window_cpg_nonzero / (double)st.windows;
        std::printf("%s CpG stats:\n", label);
        std::printf("  Total windows              : %lld\n", st.windows);
        std::printf("  Windows with >=1 CpG       : %lld (%.2f%%)\n",
                    st.window_cpg_nonzero, nonzero_pct);
        std::printf("  Total CpG across windows   : %lld\n", st.total_cpg);
        std::printf("  Mean CpG per window        : %.4f\n",
                    (double)st.total_cpg / (double)st.windows);
        std::printf("  CpG fraction over windows  : mean = %.6f, min = %.6f, max = %.6f\n\n",
                    mean_frac, st.min_frac, st.max_frac);
    };

    std::printf("--- CpG summary (REAL vs SHUFFLED) ---\n");
    print_cpg("REAL     ", real);
    print_cpg("SHUFFLED ", shuf);

    auto print_small_den = [&](const char* label, const CpGStats& st){
        auto pct = [&](long long x){ return 100.0 * (double)x / (double)st.windows; };
        std::printf("%s small-denominator frequencies (reduced CpG_frac):\n", label);
        std::printf("  den <= 2  : %lld (%.4f%%)\n", st.den_le_2,  pct(st.den_le_2));
        std::printf("  den <= 4  : %lld (%.4f%%)\n", st.den_le_4,  pct(st.den_le_4));
        std::printf("  den <= 8  : %lld (%.4f%%)\n", st.den_le_8,  pct(st.den_le_8));
        std::printf("  den <= 16 : %lld (%.4f%%)\n", st.den_le_16, pct(st.den_le_16));
        std::printf("  den <= 32 : %lld (%.4f%%)\n\n", st.den_le_32, pct(st.den_le_32));
    };

    std::printf("--- Small denominator stats (REAL vs SHUFFLED) ---\n");
    print_small_den("REAL     ", real);
    print_small_den("SHUFFLED ", shuf);

    // Top-K reduced CpG fractions
    auto real_top = top_k(real.frac_counts, 10);
    auto shuf_top = top_k(shuf.frac_counts, 10);

    auto print_top = [&](const char* label,
                         const std::vector<std::pair<std::pair<int,int>, long long>>& v,
                         long long windows){
        std::printf("%s\n", label);
        for(size_t i=0;i<v.size();i++){
            int num = v[i].first.first;
            int den = v[i].first.second;
            long long cnt = v[i].second;
            double frac = (double)num / (double)den;
            std::printf("  %2zu) %3d/%-3d ≈ %.6f | count=%lld (%.4f%%)\n",
                        i+1, num, den, frac,
                        cnt, 100.0 * (double)cnt / (double)windows);
        }
        std::printf("\n");
    };

    std::printf("--- Top 10 reduced CpG fractions (REAL) ---\n");
    print_top("REAL CpG fractions:", real_top, real.windows);
    std::printf("--- Top 10 reduced CpG fractions (SHUFFLED) ---\n");
    print_top("SHUFFLED CpG fractions:", shuf_top, shuf.windows);

    std::printf("Timing:\n");
    std::printf("  REAL CpG scan    : %.3f ms\n", real_ms);
    std::printf("  SHUFFLED CpG scan: %.3f ms\n", shuf_ms);
    std::printf("  Windows          : %d\n", N_WINDOWS);
    std::printf("\n");

    std::printf("REAL vs SHUFFLED CpG FRACTION LOCK COMPARATOR finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"[DNA-L3] Writing CpG fraction-lock compare CUDA source -> {CUDA_SRC_PATH}")
with open(CUDA_SRC_PATH, "w") as f:
    f.write(cuda_src)

#----------------------------------------------------------------------------------------------------------------------
# Compile with nvcc
#----------------------------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC_PATH,
    "-o",
    EXE_PATH,
]

print("[DNA-L3] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[DNA-L3] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[DNA-L3] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[DNA-L3] Compile OK -> {EXE_PATH}")

#----------------------------------------------------------------------------------------------------------------------
# Run the comparator and capture stdout for SHA-256
#----------------------------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING REAL vs SHUFFLED CpG FRACTION LOCK COMPARATOR (E. coli, L=256)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[DNA-L3] WARNING: CpG fraction-lock comparator exited with code {run_res.returncode}")
else:
    print("[DNA-L3] CpG fraction-lock comparator completed successfully.")

stdout_bytes = run_res.stdout.encode("utf-8", errors="replace")
digest = hashlib.sha256(stdout_bytes).hexdigest()
print(f"\n[DNA-L3] SHA256(stdout) = {digest}")

print("\n" + "="*118)
print("MODULE DNA-L3 — DONE (REAL vs SHUFFLED CpG FRACTION LOCK COMPARATOR)")
print("="*118)

#======================================================================================================================
# MODULE DNA-L4 — CpG FRACTION RANDOMNESS STRESS TEST (MULTI-SHUFFLE NULL MODEL)
#
# What this does:
#   • Uses the same E. coli MG1655 genome as DNA-L2/L3.
#   • Window config: L=256, N_WINDOWS=100000 (same random positions as the real genome).
#   • Step 1: Scan the REAL genome:
#       - For each window, count CpG = # of "CG" pairs.
#       - Compute CpG_frac = CpG/(L-1) per window.
#       - Record mean CpG per window, mean CpG_frac, min/max, etc.
#   • Step 2: Build N_SHUFFLES independent shuffled genomes:
#       - Each shuffle preserves the exact A/C/G/T multiset.
#       - For each shuffled genome, scan the same window positions and compute
#         mean CpG per window.
#   • Step 3: Compare REAL vs SHUFFLES:
#       - Print the list of shuffle means.
#       - Compute:
#           - min / max / mean / stddev shuffle mean
#           - how many shuffles >= real mean (empirical p-like)
#           - z-score = (real_mean - shuffle_mean) / shuffle_std
#   • All CpG counts are exact integers; summary statistics are in double precision.
#   • At the end, prints SHA-256(stdout) for reproducibility.
#======================================================================================================================
import subprocess, textwrap, hashlib

print("\n" + "="*118)
print("MODULE DNA-L4 — CpG FRACTION RANDOMNESS STRESS TEST (MULTI-SHUFFLE NULL MODEL)")
print("="*118)

CUDA_SRC_PATH = "/content/warpfrac_dna_cpg_multishuffle.cu"
EXE_PATH      = "/content/warpfrac_dna_cpg_multishuffle"
FASTA_PATH    = "/content/ecoli_U00096_3.fna"

#----------------------------------------------------------------------------------------------------------------------
# Ensure FASTA exists
#----------------------------------------------------------------------------------------------------------------------
print("\n[DNA-L4] Checking for E. coli FASTA at", FASTA_PATH)
ensure_fasta_cmd = [
    "bash", "-lc",
    textwrap.dedent(f"""
    set -euo pipefail
    if [ ! -f "{FASTA_PATH}" ]; then
      echo "  -> FASTA not found, fetching NC_000913.3 / U00096.3..."
      wget -q -O "{FASTA_PATH}" "https://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?db=nuccore&id=545778205&report=fasta&retmode=text"
      echo "  -> download complete."
    else
      echo "  -> FASTA found, reusing existing file."
    fi
    """)
]
res = subprocess.run(ensure_fasta_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(res.stdout)
if res.returncode != 0:
    print("[DNA-L4] FATAL: FASTA preparation failed.")
    raise SystemExit(1)

#----------------------------------------------------------------------------------------------------------------------
# Write C++ host program (CPU-only, compiled with nvcc)
#----------------------------------------------------------------------------------------------------------------------
cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <string>
#include <random>
#include <chrono>
#include <fstream>
#include <algorithm>
#include <cmath>

//------------------ DNA helpers ---------------------------------------------------
char norm_base(char c){
    switch(c){
        case 'A': case 'a': return 'A';
        case 'C': case 'c': return 'C';
        case 'G': case 'g': return 'G';
        case 'T': case 't': return 'T';
        default:            return 'A';  // normalize non-ACGT to A
    }
}

// Load FASTA sequence from file: returns A/C/G/T string, sets header_out
std::string load_fasta_sequence(const char* path, std::string& header_out){
    std::ifstream in(path);
    if(!in){
        std::fprintf(stderr,"ERROR: Cannot open FASTA file: %s\n", path);
        std::exit(1);
    }
    std::string line;
    std::string seq;
    header_out.clear();
    while(std::getline(in, line)){
        if(line.empty()) continue;
        if(line[0] == '>'){
            if(header_out.empty()){
                header_out = line.substr(1); // drop '>'
            }
            continue;
        }
        for(char c : line){
            if(c == '\n' || c == '\r') continue;
            char nc = norm_base(c);
            seq.push_back(nc);
        }
    }
    return seq;
}

// Scan CpG in windows for a given sequence
double scan_cpg_mean(const std::string& seq,
                     const std::vector<long long>& positions,
                     int L,
                     long long& total_cpg,
                     long long& windows_with_cpg,
                     double& min_frac,
                     double& max_frac)
{
    int N_WINDOWS = (int)positions.size();
    const int denom_full = L - 1; // slots per window

    total_cpg = 0;
    windows_with_cpg = 0;
    double sum_frac = 0.0;
    min_frac = 1e9;
    max_frac = -1e9;

    for(int idx = 0; idx < N_WINDOWS; ++idx){
        long long pos = positions[idx];
        int cpg = 0;
        for(int i = 0; i < L-1; ++i){
            char b1 = seq[(size_t)pos + (size_t)i];
            char b2 = seq[(size_t)pos + (size_t)i + 1];
            if(b1 == 'C' && b2 == 'G') cpg++;
        }
        total_cpg += cpg;
        if(cpg > 0) windows_with_cpg++;

        double frac = (double)cpg / (double)denom_full;
        sum_frac += frac;
        if(frac < min_frac) min_frac = frac;
        if(frac > max_frac) max_frac = frac;
    }

    double mean_cpg = (double)total_cpg / (double)N_WINDOWS;
    return mean_cpg;
}

// Compute mean and stddev of a vector<double>
void mean_std(const std::vector<double>& v, double& mean, double& stddev){
    if(v.empty()){
        mean = 0.0;
        stddev = 0.0;
        return;
    }
    double s = 0.0;
    for(double x : v) s += x;
    mean = s / (double)v.size();
    double ss = 0.0;
    for(double x : v){ double d = x - mean; ss += d*d; }
    stddev = (v.size() > 1) ? std::sqrt(ss / (double)(v.size()-1)) : 0.0;
}

//------------------ main ----------------------------------------------------------
int main(){
    std::printf("\n====================================================================================\n");
    std::printf("CpG FRACTION RANDOMNESS STRESS TEST — Multi-Shuffle Null Model (E. coli, L=256)\n");
    std::printf("====================================================================================\n");
    std::printf("We check whether E. coli's CpG usage at L=256 looks like a random shuffle.\n");
    std::printf("Steps:\n");
    std::printf("  1) Scan REAL genome: CpG per window, CpG fraction per window.\n");
    std::printf("  2) Build multiple shuffled genomes (same A/C/G/T multiset) and, for each,\n");
    std::printf("     scan the same windows and record the mean CpG per window.\n");
    std::printf("  3) Compare REAL vs SHUFFLES: min/max/mean/std of shuffle means, z-score,\n");
    std::printf("     and how many shuffles >= real.\n\n");

    const char* fasta_path = "/content/ecoli_U00096_3.fna";
    std::string header;
    std::string genome = load_fasta_sequence(fasta_path, header);
    if(genome.size() < 1000){
        std::fprintf(stderr,"ERROR: Genome too small or FASTA parse failed (len=%zu).\n", genome.size());
        return 1;
    }

    std::printf("Loaded FASTA: %s\n", fasta_path);
    if(!header.empty())
        std::printf("FASTA header: %s\n", header.c_str());
    std::printf("Genome length: %zu bases\n\n", genome.size());

    //------------------ Config ---------------------------------------------------
    const int L = 256;
    const int N_WINDOWS = 100000;
    const int denom_full = L - 1;
    const int N_SHUFFLES = 16;  // number of independent shuffles in the null model

    if(genome.size() < (size_t)L + 10){
        std::fprintf(stderr,"ERROR: Genome shorter than L.\n");
        return 1;
    }

    std::printf("Config:\n");
    std::printf("  Window length L        = %d bases\n", L);
    std::printf("  Dinucleotide slots     = %d (L-1)\n", denom_full);
    std::printf("  Number of windows      = %d\n", N_WINDOWS);
    std::printf("  Total bases examined   ≈ %.1f million (per genome)\n",
                (double)L * (double)N_WINDOWS / 1e6);
    std::printf("  Number of shuffles     = %d\n\n", N_SHUFFLES);

    //------------------ Shared window positions ----------------------------------
    std::mt19937_64 rng_pos(123456789ull);
    std::uniform_int_distribution<long long> dist_pos(
        0, (long long)genome.size() - L - 1
    );
    std::vector<long long> positions(N_WINDOWS);
    for(int i=0;i<N_WINDOWS;i++){
        positions[i] = dist_pos(rng_pos);
    }

    //------------------ REAL genome CpG scan -------------------------------------
    std::printf("--- REAL genome CpG scan ---\n");
    long long real_total_cpg = 0;
    long long real_windows_cpg = 0;
    double real_min_frac = 0.0;
    double real_max_frac = 0.0;
    auto t0_real = std::chrono::high_resolution_clock::now();
    double real_mean_cpg = scan_cpg_mean(genome, positions, L,
                                         real_total_cpg, real_windows_cpg,
                                         real_min_frac, real_max_frac);
    auto t1_real = std::chrono::high_resolution_clock::now();
    double real_ms = std::chrono::duration<double,std::milli>(t1_real - t0_real).count();

    std::printf("REAL CpG stats:\n");
    std::printf("  Total windows              : %d\n", N_WINDOWS);
    std::printf("  Windows with >=1 CpG       : %lld (%.4f%%)\n",
                real_windows_cpg,
                100.0 * (double)real_windows_cpg / (double)N_WINDOWS);
    std::printf("  Total CpG across windows   : %lld\n", real_total_cpg);
    std::printf("  Mean CpG per window        : %.6f\n", real_mean_cpg);
    std::printf("  CpG fraction per window    : min = %.6f, max = %.6f (denom=%d)\n",
                real_min_frac, real_max_frac, denom_full);
    std::printf("  Scan time                  : %.3f ms\n\n", real_ms);

    //------------------ SHUFFLED genomes CpG scan --------------------------------
    std::printf("--- SHUFFLED genomes CpG scan (null model) ---\n");
    std::vector<double> shuffle_means;
    shuffle_means.reserve(N_SHUFFLES);
    std::vector<long long> shuffle_totals;
    shuffle_totals.reserve(N_SHUFFLES);

    // For reproducibility, a fixed base seed; each shuffle gets a derived seed.
    std::mt19937_64 rng_seed(987654321ull);

    double total_shuf_ms = 0.0;

    for(int s=0; s<N_SHUFFLES; ++s){
        unsigned long long seed = rng_seed();  // new seed per shuffle
        std::mt19937_64 rng_shuffle(seed);

        std::string shuffled = genome;
        for(size_t i = shuffled.size() - 1; i > 0; --i){
            std::uniform_int_distribution<size_t> dist(0, i);
            size_t j = dist(rng_shuffle);
            std::swap(shuffled[i], shuffled[j]);
        }

        long long shuf_total_cpg = 0;
        long long shuf_windows_cpg = 0;
        double shuf_min_frac = 0.0;
        double shuf_max_frac = 0.0;

        auto t0_shuf = std::chrono::high_resolution_clock::now();
        double shuf_mean_cpg = scan_cpg_mean(shuffled, positions, L,
                                             shuf_total_cpg, shuf_windows_cpg,
                                             shuf_min_frac, shuf_max_frac);
        auto t1_shuf = std::chrono::high_resolution_clock::now();
        double shuf_ms = std::chrono::duration<double,std::milli>(t1_shuf - t0_shuf).count();
        total_shuf_ms += shuf_ms;

        shuffle_means.push_back(shuf_mean_cpg);
        shuffle_totals.push_back(shuf_total_cpg);

        std::printf("  Shuffle %2d: seed=%20llu | mean CpG/window=%.6f | total CpG=%lld | time=%.3f ms\n",
                    s+1,
                    (unsigned long long)seed,
                    shuf_mean_cpg,
                    shuf_total_cpg,
                    shuf_ms);
    }
    std::printf("\n");

    //------------------ Summary stats --------------------------------------------
    double shuf_mean = 0.0;
    double shuf_std  = 0.0;
    mean_std(shuffle_means, shuf_mean, shuf_std);

    double min_shuf = 1e9, max_shuf = -1e9;
    for(double m : shuffle_means){
        if(m < min_shuf) min_shuf = m;
        if(m > max_shuf) max_shuf = m;
    }

    int count_ge_real = 0;
    for(double m : shuffle_means){
        if(m >= real_mean_cpg) count_ge_real++;
    }

    double z = 0.0;
    if(shuf_std > 0.0){
        z = (real_mean_cpg - shuf_mean) / shuf_std;
    }

    std::printf("--- REAL vs SHUFFLED CpG mean comparison ---\n");
    std::printf("  REAL mean CpG/window      : %.6f\n", real_mean_cpg);
    std::printf("  SHUFFLES (N = %d):\n", N_SHUFFLES);
    std::printf("    min mean CpG/window     : %.6f\n", min_shuf);
    std::printf("    max mean CpG/window     : %.6f\n", max_shuf);
    std::printf("    mean of means           : %.6f\n", shuf_mean);
    std::printf("    stddev of means         : %.6f\n", shuf_std);
    std::printf("  REAL vs SHUFFLES:\n");
    std::printf("    REAL - mean_shuffle     : %.6f\n", real_mean_cpg - shuf_mean);
    std::printf("    z-score (REAL vs null)  : %.3f\n", z);
    std::printf("    shuffles with mean >= REAL: %d / %d\n",
                count_ge_real, N_SHUFFLES);
    std::printf("    (empirical upper-tail freq ≈ %.4f)\n",
                (double)count_ge_real / (double)N_SHUFFLES);
    std::printf("\n");

    std::printf("Timing summary:\n");
    std::printf("  REAL CpG scan      : %.3f ms\n", real_ms);
    std::printf("  All shuffles total : %.3f ms (avg %.3f ms / shuffle)\n",
                total_shuf_ms, total_shuf_ms / (double)N_SHUFFLES);
    std::printf("  Windows per scan   : %d\n", N_WINDOWS);
    std::printf("\n");

    std::printf("CpG FRACTION RANDOMNESS STRESS TEST finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"[DNA-L4] Writing CpG multi-shuffle CUDA source -> {CUDA_SRC_PATH}")
with open(CUDA_SRC_PATH, "w") as f:
    f.write(cuda_src)

#----------------------------------------------------------------------------------------------------------------------
# Compile with nvcc
#----------------------------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC_PATH,
    "-o",
    EXE_PATH,
]

print("[DNA-L4] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[DNA-L4] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[DNA-L4] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[DNA-L4] Compile OK -> {EXE_PATH}")

#----------------------------------------------------------------------------------------------------------------------
# Run and SHA-256 stdout
#----------------------------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING CpG FRACTION RANDOMNESS STRESS TEST (MULTI-SHUFFLE NULL MODEL)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[DNA-L4] WARNING: multi-shuffle CpG test exited with code {run_res.returncode}")
else:
    print("[DNA-L4] CpG multi-shuffle test completed successfully.")

stdout_bytes = run_res.stdout.encode("utf-8", errors="replace")
digest = hashlib.sha256(stdout_bytes).hexdigest()
print(f"\n[DNA-L4] SHA256(stdout) = {digest}")

print("\n" + "="*118)
print("MODULE DNA-L4 — DONE (CpG FRACTION RANDOMNESS STRESS TEST)")
print("="*118)

#======================================================================================================================
# MODULE DNA-L5 — CpG LOCK HOTSPOT LOCATOR (E. coli MG1655, L=256, STEP=32)
#
# What this does:
#   • Uses the same E. coli MG1655 FASTA as earlier DNA-L* modules.
#   • Sliding windows across the WHOLE genome:
#       - Window length L = 256 bases
#       - Step size STEP = 32 bases (overlapping windows)
#   • For each window:
#       - Count CpG = # of "CG" dinucleotides.
#       - Count GC  = # of 'G' or 'C' bases.
#       - CpG fraction   = CpG / (L-1)
#       - GC fraction    = GC  / L
#   • Then:
#       - Report global stats (mean/min/max CpG per window).
#       - Print the TOP 10 CpG-rich windows (hotspots).
#       - Print the BOTTOM 10 CpG-poor windows (deserts).
#       - For each: genomic position, CpG count, CpG_frac as reduced fraction,
#         GC_frac, and a sequence snippet (start/end).
#   • No CUDA kernels here — pure integer CPU scan compiled via nvcc.
#   • Ends with SHA-256(stdout) for reproducibility.
#======================================================================================================================
import subprocess, textwrap, hashlib

print("\n" + "="*118)
print("MODULE DNA-L5 — CpG LOCK HOTSPOT LOCATOR (E. coli MG1655, L=256, STEP=32)")
print("="*118)

CUDA_SRC_PATH = "/content/warpfrac_dna_cpg_hotspots.cu"
EXE_PATH      = "/content/warpfrac_dna_cpg_hotspots"
FASTA_PATH    = "/content/ecoli_U00096_3.fna"

#----------------------------------------------------------------------------------------------------------------------
# Ensure FASTA exists
#----------------------------------------------------------------------------------------------------------------------
print("\n[DNA-L5] Checking for E. coli FASTA at", FASTA_PATH)
ensure_fasta_cmd = [
    "bash", "-lc",
    textwrap.dedent(f"""
    set -euo pipefail
    if [ ! -f "{FASTA_PATH}" ]; then
      echo "  -> FASTA not found, fetching NC_000913.3 / U00096.3..."
      wget -q -O "{FASTA_PATH}" "https://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?db=nuccore&id=545778205&report=fasta&retmode=text"
      echo "  -> download complete."
    else
      echo "  -> FASTA found, reusing existing file."
    fi
    """)
]
res = subprocess.run(ensure_fasta_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(res.stdout)
if res.returncode != 0:
    print("[DNA-L5] FATAL: FASTA preparation failed.")
    raise SystemExit(1)

#----------------------------------------------------------------------------------------------------------------------
# Write C++ host program (CPU-only, compiled with nvcc)
#----------------------------------------------------------------------------------------------------------------------
cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <string>
#include <fstream>
#include <algorithm>
#include <chrono>

//------------------ helpers -------------------------------------------------------
char norm_base(char c){
    switch(c){
        case 'A': case 'a': return 'A';
        case 'C': case 'c': return 'C';
        case 'G': case 'g': return 'G';
        case 'T': case 't': return 'T';
        default:            return 'A';  // normalize ambiguous to A
    }
}

std::string load_fasta_sequence(const char* path, std::string& header_out){
    std::ifstream in(path);
    if(!in){
        std::fprintf(stderr,"ERROR: Cannot open FASTA file: %s\n", path);
        std::exit(1);
    }
    std::string line;
    std::string seq;
    header_out.clear();
    while(std::getline(in, line)){
        if(line.empty()) continue;
        if(line[0] == '>'){
            if(header_out.empty()){
                header_out = line.substr(1);
            }
            continue;
        }
        for(char c : line){
            if(c == '\n' || c == '\r') continue;
            seq.push_back(norm_base(c));
        }
    }
    return seq;
}

// integer gcd
int igcd(int a, int b){
    if(a < 0) a = -a;
    if(b < 0) b = -b;
    if(a == 0) return (b == 0) ? 1 : b;
    if(b == 0) return a;
    while(b != 0){
        int t = a % b;
        a = b;
        b = t;
    }
    return (a == 0) ? 1 : a;
}

struct WindowInfo{
    long long pos;   // 0-based genomic index
    int       cpg;   // # of CG dinucs
    int       gc;    // # of G or C bases
};

//------------------ main ----------------------------------------------------------
int main(){
    std::printf("\n====================================================================================\n");
    std::printf("CpG LOCK HOTSPOT LOCATOR — E. coli K-12 MG1655, L=256, STEP=32\n");
    std::printf("====================================================================================\n");
    std::printf("We slide a 256-bp window across the real genome (step=32),\n");
    std::printf("and for each window we count CpG dinucleotides exactly:\n");
    std::printf("  CpG = # of 'CG' pairs in the window.\n");
    std::printf("We also count GC bases and compute:\n");
    std::printf("  CpG_frac = CpG / (L-1)  (as a reduced fraction),\n");
    std::printf("  GC_frac  = (G+C) / L.\n");
    std::printf("Then we report the top 10 CpG-rich windows (hotspots)\n");
    std::printf("and bottom 10 CpG-poor windows (deserts).\n\n");

    const char* fasta_path = "/content/ecoli_U00096_3.fna";
    std::string header;
    std::string genome = load_fasta_sequence(fasta_path, header);
    if(genome.size() < 1000){
        std::fprintf(stderr,"ERROR: Genome too small or FASTA parse failed (len=%zu).\n", genome.size());
        return 1;
    }

    std::printf("Loaded FASTA: %s\n", fasta_path);
    if(!header.empty())
        std::printf("FASTA header: %s\n", header.c_str());
    std::printf("Genome length: %zu bases\n\n", genome.size());

    const int L    = 256;
    const int STEP = 32;
    if(genome.size() < (size_t)L){
        std::fprintf(stderr,"ERROR: Genome shorter than L.\n");
        return 1;
    }

    long long n_windows = ((long long)genome.size() - L) / STEP + 1;
    const int denom_full = L - 1;

    std::printf("Config:\n");
    std::printf("  Window length L    = %d bases\n", L);
    std::printf("  Step size          = %d bases\n", STEP);
    std::printf("  Dinucleotide slots = %d (L-1)\n", denom_full);
    std::printf("  Number of windows  = %lld\n", n_windows);
    std::printf("  Total bases in windows (approx) = %.3f million (with overlap)\n\n",
                (double)L * (double)n_windows / 1e6);

    std::vector<WindowInfo> windows;
    windows.reserve((size_t)n_windows);

    long long total_cpg = 0;
    int min_cpg = 1e9;
    int max_cpg = -1;
    double sum_cpg = 0.0;

    auto t0 = std::chrono::high_resolution_clock::now();
    for(long long w = 0; w < n_windows; ++w){
        long long pos = w * STEP;
        int cpg = 0;
        int gc  = 0;
        // count CpG
        for(int i = 0; i < L-1; ++i){
            char b1 = genome[(size_t)pos + (size_t)i];
            char b2 = genome[(size_t)pos + (size_t)i + 1];
            if(b1 == 'C' && b2 == 'G') cpg++;
        }
        // count GC bases
        for(int i = 0; i < L; ++i){
            char b = genome[(size_t)pos + (size_t)i];
            if(b == 'G' || b == 'C') gc++;
        }

        WindowInfo info;
        info.pos = pos;
        info.cpg = cpg;
        info.gc  = gc;
        windows.push_back(info);

        total_cpg += cpg;
        sum_cpg   += (double)cpg;
        if(cpg < min_cpg) min_cpg = cpg;
        if(cpg > max_cpg) max_cpg = cpg;
    }
    auto t1 = std::chrono::high_resolution_clock::now();
    double ms = std::chrono::duration<double,std::milli>(t1 - t0).count();

    double mean_cpg = sum_cpg / (double)n_windows;
    std::printf("--- Global CpG stats over sliding windows ---\n");
    std::printf("  Total windows           : %lld\n", n_windows);
    std::printf("  Total CpG across windows: %lld\n", total_cpg);
    std::printf("  Mean CpG per window     : %.6f\n", mean_cpg);
    std::printf("  Min CpG per window      : %d\n", min_cpg);
    std::printf("  Max CpG per window      : %d\n", max_cpg);
    std::printf("  Scan time               : %.3f ms\n", ms);
    std::printf("\n");

    // sort copies for top/bottom
    std::vector<WindowInfo> top = windows;
    std::vector<WindowInfo> bot = windows;

    std::sort(top.begin(), top.end(), [](const WindowInfo& a, const WindowInfo& b){
        if(a.cpg != b.cpg) return a.cpg > b.cpg; // descending CpG
        return a.pos < b.pos;
    });
    std::sort(bot.begin(), bot.end(), [](const WindowInfo& a, const WindowInfo& b){
        if(a.cpg != b.cpg) return a.cpg < b.cpg; // ascending CpG
        return a.pos < b.pos;
    });

    auto print_window = [&](const char* label, const WindowInfo& w){
        double cpg_frac = (double)w.cpg / (double)denom_full;
        double gc_frac  = (double)w.gc  / (double)L;
        int g = igcd(w.cpg, denom_full);
        int num = (g == 0) ? 0 : (w.cpg / g);
        int den = (g == 0) ? 1 : (denom_full / g);

        long long pos = w.pos;
        std::string subseq = genome.substr((size_t)pos, (size_t)L);

        std::string head = subseq.substr(0, 80);
        std::string tail = subseq.substr(L - 40, 40);

        std::printf("%s\n", label);
        std::printf("  Genomic start (0-based) : %lld\n", pos);
        std::printf("  CpG count               : %d\n", w.cpg);
        std::printf("  CpG fraction            : %d/%d ≈ %.6f\n", num, den, cpg_frac);
        std::printf("  GC count                : %d\n", w.gc);
        std::printf("  GC fraction             : %.6f\n", gc_frac);
        std::printf("  Sequence (L=256):\n");
        std::printf("    start: %.80s\n", head.c_str());
        std::printf("    end  : %.40s\n", tail.c_str());
        std::printf("\n");
    };

    int n_show = 10;
    if((long long)n_show > n_windows) n_show = (int)n_windows;

    std::printf("--- Top %d CpG HOTSPOTS (highest CpG per 256-bp window) ---\n\n", n_show);
    for(int i=0;i<n_show;i++){
        char label[64];
        std::snprintf(label, sizeof(label), "  [HOTSPOT %2d]", i+1);
        print_window(label, top[i]);
    }

    std::printf("--- Bottom %d CpG DESERTS (lowest CpG per 256-bp window) ---\n\n", n_show);
    for(int i=0;i<n_show;i++){
        char label[64];
        std::snprintf(label, sizeof(label), "  [DESERT  %2d]", i+1);
        print_window(label, bot[i]);
    }

    std::printf("CpG LOCK HOTSPOT LOCATOR finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"[DNA-L5] Writing CpG hotspot CUDA source -> {CUDA_SRC_PATH}")
with open(CUDA_SRC_PATH, "w") as f:
    f.write(cuda_src)

#----------------------------------------------------------------------------------------------------------------------
# Compile with nvcc
#----------------------------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC_PATH,
    "-o",
    EXE_PATH,
]

print("[DNA-L5] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[DNA-L5] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[DNA-L5] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[DNA-L5] Compile OK -> {EXE_PATH}")

#----------------------------------------------------------------------------------------------------------------------
# Run and SHA-256 stdout
#----------------------------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING CpG LOCK HOTSPOT LOCATOR (SLIDING WINDOWS ACROSS GENOME)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[DNA-L5] WARNING: hotspot locator exited with code {run_res.returncode}")
else:
    print("[DNA-L5] CpG hotspot locator completed successfully.")

stdout_bytes = run_res.stdout.encode("utf-8", errors="replace")
digest = hashlib.sha256(stdout_bytes).hexdigest()
print(f"\n[DNA-L5] SHA256(stdout) = {digest}")

print("\n" + "="*118)
print("MODULE DNA-L5 — DONE (CpG LOCK HOTSPOT LOCATOR)")
print("="*118)

#======================================================================================================================
# MODULE DNA-L5 — CpG LOCK HOTSPOT LOCATOR (E. coli MG1655, L=256, STEP=32)
#
# What this does:
#   • Uses the same E. coli MG1655 FASTA as earlier DNA-L* modules.
#   • Sliding windows across the WHOLE genome:
#       - Window length L = 256 bases
#       - Step size STEP = 32 bases (overlapping windows)
#   • For each window:
#       - Count CpG = # of "CG" dinucleotides.
#       - Count GC  = # of 'G' or 'C' bases.
#       - CpG fraction   = CpG / (L-1)
#       - GC fraction    = GC  / L
#   • Then:
#       - Report global stats (mean/min/max CpG per window).
#       - Print the TOP 10 CpG-rich windows (hotspots).
#       - Print the BOTTOM 10 CpG-poor windows (deserts).
#       - For each: genomic position, CpG count, CpG_frac as reduced fraction,
#         GC_frac, and a sequence snippet (start/end).
#   • No CUDA kernels here — pure integer CPU scan compiled via nvcc.
#   • Ends with SHA-256(stdout) for reproducibility.
#======================================================================================================================
import subprocess, textwrap, hashlib

print("\n" + "="*118)
print("MODULE DNA-L5 — CpG LOCK HOTSPOT LOCATOR (E. coli MG1655, L=256, STEP=32)")
print("="*118)

CUDA_SRC_PATH = "/content/warpfrac_dna_cpg_hotspots.cu"
EXE_PATH      = "/content/warpfrac_dna_cpg_hotspots"
FASTA_PATH    = "/content/ecoli_U00096_3.fna"

#----------------------------------------------------------------------------------------------------------------------
# Ensure FASTA exists
#----------------------------------------------------------------------------------------------------------------------
print("\n[DNA-L5] Checking for E. coli FASTA at", FASTA_PATH)
ensure_fasta_cmd = [
    "bash", "-lc",
    textwrap.dedent(f"""
    set -euo pipefail
    if [ ! -f "{FASTA_PATH}" ]; then
      echo "  -> FASTA not found, fetching NC_000913.3 / U00096.3..."
      wget -q -O "{FASTA_PATH}" "https://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?db=nuccore&id=545778205&report=fasta&retmode=text"
      echo "  -> download complete."
    else
      echo "  -> FASTA found, reusing existing file."
    fi
    """)
]
res = subprocess.run(ensure_fasta_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(res.stdout)
if res.returncode != 0:
    print("[DNA-L5] FATAL: FASTA preparation failed.")
    raise SystemExit(1)

#----------------------------------------------------------------------------------------------------------------------
# Write C++ host program (CPU-only, compiled with nvcc)
#----------------------------------------------------------------------------------------------------------------------
cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <string>
#include <fstream>
#include <algorithm>
#include <chrono>

//------------------ helpers -------------------------------------------------------
char norm_base(char c){
    switch(c){
        case 'A': case 'a': return 'A';
        case 'C': case 'c': return 'C';
        case 'G': case 'g': return 'G';
        case 'T': case 't': return 'T';
        default:            return 'A';  // normalize ambiguous to A
    }
}

std::string load_fasta_sequence(const char* path, std::string& header_out){
    std::ifstream in(path);
    if(!in){
        std::fprintf(stderr,"ERROR: Cannot open FASTA file: %s\n", path);
        std::exit(1);
    }
    std::string line;
    std::string seq;
    header_out.clear();
    while(std::getline(in, line)){
        if(line.empty()) continue;
        if(line[0] == '>'){
            if(header_out.empty()){
                header_out = line.substr(1);
            }
            continue;
        }
        for(char c : line){
            if(c == '\n' || c == '\r') continue;
            seq.push_back(norm_base(c));
        }
    }
    return seq;
}

// integer gcd
int igcd(int a, int b){
    if(a < 0) a = -a;
    if(b < 0) b = -b;
    if(a == 0) return (b == 0) ? 1 : b;
    if(b == 0) return a;
    while(b != 0){
        int t = a % b;
        a = b;
        b = t;
    }
    return (a == 0) ? 1 : a;
}

struct WindowInfo{
    long long pos;   // 0-based genomic index
    int       cpg;   // # of CG dinucs
    int       gc;    // # of G or C bases
};

//------------------ main ----------------------------------------------------------
int main(){
    std::printf("\n====================================================================================\n");
    std::printf("CpG LOCK HOTSPOT LOCATOR — E. coli K-12 MG1655, L=256, STEP=32\n");
    std::printf("====================================================================================\n");
    std::printf("We slide a 256-bp window across the real genome (step=32),\n");
    std::printf("and for each window we count CpG dinucleotides exactly:\n");
    std::printf("  CpG = # of 'CG' pairs in the window.\n");
    std::printf("We also count GC bases and compute:\n");
    std::printf("  CpG_frac = CpG / (L-1)  (as a reduced fraction),\n");
    std::printf("  GC_frac  = (G+C) / L.\n");
    std::printf("Then we report the top 10 CpG-rich windows (hotspots)\n");
    std::printf("and bottom 10 CpG-poor windows (deserts).\n\n");

    const char* fasta_path = "/content/ecoli_U00096_3.fna";
    std::string header;
    std::string genome = load_fasta_sequence(fasta_path, header);
    if(genome.size() < 1000){
        std::fprintf(stderr,"ERROR: Genome too small or FASTA parse failed (len=%zu).\n", genome.size());
        return 1;
    }

    std::printf("Loaded FASTA: %s\n", fasta_path);
    if(!header.empty())
        std::printf("FASTA header: %s\n", header.c_str());
    std::printf("Genome length: %zu bases\n\n", genome.size());

    const int L    = 256;
    const int STEP = 32;
    if(genome.size() < (size_t)L){
        std::fprintf(stderr,"ERROR: Genome shorter than L.\n");
        return 1;
    }

    long long n_windows = ((long long)genome.size() - L) / STEP + 1;
    const int denom_full = L - 1;

    std::printf("Config:\n");
    std::printf("  Window length L    = %d bases\n", L);
    std::printf("  Step size          = %d bases\n", STEP);
    std::printf("  Dinucleotide slots = %d (L-1)\n", denom_full);
    std::printf("  Number of windows  = %lld\n", n_windows);
    std::printf("  Total bases in windows (approx) = %.3f million (with overlap)\n\n",
                (double)L * (double)n_windows / 1e6);

    std::vector<WindowInfo> windows;
    windows.reserve((size_t)n_windows);

    long long total_cpg = 0;
    int min_cpg = 1e9;
    int max_cpg = -1;
    double sum_cpg = 0.0;

    auto t0 = std::chrono::high_resolution_clock::now();
    for(long long w = 0; w < n_windows; ++w){
        long long pos = w * STEP;
        int cpg = 0;
        int gc  = 0;
        // count CpG
        for(int i = 0; i < L-1; ++i){
            char b1 = genome[(size_t)pos + (size_t)i];
            char b2 = genome[(size_t)pos + (size_t)i + 1];
            if(b1 == 'C' && b2 == 'G') cpg++;
        }
        // count GC bases
        for(int i = 0; i < L; ++i){
            char b = genome[(size_t)pos + (size_t)i];
            if(b == 'G' || b == 'C') gc++;
        }

        WindowInfo info;
        info.pos = pos;
        info.cpg = cpg;
        info.gc  = gc;
        windows.push_back(info);

        total_cpg += cpg;
        sum_cpg   += (double)cpg;
        if(cpg < min_cpg) min_cpg = cpg;
        if(cpg > max_cpg) max_cpg = cpg;
    }
    auto t1 = std::chrono::high_resolution_clock::now();
    double ms = std::chrono::duration<double,std::milli>(t1 - t0).count();

    double mean_cpg = sum_cpg / (double)n_windows;
    std::printf("--- Global CpG stats over sliding windows ---\n");
    std::printf("  Total windows           : %lld\n", n_windows);
    std::printf("  Total CpG across windows: %lld\n", total_cpg);
    std::printf("  Mean CpG per window     : %.6f\n", mean_cpg);
    std::printf("  Min CpG per window      : %d\n", min_cpg);
    std::printf("  Max CpG per window      : %d\n", max_cpg);
    std::printf("  Scan time               : %.3f ms\n", ms);
    std::printf("\n");

    // sort copies for top/bottom
    std::vector<WindowInfo> top = windows;
    std::vector<WindowInfo> bot = windows;

    std::sort(top.begin(), top.end(), [](const WindowInfo& a, const WindowInfo& b){
        if(a.cpg != b.cpg) return a.cpg > b.cpg; // descending CpG
        return a.pos < b.pos;
    });
    std::sort(bot.begin(), bot.end(), [](const WindowInfo& a, const WindowInfo& b){
        if(a.cpg != b.cpg) return a.cpg < b.cpg; // ascending CpG
        return a.pos < b.pos;
    });

    auto print_window = [&](const char* label, const WindowInfo& w){
        double cpg_frac = (double)w.cpg / (double)denom_full;
        double gc_frac  = (double)w.gc  / (double)L;
        int g = igcd(w.cpg, denom_full);
        int num = (g == 0) ? 0 : (w.cpg / g);
        int den = (g == 0) ? 1 : (denom_full / g);

        long long pos = w.pos;
        std::string subseq = genome.substr((size_t)pos, (size_t)L);

        std::string head = subseq.substr(0, 80);
        std::string tail = subseq.substr(L - 40, 40);

        std::printf("%s\n", label);
        std::printf("  Genomic start (0-based) : %lld\n", pos);
        std::printf("  CpG count               : %d\n", w.cpg);
        std::printf("  CpG fraction            : %d/%d ≈ %.6f\n", num, den, cpg_frac);
        std::printf("  GC count                : %d\n", w.gc);
        std::printf("  GC fraction             : %.6f\n", gc_frac);
        std::printf("  Sequence (L=256):\n");
        std::printf("    start: %.80s\n", head.c_str());
        std::printf("    end  : %.40s\n", tail.c_str());
        std::printf("\n");
    };

    int n_show = 10;
    if((long long)n_show > n_windows) n_show = (int)n_windows;

    std::printf("--- Top %d CpG HOTSPOTS (highest CpG per 256-bp window) ---\n\n", n_show);
    for(int i=0;i<n_show;i++){
        char label[64];
        std::snprintf(label, sizeof(label), "  [HOTSPOT %2d]", i+1);
        print_window(label, top[i]);
    }

    std::printf("--- Bottom %d CpG DESERTS (lowest CpG per 256-bp window) ---\n\n", n_show);
    for(int i=0;i<n_show;i++){
        char label[64];
        std::snprintf(label, sizeof(label), "  [DESERT  %2d]", i+1);
        print_window(label, bot[i]);
    }

    std::printf("CpG LOCK HOTSPOT LOCATOR finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"[DNA-L5] Writing CpG hotspot CUDA source -> {CUDA_SRC_PATH}")
with open(CUDA_SRC_PATH, "w") as f:
    f.write(cuda_src)

#----------------------------------------------------------------------------------------------------------------------
# Compile with nvcc
#----------------------------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC_PATH,
    "-o",
    EXE_PATH,
]

print("[DNA-L5] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[DNA-L5] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[DNA-L5] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[DNA-L5] Compile OK -> {EXE_PATH}")

#----------------------------------------------------------------------------------------------------------------------
# Run and SHA-256 stdout
#----------------------------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING CpG LOCK HOTSPOT LOCATOR (SLIDING WINDOWS ACROSS GENOME)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[DNA-L5] WARNING: hotspot locator exited with code {run_res.returncode}")
else:
    print("[DNA-L5] CpG hotspot locator completed successfully.")

stdout_bytes = run_res.stdout.encode("utf-8", errors="replace")
digest = hashlib.sha256(stdout_bytes).hexdigest()
print(f"\n[DNA-L5] SHA256(stdout) = {digest}")

print("\n" + "="*118)
print("MODULE DNA-L5 — DONE (CpG LOCK HOTSPOT LOCATOR)")
print("="*118)

#======================================================================================================================
# MODULE DNA-L6 — CpG LOCK HOTSPOT ANNOTATION (E. coli MG1655, L=256, STEP=32)
#
# What this does:
#   • Uses the same E. coli MG1655 FASTA as DNA-L1..L5.
#   • Downloads the GFF3 annotation for the same genome from NCBI.
#   • Re-runs the CpG sliding-window scan:
#       - L = 256, STEP = 32
#       - CpG = # of "CG" dinucleotides per window
#       - GC = # of G or C bases per window
#   • Finds the top 10 CpG HOTSPOTS (highest CpG per window).
#   • For each hotspot:
#       - Print genomic position, CpG count, CpG_frac (reduced), GC_frac.
#       - Show sequence snippet (start/end).
#       - List overlapping GFF features (gene/CDS/etc), with names where available.
#   • Summarizes how many hotspots overlap genes vs are intergenic.
#   • CPU-only C++ (no CUDA kernels), compiled with nvcc for consistency.
#   • Ends with SHA-256(stdout).
#======================================================================================================================
import subprocess, textwrap, hashlib

print("\n" + "="*118)
print("MODULE DNA-L6 — CpG LOCK HOTSPOT ANNOTATION (E. coli MG1655, L=256, STEP=32)")
print("="*118)

FASTA_PATH = "/content/ecoli_U00096_3.fna"
GFF_PATH   = "/content/ecoli_U00096_3.gff"
CUDA_SRC   = "/content/warpfrac_dna_cpg_hotspot_annot.cu"
EXE_PATH   = "/content/warpfrac_dna_cpg_hotspot_annot"

#----------------------------------------------------------------------------------------------------------------------
# Ensure FASTA exists
#----------------------------------------------------------------------------------------------------------------------
print("\n[DNA-L6] Checking for E. coli FASTA at", FASTA_PATH)
prep_fasta_cmd = [
    "bash", "-lc",
    textwrap.dedent(f"""
    set -euo pipefail
    if [ ! -f "{FASTA_PATH}" ]; then
      echo "  -> FASTA not found, fetching NC_000913.3 / U00096.3..."
      wget -q -O "{FASTA_PATH}" "https://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?db=nuccore&id=545778205&report=fasta&retmode=text"
      echo "  -> download complete."
    else
      echo "  -> FASTA found, reusing existing file."
    fi
    """)
]
res_fa = subprocess.run(prep_fasta_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(res_fa.stdout)
if res_fa.returncode != 0:
    print("[DNA-L6] FATAL: FASTA preparation failed.")
    raise SystemExit(1)

#----------------------------------------------------------------------------------------------------------------------
# Ensure GFF annotation exists
#----------------------------------------------------------------------------------------------------------------------
print("[DNA-L6] Checking for E. coli GFF3 at", GFF_PATH)
prep_gff_cmd = [
    "bash", "-lc",
    textwrap.dedent(f"""
    set -euo pipefail
    if [ ! -f "{GFF_PATH}" ]; then
      echo "  -> GFF not found, fetching NC_000913.3 GFF3 from NCBI..."
      wget -q -O "{GFF_PATH}" "https://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?db=nuccore&id=545778205&report=gff3&retmode=text"
      echo "  -> download complete."
    else
      echo "  -> GFF found, reusing existing file."
    fi
    """)
]
res_gff = subprocess.run(prep_gff_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(res_gff.stdout)
if res_gff.returncode != 0:
    print("[DNA-L6] FATAL: GFF preparation failed.")
    raise SystemExit(1)

#----------------------------------------------------------------------------------------------------------------------
# Write C++ host program (CPU-only, parse FASTA + GFF, annotate hotspots)
#----------------------------------------------------------------------------------------------------------------------
cuda_src = r'''
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <chrono>

//------------------ helpers -------------------------------------------------------
char norm_base(char c){
    switch(c){
        case 'A': case 'a': return 'A';
        case 'C': case 'c': return 'C';
        case 'G': case 'g': return 'G';
        case 'T': case 't': return 'T';
        default:            return 'A';  // normalize ambiguous to A
    }
}

std::string load_fasta_sequence(const char* path, std::string& header_out){
    std::ifstream in(path);
    if(!in){
        std::fprintf(stderr,"ERROR: Cannot open FASTA file: %s\n", path);
        std::exit(1);
    }
    std::string line;
    std::string seq;
    header_out.clear();
    while(std::getline(in, line)){
        if(line.empty()) continue;
        if(line[0] == '>'){
            if(header_out.empty()){
                header_out = line.substr(1);
            }
            continue;
        }
        for(char c : line){
            if(c == '\n' || c == '\r') continue;
            seq.push_back(norm_base(c));
        }
    }
    return seq;
}

int igcd(int a, int b){
    if(a < 0) a = -a;
    if(b < 0) b = -b;
    if(a == 0) return (b == 0) ? 1 : b;
    if(b == 0) return a;
    while(b != 0){
        int t = a % b;
        a = b;
        b = t;
    }
    return (a == 0) ? 1 : a;
}

//------------------ GFF parsing ---------------------------------------------------
struct Feature {
    long long start0;  // 0-based inclusive
    long long end0;    // 0-based inclusive
    std::string type;
    char strand;
    std::string attrs;
};

std::string extract_attr(const std::string& attrs, const char* key){
    // attributes like: "ID=gene0;Name=thrL;locus_tag=b0001;..."
    std::string k(key);
    k.push_back('=');
    size_t pos = attrs.find(k);
    if(pos == std::string::npos) return std::string();
    pos += k.size();
    size_t end = attrs.find(';', pos);
    if(end == std::string::npos) end = attrs.size();
    return attrs.substr(pos, end - pos);
}

std::vector<Feature> load_gff_features(const char* path){
    std::ifstream in(path);
    if(!in){
        std::fprintf(stderr,"ERROR: Cannot open GFF file: %s\n", path);
        std::exit(1);
    }
    std::vector<Feature> feats;
    std::string line;
    while(std::getline(in, line)){
        if(line.empty()) continue;
        if(line[0] == '#') continue;
        std::stringstream ss(line);
        std::string seqid, source, type, start_s, end_s, score, strand_s, phase, attrs;
        if(!std::getline(ss, seqid, '\t')) continue;
        if(!std::getline(ss, source, '\t')) continue;
        if(!std::getline(ss, type,  '\t')) continue;
        if(!std::getline(ss, start_s,'\t')) continue;
        if(!std::getline(ss, end_s,  '\t')) continue;
        if(!std::getline(ss, score, '\t')) continue;
        if(!std::getline(ss, strand_s,'\t')) continue;
        if(!std::getline(ss, phase, '\t')) continue;
        std::getline(ss, attrs); // remainder

        long long start1 = std::atoll(start_s.c_str());
        long long end1   = std::atoll(end_s.c_str());
        if(start1 <= 0 || end1 <= 0) continue;
        if(end1 < start1) continue;

        Feature f;
        f.start0 = start1 - 1;   // convert to 0-based
        f.end0   = end1 - 1;
        f.type   = type;
        f.strand = strand_s.empty() ? '.' : strand_s[0];
        f.attrs  = attrs;
        feats.push_back(f);
    }
    return feats;
}

//------------------ main ----------------------------------------------------------
int main(){
    std::printf("\n====================================================================================\n");
    std::printf("CpG LOCK HOTSPOT ANNOTATION — E. coli K-12 MG1655, L=256, STEP=32\n");
    std::printf("====================================================================================\n");
    std::printf("We:\n");
    std::printf("  1) Slide a 256-bp window across the real E. coli genome (step=32).\n");
    std::printf("  2) Count CpG = # 'CG' pairs and GC = # of G/C bases per window.\n");
    std::printf("  3) Find the top 10 CpG-rich windows (hotspots).\n");
    std::printf("  4) Annotate each hotspot with overlapping GFF features (genes/CDS/etc).\n\n");

    const char* fasta_path = "/content/ecoli_U00096_3.fna";
    const char* gff_path   = "/content/ecoli_U00096_3.gff";

    std::string header;
    std::string genome = load_fasta_sequence(fasta_path, header);
    if(genome.size() < 1000){
        std::fprintf(stderr,"ERROR: Genome too small or FASTA parse failed (len=%zu).\n", genome.size());
        return 1;
    }

    std::printf("Loaded FASTA: %s\n", fasta_path);
    if(!header.empty())
        std::printf("FASTA header: %s\n", header.c_str());
    std::printf("Genome length: %zu bases\n\n", genome.size());

    std::printf("Loading GFF annotation from: %s\n", gff_path);
    std::vector<Feature> feats = load_gff_features(gff_path);
    std::printf("Loaded %zu GFF features (genes, CDS, RNAs, etc.)\n\n", feats.size());

    const int L    = 256;
    const int STEP = 32;
    const int denom_full = L - 1;

    if(genome.size() < (size_t)L){
        std::fprintf(stderr,"ERROR: Genome shorter than L.\n");
        return 1;
    }

    long long n_windows = ((long long)genome.size() - L) / STEP + 1;

    std::printf("Sliding-window config:\n");
    std::printf("  Window length L    = %d bases\n", L);
    std::printf("  Step size          = %d bases\n", STEP);
    std::printf("  Dinucleotide slots = %d (L-1)\n", denom_full);
    std::printf("  Number of windows  = %lld\n\n", n_windows);

    struct WindowInfo {
        long long pos; // 0-based
        int cpg;
        int gc;
    };
    std::vector<WindowInfo> wins;
    wins.reserve((size_t)n_windows);

    long long total_cpg = 0;
    int min_cpg = 1e9;
    int max_cpg = -1;
    double sum_cpg = 0.0;

    auto t0 = std::chrono::high_resolution_clock::now();
    for(long long w = 0; w < n_windows; ++w){
        long long pos = w * STEP;
        int cpg = 0;
        int gc  = 0;
        for(int i = 0; i < L-1; ++i){
            char b1 = genome[(size_t)pos + (size_t)i];
            char b2 = genome[(size_t)pos + (size_t)i + 1];
            if(b1 == 'C' && b2 == 'G') cpg++;
        }
        for(int i = 0; i < L; ++i){
            char b = genome[(size_t)pos + (size_t)i];
            if(b == 'G' || b == 'C') gc++;
        }
        WindowInfo wi{pos, cpg, gc};
        wins.push_back(wi);
        total_cpg += cpg;
        sum_cpg   += (double)cpg;
        if(cpg < min_cpg) min_cpg = cpg;
        if(cpg > max_cpg) max_cpg = cpg;
    }
    auto t1 = std::chrono::high_resolution_clock::now();
    double ms = std::chrono::duration<double,std::milli>(t1 - t0).count();

    double mean_cpg = sum_cpg / (double)n_windows;
    std::printf("--- Global CpG stats over sliding windows ---\n");
    std::printf("  Total windows           : %lld\n", n_windows);
    std::printf("  Total CpG across windows: %lld\n", total_cpg);
    std::printf("  Mean CpG per window     : %.6f\n", mean_cpg);
    std::printf("  Min CpG per window      : %d\n", min_cpg);
    std::printf("  Max CpG per window      : %d\n", max_cpg);
    std::printf("  Scan time               : %.3f ms\n\n", ms);

    // sort copy for hotspots
    std::vector<WindowInfo> top = wins;
    std::sort(top.begin(), top.end(), [](const WindowInfo& a, const WindowInfo& b){
        if(a.cpg != b.cpg) return a.cpg > b.cpg; // descending by CpG
        return a.pos < b.pos;
    });

    int n_show = 10;
    if((long long)n_show > n_windows) n_show = (int)n_windows;

    auto annot_window = [&](const WindowInfo& w){
        long long w_start = w.pos;
        long long w_end   = w.pos + (L - 1); // inclusive

        double cpg_frac = (double)w.cpg / (double)denom_full;
        double gc_frac  = (double)w.gc  / (double)L;
        int g = igcd(w.cpg, denom_full);
        int num = (g == 0) ? 0 : (w.cpg / g);
        int den = (g == 0) ? 1 : (denom_full / g);

        std::string subseq = genome.substr((size_t)w_start, (size_t)L);
        std::string head = subseq.substr(0, 80);
        std::string tail = subseq.substr(L - 40, 40);

        std::printf("  Genomic window:\n");
        std::printf("    start (0-based)       : %lld\n", w_start);
        std::printf("    end   (0-based, incl) : %lld\n", w_end);
        std::printf("  CpG / GC:\n");
        std::printf("    CpG count             : %d\n", w.cpg);
        std::printf("    CpG fraction          : %d/%d ≈ %.6f\n", num, den, cpg_frac);
        std::printf("    GC count              : %d\n", w.gc);
        std::printf("    GC fraction           : %.6f\n", gc_frac);
        std::printf("  Sequence (L=256):\n");
        std::printf("    start: %.80s\n", head.c_str());
        std::printf("    end  : %.40s\n", tail.c_str());
        std::printf("\n");

        // find overlapping features
        std::printf("  Overlapping GFF features:\n");
        int hits = 0;
        for(const auto& f : feats){
            if(f.end0 < w_start) continue;
            if(f.start0 > w_end) continue;
            // overlap
            hits++;
            std::string name = extract_attr(f.attrs, "gene");
            if(name.empty()) name = extract_attr(f.attrs, "locus_tag");
            if(name.empty()) name = extract_attr(f.attrs, "product");
            if(name.empty()) name = "(no-name)";

            std::printf("    - type=%s, range=%lld-%lld (0-based), strand=%c\n",
                        f.type.c_str(), f.start0, f.end0, f.strand);
            std::printf("      name: %s\n", name.c_str());
        }
        if(hits == 0){
            std::printf("    (none — window is intergenic or unannotated)\n");
        }
        std::printf("\n");
    };

    std::printf("--- Top %d CpG HOTSPOTS with GFF annotation ---\n\n", n_show);

    int gene_overlap_count = 0;
    for(int i = 0; i < n_show; ++i){
        const WindowInfo& w = top[i];
        std::printf("[HOTSPOT %2d]\n", i+1);
        annot_window(w);

        // For summary, count if it overlaps any 'gene' or 'CDS'
        long long w_start = w.pos;
        long long w_end   = w.pos + (L - 1);
        bool overlaps_gene = false;
        for(const auto& f : feats){
            if(f.end0 < w_start) continue;
            if(f.start0 > w_end) continue;
            if(f.type == "gene" || f.type == "CDS"){
                overlaps_gene = true;
                break;
            }
        }
        if(overlaps_gene) gene_overlap_count++;
    }

    std::printf("Summary over top %d CpG hotspots:\n", n_show);
    std::printf("  Hotspots overlapping at least one gene/CDS: %d / %d\n", gene_overlap_count, n_show);
    std::printf("  Hotspots with no gene/CDS overlap         : %d / %d\n",
                n_show - gene_overlap_count, n_show);
    std::printf("\nCpG LOCK HOTSPOT ANNOTATION finished.\n");
    std::printf("====================================================================================\n");
    return 0;
}
'''

print(f"[DNA-L6] Writing hotspot-annotation CUDA source -> {CUDA_SRC}")
with open(CUDA_SRC, "w") as f:
    f.write(cuda_src)

#----------------------------------------------------------------------------------------------------------------------
# Compile with nvcc (CPU-only code, but we use nvcc for consistency)
#----------------------------------------------------------------------------------------------------------------------
compile_cmd = [
    "nvcc",
    "-O3",
    "-std=c++17",
    "-gencode=arch=compute_80,code=sm_80",
    CUDA_SRC,
    "-o",
    EXE_PATH,
]

print("[DNA-L6] Compiling with:", " ".join(compile_cmd))
comp = subprocess.run(compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print("[DNA-L6] nvcc output:")
print(comp.stdout)
if comp.returncode != 0:
    print("[DNA-L6] FATAL: nvcc failed with return code", comp.returncode)
    raise SystemExit(1)

print(f"[DNA-L6] Compile OK -> {EXE_PATH}")

#----------------------------------------------------------------------------------------------------------------------
# Run and SHA-256(stdout)
#----------------------------------------------------------------------------------------------------------------------
print("\n" + "-"*118)
print("RUNNING CpG LOCK HOTSPOT ANNOTATION (SLIDING WINDOWS + GFF FEATURE OVERLAP)")
print("-"*118)

run_res = subprocess.run([EXE_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
print(run_res.stdout)

if run_res.returncode != 0:
    print(f"[DNA-L6] WARNING: hotspot annotation exited with code {run_res.returncode}")
else:
    print("[DNA-L6] CpG hotspot annotation completed successfully.")

stdout_bytes = run_res.stdout.encode("utf-8", errors="replace")
digest = hashlib.sha256(stdout_bytes).hexdigest()
print(f"\n[DNA-L6] SHA256(stdout) = {digest}")

print("\n" + "="*118)
print("MODULE DNA-L6 — DONE (CpG LOCK HOTSPOT ANNOTATION)")
print("="*118)

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# echo "======================================================================================================================"
# echo "MODULE DNA-L7 — GENE-WISE CpG/GC LOCK CENSUS (E. coli MG1655, FULL GENOME)"
# echo "======================================================================================================================"
# echo
# 
# FASTA_PATH="/content/ecoli_U00096_3.fna"
# GFF_PATH="/content/ecoli_U00096_3.gff"
# 
# # Make sure FASTA exists (reuse from earlier modules or download)
# if [[ ! -f "${FASTA_PATH}" ]]; then
#   echo "[DNA-L7] FASTA not found at ${FASTA_PATH}, fetching NC_000913.3 / U00096.3..."
#   curl -L -o "${FASTA_PATH}" "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna"
#   echo "  -> FASTA download complete."
# else
#   echo "[DNA-L7] FASTA found at ${FASTA_PATH}, reusing existing file."
# fi
# 
# # Make sure GFF exists (reuse from earlier modules or download)
# if [[ ! -f "${GFF_PATH}" ]]; then
#   echo "[DNA-L7] GFF not found at ${GFF_PATH}, fetching NC_000913.3 GFF3..."
#   curl -L -o "${GFF_PATH}" "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.gff"
#   echo "  -> GFF download complete."
# else
#   echo "[DNA-L7] GFF found at ${GFF_PATH}, reusing existing file."
# fi
# 
# echo
# echo "[DNA-L7] Writing gene-wise CpG/GC census CUDA source -> /content/warpfrac_dna_cpg_gene_census.cu"
# 
# cat >/content/warpfrac_dna_cpg_gene_census.cu <<'CPP'
# // warpfrac_dna_cpg_gene_census.cu
# // GENE-WISE CpG/GC LOCK CENSUS for E. coli MG1655
# // CPU-only analysis compiled with nvcc, no GPU needed in this module.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cstdint>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cctype>
# #include <numeric>
# #include <iostream>
# #include <cmath>
# 
# struct GeneFeature {
#     std::string name;
#     std::string type;  // "gene"
#     long long start;   // 0-based inclusive
#     long long end;     // 0-based inclusive
#     char strand;       // '+', '-', or '.'
# };
# 
# static void die(const char* msg) {
#     std::fprintf(stderr, "FATAL: %s\n", msg);
#     std::exit(1);
# }
# 
# // Trim whitespace from both ends
# static std::string trim(const std::string& s) {
#     size_t b = 0, e = s.size();
#     while (b < e && std::isspace(static_cast<unsigned char>(s[b]))) ++b;
#     while (e > b && std::isspace(static_cast<unsigned char>(s[e-1]))) --e;
#     return s.substr(b, e-b);
# }
# 
# // Split by a single character delimiter
# static std::vector<std::string> split(const std::string& s, char delim) {
#     std::vector<std::string> out;
#     std::string cur;
#     for(char c : s) {
#         if (c == delim) {
#             out.push_back(cur);
#             cur.clear();
#         } else {
#             cur.push_back(c);
#         }
#     }
#     out.push_back(cur);
#     return out;
# }
# 
# // Extract a human-friendly name from GFF attributes field
# static std::string parse_gff_name(const std::string& attr) {
#     // Look for common tags: gene=, Name=, locus_tag=
#     const char* keys[] = {"gene=", "Name=", "locus_tag="};
#     for (const char* key : keys) {
#         size_t pos = attr.find(key);
#         if (pos != std::string::npos) {
#             pos += std::strlen(key);
#             size_t end = attr.find(';', pos);
#             if (end == std::string::npos) end = attr.size();
#             std::string val = attr.substr(pos, end-pos);
#             val = trim(val);
#             if (!val.empty()) return val;
#         }
#     }
#     return "(no-name)";
# }
# 
# // Load whole genome from FASTA (first sequence only)
# static std::string load_fasta_single(const std::string& path, std::string& header_out) {
#     std::ifstream in(path);
#     if (!in) die("Failed to open FASTA file");
#     std::string line;
#     std::string seq;
#     header_out.clear();
#     bool in_seq = false;
#     while (std::getline(in, line)) {
#         if (!line.empty() && line[0] == '>') {
#             if (!header_out.empty()) {
#                 // already read a header+sequence; assume single contig
#                 break;
#             }
#             header_out = line.substr(1); // drop '>'
#             in_seq = true;
#         } else if (in_seq) {
#             for (char c : line) {
#                 if (!std::isspace(static_cast<unsigned char>(c))) {
#                     seq.push_back(std::toupper(static_cast<unsigned char>(c)));
#                 }
#             }
#         }
#     }
#     return seq;
# }
# 
# // Load gene features from GFF (we keep only "gene" type)
# static std::vector<GeneFeature> load_genes_from_gff(const std::string& path) {
#     std::ifstream in(path);
#     if (!in) die("Failed to open GFF file");
#     std::vector<GeneFeature> genes;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         auto cols = split(line, '\t');
#         if (cols.size() < 9) continue;
#         std::string type = cols[2];
#         if (type != "gene") continue; // gene-level census only
#         long long start1 = std::atoll(cols[3].c_str());
#         long long end1   = std::atoll(cols[4].c_str());
#         if (start1 <= 0 || end1 <= 0 || end1 < start1) continue;
#         char strand = cols[6].empty() ? '.' : cols[6][0];
#         std::string attrs = cols[8];
#         GeneFeature g;
#         g.type = type;
#         g.start = start1 - 1;  // convert to 0-based
#         g.end   = end1   - 1;  // inclusive
#         g.strand = strand;
#         g.name = parse_gff_name(attrs);
#         genes.push_back(g);
#     }
#     return genes;
# }
# 
# struct GeneStat {
#     std::string name;
#     std::string type;
#     long long start;
#     long long end;
#     char strand;
#     long long length;
#     long long cpg;
#     long long gc;
#     double cpg_per_kb;
#     double gc_frac;
#     long long gc_num;
#     long long gc_den;
#     long long cpg_frac_num;
#     long long cpg_frac_den;
# };
# 
# int main() {
#     const char* fasta_path = "/content/ecoli_U00096_3.fna";
#     const char* gff_path   = "/content/ecoli_U00096_3.gff";
# 
#     std::printf("=====================================================================================\n");
#     std::printf("GENE-WISE CpG/GC LOCK CENSUS — E. coli K-12 MG1655 (FULL GENOME)\n");
#     std::printf("=====================================================================================\n");
#     std::printf("We walk every annotated gene in the E. coli MG1655 GFF, and for each gene we count:\n");
#     std::printf("  • GC bases (G + C) and GC fraction = GC / length (as reduced fraction).\n");
#     std::printf("  • CpG dinucleotides ('CG') and CpG per kb, plus CpG_frac = CpG / (length-1).\n");
#     std::printf("All counts are exact over the raw FASTA bases.\n\n");
# 
#     // Load genome
#     std::string header;
#     std::printf("Loading FASTA from: %s\n", fasta_path);
#     std::string genome = load_fasta_single(fasta_path, header);
#     if (genome.empty()) die("Genome sequence is empty");
#     std::printf("FASTA header: %s\n", header.c_str());
#     std::printf("Genome length: %zu bases\n\n", genome.size());
# 
#     // Load GFF genes
#     std::printf("Loading GFF gene annotations from: %s\n", gff_path);
#     std::vector<GeneFeature> genes = load_genes_from_gff(gff_path);
#     if (genes.empty()) die("No gene features parsed from GFF");
#     std::printf("Gene features loaded: %zu\n\n", genes.size());
# 
#     // Compute stats per gene
#     std::vector<GeneStat> stats;
#     stats.reserve(genes.size());
# 
#     long long total_len = 0;
#     long long total_cpg = 0;
#     long long total_gc  = 0;
# 
#     for (const auto& g : genes) {
#         if (g.start < 0 || g.end >= (long long)genome.size()) continue;
#         long long len = g.end - g.start + 1;
#         if (len <= 0) continue;
# 
#         long long gc = 0;
#         long long cpg = 0;
# 
#         // GC bases
#         for (long long i = g.start; i <= g.end; ++i) {
#             char b = genome[(size_t)i];
#             if (b == 'G' || b == 'C') gc++;
#         }
#         // CpG dinucleotides
#         if (len > 1) {
#             for (long long i = g.start; i < g.end; ++i) {
#                 char b1 = genome[(size_t)i];
#                 char b2 = genome[(size_t)(i+1)];
#                 if (b1 == 'C' && b2 == 'G') cpg++;
#             }
#         }
# 
#         GeneStat s;
#         s.name   = g.name;
#         s.type   = g.type;
#         s.start  = g.start;
#         s.end    = g.end;
#         s.strand = g.strand;
#         s.length = len;
#         s.gc     = gc;
#         s.cpg    = cpg;
#         s.cpg_per_kb = (len > 0) ? (double)cpg * 1000.0 / (double)len : 0.0;
#         s.gc_frac    = (len > 0) ? (double)gc / (double)len : 0.0;
#         s.gc_num = gc;
#         s.gc_den = len;
#         if (len > 0) {
#             long long ggc = std::gcd(s.gc_num, s.gc_den);
#             if (ggc != 0) {
#                 s.gc_num /= ggc;
#                 s.gc_den /= ggc;
#             }
#         }
#         if (len > 1) {
#             s.cpg_frac_num = cpg;
#             s.cpg_frac_den = len - 1;
#             long long gcp = std::gcd(s.cpg_frac_num, s.cpg_frac_den);
#             if (gcp != 0) {
#                 s.cpg_frac_num /= gcp;
#                 s.cpg_frac_den /= gcp;
#             }
#         } else {
#             s.cpg_frac_num = 0;
#             s.cpg_frac_den = 1;
#         }
# 
#         stats.push_back(s);
#         total_len += len;
#         total_cpg += cpg;
#         total_gc  += gc;
#     }
# 
#     if (stats.empty()) die("No gene stats computed");
# 
#     std::printf("--- Global gene-wise totals ---\n");
#     std::printf("  Genes analyzed          : %zu\n", stats.size());
#     std::printf("  Sum gene lengths        : %lld bases\n", total_len);
#     std::printf("  Total GC across genes   : %lld bases\n", total_gc);
#     std::printf("  Total CpG across genes  : %lld dinucleotides\n", total_cpg);
#     double mean_gc_frac = (total_len > 0) ? (double)total_gc / (double)total_len : 0.0;
#     double mean_cpg_per_kb = (total_len > 0) ? (double)total_cpg * 1000.0 / (double)total_len : 0.0;
#     std::printf("  Mean GC fraction (len-weighted)     : %.4f\n", mean_gc_frac);
#     std::printf("  Mean CpG per kb (len-weighted)      : %.4f\n\n", mean_cpg_per_kb);
# 
#     // Compute simple per-gene stats (unweighted)
#     double sum_gc_frac = 0.0;
#     double sum_cpg_pkb = 0.0;
#     double min_gc_frac = 1e9, max_gc_frac = -1e9;
#     double min_cpg_pkb = 1e9, max_cpg_pkb = -1e9;
#     for (const auto& s : stats) {
#         sum_gc_frac += s.gc_frac;
#         sum_cpg_pkb += s.cpg_per_kb;
#         if (s.gc_frac < min_gc_frac) min_gc_frac = s.gc_frac;
#         if (s.gc_frac > max_gc_frac) max_gc_frac = s.gc_frac;
#         if (s.cpg_per_kb < min_cpg_pkb) min_cpg_pkb = s.cpg_per_kb;
#         if (s.cpg_per_kb > max_cpg_pkb) max_cpg_pkb = s.cpg_per_kb;
#     }
#     double mean_gc_frac_unw = sum_gc_frac / (double)stats.size();
#     double mean_cpg_pkb_unw = sum_cpg_pkb / (double)stats.size();
# 
#     std::printf("--- Per-gene distribution summary ---\n");
#     std::printf("  GC fraction per gene (unweighted):\n");
#     std::printf("    mean = %.4f, min = %.4f, max = %.4f\n", mean_gc_frac_unw, min_gc_frac, max_gc_frac);
#     std::printf("  CpG per kb per gene (unweighted):\n");
#     std::printf("    mean = %.4f, min = %.4f, max = %.4f\n\n", mean_cpg_pkb_unw, min_cpg_pkb, max_cpg_pkb);
# 
#     // Sort genes by CpG per kb descending
#     std::vector<GeneStat> sorted = stats;
#     std::sort(sorted.begin(), sorted.end(), [](const GeneStat& a, const GeneStat& b){
#         if (a.cpg_per_kb != b.cpg_per_kb) return a.cpg_per_kb > b.cpg_per_kb;
#         return a.length > b.length;
#     });
# 
#     auto print_gene = [](const GeneStat& s, int idx, const char* label) {
#         std::printf("  [%s %2d]\n", label, idx);
#         std::printf("    Gene name            : %s\n", s.name.c_str());
#         std::printf("    Coordinates (0-based): %lld - %lld (len=%lld, strand=%c)\n",
#                     s.start, s.end, s.length, s.strand);
#         std::printf("    CpG count            : %lld\n", s.cpg);
#         std::printf("    CpG per kb           : %.3f\n", s.cpg_per_kb);
#         std::printf("    CpG fraction         : %lld/%lld ≈ %.6f\n",
#                     s.cpg_frac_num, s.cpg_frac_den,
#                     (double)s.cpg_frac_num / (double)s.cpg_frac_den);
#         std::printf("    GC count             : %lld\n", s.gc);
#         std::printf("    GC fraction          : %lld/%lld ≈ %.6f\n",
#                     s.gc_num, s.gc_den,
#                     (double)s.gc_num / (double)s.gc_den);
#         std::printf("\n");
#     };
# 
#     int topN = 10;
#     if ((int)sorted.size() < topN) topN = (int)sorted.size();
# 
#     std::printf("--- Top %d genes by CpG per kb ---\n\n", topN);
#     for (int i = 0; i < topN; ++i) {
#         print_gene(sorted[i], i+1, "TOP");
#     }
# 
#     std::printf("--- Bottom %d genes by CpG per kb ---\n\n", topN);
#     for (int i = 0; i < topN; ++i) {
#         const auto& s = sorted[sorted.size() - 1 - i];
#         print_gene(s, i+1, "LOW");
#     }
# 
#     // Specifically surface yagF (if present) so we can see where it ranks
#     for (const auto& s : sorted) {
#         if (s.name == "yagF") {
#             std::printf("--- Special highlight: yagF ---\n");
#             std::printf("    CpG per kb           : %.3f\n", s.cpg_per_kb);
#             std::printf("    CpG fraction         : %lld/%lld ≈ %.6f\n",
#                         s.cpg_frac_num, s.cpg_frac_den,
#                         (double)s.cpg_frac_num / (double)s.cpg_frac_den);
#             std::printf("    GC fraction          : %lld/%lld ≈ %.6f\n",
#                         s.gc_num, s.gc_den,
#                         (double)s.gc_num / (double)s.gc_den);
#             std::printf("    Coordinates (0-based): %lld - %lld (len=%lld, strand=%c)\n\n",
#                         s.start, s.end, s.length, s.strand);
#             break;
#         }
#     }
# 
#     std::printf("GENE-WISE CpG/GC LOCK CENSUS finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# echo "[DNA-L7] Compiling with: nvcc -O3 -std=c++17 -gencode=arch=compute_80,code=sm_80 /content/warpfrac_dna_cpg_gene_census.cu -o /content/warpfrac_dna_cpg_gene_census"
# nvcc -O3 -std=c++17 -gencode=arch=compute_80,code=sm_80 /content/warpfrac_dna_cpg_gene_census.cu -o /content/warpfrac_dna_cpg_gene_census
# 
# echo
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo "RUNNING GENE-WISE CpG/GC LOCK CENSUS (E. coli, FULL GENOME)"
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo
# 
# # Run and capture stdout for SHA256
# /content/warpfrac_dna_cpg_gene_census | tee /tmp/dna_l7_stdout.txt
# 
# echo
# echo "[DNA-L7] Computing SHA256 of stdout..."
# SHA=$(sha256sum /tmp/dna_l7_stdout.txt | awk '{print $1}')
# echo "[DNA-L7] SHA256(stdout) = ${SHA}"
# echo
# echo "======================================================================================================================"
# echo "MODULE DNA-L7 — DONE (GENE-WISE CpG/GC LOCK CENSUS)"
# echo "======================================================================================================================"
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# echo "======================================================================================================================"
# echo "MODULE DNA-L8 — CODON GC-LOCK CENSUS (E. coli MG1655, CDS-LEVEL)"
# echo "======================================================================================================================"
# echo
# 
# FASTA_PATH="/content/ecoli_U00096_3.fna"
# GFF_PATH="/content/ecoli_U00096_3.gff"
# 
# # Ensure FASTA exists
# if [[ ! -f "${FASTA_PATH}" ]]; then
#   echo "[DNA-L8] FASTA not found at ${FASTA_PATH}, fetching NC_000913.3 / U00096.3..."
#   curl -L -o "${FASTA_PATH}" "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna"
#   echo "  -> FASTA download complete."
# else
#   echo "[DNA-L8] FASTA found at ${FASTA_PATH}, reusing existing file."
# fi
# 
# # Ensure GFF exists
# if [[ ! -f "${GFF_PATH}" ]]; then
#   echo "[DNA-L8] GFF not found at ${GFF_PATH}, fetching NC_000913.3 GFF3..."
#   curl -L -o "${GFF_PATH}" "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.gff"
#   echo "  -> GFF download complete."
# else
#   echo "[DNA-L8] GFF found at ${GFF_PATH}, reusing existing file."
# fi
# 
# echo
# echo "[DNA-L8] Writing codon GC-lock census CUDA source -> /content/warpfrac_dna_codon_gc_lock_census.cu"
# 
# cat >/content/warpfrac_dna_codon_gc_lock_census.cu <<'CPP'
# // warpfrac_dna_codon_gc_lock_census.cu
# // CODON GC-LOCK CENSUS for E. coli MG1655 (CDS-level, CPU-only)
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cstdint>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cctype>
# #include <numeric>
# #include <iostream>
# 
# struct CDSFeature {
#     std::string name;
#     long long start;   // 0-based inclusive
#     long long end;     // 0-based inclusive
#     char strand;       // '+', '-', or '.'
# };
# 
# struct CDSStat {
#     std::string name;
#     long long start;
#     long long end;
#     char strand;
#     long long length_bases;
#     long long total_codons;
#     long long gc_heavy_codons;   // codons with >=2 bases in {G,C}
#     double    gc_heavy_per_codon;
#     long long gc_heavy_num;
#     long long gc_heavy_den;
# };
# 
# static void die(const char* msg) {
#     std::fprintf(stderr, "FATAL: %s\n", msg);
#     std::exit(1);
# }
# 
# // Trim whitespace
# static std::string trim(const std::string& s) {
#     size_t b = 0, e = s.size();
#     while (b < e && std::isspace((unsigned char)s[b])) ++b;
#     while (e > b && std::isspace((unsigned char)s[e-1])) --e;
#     return s.substr(b, e - b);
# }
# 
# // Split by single char
# static std::vector<std::string> split(const std::string& s, char delim) {
#     std::vector<std::string> out;
#     std::string cur;
#     for (char c : s) {
#         if (c == delim) {
#             out.push_back(cur);
#             cur.clear();
#         } else {
#             cur.push_back(c);
#         }
#     }
#     out.push_back(cur);
#     return out;
# }
# 
# // Extract name from GFF attributes
# static std::string parse_gff_name(const std::string& attr) {
#     const char* keys[] = {"gene=", "Name=", "locus_tag="};
#     for (const char* key : keys) {
#         size_t pos = attr.find(key);
#         if (pos != std::string::npos) {
#             pos += std::strlen(key);
#             size_t end = attr.find(';', pos);
#             if (end == std::string::npos) end = attr.size();
#             std::string val = attr.substr(pos, end - pos);
#             val = trim(val);
#             if (!val.empty()) return val;
#         }
#     }
#     return "(no-name)";
# }
# 
# // Load FASTA (single sequence)
# static std::string load_fasta_single(const std::string& path, std::string& header_out) {
#     std::ifstream in(path);
#     if (!in) die("Failed to open FASTA file");
#     std::string line;
#     std::string seq;
#     header_out.clear();
#     bool in_seq = false;
#     while (std::getline(in, line)) {
#         if (!line.empty() && line[0] == '>') {
#             if (!header_out.empty()) {
#                 // Already had a sequence; assume single contig
#                 break;
#             }
#             header_out = line.substr(1);
#             in_seq = true;
#         } else if (in_seq) {
#             for (char c : line) {
#                 if (!std::isspace((unsigned char)c)) {
#                     seq.push_back(std::toupper((unsigned char)c));
#                 }
#             }
#         }
#     }
#     return seq;
# }
# 
# // Load CDS features from GFF
# static std::vector<CDSFeature> load_cds_from_gff(const std::string& path) {
#     std::ifstream in(path);
#     if (!in) die("Failed to open GFF file");
#     std::vector<CDSFeature> cds;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         auto cols = split(line, '\t');
#         if (cols.size() < 9) continue;
#         std::string type = cols[2];
#         if (type != "CDS") continue;
#         long long start1 = std::atoll(cols[3].c_str());
#         long long end1   = std::atoll(cols[4].c_str());
#         if (start1 <= 0 || end1 <= 0 || end1 < start1) continue;
#         char strand = cols[6].empty() ? '.' : cols[6][0];
#         std::string attrs = cols[8];
#         CDSFeature f;
#         f.start = start1 - 1; // 0-based
#         f.end   = end1   - 1;
#         f.strand = strand;
#         f.name = parse_gff_name(attrs);
#         cds.push_back(f);
#     }
#     return cds;
# }
# 
# // Complement a base
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         case 'T': return 'A';
#         default:  return 'N';
#     }
# }
# 
# // Reverse complement of a string (assumes A/C/G/T/N)
# static std::string revcomp(const std::string& s) {
#     std::string out;
#     out.reserve(s.size());
#     for (auto it = s.rbegin(); it != s.rend(); ++it) {
#         out.push_back(comp_base(*it));
#     }
#     return out;
# }
# 
# // Check if codon is GC-heavy: >= 2 of 3 bases in {G,C}
# static bool is_gc_heavy_codon(const char* codon) {
#     int gc = 0;
#     for (int i = 0; i < 3; ++i) {
#         char b = codon[i];
#         if (b == 'G' || b == 'C') gc++;
#     }
#     return gc >= 2;
# }
# 
# // Check if codon is valid A/C/G/T only
# static bool is_valid_codon(const char* codon) {
#     for (int i = 0; i < 3; ++i) {
#         char b = codon[i];
#         if (b != 'A' && b != 'C' && b != 'G' && b != 'T') return false;
#     }
#     return true;
# }
# 
# int main() {
#     const char* fasta_path = "/content/ecoli_U00096_3.fna";
#     const char* gff_path   = "/content/ecoli_U00096_3.gff";
# 
#     std::printf("=====================================================================================\n");
#     std::printf("CODON GC-LOCK CENSUS — E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n");
#     std::printf("We walk every CDS (protein-coding gene) in the GFF and:\n");
#     std::printf("  • Extract its coding sequence (respecting strand, reverse-complementing '-' CDS).\n");
#     std::printf("  • Split into codons (triplets, len divisible by 3 where possible).\n");
#     std::printf("  • Count 'GC-heavy' codons: codons with at least 2 of 3 bases in {G,C}.\n");
#     std::printf("  • Compute an exact fraction GC_heavy_codons / total_codons, reduced to lowest terms.\n");
#     std::printf("All counts are exact over the raw FASTA bases (A/C/G/T only; codons with N are skipped).\n\n");
# 
#     // Load genome
#     std::string header;
#     std::printf("Loading FASTA from: %s\n", fasta_path);
#     std::string genome = load_fasta_single(fasta_path, header);
#     if (genome.empty()) die("Genome sequence is empty");
#     std::printf("FASTA header: %s\n", header.c_str());
#     std::printf("Genome length: %zu bases\n\n", genome.size());
# 
#     // Load CDS
#     std::printf("Loading CDS annotations from: %s\n", gff_path);
#     std::vector<CDSFeature> cds_list = load_cds_from_gff(gff_path);
#     if (cds_list.empty()) die("No CDS features parsed from GFF");
#     std::printf("CDS features loaded: %zu\n\n", cds_list.size());
# 
#     std::vector<CDSStat> stats;
#     stats.reserve(cds_list.size());
# 
#     long long total_bases = 0;
#     long long total_codons = 0;
#     long long total_gc_heavy = 0;
# 
#     int skipped_len_not_multiple_of_3 = 0;
#     int skipped_out_of_range = 0;
# 
#     for (const auto& f : cds_list) {
#         if (f.start < 0 || f.end >= (long long)genome.size()) {
#             skipped_out_of_range++;
#             continue;
#         }
#         long long len = f.end - f.start + 1;
#         if (len <= 0) continue;
#         if (len % 3 != 0) {
#             skipped_len_not_multiple_of_3++;
#             continue;
#         }
# 
#         std::string seq = genome.substr((size_t)f.start, (size_t)len);
#         if (f.strand == '-') {
#             seq = revcomp(seq);
#         }
# 
#         long long codons = 0;
#         long long gc_heavy = 0;
# 
#         for (long long i = 0; i + 2 < len; i += 3) {
#             char codon[3];
#             codon[0] = seq[(size_t)i];
#             codon[1] = seq[(size_t)i+1];
#             codon[2] = seq[(size_t)i+2];
#             if (!is_valid_codon(codon)) continue; // skip codons with ambiguous bases
#             codons++;
#             if (is_gc_heavy_codon(codon)) gc_heavy++;
#         }
# 
#         if (codons == 0) continue;
# 
#         CDSStat s;
#         s.name = f.name;
#         s.start = f.start;
#         s.end = f.end;
#         s.strand = f.strand;
#         s.length_bases = len;
#         s.total_codons = codons;
#         s.gc_heavy_codons = gc_heavy;
#         s.gc_heavy_per_codon = (double)gc_heavy / (double)codons;
# 
#         s.gc_heavy_num = gc_heavy;
#         s.gc_heavy_den = codons;
#         long long g = std::gcd(s.gc_heavy_num, s.gc_heavy_den);
#         if (g != 0) {
#             s.gc_heavy_num /= g;
#             s.gc_heavy_den /= g;
#         }
# 
#         stats.push_back(s);
#         total_bases += len;
#         total_codons += codons;
#         total_gc_heavy += gc_heavy;
#     }
# 
#     if (stats.empty()) die("No CDS stats computed");
# 
#     std::printf("--- Global CDS-wise totals ---\n");
#     std::printf("  CDS analyzed                    : %zu\n", stats.size());
#     std::printf("  Sum CDS lengths                 : %lld bases\n", total_bases);
#     std::printf("  Sum valid codons (A/C/G/T only): %lld\n", total_codons);
#     std::printf("  Total GC-heavy codons           : %lld\n", total_gc_heavy);
#     double mean_gc_heavy_frac_weighted = (total_codons > 0) ? (double)total_gc_heavy / (double)total_codons : 0.0;
#     std::printf("  Mean GC-heavy fraction (codon-weighted): %.4f\n\n", mean_gc_heavy_frac_weighted);
# 
#     if (skipped_len_not_multiple_of_3 > 0) {
#         std::printf("  NOTE: CDS skipped (len %% 3 != 0): %d\n", skipped_len_not_multiple_of_3);
#     }
#     if (skipped_out_of_range > 0) {
#         std::printf("  NOTE: CDS skipped (coords out of FASTA range): %d\n", skipped_out_of_range);
#     }
#     std::printf("\n");
# 
#     // Per-CDS distribution (unweighted)
#     double sum_frac = 0.0;
#     double min_frac = 1e9, max_frac = -1e9;
#     for (const auto& s : stats) {
#         sum_frac += s.gc_heavy_per_codon;
#         if (s.gc_heavy_per_codon < min_frac) min_frac = s.gc_heavy_per_codon;
#         if (s.gc_heavy_per_codon > max_frac) max_frac = s.gc_heavy_per_codon;
#     }
#     double mean_frac_unw = sum_frac / (double)stats.size();
#     std::printf("--- Per-CDS GC-heavy fraction distribution ---\n");
#     std::printf("  GC-heavy fraction per CDS (unweighted):\n");
#     std::printf("    mean = %.4f, min = %.4f, max = %.4f\n\n",
#                 mean_frac_unw, min_frac, max_frac);
# 
#     // Sort by GC-heavy per codon
#     std::vector<CDSStat> sorted = stats;
#     std::sort(sorted.begin(), sorted.end(), [](const CDSStat& a, const CDSStat& b){
#         if (a.gc_heavy_per_codon != b.gc_heavy_per_codon)
#             return a.gc_heavy_per_codon > b.gc_heavy_per_codon;
#         return a.total_codons > b.total_codons;
#     });
# 
#     auto print_cds = [](const CDSStat& s, int idx, const char* label) {
#         std::printf("  [%s %2d]\n", label, idx);
#         std::printf("    CDS name              : %s\n", s.name.c_str());
#         std::printf("    Coordinates (0-based) : %lld - %lld (len=%lld, strand=%c)\n",
#                     s.start, s.end, s.length_bases, s.strand);
#         std::printf("    Total codons          : %lld\n", s.total_codons);
#         std::printf("    GC-heavy codons       : %lld\n", s.gc_heavy_codons);
#         std::printf("    GC-heavy per codon    : %.4f\n", s.gc_heavy_per_codon);
#         std::printf("    GC-heavy fraction     : %lld/%lld ≈ %.6f\n",
#                     s.gc_heavy_num, s.gc_heavy_den,
#                     (double)s.gc_heavy_num / (double)s.gc_heavy_den);
#         std::printf("\n");
#     };
# 
#     int topN = 10;
#     if ((int)sorted.size() < topN) topN = (int)sorted.size();
# 
#     std::printf("--- Top %d CDS by GC-heavy codons per codon ---\n\n", topN);
#     for (int i = 0; i < topN; ++i) {
#         print_cds(sorted[i], i+1, "TOP");
#     }
# 
#     std::printf("--- Bottom %d CDS by GC-heavy codons per codon ---\n\n", topN);
#     for (int i = 0; i < topN; ++i) {
#         const auto& s = sorted[sorted.size() - 1 - i];
#         print_cds(s, i+1, "LOW");
#     }
# 
#     // Highlight yagF CDS if present
#     for (const auto& s : sorted) {
#         if (s.name == "yagF") {
#             std::printf("--- Special highlight: yagF CDS ---\n");
#             std::printf("    GC-heavy per codon    : %.4f\n", s.gc_heavy_per_codon);
#             std::printf("    GC-heavy fraction     : %lld/%lld ≈ %.6f\n",
#                         s.gc_heavy_num, s.gc_heavy_den,
#                         (double)s.gc_heavy_num / (double)s.gc_heavy_den);
#             std::printf("    Total codons          : %lld\n", s.total_codons);
#             std::printf("    Coordinates (0-based) : %lld - %lld (len=%lld, strand=%c)\n\n",
#                         s.start, s.end, s.length_bases, s.strand);
#             break;
#         }
#     }
# 
#     std::printf("CODON GC-LOCK CENSUS finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# echo "[DNA-L8] Compiling with: nvcc -O3 -std=c++17 -gencode=arch=compute_80,code=sm_80 /content/warpfrac_dna_codon_gc_lock_census.cu -o /content/warpfrac_dna_codon_gc_lock_census"
# nvcc -O3 -std=c++17 -gencode=arch=compute_80,code=sm_80 /content/warpfrac_dna_codon_gc_lock_census.cu -o /content/warpfrac_dna_codon_gc_lock_census
# 
# echo
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo "RUNNING CODON GC-LOCK CENSUS (E. coli, CDS-level)"
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo
# 
# /content/warpfrac_dna_codon_gc_lock_census | tee /tmp/dna_l8_stdout.txt
# 
# echo
# echo "[DNA-L8] Computing SHA256 of stdout..."
# SHA=$(sha256sum /tmp/dna_l8_stdout.txt | awk '{print $1}')
# echo "[DNA-L8] SHA256(stdout) = ${SHA}"
# echo
# echo "======================================================================================================================"
# echo "MODULE DNA-L8 — DONE (CODON GC-LOCK CENSUS)"
# echo "======================================================================================================================"
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# echo "======================================================================================================================"
# echo "MODULE DNA-L9 — CODON-POSITION GC LOCK CENSUS (E. coli MG1655, CDS-LEVEL)"
# echo "======================================================================================================================"
# echo
# 
# FASTA_PATH="/content/ecoli_U00096_3.fna"
# GFF_PATH="/content/ecoli_U00096_3.gff"
# 
# # Ensure FASTA exists
# if [[ ! -f "${FASTA_PATH}" ]]; then
#   echo "[DNA-L9] FASTA not found at ${FASTA_PATH}, fetching NC_000913.3 / U00096.3..."
#   curl -L -o "${FASTA_PATH}" "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna"
#   echo "  -> FASTA download complete."
# else
#   echo "[DNA-L9] FASTA found at ${FASTA_PATH}, reusing existing file."
# fi
# 
# # Ensure GFF exists
# if [[ ! -f "${GFF_PATH}" ]]; then
#   echo "[DNA-L9] GFF not found at ${GFF_PATH}, fetching NC_000913.3 GFF3..."
#   curl -L -o "${GFF_PATH}" "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.gff"
#   echo "  -> GFF download complete."
# else
#   echo "[DNA-L9] GFF found at ${GFF_PATH}, reusing existing file."
# fi
# 
# echo
# echo "[DNA-L9] Writing codon-position GC-lock census CUDA source -> /content/warpfrac_dna_codon_pos_gc_lock.cu"
# 
# cat >/content/warpfrac_dna_codon_pos_gc_lock.cu <<'CPP'
# // warpfrac_dna_codon_pos_gc_lock.cu
# // CODON-POSITION GC LOCK CENSUS for E. coli MG1655 (CDS-level, CPU-only)
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cstdint>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cctype>
# #include <numeric>
# 
# struct CDSFeature {
#     std::string name;
#     long long start;   // 0-based inclusive
#     long long end;     // 0-based inclusive
#     char strand;       // '+', '-', or '.'
# };
# 
# struct CDSPosStat {
#     std::string name;
#     long long start;
#     long long end;
#     char strand;
#     long long length_bases;
#     long long total_codons;
#     long long gc1;   // GC at codon position 1
#     long long gc2;   // GC at codon position 2
#     long long gc3;   // GC at codon position 3
#     double    gc1_frac;
#     double    gc2_frac;
#     double    gc3_frac;
#     long long gc3_num;
#     long long gc3_den;
# };
# 
# static void die(const char* msg) {
#     std::fprintf(stderr, "FATAL: %s\n", msg);
#     std::exit(1);
# }
# 
# // Trim whitespace
# static std::string trim(const std::string& s) {
#     size_t b = 0, e = s.size();
#     while (b < e && std::isspace((unsigned char)s[b])) ++b;
#     while (e > b && std::isspace((unsigned char)s[e-1])) --e;
#     return s.substr(b, e - b);
# }
# 
# // Split by single char
# static std::vector<std::string> split(const std::string& s, char delim) {
#     std::vector<std::string> out;
#     std::string cur;
#     for (char c : s) {
#         if (c == delim) {
#             out.push_back(cur);
#             cur.clear();
#         } else {
#             cur.push_back(c);
#         }
#     }
#     out.push_back(cur);
#     return out;
# }
# 
# // Extract name from GFF attributes
# static std::string parse_gff_name(const std::string& attr) {
#     const char* keys[] = {"gene=", "Name=", "locus_tag="};
#     for (const char* key : keys) {
#         size_t pos = attr.find(key);
#         if (pos != std::string::npos) {
#             pos += std::strlen(key);
#             size_t end = attr.find(';', pos);
#             if (end == std::string::npos) end = attr.size();
#             std::string val = attr.substr(pos, end - pos);
#             val = trim(val);
#             if (!val.empty()) return val;
#         }
#     }
#     return "(no-name)";
# }
# 
# // Load FASTA (single sequence)
# static std::string load_fasta_single(const std::string& path, std::string& header_out) {
#     std::ifstream in(path);
#     if (!in) die("Failed to open FASTA file");
#     std::string line;
#     std::string seq;
#     header_out.clear();
#     bool in_seq = false;
#     while (std::getline(in, line)) {
#         if (!line.empty() && line[0] == '>') {
#             if (!header_out.empty()) {
#                 // Already saw a header, assume single contig
#                 break;
#             }
#             header_out = line.substr(1);
#             in_seq = true;
#         } else if (in_seq) {
#             for (char c : line) {
#                 if (!std::isspace((unsigned char)c)) {
#                     seq.push_back(std::toupper((unsigned char)c));
#                 }
#             }
#         }
#     }
#     return seq;
# }
# 
# // Load CDS features from GFF
# static std::vector<CDSFeature> load_cds_from_gff(const std::string& path) {
#     std::ifstream in(path);
#     if (!in) die("Failed to open GFF file");
#     std::vector<CDSFeature> cds;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         auto cols = split(line, '\t');
#         if (cols.size() < 9) continue;
#         std::string type = cols[2];
#         if (type != "CDS") continue;
#         long long start1 = std::atoll(cols[3].c_str());
#         long long end1   = std::atoll(cols[4].c_str());
#         if (start1 <= 0 || end1 <= 0 || end1 < start1) continue;
#         char strand = cols[6].empty() ? '.' : cols[6][0];
#         std::string attrs = cols[8];
#         CDSFeature f;
#         f.start = start1 - 1; // 0-based inclusive
#         f.end   = end1   - 1;
#         f.strand = strand;
#         f.name = parse_gff_name(attrs);
#         cds.push_back(f);
#     }
#     return cds;
# }
# 
# // Complement a base
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         case 'T': return 'A';
#         default:  return 'N';
#     }
# }
# 
# // Reverse complement of a string (A/C/G/T/N)
# static std::string revcomp(const std::string& s) {
#     std::string out;
#     out.reserve(s.size());
#     for (auto it = s.rbegin(); it != s.rend(); ++it) {
#         out.push_back(comp_base(*it));
#     }
#     return out;
# }
# 
# // Check if base is GC
# static inline bool is_gc(char b) {
#     return (b == 'G' || b == 'C');
# }
# 
# // Check if codon is valid A/C/G/T only
# static bool is_valid_codon(const char* codon) {
#     for (int i = 0; i < 3; ++i) {
#         char b = codon[i];
#         if (b != 'A' && b != 'C' && b != 'G' && b != 'T') return false;
#     }
#     return true;
# }
# 
# int main() {
#     const char* fasta_path = "/content/ecoli_U00096_3.fna";
#     const char* gff_path   = "/content/ecoli_U00096_3.gff";
# 
#     std::printf("=====================================================================================\n");
#     std::printf("CODON-POSITION GC LOCK CENSUS — E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n");
#     std::printf("We walk every CDS in the GFF and:\n");
#     std::printf("  • Extract its coding sequence (respecting strand, reverse-complementing '-' CDS).\n");
#     std::printf("  • Split into codons (triplets, only if length is divisible by 3).\n");
#     std::printf("  • For each codon position 1/2/3, count GC bases separately.\n");
#     std::printf("  • Compute exact fractions GC1/num_codons, GC2/num_codons, GC3/num_codons.\n");
#     std::printf("All counts are exact over raw FASTA bases; codons with ambiguous bases are skipped.\n\n");
# 
#     // Load genome
#     std::string header;
#     std::printf("Loading FASTA from: %s\n", fasta_path);
#     std::string genome = load_fasta_single(fasta_path, header);
#     if (genome.empty()) die("Genome sequence is empty");
#     std::printf("FASTA header: %s\n", header.c_str());
#     std::printf("Genome length: %zu bases\n\n", genome.size());
# 
#     // Load CDS
#     std::printf("Loading CDS annotations from: %s\n", gff_path);
#     std::vector<CDSFeature> cds_list = load_cds_from_gff(gff_path);
#     if (cds_list.empty()) die("No CDS features parsed from GFF");
#     std::printf("CDS features loaded: %zu\n\n", cds_list.size());
# 
#     std::vector<CDSPosStat> stats;
#     stats.reserve(cds_list.size());
# 
#     long long total_bases = 0;
#     long long total_codons = 0;
#     long long total_gc1 = 0, total_gc2 = 0, total_gc3 = 0;
# 
#     int skipped_len_not_multiple_of_3 = 0;
#     int skipped_out_of_range = 0;
# 
#     for (const auto& f : cds_list) {
#         if (f.start < 0 || f.end >= (long long)genome.size()) {
#             skipped_out_of_range++;
#             continue;
#         }
#         long long len = f.end - f.start + 1;
#         if (len <= 0) continue;
#         if (len % 3 != 0) {
#             skipped_len_not_multiple_of_3++;
#             continue;
#         }
# 
#         std::string seq = genome.substr((size_t)f.start, (size_t)len);
#         if (f.strand == '-') {
#             seq = revcomp(seq);
#         }
# 
#         long long codons = 0;
#         long long gc1 = 0, gc2 = 0, gc3 = 0;
# 
#         for (long long i = 0; i + 2 < len; i += 3) {
#             char c0 = seq[(size_t)i];
#             char c1 = seq[(size_t)i+1];
#             char c2 = seq[(size_t)i+2];
#             char codon[3] = {c0, c1, c2};
#             if (!is_valid_codon(codon)) continue;
#             codons++;
#             if (is_gc(c0)) gc1++;
#             if (is_gc(c1)) gc2++;
#             if (is_gc(c2)) gc3++;
#         }
# 
#         if (codons == 0) continue;
# 
#         CDSPosStat s;
#         s.name = f.name;
#         s.start = f.start;
#         s.end = f.end;
#         s.strand = f.strand;
#         s.length_bases = len;
#         s.total_codons = codons;
#         s.gc1 = gc1;
#         s.gc2 = gc2;
#         s.gc3 = gc3;
#         s.gc1_frac = (double)gc1 / (double)codons;
#         s.gc2_frac = (double)gc2 / (double)codons;
#         s.gc3_frac = (double)gc3 / (double)codons;
# 
#         s.gc3_num = gc3;
#         s.gc3_den = codons;
#         long long g = std::gcd(s.gc3_num, s.gc3_den);
#         if (g != 0) {
#             s.gc3_num /= g;
#             s.gc3_den /= g;
#         }
# 
#         stats.push_back(s);
#         total_bases += len;
#         total_codons += codons;
#         total_gc1 += gc1;
#         total_gc2 += gc2;
#         total_gc3 += gc3;
#     }
# 
#     if (stats.empty()) die("No CDS stats computed");
# 
#     std::printf("--- Global CDS-wise codon-position totals ---\n");
#     std::printf("  CDS analyzed                    : %zu\n", stats.size());
#     std::printf("  Sum CDS lengths                 : %lld bases\n", total_bases);
#     std::printf("  Sum valid codons (A/C/G/T only): %lld\n", total_codons);
#     std::printf("  Total GC at pos1               : %lld\n", total_gc1);
#     std::printf("  Total GC at pos2               : %lld\n", total_gc2);
#     std::printf("  Total GC at pos3               : %lld\n", total_gc3);
#     double gc1_w = (total_codons > 0) ? (double)total_gc1 / (double)total_codons : 0.0;
#     double gc2_w = (total_codons > 0) ? (double)total_gc2 / (double)total_codons : 0.0;
#     double gc3_w = (total_codons > 0) ? (double)total_gc3 / (double)total_codons : 0.0;
#     std::printf("  Mean GC fraction (codon-weighted):\n");
#     std::printf("    pos1: %.4f, pos2: %.4f, pos3: %.4f\n\n", gc1_w, gc2_w, gc3_w);
# 
#     if (skipped_len_not_multiple_of_3 > 0) {
#         std::printf("  NOTE: CDS skipped (len %% 3 != 0): %d\n", skipped_len_not_multiple_of_3);
#     }
#     if (skipped_out_of_range > 0) {
#         std::printf("  NOTE: CDS skipped (coords out of FASTA range): %d\n", skipped_out_of_range);
#     }
#     std::printf("\n");
# 
#     // Per-CDS distributions (unweighted)
#     double sum_gc1 = 0.0, sum_gc2 = 0.0, sum_gc3 = 0.0;
#     double min_gc1 =  1e9, min_gc2 =  1e9, min_gc3 =  1e9;
#     double max_gc1 = -1e9, max_gc2 = -1e9, max_gc3 = -1e9;
#     for (const auto& s : stats) {
#         sum_gc1 += s.gc1_frac;
#         sum_gc2 += s.gc2_frac;
#         sum_gc3 += s.gc3_frac;
#         if (s.gc1_frac < min_gc1) min_gc1 = s.gc1_frac;
#         if (s.gc1_frac > max_gc1) max_gc1 = s.gc1_frac;
#         if (s.gc2_frac < min_gc2) min_gc2 = s.gc2_frac;
#         if (s.gc2_frac > max_gc2) max_gc2 = s.gc2_frac;
#         if (s.gc3_frac < min_gc3) min_gc3 = s.gc3_frac;
#         if (s.gc3_frac > max_gc3) max_gc3 = s.gc3_frac;
#     }
#     double mean_gc1 = sum_gc1 / (double)stats.size();
#     double mean_gc2 = sum_gc2 / (double)stats.size();
#     double mean_gc3 = sum_gc3 / (double)stats.size();
# 
#     std::printf("--- Per-CDS GC fraction distribution (unweighted) ---\n");
#     std::printf("  pos1 GC fraction: mean = %.4f, min = %.4f, max = %.4f\n", mean_gc1, min_gc1, max_gc1);
#     std::printf("  pos2 GC fraction: mean = %.4f, min = %.4f, max = %.4f\n", mean_gc2, min_gc2, max_gc2);
#     std::printf("  pos3 GC fraction: mean = %.4f, min = %.4f, max = %.4f\n\n", mean_gc3, min_gc3, max_gc3);
# 
#     // Sort by GC3 fraction
#     std::vector<CDSPosStat> sorted = stats;
#     std::sort(sorted.begin(), sorted.end(), [](const CDSPosStat& a, const CDSPosStat& b){
#         if (a.gc3_frac != b.gc3_frac)
#             return a.gc3_frac > b.gc3_frac;
#         return a.total_codons > b.total_codons;
#     });
# 
#     auto print_cds_gc3 = [](const CDSPosStat& s, int idx, const char* label) {
#         std::printf("  [%s %2d]\n", label, idx);
#         std::printf("    CDS name              : %s\n", s.name.c_str());
#         std::printf("    Coordinates (0-based) : %lld - %lld (len=%lld, strand=%c)\n",
#                     s.start, s.end, s.length_bases, s.strand);
#         std::printf("    Total codons          : %lld\n", s.total_codons);
#         std::printf("    GC at pos1/pos2/pos3  : %lld / %lld / %lld\n", s.gc1, s.gc2, s.gc3);
#         std::printf("    GC fraction pos1/2/3  : %.4f / %.4f / %.4f\n",
#                     s.gc1_frac, s.gc2_frac, s.gc3_frac);
#         std::printf("    pos3 GC fraction      : %lld/%lld ≈ %.6f\n",
#                     s.gc3_num, s.gc3_den,
#                     (double)s.gc3_num / (double)s.gc3_den);
#         std::printf("\n");
#     };
# 
#     int topN = 10;
#     if ((int)sorted.size() < topN) topN = (int)sorted.size();
# 
#     std::printf("--- Top %d CDS by GC at codon position 3 (GC3 locks) ---\n\n", topN);
#     for (int i = 0; i < topN; ++i) {
#         print_cds_gc3(sorted[i], i+1, "TOP");
#     }
# 
#     std::printf("--- Bottom %d CDS by GC at codon position 3 (GC3 locks) ---\n\n", topN);
#     for (int i = 0; i < topN; ++i) {
#         const auto& s = sorted[sorted.size() - 1 - i];
#         print_cds_gc3(s, i+1, "LOW");
#     }
# 
#     // Highlight yagF CDS if present
#     for (const auto& s : sorted) {
#         if (s.name == "yagF") {
#             std::printf("--- Special highlight: yagF CDS (codon-position GC locks) ---\n");
#             std::printf("    GC fraction pos1/2/3  : %.4f / %.4f / %.4f\n",
#                         s.gc1_frac, s.gc2_frac, s.gc3_frac);
#             std::printf("    pos3 GC fraction      : %lld/%lld ≈ %.6f\n",
#                         s.gc3_num, s.gc3_den,
#                         (double)s.gc3_num / (double)s.gc3_den);
#             std::printf("    Total codons          : %lld\n", s.total_codons);
#             std::printf("    Coordinates (0-based) : %lld - %lld (len=%lld, strand=%c)\n\n",
#                         s.start, s.end, s.length_bases, s.strand);
#             break;
#         }
#     }
# 
#     std::printf("CODON-POSITION GC LOCK CENSUS finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# echo "[DNA-L9] Compiling with: nvcc -O3 -std=c++17 -gencode=arch=compute_80,code=sm_80 /content/warpfrac_dna_codon_pos_gc_lock.cu -o /content/warpfrac_dna_codon_pos_gc_lock"
# nvcc -O3 -std=c++17 -gencode=arch=compute_80,code=sm_80 /content/warpfrac_dna_codon_pos_gc_lock.cu -o /content/warpfrac_dna_codon_pos_gc_lock
# 
# echo
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo "RUNNING CODON-POSITION GC LOCK CENSUS (E. coli, CDS-level)"
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo
# 
# /content/warpfrac_dna_codon_pos_gc_lock | tee /tmp/dna_l9_stdout.txt
# 
# echo
# echo "[DNA-L9] Computing SHA256 of stdout..."
# SHA=$(sha256sum /tmp/dna_l9_stdout.txt | awk '{print $1}')
# echo "[DNA-L9] SHA256(stdout) = ${SHA}"
# echo
# echo "======================================================================================================================"
# echo "MODULE DNA-L9 — DONE (CODON-POSITION GC LOCK CENSUS)"
# echo "======================================================================================================================"
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_gene_lock_fingerprint.cu <<'CPP'
# // warpfrac_dna_gene_lock_fingerprint.cu
# // DNA-L10 — Gene-wise "lock fingerprint" cross-comparison
# // CPU-only: exact counts from FASTA + GFF, no GPU math.
# // For each CDS, we compute:
# //   GC_frac      = GC / length
# //   CpG_per_kb   = (#CG) * 1000 / (length-1)
# //   GC_heavy_frac = (#codons with >=2 GC bases) / total_codons
# //   GC3_frac     = (#GC at codon position 3) / total_codons
# // Then we print global stats, pairwise correlations, and outlier genes
# // where GC3 is "over-locked" vs CpG and vice versa.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# struct LockStats {
#     std::string name;
#     int length;
#     long gc_bases;
#     long cpg_count;
#     long codons;
#     long gc_heavy_codons;
#     long gc_pos1;
#     long gc_pos2;
#     long gc_pos3;
# 
#     // derived
#     double gc_frac;
#     double cpg_per_kb;
#     double gc_heavy_frac;
#     double gc3_frac;
# 
#     // z-scores (filled later)
#     double z_gc;
#     double z_cpg;
#     double z_heavy;
#     double z_gc3;
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     std::string seq;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             char u = std::toupper(static_cast<unsigned char>(c));
#             if (u=='A' || u=='C' || u=='G' || u=='T' || u=='N')
#                 seq.push_back(u);
#         }
#     }
#     return seq;
# }
# 
# static std::string get_attr_value(const std::string &attr, const char *key) {
#     // Look for key=...; or key=... end of field
#     std::string k(key);
#     k.push_back('=');
#     size_t pos = attr.find(k);
#     if (pos == std::string::npos) return "";
#     pos += k.size();
#     size_t end = attr.find(';', pos);
#     if (end == std::string::npos) end = attr.size();
#     return attr.substr(pos, end-pos);
# }
# 
# static std::vector<CDSFeature> read_cds_from_gff(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::vector<CDSFeature> cds;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0]=='#') continue;
#         std::stringstream ss(line);
#         std::string seqid, source, type, start_s, end_s, score, strand_s, phase, attr;
#         if (!std::getline(ss, seqid, '\t')) continue;
#         if (!std::getline(ss, source, '\t')) continue;
#         if (!std::getline(ss, type, '\t')) continue;
#         if (!std::getline(ss, start_s, '\t')) continue;
#         if (!std::getline(ss, end_s, '\t')) continue;
#         if (!std::getline(ss, score, '\t')) continue;
#         if (!std::getline(ss, strand_s, '\t')) continue;
#         if (!std::getline(ss, phase, '\t')) continue;
#         std::getline(ss, attr);  // attributes (may contain tabs originally but usually not)
# 
#         if (type != "CDS") continue;
# 
#         int start1 = std::atoi(start_s.c_str());
#         int end1   = std::atoi(end_s.c_str());
#         if (start1 <= 0 || end1 <= 0) continue;
#         if (end1 < start1) std::swap(start1, end1);
#         int start0 = start1 - 1;
#         int end0   = end1 - 1;
#         char strand = strand_s.empty() ? '+' : strand_s[0];
# 
#         std::string name = get_attr_value(attr, "gene");
#         if (name.empty()) name = get_attr_value(attr, "Name");
#         if (name.empty()) name = get_attr_value(attr, "locus_tag");
#         if (name.empty()) name = "(unnamed_CDS)";
# 
#         CDSFeature f;
#         f.name = name;
#         f.start0 = start0;
#         f.end0 = end0;
#         f.strand = strand;
#         cds.push_back(f);
#     }
#     return cds;
# }
# 
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         case 'T': return 'A';
#         default:  return 'N';
#     }
# }
# 
# static std::string revcomp(const std::string &s) {
#     std::string r;
#     r.reserve(s.size());
#     for (int i = (int)s.size()-1; i>=0; --i) {
#         r.push_back(comp_base(s[i]));
#     }
#     return r;
# }
# 
# // Pearson correlation of two vectors (same length, >=2)
# static double corr(const std::vector<double> &x, const std::vector<double> &y) {
#     size_t n = x.size();
#     if (n < 2 || y.size()!=n) return 0.0;
#     double sx=0, sy=0;
#     for (size_t i=0;i<n;i++){ sx += x[i]; sy += y[i]; }
#     double mx = sx / n;
#     double my = sy / n;
#     double num=0, vx=0, vy=0;
#     for (size_t i=0;i<n;i++){
#         double dx = x[i]-mx;
#         double dy = y[i]-my;
#         num += dx*dy;
#         vx  += dx*dx;
#         vy  += dy*dy;
#     }
#     if (vx<=0 || vy<=0) return 0.0;
#     return num / std::sqrt(vx*vy);
# }
# 
# int main() {
#     const std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     const std::string gff_path   = "/content/ecoli_U00096_3.gff";
# 
#     std::printf("======================================================================================================================\n");
#     std::printf("MODULE DNA-L10 — GENE LOCK FINGERPRINT CROSS-COMPARISON (E. coli MG1655, CDS-level)\n");
#     std::printf("======================================================================================================================\n\n");
# 
#     std::printf("[DNA-L10] FASTA found at %s, reusing existing file.\n", fasta_path.c_str());
#     std::printf("[DNA-L10] GFF found at %s, reusing existing file.\n\n", gff_path.c_str());
# 
#     std::printf("[DNA-L10] Writing / running gene-lock fingerprint census (CPU-only, exact counts).\n\n");
# 
#     std::string genome = read_fasta(fasta_path);
#     if (genome.empty()) {
#         std::fprintf(stderr, "ERROR: FASTA sequence is empty.\n");
#         return 1;
#     }
#     std::vector<CDSFeature> cds = read_cds_from_gff(gff_path);
#     if (cds.empty()) {
#         std::fprintf(stderr, "ERROR: no CDS features parsed from GFF.\n");
#         return 1;
#     }
# 
#     std::printf("----------------------------------------------------------------------------------------------------------------------\n");
#     std::printf("RUNNING GENE LOCK FINGERPRINT CENSUS (GC / CpG / GC-heavy / GC3 cross-compare)\n");
#     std::printf("----------------------------------------------------------------------------------------------------------------------\n\n");
# 
#     std::printf("=====================================================================================\n");
#     std::printf("GENE LOCK FINGERPRINT CENSUS — E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n");
#     std::printf("For each CDS we compute an exact \"lock fingerprint\":\n");
#     std::printf("  • GC_frac       = GC / length\n");
#     std::printf("  • CpG_per_kb    = (#CG) * 1000 / (length-1)\n");
#     std::printf("  • GC_heavy_frac = (#codons with ≥2 GC bases) / total_codons\n");
#     std::printf("  • GC3_frac      = (#GC at codon position 3) / total_codons\n");
#     std::printf("All counts are exact integer tallies over the FASTA; floating point is only used\n");
#     std::printf("for reporting averages, correlations, and z-scores.\n\n");
# 
#     std::printf("Loading FASTA from: %s\n", fasta_path.c_str());
#     std::printf("Genome length: %zu bases\n\n", genome.size());
#     std::printf("Loading CDS annotations from: %s\n", gff_path.c_str());
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     std::vector<LockStats> stats;
#     stats.reserve(cds.size());
#     int skipped_nonmod3 = 0;
# 
#     for (const auto &f : cds) {
#         if (f.start0 < 0 || f.end0 < f.start0 || f.end0 >= (int)genome.size())
#             continue;
#         int len = f.end0 - f.start0 + 1;
#         if (len < 3) continue;
#         if (len % 3 != 0) {
#             skipped_nonmod3++;
#             continue;
#         }
#         std::string seq = genome.substr(f.start0, len);
#         for (char &c : seq) c = std::toupper(static_cast<unsigned char>(c));
#         if (f.strand == '-') {
#             seq = revcomp(seq);
#         }
# 
#         LockStats s{};
#         s.name = f.name;
#         s.length = len;
#         s.gc_bases = 0;
#         s.cpg_count = 0;
#         s.codons = len / 3;
#         s.gc_heavy_codons = 0;
#         s.gc_pos1 = s.gc_pos2 = s.gc_pos3 = 0;
# 
#         // Base-wise GC & CpG
#         for (int i=0;i<len;i++) {
#             char b = seq[i];
#             if (b=='G' || b=='C') s.gc_bases++;
#             if (i+1 < len && b=='C' && seq[i+1]=='G') s.cpg_count++;
#         }
# 
#         // Codon-wise GC-heavy & positional GC
#         bool valid = true;
#         for (int c=0;c<s.codons;c++) {
#             char b1 = seq[3*c+0];
#             char b2 = seq[3*c+1];
#             char b3 = seq[3*c+2];
#             auto is_acgt = [](char b)->bool {
#                 return b=='A'||b=='C'||b=='G'||b=='T';
#             };
#             if (!is_acgt(b1) || !is_acgt(b2) || !is_acgt(b3)) {
#                 valid = false;
#                 break;
#             }
#             auto is_gc = [](char b)->bool { return b=='G'||b=='C'; };
#             if (is_gc(b1)) s.gc_pos1++;
#             if (is_gc(b2)) s.gc_pos2++;
#             if (is_gc(b3)) s.gc_pos3++;
#             int gc_in_codon = (is_gc(b1)?1:0)+(is_gc(b2)?1:0)+(is_gc(b3)?1:0);
#             if (gc_in_codon >= 2) s.gc_heavy_codons++;
#         }
#         if (!valid) {
#             // If ambiguous bases, skip this CDS entirely.
#             continue;
#         }
# 
#         if (s.codons <= 0 || s.length <= 1) continue;
# 
#         s.gc_frac        = (double)s.gc_bases / (double)s.length;
#         s.cpg_per_kb     = (double)s.cpg_count * 1000.0 / (double)(s.length-1);
#         s.gc_heavy_frac  = (double)s.gc_heavy_codons / (double)s.codons;
#         s.gc3_frac       = (double)s.gc_pos3 / (double)s.codons;
# 
#         stats.push_back(s);
#     }
# 
#     int cds_analyzed = (int)stats.size();
# 
#     long long sum_len = 0;
#     long long sum_gc  = 0;
#     long long sum_cpg = 0;
#     long long sum_codons = 0;
#     long long sum_gc_heavy = 0;
#     long long sum_gc1 = 0, sum_gc2 = 0, sum_gc3 = 0;
# 
#     std::vector<double> v_gc, v_cpg, v_heavy, v_gc3;
#     v_gc.reserve(stats.size());
#     v_cpg.reserve(stats.size());
#     v_heavy.reserve(stats.size());
#     v_gc3.reserve(stats.size());
# 
#     double min_gc_frac = 1.0, max_gc_frac = 0.0;
#     double min_cpg_pkb = 1e300, max_cpg_pkb = -1e300;
#     double min_heavy   = 1.0, max_heavy   = 0.0;
#     double min_gc3     = 1.0, max_gc3     = 0.0;
# 
#     for (auto &s : stats) {
#         sum_len      += s.length;
#         sum_gc       += s.gc_bases;
#         sum_cpg      += s.cpg_count;
#         sum_codons   += s.codons;
#         sum_gc_heavy += s.gc_heavy_codons;
#         sum_gc1      += s.gc_pos1;
#         sum_gc2      += s.gc_pos2;
#         sum_gc3      += s.gc_pos3;
# 
#         v_gc.push_back(s.gc_frac);
#         v_cpg.push_back(s.cpg_per_kb);
#         v_heavy.push_back(s.gc_heavy_frac);
#         v_gc3.push_back(s.gc3_frac);
# 
#         if (s.gc_frac       < min_gc_frac)   min_gc_frac = s.gc_frac;
#         if (s.gc_frac       > max_gc_frac)   max_gc_frac = s.gc_frac;
#         if (s.cpg_per_kb    < min_cpg_pkb)   min_cpg_pkb = s.cpg_per_kb;
#         if (s.cpg_per_kb    > max_cpg_pkb)   max_cpg_pkb = s.cpg_per_kb;
#         if (s.gc_heavy_frac < min_heavy)     min_heavy   = s.gc_heavy_frac;
#         if (s.gc_heavy_frac > max_heavy)     max_heavy   = s.gc_heavy_frac;
#         if (s.gc3_frac      < min_gc3)       min_gc3     = s.gc3_frac;
#         if (s.gc3_frac      > max_gc3)       max_gc3     = s.gc3_frac;
#     }
# 
#     auto mean_std = [](const std::vector<double> &v)->std::pair<double,double>{
#         size_t n = v.size();
#         if (n==0) return {0.0,0.0};
#         double s=0; for (double x:v) s+=x;
#         double m = s/n;
#         double v2=0; for (double x:v){ double d=x-m; v2+=d*d; }
#         double sd = (n>1)? std::sqrt(v2/(n-1)) : 0.0;
#         return {m, sd};
#     };
# 
#     auto [mean_gc_frac, sd_gc_frac]     = mean_std(v_gc);
#     auto [mean_cpg_pkb, sd_cpg_pkb]     = mean_std(v_cpg);
#     auto [mean_heavy,   sd_heavy]       = mean_std(v_heavy);
#     auto [mean_gc3,     sd_gc3]         = mean_std(v_gc3);
# 
#     double gc_frac_weighted      = (sum_len>0)    ? (double)sum_gc / (double)sum_len : 0.0;
#     double cpg_pkb_weighted      = (sum_len>1)    ? (double)sum_cpg * 1000.0 / (double)(sum_len-1) : 0.0;
#     double heavy_frac_weighted   = (sum_codons>0) ? (double)sum_gc_heavy / (double)sum_codons : 0.0;
#     double gc1_w = (sum_codons>0) ? (double)sum_gc1 / (double)sum_codons : 0.0;
#     double gc2_w = (sum_codons>0) ? (double)sum_gc2 / (double)sum_codons : 0.0;
#     double gc3_w = (sum_codons>0) ? (double)sum_gc3 / (double)sum_codons : 0.0;
# 
#     std::printf("--- Global CDS-wise lock fingerprint totals ---\n");
#     std::printf("  CDS analyzed                     : %d\n", cds_analyzed);
#     std::printf("  CDS skipped (len %% 3 != 0)       : %d\n", skipped_nonmod3);
#     std::printf("  Sum CDS lengths                  : %lld bases\n", sum_len);
#     std::printf("  Sum valid codons                 : %lld\n", sum_codons);
#     std::printf("  Total GC bases across CDS        : %lld\n", sum_gc);
#     std::printf("  Total CpG across CDS             : %lld\n", sum_cpg);
#     std::printf("  Total GC-heavy codons            : %lld\n", sum_gc_heavy);
#     std::printf("  Total GC at pos1/pos2/pos3       : %lld / %lld / %lld\n", sum_gc1, sum_gc2, sum_gc3);
#     std::printf("  Weighted mean GC_frac            : %.4f\n", gc_frac_weighted);
#     std::printf("  Weighted mean CpG_per_kb         : %.4f\n", cpg_pkb_weighted);
#     std::printf("  Weighted mean GC-heavy fraction  : %.4f\n", heavy_frac_weighted);
#     std::printf("  Weighted mean GC fraction pos1/2/3: %.4f / %.4f / %.4f\n\n",
#                 gc1_w, gc2_w, gc3_w);
# 
#     std::printf("--- Per-CDS lock metric distributions (unweighted) ---\n");
#     std::printf("  GC_frac per CDS      : mean = %.4f, sd = %.4f, min = %.4f, max = %.4f\n",
#                 mean_gc_frac, sd_gc_frac, min_gc_frac, max_gc_frac);
#     std::printf("  CpG_per_kb per CDS   : mean = %.4f, sd = %.4f, min = %.4f, max = %.4f\n",
#                 mean_cpg_pkb, sd_cpg_pkb, min_cpg_pkb, max_cpg_pkb);
#     std::printf("  GC-heavy_frac per CDS: mean = %.4f, sd = %.4f, min = %.4f, max = %.4f\n",
#                 mean_heavy, sd_heavy, min_heavy, max_heavy);
#     std::printf("  GC3_frac per CDS     : mean = %.4f, sd = %.4f, min = %.4f, max = %.4f\n\n",
#                 mean_gc3, sd_gc3, min_gc3, max_gc3);
# 
#     double corr_gc_cpg   = corr(v_gc,   v_cpg);
#     double corr_gc_heavy = corr(v_gc,   v_heavy);
#     double corr_gc_gc3   = corr(v_gc,   v_gc3);
#     double corr_cpg_heavy= corr(v_cpg,  v_heavy);
#     double corr_cpg_gc3  = corr(v_cpg,  v_gc3);
#     double corr_heavy_gc3= corr(v_heavy,v_gc3);
# 
#     std::printf("--- Pairwise Pearson correlations between lock metrics ---\n");
#     std::printf("  corr(GC_frac,   CpG_per_kb   ) = %.4f\n", corr_gc_cpg);
#     std::printf("  corr(GC_frac,   GC-heavy_frac) = %.4f\n", corr_gc_heavy);
#     std::printf("  corr(GC_frac,   GC3_frac     ) = %.4f\n", corr_gc_gc3);
#     std::printf("  corr(CpG_per_kb,GC-heavy_frac) = %.4f\n", corr_cpg_heavy);
#     std::printf("  corr(CpG_per_kb,GC3_frac     ) = %.4f\n", corr_cpg_gc3);
#     std::printf("  corr(GC-heavy_frac,GC3_frac  ) = %.4f\n\n", corr_heavy_gc3);
# 
#     // Compute z-scores for each metric
#     for (auto &s : stats) {
#         s.z_gc    = (sd_gc_frac  > 0) ? (s.gc_frac       - mean_gc_frac)  / sd_gc_frac  : 0.0;
#         s.z_cpg   = (sd_cpg_pkb  > 0) ? (s.cpg_per_kb    - mean_cpg_pkb)  / sd_cpg_pkb  : 0.0;
#         s.z_heavy = (sd_heavy    > 0) ? (s.gc_heavy_frac - mean_heavy)    / sd_heavy    : 0.0;
#         s.z_gc3   = (sd_gc3      > 0) ? (s.gc3_frac      - mean_gc3)      / sd_gc3      : 0.0;
#     }
# 
#     // Genes where GC3 is strongly over-locked vs CpG: high z_gc3, modest/low z_cpg
#     struct Outlier {
#         std::string name;
#         double z_gc3;
#         double z_cpg;
#         double gc3;
#         double cpg;
#         double gc;
#         double heavy;
#     };
#     std::vector<Outlier> gc3_over_cpg;
#     std::vector<Outlier> cpg_over_gc3;
# 
#     for (const auto &s : stats) {
#         if (s.codons <= 0) continue;
#         if (s.z_gc3 >= 2.5 && s.z_cpg <= 0.5) {
#             Outlier o{ s.name, s.z_gc3, s.z_cpg, s.gc3_frac, s.cpg_per_kb,
#                        s.gc_frac, s.gc_heavy_frac };
#             gc3_over_cpg.push_back(o);
#         }
#         if (s.z_cpg >= 2.5 && s.z_gc3 <= 0.5) {
#             Outlier o{ s.name, s.z_gc3, s.z_cpg, s.gc3_frac, s.cpg_per_kb,
#                        s.gc_frac, s.gc_heavy_frac };
#             cpg_over_gc3.push_back(o);
#         }
#     }
# 
#     auto by_gc3_minus_cpg = [](const Outlier &a, const Outlier &b){
#         double da = a.z_gc3 - a.z_cpg;
#         double db = b.z_gc3 - b.z_cpg;
#         return da > db;
#     };
#     auto by_cpg_minus_gc3 = [](const Outlier &a, const Outlier &b){
#         double da = a.z_cpg - a.z_gc3;
#         double db = b.z_cpg - b.z_gc3;
#         return da > db;
#     };
#     std::sort(gc3_over_cpg.begin(), gc3_over_cpg.end(), by_gc3_minus_cpg);
#     std::sort(cpg_over_gc3.begin(), cpg_over_gc3.end(), by_cpg_minus_gc3);
# 
#     std::printf("--- Genes where GC3 lock >> CpG lock (high z(GC3), modest/low z(CpG)) ---\n");
#     int limit = std::min<int>(10, gc3_over_cpg.size());
#     if (limit == 0) {
#         std::printf("  (none above the chosen z-thresholds in this genome)\n\n");
#     } else {
#         for (int i=0;i<limit;i++) {
#             const auto &o = gc3_over_cpg[i];
#             std::printf("  [GC3>CPG %2d]\n", i+1);
#             std::printf("    CDS name          : %s\n", o.name.c_str());
#             std::printf("    z(GC3_frac)       : %.3f\n", o.z_gc3);
#             std::printf("    z(CpG_per_kb)     : %.3f\n", o.z_cpg);
#             std::printf("    GC3_frac          : %.4f\n", o.gc3);
#             std::printf("    CpG_per_kb        : %.4f\n", o.cpg);
#             std::printf("    GC_frac           : %.4f\n", o.gc);
#             std::printf("    GC-heavy_frac     : %.4f\n\n", o.heavy);
#         }
#     }
# 
#     std::printf("--- Genes where CpG lock >> GC3 lock (high z(CpG), modest/low z(GC3)) ---\n");
#     limit = std::min<int>(10, cpg_over_gc3.size());
#     if (limit == 0) {
#         std::printf("  (none above the chosen z-thresholds in this genome)\n\n");
#     } else {
#         for (int i=0;i<limit;i++) {
#             const auto &o = cpg_over_gc3[i];
#             std::printf("  [CPG>GC3 %2d]\n", i+1);
#             std::printf("    CDS name          : %s\n", o.name.c_str());
#             std::printf("    z(CpG_per_kb)     : %.3f\n", o.z_cpg);
#             std::printf("    z(GC3_frac)       : %.3f\n", o.z_gc3);
#             std::printf("    CpG_per_kb        : %.4f\n", o.cpg);
#             std::printf("    GC3_frac          : %.4f\n", o.gc3);
#             std::printf("    GC_frac           : %.4f\n", o.gc);
#             std::printf("    GC-heavy_frac     : %.4f\n\n", o.heavy);
#         }
#     }
# 
#     // Optional highlight: yagF / yagG / yagH / phnD / phnM / phnK if present
#     std::vector<std::string> highlight = {"yagE","yagF","yagG","yagH","yagA","phnD","phnM","phnK"};
#     std::printf("--- Lock fingerprints for selected high-lock cluster genes (if present) ---\n");
#     for (const auto &tag : highlight) {
#         bool found = false;
#         for (const auto &s : stats) {
#             if (s.name == tag) {
#                 found = true;
#                 std::printf("  [%s]\n", tag.c_str());
#                 std::printf("    length            : %d\n", s.length);
#                 std::printf("    GC_frac           : %.4f\n", s.gc_frac);
#                 std::printf("    CpG_per_kb        : %.4f\n", s.cpg_per_kb);
#                 std::printf("    GC-heavy_frac     : %.4f\n", s.gc_heavy_frac);
#                 std::printf("    GC3_frac          : %.4f\n", s.gc3_frac);
#                 std::printf("    z(GC_frac)        : %.3f\n", s.z_gc);
#                 std::printf("    z(CpG_per_kb)     : %.3f\n", s.z_cpg);
#                 std::printf("    z(GC-heavy_frac)  : %.3f\n", s.z_heavy);
#                 std::printf("    z(GC3_frac)       : %.3f\n\n", s.z_gc3);
#                 break;
#             }
#         }
#         if (!found) {
#             std::printf("  [%s] not found as a CDS name in this GFF.\n\n", tag.c_str());
#         }
#     }
# 
#     std::printf("GENE LOCK FINGERPRINT CENSUS finished.\n");
#     std::printf("=====================================================================================\n");
# 
#     return 0;
# }
# CPP
# 
# nvcc -O3 -std=c++17 -gencode=arch=compute_80,code=sm_80 warpfrac_dna_gene_lock_fingerprint.cu -o warpfrac_dna_gene_lock_fingerprint
# ./warpfrac_dna_gene_lock_fingerprint
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_gene_lock_cluster.cu << 'CPP'
# // warpfrac_dna_gene_lock_cluster.cu
# // DNA-L11 — Gene-wise "lock regime" clustering (CPU-only)
# //
# // For each CDS we compute the same lock fingerprint as DNA-L10:
# //   GC_frac       = GC / length
# //   CpG_per_kb    = (#CG) * 1000 / (length-1)
# //   GC_heavy_frac = (#codons with >=2 GC bases) / total_codons
# //   GC3_frac      = (#GC at codon position 3) / total_codons
# //
# // Then we normalize these 4 metrics and run a deterministic K=3 k-means
# // in this 4D space, and print:
# //   - cluster sizes
# //   - per-cluster mean GC_frac, CpG_per_kb, GC_heavy_frac, GC3_frac
# //   - which cluster looks "low-lock" / "mid-lock" / "high-lock"
# //   - top hyper-locked genes in the high-lock cluster.
# //
# // CPU-only: no CUDA kernels, just compiled with nvcc as a C++17 program.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# struct LockStats {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;
# 
#     int length;
#     long gc_bases;
#     long cpg_count;
#     long codons;
#     long gc_heavy_codons;
#     long gc_pos1;
#     long gc_pos2;
#     long gc_pos3;
# 
#     double gc_frac;
#     double cpg_per_kb;
#     double gc_heavy_frac;
#     double gc3_frac;
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     std::string seq;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             char u = std::toupper(static_cast<unsigned char>(c));
#             if (u == 'A' || u == 'C' || u == 'G' || u == 'T' || u == 'N') {
#                 seq.push_back(u);
#             }
#         }
#     }
#     return seq;
# }
# 
# static std::string reverse_complement(const std::string &s) {
#     std::string out;
#     out.reserve(s.size());
#     for (int i = (int)s.size() - 1; i >= 0; --i) {
#         char c = s[i];
#         char rc = 'N';
#         switch (c) {
#             case 'A': rc = 'T'; break;
#             case 'T': rc = 'A'; break;
#             case 'C': rc = 'G'; break;
#             case 'G': rc = 'C'; break;
#             default:  rc = 'N'; break;
#         }
#         out.push_back(rc);
#     }
#     return out;
# }
# 
# static std::vector<std::string> split_tab(const std::string &line) {
#     std::vector<std::string> out;
#     std::string cur;
#     for (char c : line) {
#         if (c == '\t') {
#             out.push_back(cur);
#             cur.clear();
#         } else {
#             cur.push_back(c);
#         }
#     }
#     out.push_back(cur);
#     return out;
# }
# 
# static std::string extract_name_from_attr(const std::string &attr) {
#     const char* keys[] = {"gene=", "Name=", "locus_tag="};
#     for (const char* k : keys) {
#         std::size_t pos = attr.find(k);
#         if (pos != std::string::npos) {
#             pos += std::strlen(k);
#             std::size_t end = pos;
#             while (end < attr.size() && attr[end] != ';' && attr[end] != ' ' && attr[end] != '\t')
#                 ++end;
#             return attr.substr(pos, end - pos);
#         }
#     }
#     return std::string("unknown");
# }
# 
# static std::vector<CDSFeature> read_cds_from_gff(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::vector<CDSFeature> cds;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '#') continue;
#         auto fields = split_tab(line);
#         if (fields.size() < 9) continue;
#         const std::string &type = fields[2];
#         if (type != "CDS") continue;
#         int start1 = std::atoi(fields[3].c_str());
#         int end1   = std::atoi(fields[4].c_str());
#         char strand = fields[6].empty() ? '+' : fields[6][0];
#         std::string name = extract_name_from_attr(fields[8]);
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start1 - 1;
#         f.end0   = end1 - 1;
#         f.strand = strand;
#         if (f.start0 >= 0 && f.end0 >= f.start0)
#             cds.push_back(f);
#     }
#     return cds;
# }
# 
# static bool is_acgt(char c) {
#     return c == 'A' || c == 'C' || c == 'G' || c == 'T';
# }
# 
# int main() {
#     const std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     const std::string gff_path   = "/content/ecoli_U00096_3.gff";
# 
#     std::printf("=====================================================================================\n");
#     std::printf("GENE LOCK REGIME CLUSTERING — E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n");
#     std::printf("We recompute per-CDS lock fingerprints:\n");
#     std::printf("  GC_frac       = GC / length\n");
#     std::printf("  CpG_per_kb    = (#CG) * 1000 / (length-1)\n");
#     std::printf("  GC_heavy_frac = (#codons with >=2 GC bases) / total_codons\n");
#     std::printf("  GC3_frac      = (#GC at codon position 3) / total_codons\n");
#     std::printf("Then we run K=3 k-means in this 4D lock space and summarize the clusters.\n\n");
# 
#     std::printf("Loading FASTA from: %s\n", fasta_path.c_str());
#     std::string genome = read_fasta(fasta_path);
#     std::printf("Genome length: %zu bases\n\n", genome.size());
# 
#     std::printf("Loading CDS annotations from: %s\n", gff_path.c_str());
#     auto cds = read_cds_from_gff(gff_path);
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     std::vector<LockStats> stats;
#     stats.reserve(cds.size());
# 
#     long sum_len = 0;
#     long sum_gc = 0;
#     long sum_cpg = 0;
#     long sum_codons = 0;
#     long skipped_len_mod3 = 0;
# 
#     for (const auto &f : cds) {
#         if (f.start0 < 0 || f.end0 >= (int)genome.size() || f.end0 < f.start0) continue;
#         int len = f.end0 - f.start0 + 1;
#         if (len < 3) continue;
#         if (len % 3 != 0) {
#             skipped_len_mod3++;
#             continue;
#         }
# 
#         std::string seq = genome.substr(f.start0, len);
#         for (char &c : seq) c = std::toupper(static_cast<unsigned char>(c));
#         if (f.strand == '-') {
#             seq = reverse_complement(seq);
#         }
# 
#         long gc_bases = 0;
#         long cpg_count = 0;
#         for (int i = 0; i < len; ++i) {
#             char c = seq[i];
#             if (c == 'G' || c == 'C') gc_bases++;
#         }
#         for (int i = 0; i + 1 < len; ++i) {
#             if (seq[i] == 'C' && seq[i+1] == 'G') cpg_count++;
#         }
# 
#         long valid_codons = 0;
#         long gc_heavy_codons = 0;
#         long gc1 = 0, gc2 = 0, gc3 = 0;
# 
#         for (int i = 0; i + 2 < len; i += 3) {
#             char b1 = seq[i];
#             char b2 = seq[i+1];
#             char b3 = seq[i+2];
#             if (!is_acgt(b1) || !is_acgt(b2) || !is_acgt(b3)) {
#                 continue;
#             }
#             valid_codons++;
#             int gc = (b1=='G'||b1=='C') + (b2=='G'||b2=='C') + (b3=='G'||b3=='C');
#             if (gc >= 2) gc_heavy_codons++;
#             if (b1=='G'||b1=='C') gc1++;
#             if (b2=='G'||b2=='C') gc2++;
#             if (b3=='G'||b3=='C') gc3++;
#         }
# 
#         if (valid_codons == 0) continue;
# 
#         LockStats s;
#         s.name = f.name;
#         s.start0 = f.start0;
#         s.end0 = f.end0;
#         s.strand = f.strand;
#         s.length = len;
#         s.gc_bases = gc_bases;
#         s.cpg_count = cpg_count;
#         s.codons = valid_codons;
#         s.gc_heavy_codons = gc_heavy_codons;
#         s.gc_pos1 = gc1;
#         s.gc_pos2 = gc2;
#         s.gc_pos3 = gc3;
# 
#         s.gc_frac = (double)gc_bases / (double)len;
#         s.cpg_per_kb = (len > 1) ? (double)cpg_count * 1000.0 / (double)(len - 1) : 0.0;
#         s.gc_heavy_frac = (double)gc_heavy_codons / (double)valid_codons;
#         s.gc3_frac = (double)gc3 / (double)valid_codons;
# 
#         stats.push_back(s);
#         sum_len += len;
#         sum_gc  += gc_bases;
#         sum_cpg += cpg_count;
#         sum_codons += valid_codons;
#     }
# 
#     int n = (int)stats.size();
#     if (n == 0) {
#         std::printf("No valid CDS after filters; exiting.\n");
#         return 0;
#     }
# 
#     std::printf("--- Global CDS-wise lock fingerprint totals (for clustering set) ---\n");
#     std::printf("  CDS analyzed (valid, len%%3==0)   : %d\n", n);
#     std::printf("  CDS skipped (len%%3!=0)           : %ld\n", skipped_len_mod3);
#     std::printf("  Sum CDS lengths                   : %ld bases\n", sum_len);
#     std::printf("  Sum valid codons                  : %ld\n", sum_codons);
#     std::printf("  Total GC bases across CDS         : %ld\n", sum_gc);
#     std::printf("  Total CpG across CDS              : %ld\n", sum_cpg);
#     std::printf("\n");
# 
#     double m_gc=0, m_cpg=0, m_heavy=0, m_gc3=0;
#     for (const auto &s : stats) {
#         m_gc    += s.gc_frac;
#         m_cpg   += s.cpg_per_kb;
#         m_heavy += s.gc_heavy_frac;
#         m_gc3   += s.gc3_frac;
#     }
#     m_gc    /= n;
#     m_cpg   /= n;
#     m_heavy /= n;
#     m_gc3   /= n;
# 
#     double v_gc=0, v_cpg=0, v_heavy=0, v_gc3=0;
#     for (const auto &s : stats) {
#         v_gc    += (s.gc_frac       - m_gc)    * (s.gc_frac       - m_gc);
#         v_cpg   += (s.cpg_per_kb    - m_cpg)   * (s.cpg_per_kb    - m_cpg);
#         v_heavy += (s.gc_heavy_frac - m_heavy) * (s.gc_heavy_frac - m_heavy);
#         v_gc3   += (s.gc3_frac      - m_gc3)   * (s.gc3_frac      - m_gc3);
#     }
#     v_gc    /= n;
#     v_cpg   /= n;
#     v_heavy /= n;
#     v_gc3   /= n;
# 
#     double sd_gc    = std::sqrt(v_gc);
#     double sd_cpg   = std::sqrt(v_cpg);
#     double sd_heavy = std::sqrt(v_heavy);
#     double sd_gc3   = std::sqrt(v_gc3);
# 
#     std::printf("--- Per-CDS lock metric distributions (unweighted) ---\n");
#     std::printf("  GC_frac mean = %.4f, sd = %.4f\n", m_gc, sd_gc);
#     std::printf("  CpG_per_kb mean = %.4f, sd = %.4f\n", m_cpg, sd_cpg);
#     std::printf("  GC-heavy_frac mean = %.4f, sd = %.4f\n", m_heavy, sd_heavy);
#     std::printf("  GC3_frac mean = %.4f, sd = %.4f\n\n", m_gc3, sd_gc3);
# 
#     struct Vec4 { double x[4]; };
#     std::vector<Vec4> feats(n);
#     for (int i = 0; i < n; ++i) {
#         const auto &s = stats[i];
#         feats[i].x[0] = (s.gc_frac       - m_gc)    / (sd_gc    > 0 ? sd_gc    : 1.0);
#         feats[i].x[1] = (s.cpg_per_kb    - m_cpg)   / (sd_cpg   > 0 ? sd_cpg   : 1.0);
#         feats[i].x[2] = (s.gc_heavy_frac - m_heavy) / (sd_heavy > 0 ? sd_heavy : 1.0);
#         feats[i].x[3] = (s.gc3_frac      - m_gc3)   / (sd_gc3   > 0 ? sd_gc3   : 1.0);
#     }
# 
#     const int K = 3;
#     Vec4 cent[K];
# 
#     // Seed: gene with min GC_frac, median index, max GC_frac
#     int idx_min_gc = 0, idx_max_gc = 0;
#     for (int i = 1; i < n; ++i) {
#         if (stats[i].gc_frac < stats[idx_min_gc].gc_frac) idx_min_gc = i;
#         if (stats[i].gc_frac > stats[idx_max_gc].gc_frac) idx_max_gc = i;
#     }
#     int idx_seed_mid = n / 2;  // renamed to avoid clash later
# 
#     cent[0] = feats[idx_min_gc];
#     cent[1] = feats[idx_seed_mid];
#     cent[2] = feats[idx_max_gc];
# 
#     std::vector<int> assign(n, 0);
# 
#     auto dist2 = [](const Vec4 &a, const Vec4 &b) {
#         double d0 = a.x[0] - b.x[0];
#         double d1 = a.x[1] - b.x[1];
#         double d2 = a.x[2] - b.x[2];
#         double d3 = a.x[3] - b.x[3];
#         return d0*d0 + d1*d1 + d2*d2 + d3*d3;
#     };
# 
#     const int MAX_ITERS = 50;
#     for (int it = 0; it < MAX_ITERS; ++it) {
#         bool changed = false;
#         for (int i = 0; i < n; ++i) {
#             double best_d = dist2(feats[i], cent[0]);
#             int best_k = 0;
#             for (int k = 1; k < K; ++k) {
#                 double d = dist2(feats[i], cent[k]);
#                 if (d < best_d) { best_d = d; best_k = k; }
#             }
#             if (assign[i] != best_k) {
#                 assign[i] = best_k;
#                 changed = true;
#             }
#         }
#         Vec4 newc[K];
#         int counts[K] = {0,0,0};
#         for (int k = 0; k < K; ++k)
#             for (int j = 0; j < 4; ++j)
#                 newc[k].x[j] = 0.0;
#         for (int i = 0; i < n; ++i) {
#             int k = assign[i];
#             counts[k]++;
#             for (int j = 0; j < 4; ++j)
#                 newc[k].x[j] += feats[i].x[j];
#         }
#         for (int k = 0; k < K; ++k) {
#             if (counts[k] == 0) {
#                 int far_idx = 0;
#                 double far_d = -1.0;
#                 for (int i = 0; i < n; ++i) {
#                     double d = dist2(feats[i], cent[0]);
#                     if (d > far_d) { far_d = d; far_idx = i; }
#                 }
#                 newc[k] = feats[far_idx];
#                 counts[k] = 1;
#             } else {
#                 for (int j = 0; j < 4; ++j)
#                     newc[k].x[j] /= counts[k];
#             }
#         }
#         for (int k = 0; k < K; ++k)
#             cent[k] = newc[k];
# 
#         if (!changed) break;
#     }
# 
#     struct ClusterSummary {
#         int count;
#         double mean_gc;
#         double mean_cpg;
#         double mean_heavy;
#         double mean_gc3;
#     };
#     ClusterSummary cs[K];
#     for (int k = 0; k < K; ++k) {
#         cs[k].count = 0;
#         cs[k].mean_gc = cs[k].mean_cpg = cs[k].mean_heavy = cs[k].mean_gc3 = 0.0;
#     }
#     for (int i = 0; i < n; ++i) {
#         int k = assign[i];
#         cs[k].count++;
#         cs[k].mean_gc    += stats[i].gc_frac;
#         cs[k].mean_cpg   += stats[i].cpg_per_kb;
#         cs[k].mean_heavy += stats[i].gc_heavy_frac;
#         cs[k].mean_gc3   += stats[i].gc3_frac;
#     }
#     for (int k = 0; k < K; ++k) {
#         if (cs[k].count > 0) {
#             cs[k].mean_gc    /= cs[k].count;
#             cs[k].mean_cpg   /= cs[k].count;
#             cs[k].mean_heavy /= cs[k].count;
#             cs[k].mean_gc3   /= cs[k].count;
#         }
#     }
# 
#     std::printf("--- K-means lock regime clustering (K=3, 4D lock space) ---\n");
#     for (int k = 0; k < K; ++k) {
#         std::printf("  Cluster %d:\n", k);
#         std::printf("    size              : %d genes\n", cs[k].count);
#         std::printf("    mean GC_frac      : %.4f\n", cs[k].mean_gc);
#         std::printf("    mean CpG_per_kb   : %.2f\n", cs[k].mean_cpg);
#         std::printf("    mean GC-heavy_frac: %.4f\n", cs[k].mean_heavy);
#         std::printf("    mean GC3_frac     : %.4f\n", cs[k].mean_gc3);
#     }
#     std::printf("\n");
# 
#     int idx_low = 0, idx_high = 0;
#     for (int k = 1; k < K; ++k) {
#         if (cs[k].mean_gc3 < cs[idx_low].mean_gc3) idx_low = k;
#         if (cs[k].mean_gc3 > cs[idx_high].mean_gc3) idx_high = k;
#     }
#     int idx_mid_cluster = 3 - idx_low - idx_high;
# 
#     std::printf("Cluster interpretation by GC3 lock:\n");
#     std::printf("  Low-lock  cluster: %d (mean GC3 = %.4f)\n", idx_low, cs[idx_low].mean_gc3);
#     std::printf("  Mid-lock  cluster: %d (mean GC3 = %.4f)\n", idx_mid_cluster, cs[idx_mid_cluster].mean_gc3);
#     std::printf("  High-lock cluster: %d (mean GC3 = %.4f)\n\n", idx_high, cs[idx_high].mean_gc3);
# 
#     struct GeneRef { int idx; double gc3; };
#     std::vector<GeneRef> high_list;
#     for (int i = 0; i < n; ++i) {
#         if (assign[i] == idx_high) {
#             high_list.push_back({i, stats[i].gc3_frac});
#         }
#     }
#     std::sort(high_list.begin(), high_list.end(),
#               [](const GeneRef &a, const GeneRef &b){ return a.gc3 > b.gc3; });
# 
#     std::printf("--- Top hyper-locked genes in high-lock cluster (by GC3_frac) ---\n");
#     int max_show = (int)std::min<size_t>(high_list.size(), 10);
#     for (int r = 0; r < max_show; ++r) {
#         const auto &s = stats[high_list[r].idx];
#         std::printf("  [%2d] %s | len=%d | GC_frac=%.4f | CpG_per_kb=%.2f | GC-heavy=%.4f | GC3=%.4f\n",
#                     r+1, s.name.c_str(), s.length, s.gc_frac, s.cpg_per_kb, s.gc_heavy_frac, s.gc3_frac);
#     }
#     std::printf("\n");
# 
#     const char* interesting[] = {"yagE","yagF","yagG","yagH","yagA","phnD","phnK","phnM"};
#     const int interesting_n = (int)(sizeof(interesting)/sizeof(interesting[0]));
#     std::printf("--- Cluster membership for selected high-lock loci (if present) ---\n");
#     for (int t = 0; t < interesting_n; ++t) {
#         const std::string target = interesting[t];
#         int found = -1;
#         for (int i = 0; i < n; ++i) {
#             if (stats[i].name == target) {
#                 found = i;
#                 break;
#             }
#         }
#         if (found >= 0) {
#             int k = assign[found];
#             const auto &s = stats[found];
#             std::printf("  %-4s -> cluster %d | GC_frac=%.4f | CpG_per_kb=%.2f | GC-heavy=%.4f | GC3=%.4f\n",
#                         target.c_str(), k, s.gc_frac, s.cpg_per_kb, s.gc_heavy_frac, s.gc3_frac);
#         } else {
#             std::printf("  %-4s -> (not found as CDS name)\n", target.c_str());
#         }
#     }
# 
#     std::printf("\nGENE LOCK REGIME CLUSTERING finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# nvcc -O3 -std=c++17 warpfrac_dna_gene_lock_cluster.cu -o warpfrac_dna_gene_lock_cluster
# ./warpfrac_dna_gene_lock_cluster
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_gene_lock_null.cu << 'CPP'
# // warpfrac_dna_gene_lock_null.cu
# // DNA-L12 — Gene-wise lock vs per-gene shuffled null model (CPU-only)
# //
# // For each CDS we compute the same lock fingerprint as DNA-L10/11:
# //   GC_frac       = GC / length
# //   CpG_per_kb    = (#CG) * 1000 / (length-1)
# //   GC_heavy_frac = (#codons with >=2 GC bases) / total_codons
# //   GC3_frac      = (#GC at codon position 3) / total_codons
# //
# // Then, for each gene, we construct a null model by shuffling the bases
# // within that gene (preserving length and A/C/G/T counts), computing the
# // same lock metrics on each shuffle, and comparing:
# //
# //   - For each metric, mean +/- std over shuffles per gene.
# //   - z-scores: (real - mean_shuffle) / std_shuffle, when std > 0.
# //   - Global summary + top genes whose real locks >> shuffled null.
# //
# // CPU-only: compiled with nvcc as a C++17 program, no CUDA kernels.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# #include <random>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# struct LockStats {
#     std::string name;
#     int   start0;
#     int   end0;
#     char  strand;
#     int   length;
# 
#     long  gc_bases;
#     long  cpg_count;
#     long  codons;
#     long  gc_heavy_codons;
#     long  gc_pos3;
# 
#     double GC_frac;
#     double CpG_per_kb;
#     double GC_heavy_frac;
#     double GC3_frac;
# 
#     // shuffle means / stddevs
#     double shGC_frac_mean;
#     double shGC_frac_std;
#     double shCpG_per_kb_mean;
#     double shCpG_per_kb_std;
#     double shGC_heavy_frac_mean;
#     double shGC_heavy_frac_std;
#     double shGC3_frac_mean;
#     double shGC3_frac_std;
# 
#     // z-scores (real vs shuffled)
#     double z_GC_frac;
#     double z_CpG_per_kb;
#     double z_GC_heavy_frac;
#     double z_GC3_frac;
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         return "";
#     }
#     std::string line;
#     std::string seq;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (!std::isspace((unsigned char)c)) {
#                 seq.push_back(std::toupper((unsigned char)c));
#             }
#         }
#     }
#     return seq;
# }
# 
# static std::string get_attr_field(const std::string &attr, const char *key) {
#     // attributes like: key=value;key2=value2;
#     // We look for key= and return value up to ';'
#     std::string k(key);
#     k += "=";
#     std::size_t pos = attr.find(k);
#     if (pos == std::string::npos) return "";
#     pos += k.size();
#     std::size_t end = attr.find(';', pos);
#     if (end == std::string::npos) end = attr.size();
#     return attr.substr(pos, end - pos);
# }
# 
# static std::vector<CDSFeature> read_cds_gff(const std::string &path) {
#     std::vector<CDSFeature> out;
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         return out;
#     }
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string seqid, source, type, start, end, score, strand_s, phase, attr;
#         if (!std::getline(ss, seqid, '\t')) continue;
#         if (!std::getline(ss, source, '\t')) continue;
#         if (!std::getline(ss, type,  '\t')) continue;
#         if (!std::getline(ss, start, '\t')) continue;
#         if (!std::getline(ss, end,   '\t')) continue;
#         if (!std::getline(ss, score, '\t')) continue;
#         if (!std::getline(ss, strand_s, '\t')) continue;
#         if (!std::getline(ss, phase, '\t')) continue;
#         if (!std::getline(ss, attr)) attr.clear();
#         if (type != "CDS") continue;
# 
#         int s = std::atoi(start.c_str());
#         int e = std::atoi(end.c_str());
#         if (s <= 0 || e <= 0) continue;
#         if (e < s) std::swap(e, s);
#         int start0 = s - 1;
#         int end0   = e - 1;
#         char strand = strand_s.empty() ? '+' : strand_s[0];
# 
#         std::string name = get_attr_field(attr, "gene");
#         if (name.empty()) name = get_attr_field(attr, "Name");
#         if (name.empty()) name = get_attr_field(attr, "locus_tag");
#         if (name.empty()) name = get_attr_field(attr, "ID");
#         if (name.empty()) name = "CDS_" + std::to_string(start0) + "_" + std::to_string(end0);
# 
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start0;
#         f.end0   = end0;
#         f.strand = strand;
#         out.push_back(f);
#     }
#     return out;
# }
# 
# static char complement_base(char c) {
#     switch (std::toupper((unsigned char)c)) {
#         case 'A': return 'T';
#         case 'T': return 'A';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         default:  return 'N';
#     }
# }
# 
# static std::string extract_cds_seq(const std::string &genome, const CDSFeature &f) {
#     int len = f.end0 - f.start0 + 1;
#     if (f.start0 < 0 || f.end0 >= (int)genome.size() || len <= 0) return "";
#     std::string s = genome.substr(f.start0, len);
#     if (f.strand == '-') {
#         std::string rc;
#         rc.reserve(s.size());
#         for (int i = (int)s.size() - 1; i >= 0; --i) {
#             rc.push_back(complement_base(s[i]));
#         }
#         return rc;
#     }
#     return s;
# }
# 
# // Compute lock metrics from a single DNA sequence.
# static void compute_lock_metrics_from_seq(const std::string &seq,
#                                           long &gc_bases,
#                                           long &cpg_count,
#                                           long &codons,
#                                           long &gc_heavy_codons,
#                                           long &gc_pos3,
#                                           double &GC_frac,
#                                           double &CpG_per_kb,
#                                           double &GC_heavy_frac,
#                                           double &GC3_frac)
# {
#     const int L = (int)seq.size();
#     gc_bases = 0;
#     cpg_count = 0;
#     codons = 0;
#     gc_heavy_codons = 0;
#     gc_pos3 = 0;
# 
#     if (L <= 0) {
#         GC_frac = CpG_per_kb = GC_heavy_frac = GC3_frac = 0.0;
#         return;
#     }
# 
#     // GC bases
#     for (int i = 0; i < L; ++i) {
#         char c = std::toupper((unsigned char)seq[i]);
#         if (c == 'G' || c == 'C') gc_bases++;
#     }
# 
#     // CpG dinucleotides
#     for (int i = 0; i + 1 < L; ++i) {
#         char c1 = std::toupper((unsigned char)seq[i]);
#         char c2 = std::toupper((unsigned char)seq[i+1]);
#         if (c1 == 'C' && c2 == 'G') cpg_count++;
#     }
# 
#     // Codon-based metrics (triplets, skip codons with ambiguous bases)
#     if (L >= 3) {
#         for (int i = 0; i + 2 < L; i += 3) {
#             char b1 = std::toupper((unsigned char)seq[i  ]);
#             char b2 = std::toupper((unsigned char)seq[i+1]);
#             char b3 = std::toupper((unsigned char)seq[i+2]);
#             if ((b1!='A' && b1!='C' && b1!='G' && b1!='T') ||
#                 (b2!='A' && b2!='C' && b2!='G' && b2!='T') ||
#                 (b3!='A' && b3!='C' && b3!='G' && b3!='T')) {
#                 continue; // skip codon with N/other
#             }
#             codons++;
#             int gc_in_codon = 0;
#             if (b1=='G' || b1=='C') gc_in_codon++;
#             if (b2=='G' || b2=='C') gc_in_codon++;
#             if (b3=='G' || b3=='C') gc_in_codon++;
#             if (gc_in_codon >= 2) gc_heavy_codons++;
#             if (b3=='G' || b3=='C') gc_pos3++;
#         }
#     }
# 
#     GC_frac = (double)gc_bases / (double)L;
#     CpG_per_kb = (L > 1) ? ((double)cpg_count * 1000.0 / (double)(L - 1)) : 0.0;
#     GC_heavy_frac = (codons > 0) ? (double)gc_heavy_codons / (double)codons : 0.0;
#     GC3_frac      = (codons > 0) ? (double)gc_pos3        / (double)codons : 0.0;
# }
# 
# static void compute_mean_std(const std::vector<double> &vals, double &mean, double &sd) {
#     if (vals.empty()) { mean = 0.0; sd = 0.0; return; }
#     double s = 0.0;
#     for (double v : vals) s += v;
#     mean = s / (double)vals.size();
#     double var = 0.0;
#     for (double v : vals) {
#         double d = v - mean;
#         var += d*d;
#     }
#     var /= (double)vals.size();
#     sd = std::sqrt(var);
# }
# 
# int main() {
#     const std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     const std::string gff_path   = "/content/ecoli_U00096_3.gff";
#     const int N_SHUFFLES = 16;
# 
#     std::string genome = read_fasta(fasta_path);
#     if (genome.empty()) {
#         std::fprintf(stderr, "GENE LOCK NULL MODEL: failed to read FASTA.\n");
#         return 1;
#     }
#     std::vector<CDSFeature> cds = read_cds_gff(gff_path);
#     if (cds.empty()) {
#         std::fprintf(stderr, "GENE LOCK NULL MODEL: no CDS features loaded.\n");
#         return 1;
#     }
# 
#     std::printf("=====================================================================================\n");
#     std::printf("GENE LOCK NULL MODEL — Real vs Per-Gene Shuffled Locks (E. coli K-12 MG1655)\n");
#     std::printf("=====================================================================================\n");
#     std::printf("For each CDS we:\n");
#     std::printf("  1) Compute exact lock metrics on the real coding sequence:\n");
#     std::printf("     GC_frac, CpG_per_kb, GC_heavy_frac, GC3_frac.\n");
#     std::printf("  2) Shuffle the bases within that CDS %d times (same length + base counts),\n", N_SHUFFLES);
#     std::printf("     recompute the same metrics, and build a per-gene null model.\n");
#     std::printf("  3) Report per-gene z-scores: (real - mean_shuffle) / std_shuffle.\n");
#     std::printf("All counting is exact over the FASTA; floating point is only used for reporting\n");
#     std::printf("averages, stddevs and z-scores.\n\n");
# 
#     std::printf("Loading FASTA from: %s\n", fasta_path.c_str());
#     std::printf("Genome length: %zu bases\n\n", genome.size());
#     std::printf("Loading CDS annotations from: %s\n", gff_path.c_str());
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     std::vector<LockStats> all;
#     all.reserve(cds.size());
# 
#     std::mt19937_64 rng(123456789ULL);
# 
#     long total_len = 0;
#     long total_gc_bases = 0;
#     long total_cpg = 0;
#     long total_codons = 0;
#     long total_gc_heavy = 0;
#     long total_gc3 = 0;
# 
#     double sum_GC_frac = 0.0, sum_CpG = 0.0, sum_GCh = 0.0, sum_GC3 = 0.0;
#     double sum_GC_frac2 = 0.0, sum_CpG2 = 0.0, sum_GCh2 = 0.0, sum_GC32 = 0.0;
# 
#     for (const auto &f : cds) {
#         std::string seq = extract_cds_seq(genome, f);
#         int L = (int)seq.size();
#         if (L <= 0) continue;
#         if (L % 3 != 0) continue; // keep consistent with previous CDS-level modules
# 
#         LockStats ls;
#         ls.name   = f.name;
#         ls.start0 = f.start0;
#         ls.end0   = f.end0;
#         ls.strand = f.strand;
#         ls.length = L;
# 
#         compute_lock_metrics_from_seq(seq,
#                                       ls.gc_bases,
#                                       ls.cpg_count,
#                                       ls.codons,
#                                       ls.gc_heavy_codons,
#                                       ls.gc_pos3,
#                                       ls.GC_frac,
#                                       ls.CpG_per_kb,
#                                       ls.GC_heavy_frac,
#                                       ls.GC3_frac);
# 
#         // Build per-gene shuffled null model
#         std::vector<double> shGC, shCpG, shGCh, shGC3;
#         shGC.reserve(N_SHUFFLES);
#         shCpG.reserve(N_SHUFFLES);
#         shGCh.reserve(N_SHUFFLES);
#         shGC3.reserve(N_SHUFFLES);
# 
#         std::string sh = seq;
#         for (int r = 0; r < N_SHUFFLES; ++r) {
#             std::shuffle(sh.begin(), sh.end(), rng);
# 
#             long sgc_b, scpg, scod, sgch, sgc3;
#             double GCf, CpGkb, GHf, GC3f;
#             compute_lock_metrics_from_seq(sh,
#                                           sgc_b,
#                                           scpg,
#                                           scod,
#                                           sgch,
#                                           sgc3,
#                                           GCf,
#                                           CpGkb,
#                                           GHf,
#                                           GC3f);
# 
#             shGC.push_back(GCf);
#             shCpG.push_back(CpGkb);
#             shGCh.push_back(GHf);
#             shGC3.push_back(GC3f);
#         }
# 
#         compute_mean_std(shGC,  ls.shGC_frac_mean,       ls.shGC_frac_std);
#         compute_mean_std(shCpG, ls.shCpG_per_kb_mean,    ls.shCpG_per_kb_std);
#         compute_mean_std(shGCh, ls.shGC_heavy_frac_mean, ls.shGC_heavy_frac_std);
#         compute_mean_std(shGC3, ls.shGC3_frac_mean,      ls.shGC3_frac_std);
# 
#         auto zfun = [](double realv, double m, double s) -> double {
#             if (s <= 0.0) return 0.0;
#             return (realv - m) / s;
#         };
#         ls.z_GC_frac        = zfun(ls.GC_frac,       ls.shGC_frac_mean,       ls.shGC_frac_std);
#         ls.z_CpG_per_kb     = zfun(ls.CpG_per_kb,    ls.shCpG_per_kb_mean,    ls.shCpG_per_kb_std);
#         ls.z_GC_heavy_frac  = zfun(ls.GC_heavy_frac, ls.shGC_heavy_frac_mean, ls.shGC_heavy_frac_std);
#         ls.z_GC3_frac       = zfun(ls.GC3_frac,      ls.shGC3_frac_mean,      ls.shGC3_frac_std);
# 
#         total_len       += L;
#         total_gc_bases  += ls.gc_bases;
#         total_cpg       += ls.cpg_count;
#         total_codons    += ls.codons;
#         total_gc_heavy  += ls.gc_heavy_codons;
#         total_gc3       += ls.gc_pos3;
# 
#         sum_GC_frac  += ls.GC_frac;
#         sum_CpG      += ls.CpG_per_kb;
#         sum_GCh      += ls.GC_heavy_frac;
#         sum_GC3      += ls.GC3_frac;
#         sum_GC_frac2 += ls.GC_frac * ls.GC_frac;
#         sum_CpG2     += ls.CpG_per_kb * ls.CpG_per_kb;
#         sum_GCh2     += ls.GC_heavy_frac * ls.GC_heavy_frac;
#         sum_GC32     += ls.GC3_frac * ls.GC3_frac;
# 
#         all.push_back(ls);
#     }
# 
#     int N = (int)all.size();
#     double mean_GC  = (N > 0) ? sum_GC_frac  / N : 0.0;
#     double mean_CpG = (N > 0) ? sum_CpG      / N : 0.0;
#     double mean_GCh = (N > 0) ? sum_GCh      / N : 0.0;
#     double mean_GC3 = (N > 0) ? sum_GC3      / N : 0.0;
#     double sd_GC    = (N > 0) ? std::sqrt(sum_GC_frac2 / N - mean_GC*mean_GC) : 0.0;
#     double sd_CpG   = (N > 0) ? std::sqrt(sum_CpG2     / N - mean_CpG*mean_CpG) : 0.0;
#     double sd_GCh   = (N > 0) ? std::sqrt(sum_GCh2     / N - mean_GCh*mean_GCh) : 0.0;
#     double sd_GC3   = (N > 0) ? std::sqrt(sum_GC32     / N - mean_GC3*mean_GC3) : 0.0;
# 
#     std::printf("--- Global CDS-wise lock fingerprints (real) ---\n");
#     std::printf("  CDS analyzed (len%%3==0)         : %d\n", N);
#     std::printf("  Sum CDS lengths                  : %ld bases\n", total_len);
#     std::printf("  Sum valid codons                 : %ld\n", total_codons);
#     std::printf("  Total GC bases across CDS        : %ld\n", total_gc_bases);
#     std::printf("  Total CpG across CDS             : %ld\n", total_cpg);
#     std::printf("  Total GC-heavy codons            : %ld\n", total_gc_heavy);
#     std::printf("  Total GC at pos3                 : %ld\n", total_gc3);
#     std::printf("  Unweighted mean GC_frac          : %.4f (sd=%.4f)\n", mean_GC, sd_GC);
#     std::printf("  Unweighted mean CpG_per_kb       : %.4f (sd=%.4f)\n", mean_CpG, sd_CpG);
#     std::printf("  Unweighted mean GC-heavy_frac    : %.4f (sd=%.4f)\n", mean_GCh, sd_GCh);
#     std::printf("  Unweighted mean GC3_frac         : %.4f (sd=%.4f)\n\n", mean_GC3, sd_GC3);
# 
#     // Aggregate z-score distributions
#     double sum_zGC = 0.0, sum_zCpG = 0.0, sum_zGCh = 0.0, sum_zGC3 = 0.0;
#     double sum_zGC2 = 0.0, sum_zCpG2 = 0.0, sum_zGCh2 = 0.0, sum_zGC32 = 0.0;
#     int    cnt_zGC = 0,    cnt_zCpG = 0,    cnt_zGCh = 0,    cnt_zGC3 = 0;
# 
#     int zGC3_gt3 = 0, zGC3_gt5 = 0, zGC3_gt7 = 0;
#     int zCpG_gt3 = 0, zCpG_gt5 = 0, zCpG_gt7 = 0;
# 
#     for (const auto &ls : all) {
#         if (ls.shGC_frac_std > 0.0) {
#             sum_zGC  += ls.z_GC_frac;
#             sum_zGC2 += ls.z_GC_frac * ls.z_GC_frac;
#             cnt_zGC++;
#         }
#         if (ls.shCpG_per_kb_std > 0.0) {
#             sum_zCpG  += ls.z_CpG_per_kb;
#             sum_zCpG2 += ls.z_CpG_per_kb * ls.z_CpG_per_kb;
#             cnt_zCpG++;
#             if (ls.z_CpG_per_kb > 3.0) zCpG_gt3++;
#             if (ls.z_CpG_per_kb > 5.0) zCpG_gt5++;
#             if (ls.z_CpG_per_kb > 7.0) zCpG_gt7++;
#         }
#         if (ls.shGC_heavy_frac_std > 0.0) {
#             sum_zGCh  += ls.z_GC_heavy_frac;
#             sum_zGCh2 += ls.z_GC_heavy_frac * ls.z_GC_heavy_frac;
#             cnt_zGCh++;
#         }
#         if (ls.shGC3_frac_std > 0.0) {
#             sum_zGC3  += ls.z_GC3_frac;
#             sum_zGC32 += ls.z_GC3_frac * ls.z_GC3_frac;
#             cnt_zGC3++;
#             if (ls.z_GC3_frac > 3.0) zGC3_gt3++;
#             if (ls.z_GC3_frac > 5.0) zGC3_gt5++;
#             if (ls.z_GC3_frac > 7.0) zGC3_gt7++;
#         }
#     }
# 
#     auto zmean_sd = [](double sum, double sum2, int n, double &m, double &sd) {
#         if (n <= 0) { m = 0.0; sd = 0.0; return; }
#         m = sum / (double)n;
#         double var = sum2 / (double)n - m*m;
#         if (var < 0.0) var = 0.0;
#         sd = std::sqrt(var);
#     };
# 
#     double m_zGC, sd_zGC, m_zCpG, sd_zCpG, m_zGCh, sd_zGCh, m_zGC3, sd_zGC3;
#     zmean_sd(sum_zGC,  sum_zGC2,  cnt_zGC,  m_zGC,  sd_zGC);
#     zmean_sd(sum_zCpG, sum_zCpG2, cnt_zCpG, m_zCpG, sd_zCpG);
#     zmean_sd(sum_zGCh, sum_zGCh2, cnt_zGCh, m_zGCh, sd_zGCh);
#     zmean_sd(sum_zGC3, sum_zGC32, cnt_zGC3, m_zGC3, sd_zGC3);
# 
#     std::printf("--- Real vs shuffled z-score distributions ---\n");
#     std::printf("  GC_frac z-scores      : N=%d, mean=%.3f, sd=%.3f\n", cnt_zGC,  m_zGC,  sd_zGC);
#     std::printf("  CpG_per_kb z-scores   : N=%d, mean=%.3f, sd=%.3f\n", cnt_zCpG, m_zCpG, sd_zCpG);
#     std::printf("  GC-heavy_frac z-scores: N=%d, mean=%.3f, sd=%.3f\n", cnt_zGCh, m_zGCh, sd_zGCh);
#     std::printf("  GC3_frac z-scores     : N=%d, mean=%.3f, sd=%.3f\n\n", cnt_zGC3, m_zGC3, sd_zGC3);
# 
#     std::printf("  GC3 lock vs shuffled (per gene):\n");
#     std::printf("    z(GC3) > 3   : %d / %d\n", zGC3_gt3, N);
#     std::printf("    z(GC3) > 5   : %d / %d\n", zGC3_gt5, N);
#     std::printf("    z(GC3) > 7   : %d / %d\n\n", zGC3_gt7, N);
# 
#     std::printf("  CpG lock vs shuffled (per gene):\n");
#     std::printf("    z(CpG_per_kb) > 3 : %d / %d\n", zCpG_gt3, N);
#     std::printf("    z(CpG_per_kb) > 5 : %d / %d\n", zCpG_gt5, N);
#     std::printf("    z(CpG_per_kb) > 7 : %d / %d\n\n", zCpG_gt7, N);
# 
#     // Top genes by GC3 z-score
#     std::sort(all.begin(), all.end(), [](const LockStats &a, const LockStats &b){
#         return a.z_GC3_frac > b.z_GC3_frac;
#     });
# 
#     int topN = std::min(10, N);
#     std::printf("--- Top %d genes by GC3 lock vs shuffled (z(GC3_frac)) ---\n", topN);
#     for (int i = 0; i < topN; ++i) {
#         const auto &ls = all[i];
#         std::printf("  [%2d] %-8s | len=%d | GC_frac=%.4f | CpG_per_kb=%.2f | GC-heavy=%.4f | GC3=%.4f | z(GC3)=%.2f | z(CpG)=%.2f\n",
#                     i+1,
#                     ls.name.c_str(),
#                     ls.length,
#                     ls.GC_frac,
#                     ls.CpG_per_kb,
#                     ls.GC_heavy_frac,
#                     ls.GC3_frac,
#                     ls.z_GC3_frac,
#                     ls.z_CpG_per_kb);
#     }
# 
#     // Also report a few specific loci if present (yag cluster + phn cluster)
#     auto print_if_present = [&](const char *tag){
#         for (const auto &ls : all) {
#             if (ls.name == tag) {
#                 std::printf("\n  [%s] lock vs shuffled:\n", tag);
#                 std::printf("    length            : %d\n", ls.length);
#                 std::printf("    GC_frac (real)    : %.4f | shuffle mean=%.4f, sd=%.4f, z=%.2f\n",
#                             ls.GC_frac, ls.shGC_frac_mean, ls.shGC_frac_std, ls.z_GC_frac);
#                 std::printf("    CpG_per_kb (real) : %.2f | shuffle mean=%.2f, sd=%.2f, z=%.2f\n",
#                             ls.CpG_per_kb, ls.shCpG_per_kb_mean, ls.shCpG_per_kb_std, ls.z_CpG_per_kb);
#                 std::printf("    GC-heavy (real)   : %.4f | shuffle mean=%.4f, sd=%.4f, z=%.2f\n",
#                             ls.GC_heavy_frac, ls.shGC_heavy_frac_mean, ls.shGC_heavy_frac_std, ls.z_GC_heavy_frac);
#                 std::printf("    GC3_frac (real)   : %.4f | shuffle mean=%.4f, sd=%.4f, z=%.2f\n",
#                             ls.GC3_frac, ls.shGC3_frac_mean, ls.shGC3_frac_std, ls.z_GC3_frac);
#                 return;
#             }
#         }
#     };
# 
#     std::printf("\n--- Lock vs shuffled for key high-lock cluster genes (if present) ---\n");
#     print_if_present("yagE");
#     print_if_present("yagF");
#     print_if_present("yagG");
#     print_if_present("yagH");
#     print_if_present("yagA");
#     print_if_present("phnD");
#     print_if_present("phnK");
#     print_if_present("phnM");
# 
#     std::printf("\nGENE LOCK NULL MODEL analysis finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# nvcc -O3 -std=c++17 warpfrac_dna_gene_lock_null.cu -o warpfrac_dna_gene_lock_null
# ./warpfrac_dna_gene_lock_null
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_codon_recode_null.cu << 'CPP'
# // warpfrac_dna_codon_recode_null.cu
# // DNA-L13 — Codon-level lock vs synonymous recoding null model (CPU-only)
# //
# // For each CDS (len % 3 == 0) we:
# //   1) Compute "lock" metrics on the real coding sequence:
# //        GC_frac       = GC / length
# //        CpG_per_kb    = (#CG) * 1000 / (length - 1)
# //        GC_heavy_frac = (#codons with >=2 GC bases) / total_codons
# //        GC3_frac      = (#GC at codon position 3) / total_codons
# //   2) Translate the CDS to amino acids using the standard genetic code.
# //   3) Build a null model by randomly recoding the CDS N_RECODES times:
# //        - Keep the amino-acid sequence fixed.
# //        - For each amino acid, choose a random synonymous codon
# //          from the standard genetic code (stop codons kept as-is).
# //        - Compute the same lock metrics.
# //   4) For each metric, compute per-gene mean/std over recodes and a z-score:
# //        z = (real - mean_recode) / std_recode  (if std>0; else 0).
# //
# // This asks: “Is this gene’s GC3 / CpG / GC-heavy pattern more extreme than
# // what you’d get by random synonymous recoding of the same protein?”
# //
# // CPU-only: compiled with nvcc as a C++17 program, but no CUDA kernels.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# #include <random>
# #include <unordered_map>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# struct LockStats {
#     std::string name;
#     int   start0;
#     int   end0;
#     char  strand;
#     int   length;
# 
#     long  gc_bases;
#     long  cpg_count;
#     long  codons;
#     long  gc_heavy_codons;
#     long  gc_pos3;
# 
#     double GC_frac;
#     double CpG_per_kb;
#     double GC_heavy_frac;
#     double GC3_frac;
# 
#     // recode means/stddevs
#     double rGC_frac_mean;
#     double rGC_frac_std;
#     double rCpG_per_kb_mean;
#     double rCpG_per_kb_std;
#     double rGC_heavy_frac_mean;
#     double rGC_heavy_frac_std;
#     double rGC3_frac_mean;
#     double rGC3_frac_std;
# 
#     // z-scores (real vs recoded)
#     double z_GC_frac;
#     double z_CpG_per_kb;
#     double z_GC_heavy_frac;
#     double z_GC3_frac;
# };
# 
# struct CodonEntry {
#     const char *codon;
#     char aa; // amino acid (single-letter), '*' for stop
# };
# 
# static const CodonEntry CODON_TABLE[] = {
#     // Standard genetic code (ATG...); all in uppercase.
#     {"TTT",'F'}, {"TTC",'F'}, {"TTA",'L'}, {"TTG",'L'},
#     {"CTT",'L'}, {"CTC",'L'}, {"CTA",'L'}, {"CTG",'L'},
#     {"ATT",'I'}, {"ATC",'I'}, {"ATA",'I'}, {"ATG",'M'},
#     {"GTT",'V'}, {"GTC",'V'}, {"GTA",'V'}, {"GTG",'V'},
# 
#     {"TCT",'S'}, {"TCC",'S'}, {"TCA",'S'}, {"TCG",'S'},
#     {"CCT",'P'}, {"CCC",'P'}, {"CCA",'P'}, {"CCG",'P'},
#     {"ACT",'T'}, {"ACC",'T'}, {"ACA",'T'}, {"ACG",'T'},
#     {"GCT",'A'}, {"GCC",'A'}, {"GCA",'A'}, {"GCG",'A'},
# 
#     {"TAT",'Y'}, {"TAC",'Y'}, {"TAA",'*'}, {"TAG",'*'},
#     {"CAT",'H'}, {"CAC",'H'}, {"CAA",'Q'}, {"CAG",'Q'},
#     {"AAT",'N'}, {"AAC",'N'}, {"AAA",'K'}, {"AAG",'K'},
#     {"GAT",'D'}, {"GAC",'D'}, {"GAA",'E'}, {"GAG",'E'},
# 
#     {"TGT",'C'}, {"TGC",'C'}, {"TGA",'*'}, {"TGG",'W'},
#     {"CGT",'R'}, {"CGC",'R'}, {"CGA",'R'}, {"CGG",'R'},
#     {"AGT",'S'}, {"AGC",'S'}, {"AGA",'R'}, {"AGG",'R'},
#     {"GGT",'G'}, {"GGC",'G'}, {"GGA",'G'}, {"GGG",'G'},
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         return "";
#     }
#     std::string line;
#     std::string seq;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (!std::isspace((unsigned char)c)) {
#                 seq.push_back(std::toupper((unsigned char)c));
#             }
#         }
#     }
#     return seq;
# }
# 
# static std::string get_attr_field(const std::string &attr, const char *key) {
#     std::string k(key);
#     k += "=";
#     std::size_t pos = attr.find(k);
#     if (pos == std::string::npos) return "";
#     pos += k.size();
#     std::size_t end = attr.find(';', pos);
#     if (end == std::string::npos) end = attr.size();
#     return attr.substr(pos, end - pos);
# }
# 
# static std::vector<CDSFeature> read_cds_gff(const std::string &path) {
#     std::vector<CDSFeature> out;
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         return out;
#     }
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string seqid, source, type, start, end, score, strand_s, phase, attr;
#         if (!std::getline(ss, seqid, '\t')) continue;
#         if (!std::getline(ss, source, '\t')) continue;
#         if (!std::getline(ss, type,  '\t')) continue;
#         if (!std::getline(ss, start, '\t')) continue;
#         if (!std::getline(ss, end,   '\t')) continue;
#         if (!std::getline(ss, score, '\t')) continue;
#         if (!std::getline(ss, strand_s, '\t')) continue;
#         if (!std::getline(ss, phase, '\t')) continue;
#         if (!std::getline(ss, attr)) attr.clear();
#         if (type != "CDS") continue;
# 
#         int s = std::atoi(start.c_str());
#         int e = std::atoi(end.c_str());
#         if (s <= 0 || e <= 0) continue;
#         if (e < s) std::swap(e, s);
#         int start0 = s - 1;
#         int end0   = e - 1;
#         char strand = strand_s.empty() ? '+' : strand_s[0];
# 
#         std::string name = get_attr_field(attr, "gene");
#         if (name.empty()) name = get_attr_field(attr, "Name");
#         if (name.empty()) name = get_attr_field(attr, "locus_tag");
#         if (name.empty()) name = get_attr_field(attr, "ID");
#         if (name.empty()) name = "CDS_" + std::to_string(start0) + "_" + std::to_string(end0);
# 
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start0;
#         f.end0   = end0;
#         f.strand = strand;
#         out.push_back(f);
#     }
#     return out;
# }
# 
# static char complement_base(char c) {
#     switch (std::toupper((unsigned char)c)) {
#         case 'A': return 'T';
#         case 'T': return 'A';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         default:  return 'N';
#     }
# }
# 
# static std::string extract_cds_seq(const std::string &genome, const CDSFeature &f) {
#     int len = f.end0 - f.start0 + 1;
#     if (f.start0 < 0 || f.end0 >= (int)genome.size() || len <= 0) return "";
#     std::string s = genome.substr(f.start0, len);
#     if (f.strand == '-') {
#         std::string rc;
#         rc.reserve(s.size());
#         for (int i = (int)s.size() - 1; i >= 0; --i) {
#             rc.push_back(complement_base(s[i]));
#         }
#         return rc;
#     }
#     return s;
# }
# 
# // Compute lock metrics from a single DNA sequence (assumed CDS, len%3==0)
# static void compute_lock_metrics_from_seq(const std::string &seq,
#                                           long &gc_bases,
#                                           long &cpg_count,
#                                           long &codons,
#                                           long &gc_heavy_codons,
#                                           long &gc_pos3,
#                                           double &GC_frac,
#                                           double &CpG_per_kb,
#                                           double &GC_heavy_frac,
#                                           double &GC3_frac)
# {
#     const int L = (int)seq.size();
#     gc_bases = 0;
#     cpg_count = 0;
#     codons = 0;
#     gc_heavy_codons = 0;
#     gc_pos3 = 0;
# 
#     if (L <= 0) {
#         GC_frac = CpG_per_kb = GC_heavy_frac = GC3_frac = 0.0;
#         return;
#     }
# 
#     for (int i = 0; i < L; ++i) {
#         char c = std::toupper((unsigned char)seq[i]);
#         if (c == 'G' || c == 'C') gc_bases++;
#     }
# 
#     for (int i = 0; i + 1 < L; ++i) {
#         char c1 = std::toupper((unsigned char)seq[i]);
#         char c2 = std::toupper((unsigned char)seq[i+1]);
#         if (c1 == 'C' && c2 == 'G') cpg_count++;
#     }
# 
#     if (L >= 3) {
#         for (int i = 0; i + 2 < L; i += 3) {
#             char b1 = std::toupper((unsigned char)seq[i  ]);
#             char b2 = std::toupper((unsigned char)seq[i+1]);
#             char b3 = std::toupper((unsigned char)seq[i+2]);
#             if ((b1!='A' && b1!='C' && b1!='G' && b1!='T') ||
#                 (b2!='A' && b2!='C' && b2!='G' && b2!='T') ||
#                 (b3!='A' && b3!='C' && b3!='G' && b3!='T')) {
#                 continue;
#             }
#             codons++;
#             int gc_in_codon = 0;
#             if (b1=='G' || b1=='C') gc_in_codon++;
#             if (b2=='G' || b2=='C') gc_in_codon++;
#             if (b3=='G' || b3=='C') gc_in_codon++;
#             if (gc_in_codon >= 2) gc_heavy_codons++;
#             if (b3=='G' || b3=='C') gc_pos3++;
#         }
#     }
# 
#     GC_frac = (double)gc_bases / (double)L;
#     CpG_per_kb = (L > 1) ? ((double)cpg_count * 1000.0 / (double)(L - 1)) : 0.0;
#     GC_heavy_frac = (codons > 0) ? (double)gc_heavy_codons / (double)codons : 0.0;
#     GC3_frac      = (codons > 0) ? (double)gc_pos3        / (double)codons : 0.0;
# }
# 
# static char translate_codon(const std::string &codon,
#                             const std::unordered_map<std::string,char> &codon2aa)
# {
#     auto it = codon2aa.find(codon);
#     if (it == codon2aa.end()) return '?';
#     return it->second;
# }
# 
# static void compute_mean_std(const std::vector<double> &vals, double &mean, double &sd) {
#     if (vals.empty()) { mean = 0.0; sd = 0.0; return; }
#     double s = 0.0;
#     for (double v : vals) s += v;
#     mean = s / (double)vals.size();
#     double var = 0.0;
#     for (double v : vals) {
#         double d = v - mean;
#         var += d*d;
#     }
#     var /= (double)vals.size();
#     sd = std::sqrt(var);
# }
# 
# int main() {
#     const std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     const std::string gff_path   = "/content/ecoli_U00096_3.gff";
#     const int N_RECODES = 16;
# 
#     std::string genome = read_fasta(fasta_path);
#     if (genome.empty()) {
#         std::fprintf(stderr, "CODON RECODE NULL: failed to read FASTA.\n");
#         return 1;
#     }
#     std::vector<CDSFeature> cds = read_cds_gff(gff_path);
#     if (cds.empty()) {
#         std::fprintf(stderr, "CODON RECODE NULL: no CDS features loaded.\n");
#         return 1;
#     }
# 
#     // Build codon -> aa map and aa -> list of synonymous codons
#     std::unordered_map<std::string,char> codon2aa;
#     std::vector<std::string> aa_codons[26]; // 'A'..'Z'
#     for (const auto &ce : CODON_TABLE) {
#         std::string c(ce.codon);
#         std::string cu;
#         for (char ch : c) cu.push_back(std::toupper((unsigned char)ch));
#         codon2aa[cu] = ce.aa;
#     }
#     for (const auto &ce : CODON_TABLE) {
#         char aa = ce.aa;
#         if (aa == '*') continue; // don't recode stop codons here
#         int idx = aa - 'A';
#         if (idx < 0 || idx >= 26) continue;
#         std::string c(ce.codon);
#         std::string cu;
#         for (char ch : c) cu.push_back(std::toupper((unsigned char)ch));
#         aa_codons[idx].push_back(cu);
#     }
# 
#     std::mt19937_64 rng(987654321ULL);
# 
#     std::printf("=====================================================================================\n");
#     std::printf("CODON-LEVEL LOCK vs SYNONYMOUS RECODING NULL MODEL — E. coli K-12 MG1655\n");
#     std::printf("=====================================================================================\n");
#     std::printf("For each CDS (len %% 3 == 0) we:\n");
#     std::printf("  • Compute exact lock metrics on the real coding sequence:\n");
#     std::printf("      GC_frac, CpG_per_kb, GC_heavy_frac, GC3_frac.\n");
#     std::printf("  • Translate to amino acids using the standard genetic code.\n");
#     std::printf("  • Recoding null model: %d random synonymous recodes per CDS\n", N_RECODES);
#     std::printf("      (AA sequence fixed, codons randomized among all synonyms).\n");
#     std::printf("  • For each metric, we get per-gene mean/std over recodes and a z-score\n");
#     std::printf("      z = (real - mean_recode) / std_recode.\n\n");
# 
#     std::printf("Loading FASTA from: %s\n", fasta_path.c_str());
#     std::printf("Genome length: %zu bases\n\n", genome.size());
#     std::printf("Loading CDS annotations from: %s\n", gff_path.c_str());
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     std::vector<LockStats> all;
#     all.reserve(cds.size());
# 
#     long total_len = 0;
#     long total_gc_bases = 0;
#     long total_cpg = 0;
#     long total_codons = 0;
#     long total_gc_heavy = 0;
#     long total_gc3 = 0;
# 
#     for (const auto &f : cds) {
#         std::string seq = extract_cds_seq(genome, f);
#         int L = (int)seq.size();
#         if (L <= 0) continue;
#         if (L % 3 != 0) continue;
# 
#         // Translate to amino acids and build codon index list
#         std::vector<char> aa_seq;
#         std::vector<int>  aa_index; // index into aa_codons (0..25) or -1 for invalid/stop
#         aa_seq.reserve(L/3);
#         aa_index.reserve(L/3);
# 
#         bool translation_ok = true;
#         for (int i = 0; i + 2 < L; i += 3) {
#             std::string codon;
#             codon.push_back(std::toupper((unsigned char)seq[i]));
#             codon.push_back(std::toupper((unsigned char)seq[i+1]));
#             codon.push_back(std::toupper((unsigned char)seq[i+2]));
#             char aa = translate_codon(codon, codon2aa);
#             if (aa == '?') {
#                 translation_ok = false;
#                 break;
#             }
#             if (aa == '*') {
#                 // stop codon inside CDS: keep as '*' but don't recode; we'll
#                 // just re-use the same codon when recoding.
#                 aa_seq.push_back('*');
#                 aa_index.push_back(-1);
#             } else {
#                 aa_seq.push_back(aa);
#                 int idx = aa - 'A';
#                 if (idx < 0 || idx >= 26 || aa_codons[idx].empty()) {
#                     translation_ok = false;
#                     break;
#                 }
#                 aa_index.push_back(idx);
#             }
#         }
#         if (!translation_ok) continue;
# 
#         LockStats ls;
#         ls.name   = f.name;
#         ls.start0 = f.start0;
#         ls.end0   = f.end0;
#         ls.strand = f.strand;
#         ls.length = L;
# 
#         compute_lock_metrics_from_seq(seq,
#                                       ls.gc_bases,
#                                       ls.cpg_count,
#                                       ls.codons,
#                                       ls.gc_heavy_codons,
#                                       ls.gc_pos3,
#                                       ls.GC_frac,
#                                       ls.CpG_per_kb,
#                                       ls.GC_heavy_frac,
#                                       ls.GC3_frac);
# 
#         std::vector<double> rGC, rCpG, rGCh, rGC3;
#         rGC.reserve(N_RECODES);
#         rCpG.reserve(N_RECODES);
#         rGCh.reserve(N_RECODES);
#         rGC3.reserve(N_RECODES);
# 
#         // Recoding runs
#         std::uniform_real_distribution<double> ud(0.0, 1.0);
#         for (int r = 0; r < N_RECODES; ++r) {
#             std::string recoded;
#             recoded.reserve(L);
# 
#             int codon_idx = 0;
#             for (int i = 0; i + 2 < L; i += 3, ++codon_idx) {
#                 std::string orig_codon;
#                 orig_codon.push_back(std::toupper((unsigned char)seq[i]));
#                 orig_codon.push_back(std::toupper((unsigned char)seq[i+1]));
#                 orig_codon.push_back(std::toupper((unsigned char)seq[i+2]));
# 
#                 int idx = aa_index[codon_idx];
#                 if (idx < 0) {
#                     // stop codon: keep original codon
#                     recoded.append(orig_codon);
#                     continue;
#                 }
#                 const auto &syns = aa_codons[idx];
#                 if (syns.empty()) {
#                     recoded.append(orig_codon);
#                     continue;
#                 }
#                 // choose a random synonym
#                 int sidx = (int)(ud(rng) * syns.size());
#                 if (sidx < 0) sidx = 0;
#                 if (sidx >= (int)syns.size()) sidx = (int)syns.size() - 1;
#                 recoded.append(syns[sidx]);
#             }
# 
#             long rgc_b, rcpg, rcod, rgch, rgc3;
#             double GCf, CpGkb, GHf, GC3f;
#             compute_lock_metrics_from_seq(recoded,
#                                           rgc_b,
#                                           rcpg,
#                                           rcod,
#                                           rgch,
#                                           rgc3,
#                                           GCf,
#                                           CpGkb,
#                                           GHf,
#                                           GC3f);
#             rGC.push_back(GCf);
#             rCpG.push_back(CpGkb);
#             rGCh.push_back(GHf);
#             rGC3.push_back(GC3f);
#         }
# 
#         compute_mean_std(rGC,  ls.rGC_frac_mean,       ls.rGC_frac_std);
#         compute_mean_std(rCpG, ls.rCpG_per_kb_mean,    ls.rCpG_per_kb_std);
#         compute_mean_std(rGCh, ls.rGC_heavy_frac_mean, ls.rGC_heavy_frac_std);
#         compute_mean_std(rGC3, ls.rGC3_frac_mean,      ls.rGC3_frac_std);
# 
#         auto zfun = [](double realv, double m, double s) -> double {
#             if (s <= 0.0) return 0.0;
#             return (realv - m) / s;
#         };
#         ls.z_GC_frac        = zfun(ls.GC_frac,       ls.rGC_frac_mean,       ls.rGC_frac_std);
#         ls.z_CpG_per_kb     = zfun(ls.CpG_per_kb,    ls.rCpG_per_kb_mean,    ls.rCpG_per_kb_std);
#         ls.z_GC_heavy_frac  = zfun(ls.GC_heavy_frac, ls.rGC_heavy_frac_mean, ls.rGC_heavy_frac_std);
#         ls.z_GC3_frac       = zfun(ls.GC3_frac,      ls.rGC3_frac_mean,      ls.rGC3_frac_std);
# 
#         total_len      += L;
#         total_gc_bases += ls.gc_bases;
#         total_cpg      += ls.cpg_count;
#         total_codons   += ls.codons;
#         total_gc_heavy += ls.gc_heavy_codons;
#         total_gc3      += ls.gc_pos3;
# 
#         all.push_back(ls);
#     }
# 
#     int N = (int)all.size();
#     std::printf("--- CDS set used for codon-recoding null model ---\n");
#     std::printf("  CDS analyzed (len%%3==0, translatable) : %d\n", N);
#     std::printf("  Sum CDS lengths                        : %ld bases\n", total_len);
#     std::printf("  Sum valid codons                       : %ld\n", total_codons);
#     std::printf("  Total GC bases across CDS              : %ld\n", total_gc_bases);
#     std::printf("  Total CpG across CDS                   : %ld\n", total_cpg);
#     std::printf("  Total GC-heavy codons                  : %ld\n", total_gc_heavy);
#     std::printf("  Total GC at pos3                       : %ld\n\n", total_gc3);
# 
#     int zGC3_gt3 = 0, zGC3_gt5 = 0, zGC3_gt7 = 0;
#     int zCpG_gt3 = 0, zCpG_gt5 = 0, zCpG_gt7 = 0;
# 
#     for (const auto &ls : all) {
#         if (ls.z_GC3_frac > 3.0) zGC3_gt3++;
#         if (ls.z_GC3_frac > 5.0) zGC3_gt5++;
#         if (ls.z_GC3_frac > 7.0) zGC3_gt7++;
# 
#         if (ls.z_CpG_per_kb > 3.0) zCpG_gt3++;
#         if (ls.z_CpG_per_kb > 5.0) zCpG_gt5++;
#         if (ls.z_CpG_per_kb > 7.0) zCpG_gt7++;
#     }
# 
#     std::printf("--- Per-gene z-score counts (real vs synonymous recodes) ---\n");
#     std::printf("  GC3 lock vs recodes:\n");
#     std::printf("    z(GC3) > 3 : %d / %d\n", zGC3_gt3, N);
#     std::printf("    z(GC3) > 5 : %d / %d\n", zGC3_gt5, N);
#     std::printf("    z(GC3) > 7 : %d / %d\n\n", zGC3_gt7, N);
# 
#     std::printf("  CpG lock vs recodes:\n");
#     std::printf("    z(CpG_per_kb) > 3 : %d / %d\n", zCpG_gt3, N);
#     std::printf("    z(CpG_per_kb) > 5 : %d / %d\n", zCpG_gt5, N);
#     std::printf("    z(CpG_per_kb) > 7 : %d / %d\n\n", zCpG_gt7, N);
# 
#     // Sort by GC3 z-score
#     std::sort(all.begin(), all.end(), [](const LockStats &a, const LockStats &b){
#         return a.z_GC3_frac > b.z_GC3_frac;
#     });
# 
#     int topN = std::min(10, N);
#     std::printf("--- Top %d genes by GC3 lock vs synonymous recodes (z(GC3_frac)) ---\n", topN);
#     for (int i = 0; i < topN; ++i) {
#         const auto &ls = all[i];
#         std::printf("  [%2d] %-8s | len=%d | GC_frac=%.4f | CpG_per_kb=%.2f | GC-heavy=%.4f | GC3=%.4f | z(GC3)=%.2f | z(CpG)=%.2f\n",
#                     i+1,
#                     ls.name.c_str(),
#                     ls.length,
#                     ls.GC_frac,
#                     ls.CpG_per_kb,
#                     ls.GC_heavy_frac,
#                     ls.GC3_frac,
#                     ls.z_GC3_frac,
#                     ls.z_CpG_per_kb);
#     }
# 
#     auto print_if_present = [&](const char *tag){
#         for (const auto &ls : all) {
#             if (ls.name == tag) {
#                 std::printf("\n  [%s] lock vs synonymous recodes:\n", tag);
#                 std::printf("    length            : %d\n", ls.length);
#                 std::printf("    GC_frac (real)    : %.4f | recode mean=%.4f, sd=%.4f, z=%.2f\n",
#                             ls.GC_frac, ls.rGC_frac_mean, ls.rGC_frac_std, ls.z_GC_frac);
#                 std::printf("    CpG_per_kb (real) : %.2f | recode mean=%.2f, sd=%.2f, z=%.2f\n",
#                             ls.CpG_per_kb, ls.rCpG_per_kb_mean, ls.rCpG_per_kb_std, ls.z_CpG_per_kb);
#                 std::printf("    GC-heavy (real)   : %.4f | recode mean=%.4f, sd=%.4f, z=%.2f\n",
#                             ls.GC_heavy_frac, ls.rGC_heavy_frac_mean, ls.rGC_heavy_frac_std, ls.z_GC_heavy_frac);
#                 std::printf("    GC3_frac (real)   : %.4f | recode mean=%.4f, sd=%.4f, z=%.2f\n",
#                             ls.GC3_frac, ls.rGC3_frac_mean, ls.rGC3_frac_std, ls.z_GC3_frac);
#                 return;
#             }
#         }
#     };
# 
#     std::printf("\n--- Lock vs synonymous recodes for key loci (if present) ---\n");
#     print_if_present("yagE");
#     print_if_present("yagF");
#     print_if_present("yagG");
#     print_if_present("yagH");
#     print_if_present("yagA");
#     print_if_present("phnD");
#     print_if_present("phnK");
#     print_if_present("phnM");
# 
#     std::printf("\nCODON-LEVEL LOCK vs SYNONYMOUS RECODING NULL MODEL finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# nvcc -O3 -std=c++17 warpfrac_dna_codon_recode_null.cu -o warpfrac_dna_codon_recode_null
# ./warpfrac_dna_codon_recode_null
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# echo "======================================================================================================================"
# echo "MODULE DNA-L14 — INTRA-GENE GC3 LOCK LANDSCAPE (E. coli MG1655, CDS-level)"
# echo "======================================================================================================================"
# echo
# 
# FASTA=/content/ecoli_U00096_3.fna
# GFF=/content/ecoli_U00096_3.gff
# 
# if [ ! -f "$FASTA" ]; then
#   echo "[DNA-L14] FASTA not found at $FASTA, fetching U00096.3 from NCBI..."
#   curl -sS -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna.gz" \
#     -o /content/ecoli.fna.gz
#   gunzip -f /content/ecoli.fna.gz
#   mv /content/ecoli.fna "$FASTA"
#   echo "[DNA-L14] FASTA downloaded."
# else
#   echo "[DNA-L14] FASTA found at $FASTA, reusing."
# fi
# 
# if [ ! -f "$GFF" ]; then
#   echo "[DNA-L14] GFF not found at $GFF, fetching U00096.3 GFF3 from NCBI..."
#   curl -sS -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.gff.gz" \
#     -o /content/ecoli.gff.gz
#   gunzip -f /content/ecoli.gff.gz
#   mv /content/ecoli.gff "$GFF"
#   echo "[DNA-L14] GFF downloaded."
# else
#   echo "[DNA-L14] GFF found at $GFF, reusing."
# fi
# 
# cat > warpfrac_dna_gc3_landscape.cu << 'CPP'
# // warpfrac_dna_gc3_landscape.cu
# // DNA-L14 — Intra-gene GC3 lock landscape (CPU-only)
# //
# // For each CDS (len % 3 == 0) we:
# //   • Extract its coding sequence (respecting strand).
# //   • Treat it as codons; slide a window of W codons along the gene.
# //   • For each window, compute GC3_frac = (#GC at codon position 3) / window_codons.
# //   • For each gene, record min / max / range of GC3 over windows.
# //   • For a small set of "special" hyper-locked genes (yag*, phn*, etc.),
# //     print the top 3 GC3-hottest windows with positions.
# //
# // No GPU. Just nvcc compiling a C++17 program.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         return "";
#     }
#     std::string line, seq;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (!std::isspace((unsigned char)c)) {
#                 seq.push_back(std::toupper((unsigned char)c));
#             }
#         }
#     }
#     return seq;
# }
# 
# static std::string get_attr_field(const std::string &attr, const char *key) {
#     std::string k(key);
#     k += "=";
#     std::size_t pos = attr.find(k);
#     if (pos == std::string::npos) return "";
#     pos += k.size();
#     std::size_t end = attr.find(';', pos);
#     if (end == std::string::npos) end = attr.size();
#     return attr.substr(pos, end - pos);
# }
# 
# static std::vector<CDSFeature> read_cds_gff(const std::string &path) {
#     std::vector<CDSFeature> out;
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         return out;
#     }
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string seqid, source, type, start, end, score, strand_s, phase, attr;
#         if (!std::getline(ss, seqid, '\t')) continue;
#         if (!std::getline(ss, source, '\t')) continue;
#         if (!std::getline(ss, type,  '\t')) continue;
#         if (!std::getline(ss, start, '\t')) continue;
#         if (!std::getline(ss, end,   '\t')) continue;
#         if (!std::getline(ss, score, '\t')) continue;
#         if (!std::getline(ss, strand_s, '\t')) continue;
#         if (!std::getline(ss, phase, '\t')) continue;
#         if (!std::getline(ss, attr)) attr.clear();
#         if (type != "CDS") continue;
# 
#         int s = std::atoi(start.c_str());
#         int e = std::atoi(end.c_str());
#         if (s <= 0 || e <= 0) continue;
#         if (e < s) std::swap(e, s);
#         int start0 = s - 1;
#         int end0   = e - 1;
#         char strand = strand_s.empty() ? '+' : strand_s[0];
# 
#         std::string name = get_attr_field(attr, "gene");
#         if (name.empty()) name = get_attr_field(attr, "Name");
#         if (name.empty()) name = get_attr_field(attr, "locus_tag");
#         if (name.empty()) name = get_attr_field(attr, "ID");
#         if (name.empty()) name = "CDS_" + std::to_string(start0) + "_" + std::to_string(end0);
# 
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start0;
#         f.end0   = end0;
#         f.strand = strand;
#         out.push_back(f);
#     }
#     return out;
# }
# 
# static char complement_base(char c) {
#     switch (std::toupper((unsigned char)c)) {
#         case 'A': return 'T';
#         case 'T': return 'A';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         default:  return 'N';
#     }
# }
# 
# static std::string extract_cds_seq(const std::string &genome, const CDSFeature &f) {
#     int len = f.end0 - f.start0 + 1;
#     if (f.start0 < 0 || f.end0 >= (int)genome.size() || len <= 0) return "";
#     std::string s = genome.substr(f.start0, len);
#     if (f.strand == '-') {
#         std::string rc;
#         rc.reserve(s.size());
#         for (int i = (int)s.size() - 1; i >= 0; --i) {
#             rc.push_back(complement_base(s[i]));
#         }
#         return rc;
#     }
#     return s;
# }
# 
# struct GeneLandscape {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;
#     int length;
#     int n_codons;
#     double gc3_min;
#     double gc3_max;
#     double gc3_range;
# };
# 
# struct WindowHit {
#     int codon_start;
#     double gc3_frac;
# };
# 
# static bool is_special(const std::string &name) {
#     static const char* SPECIAL[] = {
#         "yagE","yagF","yagG","yagH","yagA",
#         "phnD","phnK","phnM",
#         "mutS","rhsD","mdtB","mdtC"
#     };
#     for (const char* s : SPECIAL) {
#         if (name == s) return true;
#     }
#     return false;
# }
# 
# static void compute_mean_sd_range(const std::vector<double> &vals,
#                                   double &mean, double &sd,
#                                   double &vmin, double &vmax) {
#     if (vals.empty()) {
#         mean = sd = vmin = vmax = 0.0;
#         return;
#     }
#     vmin = vals[0];
#     vmax = vals[0];
#     double s = 0.0;
#     for (double v : vals) {
#         s += v;
#         if (v < vmin) vmin = v;
#         if (v > vmax) vmax = v;
#     }
#     mean = s / (double)vals.size();
#     double var = 0.0;
#     for (double v : vals) {
#         double d = v - mean;
#         var += d*d;
#     }
#     var /= (double)vals.size();
#     sd = std::sqrt(var);
# }
# 
# int main() {
#     const std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     const std::string gff_path   = "/content/ecoli_U00096_3.gff";
# 
#     const int WINDOW_CODONS = 30;  // sliding window size in codons
#     const int STEP_CODONS   = 10;  // step in codons between windows
# 
#     std::string genome = read_fasta(fasta_path);
#     if (genome.empty()) {
#         std::fprintf(stderr, "ERROR: FASTA read failed.\n");
#         return 1;
#     }
#     std::vector<CDSFeature> cds = read_cds_gff(gff_path);
#     if (cds.empty()) {
#         std::fprintf(stderr, "ERROR: no CDS features loaded from GFF.\n");
#         return 1;
#     }
# 
#     std::printf("=====================================================================================\n");
#     std::printf("INTRA-GENE GC3 LOCK LANDSCAPE — E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n");
#     std::printf("We slide a codon window inside each CDS and measure GC3 per window:\n");
#     std::printf("  GC3_frac(window) = (#GC at third position in window) / window_codons.\n");
#     std::printf("For each gene we record min/max GC3 over windows and the range (max - min),\n");
#     std::printf("and we print the hottest GC3 windows for a small set of hyper-locked loci.\n\n");
# 
#     std::printf("Loading FASTA from: %s\n", fasta_path.c_str());
#     std::printf("Genome length: %zu bases\n\n", genome.size());
#     std::printf("Loading CDS annotations from: %s\n", gff_path.c_str());
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     std::vector<GeneLandscape> landscapes;
#     landscapes.reserve(cds.size());
#     std::vector<double> ranges;
# 
#     int cds_used = 0;
#     long sum_cds_len = 0;
# 
#     std::vector<std::string> special_names_seen;
# 
#     for (const auto &f : cds) {
#         std::string seq = extract_cds_seq(genome, f);
#         int L = (int)seq.size();
#         if (L <= 0) continue;
#         if (L % 3 != 0) continue; // only clean CDS
# 
#         int n_codons = L / 3;
#         if (n_codons < 5) continue; // tiny genes not very interesting
# 
#         int W = WINDOW_CODONS;
#         if (W > n_codons) W = n_codons;
#         int step = STEP_CODONS;
#         if (step <= 0) step = 1;
# 
#         double gc3_min = 1.0;
#         double gc3_max = 0.0;
#         bool any_window = false;
# 
#         std::vector<WindowHit> special_hits;
#         bool special = is_special(f.name);
#         if (special) special_names_seen.push_back(f.name);
# 
#         for (int c0 = 0; c0 + W <= n_codons; c0 += step) {
#             int start_base = c0 * 3;
#             int gc3_count = 0;
#             for (int k = 0; k < W; ++k) {
#                 int codon_base = start_base + 3*k + 2;
#                 if (codon_base >= L) break;
#                 char b3 = std::toupper((unsigned char)seq[codon_base]);
#                 if (b3 == 'G' || b3 == 'C') gc3_count++;
#             }
#             double gc3_frac = (double)gc3_count / (double)W;
#             if (!any_window) {
#                 gc3_min = gc3_max = gc3_frac;
#                 any_window = true;
#             } else {
#                 if (gc3_frac < gc3_min) gc3_min = gc3_frac;
#                 if (gc3_frac > gc3_max) gc3_max = gc3_frac;
#             }
#             if (special) {
#                 WindowHit wh;
#                 wh.codon_start = c0;
#                 wh.gc3_frac = gc3_frac;
#                 special_hits.push_back(wh);
#             }
#         }
#         if (!any_window) continue;
# 
#         GeneLandscape gl;
#         gl.name    = f.name;
#         gl.start0  = f.start0;
#         gl.end0    = f.end0;
#         gl.strand  = f.strand;
#         gl.length  = L;
#         gl.n_codons = n_codons;
#         gl.gc3_min = gc3_min;
#         gl.gc3_max = gc3_max;
#         gl.gc3_range = gc3_max - gc3_min;
# 
#         landscapes.push_back(gl);
#         ranges.push_back(gl.gc3_range);
#         cds_used++;
#         sum_cds_len += L;
# 
#         if (special && !special_hits.empty()) {
#             std::sort(special_hits.begin(), special_hits.end(),
#                       [](const WindowHit &a, const WindowHit &b){
#                           return a.gc3_frac > b.gc3_frac;
#                       });
#             int topN = (int)std::min<size_t>(3, special_hits.size());
#             std::printf("--- Intra-gene GC3 windows for %s ---\n", f.name.c_str());
#             std::printf("  CDS coords (0-based): %d - %d, len=%d, codons=%d, strand=%c\n",
#                         f.start0, f.end0, L, n_codons, f.strand);
#             std::printf("  GC3 over windows: min=%.4f, max=%.4f, range=%.4f\n",
#                         gc3_min, gc3_max, gl.gc3_range);
#             for (int i = 0; i < topN; ++i) {
#                 const auto &wh = special_hits[i];
#                 double rel = (double)wh.codon_start / (double)n_codons;
#                 int base_start = f.start0 + (f.strand == '+' ? wh.codon_start*3 : (n_codons - (wh.codon_start+W))*3);
#                 std::printf("    [TOP %d] codon_start=%d (%.2f of CDS), window_codons=%d, GC3=%.4f\n",
#                             i+1, wh.codon_start, rel, W, wh.gc3_frac);
#             }
#             std::printf("\n");
#         }
#     }
# 
#     double mean_range, sd_range, min_range, max_range;
#     compute_mean_sd_range(ranges, mean_range, sd_range, min_range, max_range);
# 
#     int flat_genes = 0;
#     int very_flat_genes = 0;
#     int highly_variable = 0;
#     int ultra_variable = 0;
# 
#     for (double r : ranges) {
#         if (r < 0.05) very_flat_genes++;
#         if (r < 0.10) flat_genes++;
#         if (r > 0.20) highly_variable++;
#         if (r > 0.30) ultra_variable++;
#     }
# 
#     std::printf("=== Global GC3 window-spread stats over CDS ===\n");
#     std::printf("  CDS analyzed (with windowing)  : %d\n", cds_used);
#     std::printf("  Sum CDS lengths                 : %ld bases\n", sum_cds_len);
#     std::printf("  Window GC3 range per gene = (max_window_GC3 - min_window_GC3)\n");
#     std::printf("    mean range = %.4f, sd = %.4f\n", mean_range, sd_range);
#     std::printf("    min range  = %.4f, max range = %.4f\n", min_range, max_range);
#     std::printf("    genes with range < 0.05      : %d\n", very_flat_genes);
#     std::printf("    genes with range < 0.10      : %d\n", flat_genes);
#     std::printf("    genes with range > 0.20      : %d\n", highly_variable);
#     std::printf("    genes with range > 0.30      : %d\n", ultra_variable);
#     std::printf("\n");
# 
#     std::printf("=== Summary ===\n");
#     std::printf("  This module shows whether GC3 lock is flat across each gene\n");
#     std::printf("  or concentrated in internal \"hot\" subregions. High-range genes\n");
#     std::printf("  have very uneven GC3; low-range genes are locked almost everywhere.\n\n");
# 
#     std::printf("INTRA-GENE GC3 LOCK LANDSCAPE finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# echo "[DNA-L14] Compiling intra-gene GC3 landscape (CPU-only)..."
# nvcc -O3 -std=c++17 warpfrac_dna_gc3_landscape.cu -o warpfrac_dna_gc3_landscape
# 
# echo "[DNA-L14] Running intra-gene GC3 landscape..."
# ./warpfrac_dna_gc3_landscape | tee DNA-L14.log
# 
# echo
# echo "[DNA-L14] SHA256(stdout) = $(sha256sum DNA-L14.log | awk '{print $1}')"
# 
# echo
# echo "======================================================================================================================"
# echo "MODULE DNA-L14 — DONE (INTRA-GENE GC3 LOCK LANDSCAPE)"
# echo "======================================================================================================================"
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# # ---------------------------------------------------------------------------
# # MODULE DNA-L15 — CROSS-GENOME LOCK CONSERVATION
# #   E. coli K-12 MG1655 vs E. coli O157:H7 Sakai
# #   CPU-only, exact counts
# # ---------------------------------------------------------------------------
# 
# # Reuse MG1655 FASTA/GFF if present, else fetch (should already be there from L1+)
# if [ ! -f /content/ecoli_U00096_3.fna ]; then
#   echo "[DNA-L15] MG1655 FASTA not found, fetching..."
#   curl -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna.gz" -o /content/mg1655.fna.gz
#   gunzip -c /content/mg1655.fna.gz > /content/ecoli_U00096_3.fna
# fi
# 
# if [ ! -f /content/ecoli_U00096_3.gff ]; then
#   echo "[DNA-L15] MG1655 GFF not found, fetching..."
#   curl -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.gff.gz" -o /content/mg1655.gff.gz
#   gunzip -c /content/mg1655.gff.gz > /content/ecoli_U00096_3.gff
# fi
# 
# # Second genome: E. coli O157:H7 str. Sakai (GCF_000008865.2_ASM886v2)
# if [ ! -f /content/ecoli_O157_Sakai.fna ]; then
#   echo "[DNA-L15] O157:H7 FASTA not found, fetching..."
#   curl -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/008/865/GCF_000008865.2_ASM886v2/GCF_000008865.2_ASM886v2_genomic.fna.gz" -o /content/o157.fna.gz
#   gunzip -c /content/o157.fna.gz > /content/ecoli_O157_Sakai.fna
# fi
# 
# if [ ! -f /content/ecoli_O157_Sakai.gff ]; then
#   echo "[DNA-L15] O157:H7 GFF not found, fetching..."
#   curl -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/008/865/GCF_000008865.2_ASM886v2/GCF_000008865.2_ASM886v2_genomic.gff.gz" -o /content/o157.gff.gz
#   gunzip -c /content/o157.gff.gz > /content/ecoli_O157_Sakai.gff
# fi
# 
# cat > warpfrac_dna_lock_conservation.cu << 'CPP'
# // warpfrac_dna_lock_conservation.cu
# // DNA-L15 — Cross-genome lock conservation (CPU-only)
# //
# // Compare gene-wise lock fingerprints between:
# //   - E. coli K-12 MG1655
# //   - E. coli O157:H7 Sakai
# //
# // For each CDS (len % 3 == 0) we compute on each genome:
# //
# //   GC_frac       = GC / length
# //   CpG_per_kb    = (#CG) * 1000 / (length-1)
# //   GC_heavy_frac = (#codons with >=2 GC bases) / total_codons
# //   GC3_frac      = (#GC at codon position 3) / total_codons
# //
# // Then we match genes by name between the two genomes and report:
# //   - How many genes are shared by name.
# //   - Pearson correlations between MG1655 vs O157 for each metric.
# //   - Top "conserved hyper-lock" genes (high GC3 in both).
# //   - Genes where MG1655 is GC3 hyper-locked but O157 is not.
# //
# // CPU-only: no GPU kernels; just compiled with nvcc as C++17.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# #include <unordered_map>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# struct LockStats {
#     std::string name;
#     int length;
#     long gc_bases;
#     long cpg_count;
#     long codons;
#     long gc_heavy_codons;
#     long gc_pos3;
# 
#     double gc_frac;
#     double cpg_per_kb;
#     double gc_heavy_frac;
#     double gc3_frac;
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     std::string seq;
#     while (std::getline(in, line)) {
#         if (line.size() == 0) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (std::isalpha((unsigned char)c)) {
#                 seq.push_back((char)std::toupper((unsigned char)c));
#             }
#         }
#     }
#     return seq;
# }
# 
# static void revcomp(std::string &s) {
#     auto comp = [](char c)->char {
#         switch (c) {
#             case 'A': return 'T';
#             case 'C': return 'G';
#             case 'G': return 'C';
#             case 'T': return 'A';
#             default:  return 'N';
#         }
#     };
#     std::reverse(s.begin(), s.end());
#     for (char &c : s) c = comp(c);
# }
# 
# static void parse_gff_cds(const std::string &path, std::vector<CDSFeature> &out) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.size() == 0 || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string cols[9];
#         bool ok = true;
#         for (int i = 0; i < 9; ++i) {
#             if (!std::getline(ss, cols[i], '\t')) { ok = false; break; }
#         }
#         if (!ok) continue;
#         if (cols[2] != "CDS") continue;
# 
#         int start1 = std::atoi(cols[3].c_str()); // 1-based
#         int end1   = std::atoi(cols[4].c_str());
#         if (start1 <= 0 || end1 <= 0) continue;
#         int start0 = start1 - 1;
#         int end0   = end1 - 1;
#         if (end0 < start0) std::swap(end0, start0);
#         char strand = cols[6].empty() ? '+' : cols[6][0];
# 
#         std::string attrs = cols[8];
#         std::string name;
#         // Try gene=
#         {
#             std::size_t p = attrs.find("gene=");
#             if (p != std::string::npos) {
#                 std::size_t q = attrs.find_first_of(";\t\r\n", p+5);
#                 if (q == std::string::npos) q = attrs.size();
#                 name = attrs.substr(p+5, q-(p+5));
#             }
#         }
#         // Fallback: Name=
#         if (name.empty()) {
#             std::size_t p = attrs.find("Name=");
#             if (p != std::string::npos) {
#                 std::size_t q = attrs.find_first_of(";\t\r\n", p+5);
#                 if (q == std::string::npos) q = attrs.size();
#                 name = attrs.substr(p+5, q-(p+5));
#             }
#         }
#         if (name.empty()) continue;
# 
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start0;
#         f.end0   = end0;
#         f.strand = strand;
#         out.push_back(f);
#     }
# }
# 
# static bool is_acgt(char c) {
#     return (c=='A' || c=='C' || c=='G' || c=='T');
# }
# 
# static bool compute_lock_for_cds(const std::string &genome,
#                                  const CDSFeature &f,
#                                  LockStats &out)
# {
#     int len = f.end0 - f.start0 + 1;
#     if (len <= 3) return false;
# 
#     if (f.start0 < 0 || f.end0 >= (int)genome.size()) return false;
# 
#     std::string seq = genome.substr(f.start0, len);
#     if (f.strand == '-') {
#         revcomp(seq);
#     }
#     for (char &c : seq) {
#         c = (char)std::toupper((unsigned char)c);
#     }
# 
#     long gc = 0;
#     long cpg = 0;
#     for (int i = 0; i < len; ++i) {
#         char b = seq[i];
#         if (b=='G' || b=='C') gc++;
#     }
#     for (int i = 0; i+1 < len; ++i) {
#         char b1 = seq[i];
#         char b2 = seq[i+1];
#         if (b1=='C' && b2=='G') cpg++;
#     }
# 
#     long codons = 0;
#     long gc_heavy = 0;
#     long gc1 = 0, gc2 = 0, gc3 = 0;
# 
#     int max_codons = len / 3;
#     for (int i = 0; i < max_codons; ++i) {
#         int pos = i*3;
#         char b1 = seq[pos];
#         char b2 = seq[pos+1];
#         char b3 = seq[pos+2];
#         if (!is_acgt(b1) || !is_acgt(b2) || !is_acgt(b3)) continue;
# 
#         codons++;
#         int gc_count = 0;
#         if (b1=='G' || b1=='C') { gc1++; gc_count++; }
#         if (b2=='G' || b2=='C') { gc2++; gc_count++; }
#         if (b3=='G' || b3=='C') { gc3++; gc_count++; }
#         if (gc_count >= 2) gc_heavy++;
#     }
# 
#     if (codons == 0) return false;
# 
#     out.name             = f.name;
#     out.length           = len;
#     out.gc_bases         = gc;
#     out.cpg_count        = cpg;
#     out.codons           = codons;
#     out.gc_heavy_codons  = gc_heavy;
#     out.gc_pos3          = gc3;
# 
#     out.gc_frac          = (double)gc / (double)len;
#     out.cpg_per_kb       = (len > 1) ? (double)cpg * 1000.0 / (double)(len-1) : 0.0;
#     out.gc_heavy_frac    = (double)gc_heavy / (double)codons;
#     out.gc3_frac         = (double)gc3 / (double)codons;
# 
#     return true;
# }
# 
# static double pearson(const std::vector<double> &a,
#                       const std::vector<double> &b)
# {
#     int n = (int)a.size();
#     if (n < 2 || (int)b.size() != n) return 0.0;
#     double ma = 0.0, mb = 0.0;
#     for (int i = 0; i < n; ++i) {
#         ma += a[i];
#         mb += b[i];
#     }
#     ma /= n;
#     mb /= n;
#     double num = 0.0, da = 0.0, db = 0.0;
#     for (int i = 0; i < n; ++i) {
#         double xa = a[i] - ma;
#         double xb = b[i] - mb;
#         num += xa * xb;
#         da  += xa * xa;
#         db  += xb * xb;
#     }
#     if (da <= 0.0 || db <= 0.0) return 0.0;
#     return num / std::sqrt(da * db);
# }
# 
# int main() {
#     const char *fasta1 = "/content/ecoli_U00096_3.fna";     // MG1655
#     const char *gff1   = "/content/ecoli_U00096_3.gff";
#     const char *fasta2 = "/content/ecoli_O157_Sakai.fna";   // O157:H7 Sakai
#     const char *gff2   = "/content/ecoli_O157_Sakai.gff";
# 
#     std::printf("=====================================================================================\n");
#     std::printf("CROSS-GENOME LOCK CONSERVATION — MG1655 vs O157:H7 Sakai (CDS-level)\n");
#     std::printf("=====================================================================================\n");
#     std::printf("We compute per-CDS lock fingerprints in both genomes:\n");
#     std::printf("  GC_frac, CpG_per_kb, GC_heavy_frac, GC3_frac\n");
#     std::printf("Then we match genes by name and compare locks across species.\n\n");
# 
#     std::printf("Loading MG1655 FASTA from: %s\n", fasta1);
#     std::string genome1 = read_fasta(fasta1);
#     std::printf("MG1655 genome length: %zu bases\n\n", genome1.size());
# 
#     std::printf("Loading MG1655 GFF from: %s\n", gff1);
#     std::vector<CDSFeature> cds1;
#     parse_gff_cds(gff1, cds1);
#     std::printf("MG1655 CDS features loaded: %zu\n\n", cds1.size());
# 
#     std::printf("Loading O157:H7 FASTA from: %s\n", fasta2);
#     std::string genome2 = read_fasta(fasta2);
#     std::printf("O157:H7 genome length: %zu bases\n\n", genome2.size());
# 
#     std::printf("Loading O157:H7 GFF from: %s\n", gff2);
#     std::vector<CDSFeature> cds2;
#     parse_gff_cds(gff2, cds2);
#     std::printf("O157:H7 CDS features loaded: %zu\n\n", cds2.size());
# 
#     // Compute lock stats for MG1655
#     std::vector<LockStats> locks1;
#     locks1.reserve(cds1.size());
#     long sum_len1 = 0;
#     long sum_codons1 = 0;
#     long total_gc1 = 0;
#     long total_cpg1 = 0;
#     for (const auto &f : cds1) {
#         LockStats s;
#         if (!compute_lock_for_cds(genome1, f, s)) continue;
#         locks1.push_back(s);
#         sum_len1    += s.length;
#         sum_codons1 += s.codons;
#         total_gc1   += s.gc_bases;
#         total_cpg1  += s.cpg_count;
#     }
# 
#     // Compute lock stats for O157:H7
#     std::vector<LockStats> locks2;
#     locks2.reserve(cds2.size());
#     long sum_len2 = 0;
#     long sum_codons2 = 0;
#     long total_gc2 = 0;
#     long total_cpg2 = 0;
#     for (const auto &f : cds2) {
#         LockStats s;
#         if (!compute_lock_for_cds(genome2, f, s)) continue;
#         locks2.push_back(s);
#         sum_len2    += s.length;
#         sum_codons2 += s.codons;
#         total_gc2   += s.gc_bases;
#         total_cpg2  += s.cpg_count;
#     }
# 
#     std::printf("--- Per-genome CDS-wise totals ---\n");
#     std::printf("  MG1655: CDS with valid locks : %zu\n", locks1.size());
#     std::printf("         Sum CDS lengths       : %ld bases\n", sum_len1);
#     std::printf("         Sum codons            : %ld\n", sum_codons1);
#     std::printf("         Total GC bases        : %ld\n", total_gc1);
#     std::printf("         Total CpG             : %ld\n", total_cpg1);
#     std::printf("  O157:H7: CDS with valid locks: %zu\n", locks2.size());
#     std::printf("          Sum CDS lengths      : %ld bases\n", sum_len2);
#     std::printf("          Sum codons           : %ld\n", sum_codons2);
#     std::printf("          Total GC bases       : %ld\n", total_gc2);
#     std::printf("          Total CpG            : %ld\n\n", total_cpg2);
# 
#     // Build map for O157:H7
#     std::unordered_map<std::string, LockStats> map2;
#     map2.reserve(locks2.size()*2);
#     for (const auto &s : locks2) {
#         map2[s.name] = s;
#     }
# 
#     // Intersection by gene name
#     struct Pair {
#         std::string name;
#         LockStats s1;
#         LockStats s2;
#     };
#     std::vector<Pair> pairs;
#     pairs.reserve(locks1.size());
#     for (const auto &s1 : locks1) {
#         auto it = map2.find(s1.name);
#         if (it == map2.end()) continue;
#         Pair p;
#         p.name = s1.name;
#         p.s1   = s1;
#         p.s2   = it->second;
#         pairs.push_back(p);
#     }
# 
#     std::printf("--- Cross-genome intersection ---\n");
#     std::printf("  Genes with CDS locks in MG1655    : %zu\n", locks1.size());
#     std::printf("  Genes with CDS locks in O157:H7   : %zu\n", locks2.size());
#     std::printf("  Shared gene names with locks in both: %zu\n\n", pairs.size());
# 
#     if (pairs.size() < 10) {
#         std::printf("Not enough shared genes for meaningful cross-genome stats. Exiting.\n");
#         return 0;
#     }
# 
#     std::vector<double> v_gc1, v_gc2, v_cpg1, v_cpg2, v_heavy1, v_heavy2, v_gc3_1, v_gc3_2;
#     v_gc1.reserve(pairs.size());
#     v_gc2.reserve(pairs.size());
#     v_cpg1.reserve(pairs.size());
#     v_cpg2.reserve(pairs.size());
#     v_heavy1.reserve(pairs.size());
#     v_heavy2.reserve(pairs.size());
#     v_gc3_1.reserve(pairs.size());
#     v_gc3_2.reserve(pairs.size());
# 
#     for (const auto &p : pairs) {
#         v_gc1.push_back(p.s1.gc_frac);
#         v_gc2.push_back(p.s2.gc_frac);
#         v_cpg1.push_back(p.s1.cpg_per_kb);
#         v_cpg2.push_back(p.s2.cpg_per_kb);
#         v_heavy1.push_back(p.s1.gc_heavy_frac);
#         v_heavy2.push_back(p.s2.gc_heavy_frac);
#         v_gc3_1.push_back(p.s1.gc3_frac);
#         v_gc3_2.push_back(p.s2.gc3_frac);
#     }
# 
#     double corr_gc   = pearson(v_gc1,   v_gc2);
#     double corr_cpg  = pearson(v_cpg1,  v_cpg2);
#     double corr_heavy= pearson(v_heavy1,v_heavy2);
#     double corr_gc3  = pearson(v_gc3_1, v_gc3_2);
# 
#     std::printf("--- Cross-genome Pearson correlations (MG1655 vs O157:H7) ---\n");
#     std::printf("  corr(GC_frac)       = %.4f\n", corr_gc);
#     std::printf("  corr(CpG_per_kb)    = %.4f\n", corr_cpg);
#     std::printf("  corr(GC-heavy_frac) = %.4f\n", corr_heavy);
#     std::printf("  corr(GC3_frac)      = %.4f\n\n", corr_gc3);
# 
#     // Find conserved hyper-locked genes: GC3 high in both genomes
#     struct Hyper {
#         std::string name;
#         double gc3_1, gc3_2;
#         double cpg1, cpg2;
#         double gc1,  gc2;
#         double heavy1, heavy2;
#         int len1, len2;
#     };
#     std::vector<Hyper> conserved;
#     std::vector<Hyper> mg_only;
# 
#     for (const auto &p : pairs) {
#         Hyper h;
#         h.name   = p.name;
#         h.gc3_1  = p.s1.gc3_frac;
#         h.gc3_2  = p.s2.gc3_frac;
#         h.cpg1   = p.s1.cpg_per_kb;
#         h.cpg2   = p.s2.cpg_per_kb;
#         h.gc1    = p.s1.gc_frac;
#         h.gc2    = p.s2.gc_frac;
#         h.heavy1 = p.s1.gc_heavy_frac;
#         h.heavy2 = p.s2.gc_heavy_frac;
#         h.len1   = p.s1.length;
#         h.len2   = p.s2.length;
# 
#         // thresholds: GC3 > 0.7 in both -> conserved hyper-lock
#         if (h.gc3_1 > 0.7 && h.gc3_2 > 0.7) {
#             conserved.push_back(h);
#         }
#         // MG1655 high GC3, O157 reasonably lower -> MG-only lock
#         if (h.gc3_1 > 0.7 && h.gc3_2 < 0.6 && (h.gc3_1 - h.gc3_2) > 0.15) {
#             mg_only.push_back(h);
#         }
#     }
# 
#     auto by_min_gc3_desc = [](const Hyper &a, const Hyper &b) {
#         double ma = std::min(a.gc3_1, a.gc3_2);
#         double mb = std::min(b.gc3_1, b.gc3_2);
#         if (ma != mb) return ma > mb;
#         return a.name < b.name;
#     };
#     std::sort(conserved.begin(), conserved.end(), by_min_gc3_desc);
# 
#     auto by_diff_gc3_desc = [](const Hyper &a, const Hyper &b) {
#         double da = a.gc3_1 - a.gc3_2;
#         double db = b.gc3_1 - b.gc3_2;
#         if (da != db) return da > db;
#         return a.name < b.name;
#     };
#     std::sort(mg_only.begin(), mg_only.end(), by_diff_gc3_desc);
# 
#     std::printf("--- Conserved hyper-locked genes (GC3 high in both genomes) ---\n");
#     int max_print = 10;
#     int printed = 0;
#     for (const auto &h : conserved) {
#         if (printed >= max_print) break;
#         std::printf("  [%2d] %-8s | lenMG=%4d lenO157=%4d | GC3: MG=%.4f O157=%.4f | CpG/kb: MG=%.2f O157=%.2f | GC_frac: MG=%.4f O157=%.4f | GC-heavy: MG=%.4f O157=%.4f\n",
#                     printed+1,
#                     h.name.c_str(),
#                     h.len1, h.len2,
#                     h.gc3_1, h.gc3_2,
#                     h.cpg1, h.cpg2,
#                     h.gc1, h.gc2,
#                     h.heavy1, h.heavy2);
#         printed++;
#     }
#     if (printed == 0) {
#         std::printf("  (none meet the GC3>0.7 in both genomes threshold)\n");
#     }
#     std::printf("\n");
# 
#     std::printf("--- MG1655-only GC3 hyper-lock candidates (GC3 high in MG, lower in O157) ---\n");
#     printed = 0;
#     for (const auto &h : mg_only) {
#         if (printed >= max_print) break;
#         std::printf("  [%2d] %-8s | lenMG=%4d lenO157=%4d | GC3: MG=%.4f O157=%.4f (diff=%.4f) | CpG/kb: MG=%.2f O157=%.2f\n",
#                     printed+1,
#                     h.name.c_str(),
#                     h.len1, h.len2,
#                     h.gc3_1, h.gc3_2, (h.gc3_1 - h.gc3_2),
#                     h.cpg1, h.cpg2);
#         printed++;
#     }
#     if (printed == 0) {
#         std::printf("  (none meet the MG>0.7 & O157<0.6 & diff>0.15 thresholds)\n");
#     }
#     std::printf("\n");
# 
#     // Special: show our favorite lock monsters if present in both
#     const char *interesting[] = {"yagE","yagF","yagG","yagH","yagA",
#                                  "rhsD","mdtB","mdtC","mutS","phnD","phnK","phnM"};
#     std::printf("--- Lock comparison for selected loci (if shared by name) ---\n");
#     for (const char *gn : interesting) {
#         std::string key(gn);
#         // search pair list
#         bool found = false;
#         for (const auto &p : pairs) {
#             if (p.name == key) {
#                 found = true;
#                 std::printf("  [%s]\n", key.c_str());
#                 std::printf("    MG1655: len=%d | GC_frac=%.4f | CpG_per_kb=%.2f | GC-heavy=%.4f | GC3=%.4f\n",
#                             p.s1.length, p.s1.gc_frac, p.s1.cpg_per_kb,
#                             p.s1.gc_heavy_frac, p.s1.gc3_frac);
#                 std::printf("    O157:H7: len=%d | GC_frac=%.4f | CpG_per_kb=%.2f | GC-heavy=%.4f | GC3=%.4f\n",
#                             p.s2.length, p.s2.gc_frac, p.s2.cpg_per_kb,
#                             p.s2.gc_heavy_frac, p.s2.gc3_frac);
#                 break;
#             }
#         }
#         if (!found) {
#             std::printf("  [%s] not found in intersection.\n", key.c_str());
#         }
#     }
# 
#     std::printf("\nCROSS-GENOME LOCK CONSERVATION analysis finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# echo "[DNA-L15] Compiling cross-genome lock conservation (CPU-only)..."
# nvcc -O3 -std=c++17 warpfrac_dna_lock_conservation.cu -o warpfrac_dna_lock_conservation
# 
# echo
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo "RUNNING DNA-L15 — CROSS-GENOME LOCK CONSERVATION (MG1655 vs O157:H7, CPU-only)"
# echo "----------------------------------------------------------------------------------------------------------------------"
# ./warpfrac_dna_lock_conservation | tee DNA-L15_lock_conservation.out
# 
# echo
# echo "[DNA-L15] SHA256(stdout) ="
# sha256sum DNA-L15_lock_conservation.out
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# # ---------------------------------------------------------------------------
# # MODULE DNA-L16 — GC3 LOCK UNLOCK EDIT BUDGET (E. coli MG1655, CDS-level)
# #   CPU-only, exact counts
# # ---------------------------------------------------------------------------
# 
# if [ ! -f /content/ecoli_U00096_3.fna ]; then
#   echo "[DNA-L16] MG1655 FASTA not found, fetching..."
#   curl -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna.gz" -o /content/mg1655.fna.gz
#   gunzip -c /content/mg1655.fna.gz > /content/ecoli_U00096_3.fna
# fi
# 
# if [ ! -f /content/ecoli_U00096_3.gff ]; then
#   echo "[DNA-L16] MG1655 GFF not found, fetching..."
#   curl -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.gff.gz" -o /content/mg1655.gff.gz
#   gunzip -c /content/mg1655.gff.gz > /content/ecoli_U00096_3.gff
# fi
# 
# cat > warpfrac_dna_gc3_unlock_budget.cu << 'CPP'
# // warpfrac_dna_gc3_unlock_budget.cu
# // DNA-L16 — GC3 "unlock edit budget" per gene (CPU-only)
# //
# // For each CDS in E. coli MG1655:
# //   1) Compute GC3_frac = (#GC at codon position 3) / #valid_codons.
# //   2) Compute the global mean GC3_frac across all CDS (codon-weighted).
# //   3) For each gene, ask: if we only allow synonymous changes
# //      (same amino acids) and only tweak codon third bases,
# //      how many codons would we need to edit to bring GC3 down
# //      to the global mean?
# //
# //   We approximate this by counting:
# //
# //     - valid codons contributing to GC3
# //     - codons whose 3rd base is G/C AND that amino acid has at least
# //       one synonymous codon with A/T at position 3 (unlockable sites)
# //
# //   Minimal edits needed:
# //     edits = min(max_unlockable,
# //                 max(0, gc3_count - target_gc3_count))
# //
# //   where target_gc3_count = ceil(global_mean_GC3 * num_codons).
# //
# // All counting is exact; floating point only for reporting.
# //
# // CPU-only: compiled with nvcc as C++17, but no GPU kernels.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# #include <unordered_map>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# struct LockStats {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;
# 
#     int length;
#     long codons;
#     long gc_pos3;
# 
#     double gc_frac;       // not strictly needed here, but nice to print
#     double gc3_frac;
# };
# 
# struct UnlockStats {
#     std::string name;
#     int length;
#     long codons;
#     long gc3_count;
#     double gc3_frac;
#     long edits_needed;
#     double edit_frac;
#     double gc3_after;
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     std::string seq;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (std::isalpha((unsigned char)c)) {
#                 seq.push_back((char)std::toupper((unsigned char)c));
#             }
#         }
#     }
#     return seq;
# }
# 
# static void revcomp(std::string &s) {
#     auto comp = [](char c)->char {
#         switch (c) {
#             case 'A': return 'T';
#             case 'C': return 'G';
#             case 'G': return 'C';
#             case 'T': return 'A';
#             default:  return 'N';
#         }
#     };
#     std::reverse(s.begin(), s.end());
#     for (char &c : s) c = comp(c);
# }
# 
# static void parse_gff_cds(const std::string &path, std::vector<CDSFeature> &out) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string cols[9];
#         bool ok = true;
#         for (int i = 0; i < 9; ++i) {
#             if (!std::getline(ss, cols[i], '\t')) { ok = false; break; }
#         }
#         if (!ok) continue;
#         if (cols[2] != "CDS") continue;
# 
#         int start1 = std::atoi(cols[3].c_str());
#         int end1   = std::atoi(cols[4].c_str());
#         if (start1 <= 0 || end1 <= 0) continue;
#         int start0 = start1 - 1;
#         int end0   = end1 - 1;
#         if (end0 < start0) std::swap(end0, start0);
#         char strand = cols[6].empty() ? '+' : cols[6][0];
# 
#         std::string attrs = cols[8];
#         std::string name;
#         {
#             std::size_t p = attrs.find("gene=");
#             if (p != std::string::npos) {
#                 std::size_t q = attrs.find_first_of(";\t\r\n", p+5);
#                 if (q == std::string::npos) q = attrs.size();
#                 name = attrs.substr(p+5, q-(p+5));
#             }
#         }
#         if (name.empty()) {
#             std::size_t p = attrs.find("Name=");
#             if (p != std::string::npos) {
#                 std::size_t q = attrs.find_first_of(";\t\r\n", p+5);
#                 if (q == std::string::npos) q = attrs.size();
#                 name = attrs.substr(p+5, q-(p+5));
#             }
#         }
#         if (name.empty()) continue;
# 
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start0;
#         f.end0   = end0;
#         f.strand = strand;
#         out.push_back(f);
#     }
# }
# 
# static bool is_acgt(char c) {
#     return (c=='A' || c=='C' || c=='G' || c=='T');
# }
# 
# // Genetic code + synonym table
# static std::unordered_map<std::string,char> codon2aa;
# static std::unordered_map<char,std::vector<std::string>> aa2codons;
# static bool code_inited = false;
# 
# static void init_genetic_code() {
#     if (code_inited) return;
#     struct Entry { const char *cod; char aa; };
#     static const Entry tbl[] = {
#         {"TTT",'F'},{"TTC",'F'},{"TTA",'L'},{"TTG",'L'},
#         {"TCT",'S'},{"TCC",'S'},{"TCA",'S'},{"TCG",'S'},
#         {"TAT",'Y'},{"TAC",'Y'},{"TAA",'*'},{"TAG",'*'},
#         {"TGT",'C'},{"TGC",'C'},{"TGA",'*'},{"TGG",'W'},
#         {"CTT",'L'},{"CTC",'L'},{"CTA",'L'},{"CTG",'L'},
#         {"CCT",'P'},{"CCC",'P'},{"CCA",'P'},{"CCG",'P'},
#         {"CAT",'H'},{"CAC",'H'},{"CAA",'Q'},{"CAG",'Q'},
#         {"CGT",'R'},{"CGC",'R'},{"CGA",'R'},{"CGG",'R'},
#         {"ATT",'I'},{"ATC",'I'},{"ATA",'I'},{"ATG",'M'},
#         {"ACT",'T'},{"ACC",'T'},{"ACA",'T'},{"ACG",'T'},
#         {"AAT",'N'},{"AAC",'N'},{"AAA",'K'},{"AAG",'K'},
#         {"AGT",'S'},{"AGC",'S'},{"AGA",'R'},{"AGG",'R'},
#         {"GTT",'V'},{"GTC",'V'},{"GTA",'V'},{"GTG",'V'},
#         {"GCT",'A'},{"GCC",'A'},{"GCA",'A'},{"GCG",'A'},
#         {"GAT",'D'},{"GAC",'D'},{"GAA",'E'},{"GAG",'E'},
#         {"GGT",'G'},{"GGC",'G'},{"GGA",'G'},{"GGG",'G'}
#     };
#     int N = sizeof(tbl)/sizeof(tbl[0]);
#     for (int i = 0; i < N; ++i) {
#         std::string cod(tbl[i].cod);
#         char aa = tbl[i].aa;
#         codon2aa[cod] = aa;
#         aa2codons[aa].push_back(cod);
#     }
#     code_inited = true;
# }
# 
# static char codon_to_aa(const std::string &cod) {
#     init_genetic_code();
#     auto it = codon2aa.find(cod);
#     if (it == codon2aa.end()) return '?';
#     return it->second;
# }
# 
# // Compute GC3 stats for a CDS
# static bool compute_lock_for_cds(const std::string &genome,
#                                  const CDSFeature &f,
#                                  LockStats &out)
# {
#     int len = f.end0 - f.start0 + 1;
#     if (len <= 3) return false;
#     if (f.start0 < 0 || f.end0 >= (int)genome.size()) return false;
# 
#     std::string seq = genome.substr(f.start0, len);
#     if (f.strand == '-') {
#         revcomp(seq);
#     }
#     for (char &c : seq) {
#         c = (char)std::toupper((unsigned char)c);
#     }
# 
#     long gc_bases = 0;
#     for (int i = 0; i < len; ++i) {
#         char b = seq[i];
#         if (b=='G' || b=='C') gc_bases++;
#     }
# 
#     long codons = 0;
#     long gc3 = 0;
#     int max_codons = len / 3;
#     for (int i = 0; i < max_codons; ++i) {
#         int pos = i*3;
#         char b1 = seq[pos];
#         char b2 = seq[pos+1];
#         char b3 = seq[pos+2];
#         if (!is_acgt(b1) || !is_acgt(b2) || !is_acgt(b3)) continue;
#         codons++;
#         if (b3=='G' || b3=='C') gc3++;
#     }
#     if (codons == 0) return false;
# 
#     out.name   = f.name;
#     out.start0 = f.start0;
#     out.end0   = f.end0;
#     out.strand = f.strand;
#     out.length = len;
#     out.codons = codons;
#     out.gc_pos3 = gc3;
# 
#     out.gc_frac  = (double)gc_bases / (double)len;
#     out.gc3_frac = (double)gc3 / (double)codons;
#     return true;
# }
# 
# // For a given CDS, approximate minimal number of synonymous 3rd-base edits
# // needed to bring GC3 down to target_gc3 (fraction).
# static bool compute_unlock_budget_for_cds(const std::string &genome,
#                                           const CDSFeature &f,
#                                           double target_gc3,
#                                           UnlockStats &out)
# {
#     int len = f.end0 - f.start0 + 1;
#     if (len <= 3) return false;
#     if (f.start0 < 0 || f.end0 >= (int)genome.size()) return false;
# 
#     std::string seq = genome.substr(f.start0, len);
#     if (f.strand == '-') {
#         revcomp(seq);
#     }
#     for (char &c : seq) {
#         c = (char)std::toupper((unsigned char)c);
#     }
# 
#     init_genetic_code();
# 
#     long codons = 0;
#     long gc3 = 0;
#     long unlockable = 0;
# 
#     int max_codons = len / 3;
#     for (int i = 0; i < max_codons; ++i) {
#         int pos = i*3;
#         char b1 = seq[pos];
#         char b2 = seq[pos+1];
#         char b3 = seq[pos+2];
#         if (!is_acgt(b1) || !is_acgt(b2) || !is_acgt(b3)) continue;
# 
#         std::string cod;
#         cod.push_back(b1);
#         cod.push_back(b2);
#         cod.push_back(b3);
#         char aa = codon_to_aa(cod);
#         if (aa == '?') continue; // unknown
#         if (aa == '*') {
#             // ignore stop codons for both GC3 and unlock
#             continue;
#         }
# 
#         codons++;
#         bool is_gc3 = (b3=='G' || b3=='C');
#         if (is_gc3) gc3++;
# 
#         // unlockable if this codon currently contributes to GC3 AND
#         // there exists a synonymous codon with A/T at 3rd pos.
#         if (is_gc3) {
#             bool has_AT3 = false;
#             auto it = aa2codons.find(aa);
#             if (it != aa2codons.end()) {
#                 for (const std::string &alt : it->second) {
#                     char c3 = alt[2];
#                     if (c3=='A' || c3=='T') {
#                         has_AT3 = true;
#                         break;
#                     }
#                 }
#             }
#             if (has_AT3) unlockable++;
#         }
#     }
# 
#     if (codons == 0) return false;
# 
#     long target_gc3_count = (long)std::ceil(target_gc3 * (double)codons);
#     if (target_gc3_count < 0) target_gc3_count = 0;
#     if (target_gc3_count > gc3) target_gc3_count = gc3; // can't increase GC3 by editing
# 
#     long needed = gc3 - target_gc3_count;
#     if (needed < 0) needed = 0;
#     long edits = needed;
#     if (edits > unlockable) edits = unlockable;
# 
#     long gc3_after_count = gc3 - edits;
#     double gc3_frac = (double)gc3 / (double)codons;
#     double gc3_after = (double)gc3_after_count / (double)codons;
#     double edit_frac = (codons > 0) ? (double)edits / (double)codons : 0.0;
# 
#     out.name        = f.name;
#     out.length      = len;
#     out.codons      = codons;
#     out.gc3_count   = gc3;
#     out.gc3_frac    = gc3_frac;
#     out.edits_needed= edits;
#     out.edit_frac   = edit_frac;
#     out.gc3_after   = gc3_after;
#     return true;
# }
# 
# static double pearson(const std::vector<double> &a,
#                       const std::vector<double> &b)
# {
#     int n = (int)a.size();
#     if (n < 2 || (int)b.size() != n) return 0.0;
#     double ma = 0.0, mb = 0.0;
#     for (int i = 0; i < n; ++i) {
#         ma += a[i];
#         mb += b[i];
#     }
#     ma /= n;
#     mb /= n;
#     double num = 0.0, da = 0.0, db = 0.0;
#     for (int i = 0; i < n; ++i) {
#         double xa = a[i] - ma;
#         double xb = b[i] - mb;
#         num += xa * xb;
#         da  += xa * xa;
#         db  += xb * xb;
#     }
#     if (da <= 0.0 || db <= 0.0) return 0.0;
#     return num / std::sqrt(da * db);
# }
# 
# int main() {
#     const char *fasta_path = "/content/ecoli_U00096_3.fna";
#     const char *gff_path   = "/content/ecoli_U00096_3.gff";
# 
#     std::printf("=====================================================================================\n");
#     std::printf("GC3 LOCK UNLOCK EDIT BUDGET — E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n");
#     std::printf("For each CDS we compute GC3_frac and then estimate how many synonymous\n");
#     std::printf("third-base edits are needed to bring GC3 down to the genome-wide mean.\n\n");
# 
#     std::printf("Loading FASTA from: %s\n", fasta_path);
#     std::string genome = read_fasta(fasta_path);
#     std::printf("Genome length: %zu bases\n\n", genome.size());
# 
#     std::printf("Loading GFF CDS from: %s\n", gff_path);
#     std::vector<CDSFeature> cds;
#     parse_gff_cds(gff_path, cds);
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     // First pass: per-gene GC3 stats and global mean GC3
#     std::vector<LockStats> locks;
#     locks.reserve(cds.size());
#     long sum_len = 0;
#     long sum_codons = 0;
#     long sum_gc3 = 0;
# 
#     for (const auto &f : cds) {
#         LockStats s;
#         if (!compute_lock_for_cds(genome, f, s)) continue;
#         locks.push_back(s);
#         sum_len    += s.length;
#         sum_codons += s.codons;
#         sum_gc3    += s.gc_pos3;
#     }
# 
#     if (locks.empty() || sum_codons == 0) {
#         std::printf("No valid CDS with codons found. Exiting.\n");
#         return 0;
#     }
# 
#     double global_gc3_mean = (double)sum_gc3 / (double)sum_codons;
# 
#     std::printf("--- Global CDS-wise GC3 stats ---\n");
#     std::printf("  CDS analyzed (valid)         : %zu\n", locks.size());
#     std::printf("  Sum CDS lengths              : %ld bases\n", sum_len);
#     std::printf("  Sum codons                   : %ld\n", sum_codons);
#     std::printf("  Total GC at codon pos3       : %ld\n", sum_gc3);
#     std::printf("  Codon-weighted mean GC3_frac : %.4f\n\n", global_gc3_mean);
# 
#     // Second pass: unlock budgets
#     std::vector<UnlockStats> unlocks;
#     unlocks.reserve(locks.size());
# 
#     for (const auto &f : cds) {
#         UnlockStats u;
#         if (!compute_unlock_budget_for_cds(genome, f, global_gc3_mean, u)) continue;
#         unlocks.push_back(u);
#     }
# 
#     if (unlocks.empty()) {
#         std::printf("No unlock budgets could be computed. Exiting.\n");
#         return 0;
#     }
# 
#     // Basic distribution of edit fractions
#     double sum_edit_frac = 0.0;
#     double min_edit_frac = 1e9;
#     double max_edit_frac = -1e9;
#     int cnt_lt_0_05 = 0;
#     int cnt_lt_0_10 = 0;
#     int cnt_gt_0_20 = 0;
#     int cnt_gt_0_30 = 0;
# 
#     std::vector<double> v_gc3, v_edit;
#     v_gc3.reserve(unlocks.size());
#     v_edit.reserve(unlocks.size());
# 
#     for (const auto &u : unlocks) {
#         sum_edit_frac += u.edit_frac;
#         if (u.edit_frac < min_edit_frac) min_edit_frac = u.edit_frac;
#         if (u.edit_frac > max_edit_frac) max_edit_frac = u.edit_frac;
#         if (u.edit_frac < 0.05) cnt_lt_0_05++;
#         if (u.edit_frac < 0.10) cnt_lt_0_10++;
#         if (u.edit_frac > 0.20) cnt_gt_0_20++;
#         if (u.edit_frac > 0.30) cnt_gt_0_30++;
# 
#         v_gc3.push_back(u.gc3_frac);
#         v_edit.push_back(u.edit_frac);
#     }
#     double mean_edit_frac = sum_edit_frac / (double)unlocks.size();
#     double corr_gc3_edit = pearson(v_gc3, v_edit);
# 
#     std::printf("--- Unlock edit fraction distribution (GC3 -> global mean) ---\n");
#     std::printf("  Genes with unlock budgets    : %zu\n", unlocks.size());
#     std::printf("  Mean edit fraction           : %.4f\n", mean_edit_frac);
#     std::printf("  Min edit fraction            : %.4f\n", min_edit_frac);
#     std::printf("  Max edit fraction            : %.4f\n", max_edit_frac);
#     std::printf("  Genes with edit_frac < 0.05  : %d\n", cnt_lt_0_05);
#     std::printf("  Genes with edit_frac < 0.10  : %d\n", cnt_lt_0_10);
#     std::printf("  Genes with edit_frac > 0.20  : %d\n", cnt_gt_0_20);
#     std::printf("  Genes with edit_frac > 0.30  : %d\n", cnt_gt_0_30);
#     std::printf("  corr(GC3_frac, edit_frac)    : %.4f\n\n", corr_gc3_edit);
# 
#     // Top 10 genes by GC3_frac and their edit budgets
#     std::vector<UnlockStats> sorted = unlocks;
#     std::sort(sorted.begin(), sorted.end(),
#               [](const UnlockStats &a, const UnlockStats &b) {
#                   if (a.gc3_frac != b.gc3_frac) return a.gc3_frac > b.gc3_frac;
#                   return a.name < b.name;
#               });
# 
#     std::printf("--- Top 10 most GC3-locked genes and their unlock budgets ---\n");
#     int max_print = 10;
#     for (int i = 0; i < max_print && i < (int)sorted.size(); ++i) {
#         const auto &u = sorted[i];
#         std::printf("  [%2d] %-8s | len=%4d codons=%4ld | GC3=%.4f -> %.4f | edits=%4ld (edit_frac=%.4f)\n",
#                     i+1,
#                     u.name.c_str(),
#                     u.length,
#                     u.codons,
#                     u.gc3_frac,
#                     u.gc3_after,
#                     u.edits_needed,
#                     u.edit_frac);
#     }
#     std::printf("\n");
# 
#     // Unlock budgets for selected loci
#     const char *interesting[] = {
#         "yagE","yagF","yagG","yagH","yagA",
#         "rhsD","mdtB","mdtC","mutS",
#         "phnD","phnK","phnM"
#     };
#     std::printf("--- Unlock budgets for selected hyper-locked loci (if present) ---\n");
#     for (const char *gn : interesting) {
#         std::string key(gn);
#         bool found = false;
#         for (const auto &u : unlocks) {
#             if (u.name == key) {
#                 found = true;
#                 std::printf("  [%s]\n", key.c_str());
#                 std::printf("    length        : %d\n", u.length);
#                 std::printf("    codons        : %ld\n", u.codons);
#                 std::printf("    GC3_frac      : %.4f (global mean=%.4f)\n", u.gc3_frac, global_gc3_mean);
#                 std::printf("    edits_needed  : %ld (%.4f of codons)\n", u.edits_needed, u.edit_frac);
#                 std::printf("    GC3_after     : %.4f\n", u.gc3_after);
#                 break;
#             }
#         }
#         if (!found) {
#             std::printf("  [%s] not found in CDS unlock set.\n", key.c_str());
#         }
#     }
# 
#     std::printf("\nGC3 LOCK UNLOCK EDIT BUDGET analysis finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# echo "[DNA-L16] Compiling GC3 unlock edit budget (CPU-only)..."
# nvcc -O3 -std=c++17 warpfrac_dna_gc3_unlock_budget.cu -o warpfrac_dna_gc3_unlock_budget
# 
# echo
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo "RUNNING DNA-L16 — GC3 LOCK UNLOCK EDIT BUDGET (CPU-only)"
# echo "----------------------------------------------------------------------------------------------------------------------"
# ./warpfrac_dna_gc3_unlock_budget | tee DNA-L16_gc3_unlock_budget.out
# 
# echo
# echo "[DNA-L16] SHA256(stdout) ="
# sha256sum DNA-L16_gc3_unlock_budget.out
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# # ---------------------------------------------------------------------------
# # MODULE DNA-L17 — LOCKED CODON SIGNATURES (E. coli MG1655, CDS-level, CPU-only)
# #   Find which specific codons are enriched in hyper-GC3-locked genes.
# # ---------------------------------------------------------------------------
# 
# if [ ! -f /content/ecoli_U00096_3.fna ]; then
#   echo "[DNA-L17] MG1655 FASTA not found, fetching..."
#   curl -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna.gz" -o /content/mg1655.fna.gz
#   gunzip -c /content/mg1655.fna.gz > /content/ecoli_U00096_3.fna
# fi
# 
# if [ ! -f /content/ecoli_U00096_3.gff ]; then
#   echo "[DNA-L17] MG1655 GFF not found, fetching..."
#   curl -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.gff.gz" -o /content/mg1655.gff.gz
#   gunzip -c /content/mg1655.gff.gz > /content/ecoli_U00096_3.gff
# fi
# 
# cat > warpfrac_dna_codon_lock_signatures.cu << 'CPP'
# // warpfrac_dna_codon_lock_signatures.cu
# // DNA-L17 — Locked codon signatures (CPU-only)
# //
# // For each CDS in E. coli MG1655:
# //   1) Compute GC3_frac per CDS.
# //   2) Compute GC3 mean/sd across genes, define hyper-GC3 genes as
# //      GC3_frac >= mean + 2*sd.
# //   3) Count codon usage globally and within hyper-GC3 genes.
# //   4) Report global codon usage, global GC3 codons, and enrichment
# //      of codons in hyper-GC3 genes vs all genes.
# //
# // CPU-only: compiled with nvcc as C++17, but no CUDA kernels.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# struct GeneInfo {
#     CDSFeature f;
#     double gc3_frac;
#     int codons;
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     std::string seq;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (std::isalpha((unsigned char)c)) {
#                 seq.push_back((char)std::toupper((unsigned char)c));
#             }
#         }
#     }
#     return seq;
# }
# 
# static void revcomp(std::string &s) {
#     auto comp = [](char c)->char {
#         switch (c) {
#             case 'A': return 'T';
#             case 'C': return 'G';
#             case 'G': return 'C';
#             case 'T': return 'A';
#             default:  return 'N';
#         }
#     };
#     std::reverse(s.begin(), s.end());
#     for (char &c : s) c = comp(c);
# }
# 
# static void parse_gff_cds(const std::string &path, std::vector<CDSFeature> &out) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string cols[9];
#         bool ok = true;
#         for (int i = 0; i < 9; ++i) {
#             if (!std::getline(ss, cols[i], '\t')) { ok = false; break; }
#         }
#         if (!ok) continue;
#         if (cols[2] != "CDS") continue;
# 
#         int start1 = std::atoi(cols[3].c_str());
#         int end1   = std::atoi(cols[4].c_str());
#         if (start1 <= 0 || end1 <= 0) continue;
#         int start0 = start1 - 1;
#         int end0   = end1 - 1;
#         if (end0 < start0) std::swap(end0, start0);
#         char strand = cols[6].empty() ? '+' : cols[6][0];
# 
#         std::string attrs = cols[8];
#         std::string name;
#         {
#             std::size_t p = attrs.find("gene=");
#             if (p != std::string::npos) {
#                 std::size_t q = attrs.find_first_of(";\t\r\n", p+5);
#                 if (q == std::string::npos) q = attrs.size();
#                 name = attrs.substr(p+5, q-(p+5));
#             }
#         }
#         if (name.empty()) {
#             std::size_t p = attrs.find("Name=");
#             if (p != std::string::npos) {
#                 std::size_t q = attrs.find_first_of(";\t\r\n", p+5);
#                 if (q == std::string::npos) q = attrs.size();
#                 name = attrs.substr(p+5, q-(p+5));
#             }
#         }
#         if (name.empty()) continue;
# 
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start0;
#         f.end0   = end0;
#         f.strand = strand;
#         out.push_back(f);
#     }
# }
# 
# static bool is_acgt(char c) {
#     return (c=='A' || c=='C' || c=='G' || c=='T');
# }
# 
# static int base_index(char b) {
#     switch (b) {
#         case 'A': return 0;
#         case 'C': return 1;
#         case 'G': return 2;
#         case 'T': return 3;
#         default:  return -1;
#     }
# }
# 
# // Map codon index <-> codon string
# static std::string idx_to_codon[64];
# static void init_codon_strings() {
#     static bool inited = false;
#     if (inited) return;
#     const char bases[4] = {'A','C','G','T'};
#     int idx = 0;
#     for (int i = 0; i < 4; ++i) {
#         for (int j = 0; j < 4; ++j) {
#             for (int k = 0; k < 4; ++k) {
#                 std::string cod;
#                 cod.push_back(bases[i]);
#                 cod.push_back(bases[j]);
#                 cod.push_back(bases[k]);
#                 idx_to_codon[idx++] = cod;
#             }
#         }
#     }
#     inited = true;
# }
# 
# static int codon_index_3(char b1, char b2, char b3) {
#     int i1 = base_index(b1);
#     int i2 = base_index(b2);
#     int i3 = base_index(b3);
#     if (i1 < 0 || i2 < 0 || i3 < 0) return -1;
#     return i1*16 + i2*4 + i3;
# }
# 
# // Compute GC3 for a CDS and count global codons
# static bool scan_cds_first_pass(const std::string &genome,
#                                 const CDSFeature &f,
#                                 double &gc3_frac,
#                                 int &codon_count,
#                                 long global_codons[64],
#                                 long global_gc3_codons[64])
# {
#     int len = f.end0 - f.start0 + 1;
#     if (len <= 3) return false;
#     if (f.start0 < 0 || f.end0 >= (int)genome.size()) return false;
# 
#     std::string seq = genome.substr(f.start0, len);
#     if (f.strand == '-') {
#         revcomp(seq);
#     }
#     for (char &c : seq) c = (char)std::toupper((unsigned char)c);
# 
#     long codons = 0;
#     long gc3 = 0;
#     int max_codons = len / 3;
#     for (int i = 0; i < max_codons; ++i) {
#         int pos = i*3;
#         char b1 = seq[pos];
#         char b2 = seq[pos+1];
#         char b3 = seq[pos+2];
#         if (!is_acgt(b1) || !is_acgt(b2) || !is_acgt(b3)) continue;
#         int idx = codon_index_3(b1,b2,b3);
#         if (idx < 0) continue;
#         codons++;
#         global_codons[idx]++;
#         bool is_gc3 = (b3=='G' || b3=='C');
#         if (is_gc3) {
#             gc3++;
#             global_gc3_codons[idx]++;
#         }
#     }
#     if (codons == 0) return false;
#     gc3_frac = (double)gc3 / (double)codons;
#     codon_count = (int)codons;
#     return true;
# }
# 
# // Second pass: for hyper-GC3 genes, count codon usage
# static bool scan_cds_hyper(const std::string &genome,
#                            const CDSFeature &f,
#                            long hyper_codons[64],
#                            long hyper_gc3_codons[64])
# {
#     int len = f.end0 - f.start0 + 1;
#     if (len <= 3) return false;
#     if (f.start0 < 0 || f.end0 >= (int)genome.size()) return false;
# 
#     std::string seq = genome.substr(f.start0, len);
#     if (f.strand == '-') {
#         revcomp(seq);
#     }
#     for (char &c : seq) c = (char)std::toupper((unsigned char)c);
# 
#     int max_codons = len / 3;
#     for (int i = 0; i < max_codons; ++i) {
#         int pos = i*3;
#         char b1 = seq[pos];
#         char b2 = seq[pos+1];
#         char b3 = seq[pos+2];
#         if (!is_acgt(b1) || !is_acgt(b2) || !is_acgt(b3)) continue;
#         int idx = codon_index_3(b1,b2,b3);
#         if (idx < 0) continue;
#         hyper_codons[idx]++;
#         if (b3=='G' || b3=='C') {
#             hyper_gc3_codons[idx]++;
#         }
#     }
#     return true;
# }
# 
# struct CodonReport {
#     std::string codon;
#     long total_all;
#     long gc3_all;
#     long total_hyper;
#     long gc3_hyper;
#     double freq_all;
#     double freq_hyper;
#     double enrich;
# };
# 
# int main() {
#     const char *fasta_path = "/content/ecoli_U00096_3.fna";
#     const char *gff_path   = "/content/ecoli_U00096_3.gff";
# 
#     std::printf("=====================================================================================\n");
#     std::printf("LOCKED CODON SIGNATURES — E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n");
#     std::printf("We compute GC3_frac per CDS, define hyper-GC3 genes (GC3 >= mean+2*sd),\n");
#     std::printf("and compare codon usage globally vs in those hyper-locked genes.\n\n");
# 
#     std::printf("Loading FASTA from: %s\n", fasta_path);
#     std::string genome = read_fasta(fasta_path);
#     std::printf("Genome length: %zu bases\n\n", genome.size());
# 
#     std::printf("Loading GFF CDS from: %s\n", gff_path);
#     std::vector<CDSFeature> cds;
#     parse_gff_cds(gff_path, cds);
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     init_codon_strings();
# 
#     // First pass: GC3 per gene + global codon counts
#     long global_codons[64] = {0};
#     long global_gc3_codons[64] = {0};
# 
#     std::vector<GeneInfo> genes;
#     genes.reserve(cds.size());
#     double sum_gc3 = 0.0;
#     double sum_gc3_sq = 0.0;
#     int gene_count = 0;
# 
#     long sum_all_codons = 0;
#     long sum_all_gc3_codons = 0;
# 
#     for (const auto &f : cds) {
#         double gc3_frac = 0.0;
#         int codon_count = 0;
#         if (!scan_cds_first_pass(genome, f, gc3_frac, codon_count, global_codons, global_gc3_codons)) {
#             continue;
#         }
#         GeneInfo gi;
#         gi.f = f;
#         gi.gc3_frac = gc3_frac;
#         gi.codons = codon_count;
#         genes.push_back(gi);
# 
#         sum_gc3 += gc3_frac;
#         sum_gc3_sq += gc3_frac * gc3_frac;
#         gene_count++;
#     }
# 
#     if (gene_count == 0) {
#         std::printf("No valid CDS found. Exiting.\n");
#         return 0;
#     }
# 
#     for (int i = 0; i < 64; ++i) {
#         sum_all_codons += global_codons[i];
#         sum_all_gc3_codons += global_gc3_codons[i];
#     }
# 
#     double mean_gc3 = sum_gc3 / (double)gene_count;
#     double var_gc3  = (sum_gc3_sq / (double)gene_count) - (mean_gc3 * mean_gc3);
#     if (var_gc3 < 0.0) var_gc3 = 0.0;
#     double sd_gc3   = std::sqrt(var_gc3);
#     double thr_gc3  = mean_gc3 + 2.0 * sd_gc3;
# 
#     std::printf("--- GC3 distribution over CDS ---\n");
#     std::printf("  Genes analyzed (valid)        : %d\n", gene_count);
#     std::printf("  Mean GC3_frac (unweighted)    : %.4f\n", mean_gc3);
#     std::printf("  SD GC3_frac                   : %.4f\n", sd_gc3);
#     std::printf("  Hyper-GC3 threshold (mean+2sd): %.4f\n\n", thr_gc3);
# 
#     std::printf("--- Global codon counts (all CDS) ---\n");
#     std::printf("  Total codons counted          : %ld\n", sum_all_codons);
#     std::printf("  Total GC3 codons (3rd base GC): %ld\n\n", sum_all_gc3_codons);
# 
#     // Second pass: hyper-GC3 genes codon counts
#     long hyper_codons[64] = {0};
#     long hyper_gc3_codons[64] = {0};
#     int hyper_gene_count = 0;
#     long sum_hyper_codons = 0;
#     long sum_hyper_gc3_codons = 0;
# 
#     for (const auto &gi : genes) {
#         if (gi.gc3_frac >= thr_gc3) {
#             hyper_gene_count++;
#             scan_cds_hyper(genome, gi.f, hyper_codons, hyper_gc3_codons);
#         }
#     }
# 
#     for (int i = 0; i < 64; ++i) {
#         sum_hyper_codons       += hyper_codons[i];
#         sum_hyper_gc3_codons   += hyper_gc3_codons[i];
#     }
# 
#     std::printf("--- Hyper-GC3 gene set ---\n");
#     std::printf("  Hyper-GC3 genes (GC3 >= thr) : %d\n", hyper_gene_count);
#     std::printf("  Total codons in hyper genes  : %ld\n", sum_hyper_codons);
#     std::printf("  GC3 codons in hyper genes    : %ld\n\n", sum_hyper_gc3_codons);
# 
#     // Build codon reports
#     std::vector<CodonReport> reports;
#     reports.reserve(64);
#     for (int i = 0; i < 64; ++i) {
#         CodonReport r;
#         r.codon       = idx_to_codon[i];
#         r.total_all   = global_codons[i];
#         r.gc3_all     = global_gc3_codons[i];
#         r.total_hyper = hyper_codons[i];
#         r.gc3_hyper   = hyper_gc3_codons[i];
#         r.freq_all    = (sum_all_codons   > 0) ? (double)r.total_all   / (double)sum_all_codons   : 0.0;
#         r.freq_hyper  = (sum_hyper_codons > 0) ? (double)r.total_hyper / (double)sum_hyper_codons : 0.0;
#         if (r.freq_all > 0.0) r.enrich = r.freq_hyper / r.freq_all;
#         else r.enrich = 0.0;
#         reports.push_back(r);
#     }
# 
#     auto is_gc3_codon = [](const std::string &cod)->bool {
#         if (cod.size() != 3) return false;
#         char b3 = cod[2];
#         return (b3=='G' || b3=='C');
#     };
# 
#     // 1) Top 20 codons globally
#     std::vector<CodonReport> sorted_all = reports;
#     std::sort(sorted_all.begin(), sorted_all.end(),
#               [](const CodonReport &a, const CodonReport &b){
#                   if (a.total_all != b.total_all) return a.total_all > b.total_all;
#                   return a.codon < b.codon;
#               });
# 
#     std::printf("--- Top 20 codons by global usage (all CDS) ---\n");
#     int max_print = 20;
#     for (int i = 0; i < max_print && i < (int)sorted_all.size(); ++i) {
#         const auto &r = sorted_all[i];
#         std::printf("  [%2d] %s | total=%8ld (freq=%.4f) | GC3=%s\n",
#                     i+1,
#                     r.codon.c_str(),
#                     r.total_all,
#                     r.freq_all,
#                     is_gc3_codon(r.codon) ? "yes" : "no");
#     }
#     std::printf("\n");
# 
#     // 2) Codons contributing to GC3 globally (third base GC), sorted by GC3 contribution
#     std::vector<CodonReport> gc3_all;
#     for (const auto &r : reports) {
#         if (!is_gc3_codon(r.codon)) continue;
#         if (r.gc3_all == 0) continue;
#         gc3_all.push_back(r);
#     }
#     std::sort(gc3_all.begin(), gc3_all.end(),
#               [](const CodonReport &a, const CodonReport &b){
#                   if (a.gc3_all != b.gc3_all) return a.gc3_all > b.gc3_all;
#                   return a.codon < b.codon;
#               });
# 
#     std::printf("--- Top GC3 codons globally (by GC3 count) ---\n");
#     for (int i = 0; i < max_print && i < (int)gc3_all.size(); ++i) {
#         const auto &r = gc3_all[i];
#         double share_gc3 = (sum_all_gc3_codons > 0) ? (double)r.gc3_all / (double)sum_all_gc3_codons : 0.0;
#         std::printf("  [%2d] %s | GC3_all=%8ld (share_of_GC3=%.4f) | total_all=%8ld\n",
#                     i+1,
#                     r.codon.c_str(),
#                     r.gc3_all,
#                     share_gc3,
#                     r.total_all);
#     }
#     std::printf("\n");
# 
#     // 3) Codon enrichment in hyper-GC3 genes vs all genes
#     std::vector<CodonReport> sorted_enrich = reports;
#     std::sort(sorted_enrich.begin(), sorted_enrich.end(),
#               [](const CodonReport &a, const CodonReport &b){
#                   if (a.enrich != b.enrich) return a.enrich > b.enrich;
#                   return a.codon < b.codon;
#               });
# 
#     std::printf("--- Top 20 codons enriched in hyper-GC3 genes (hyper / global) ---\n");
#     for (int i = 0; i < max_print && i < (int)sorted_enrich.size(); ++i) {
#         const auto &r = sorted_enrich[i];
#         if (r.total_all == 0 && r.total_hyper == 0) continue;
#         std::printf("  [%2d] %s | freq_all=%.4f, freq_hyper=%.4f, enrich=%.3f | GC3=%s\n",
#                     i+1,
#                     r.codon.c_str(),
#                     r.freq_all,
#                     r.freq_hyper,
#                     r.enrich,
#                     is_gc3_codon(r.codon) ? "yes" : "no");
#     }
#     std::printf("\n");
# 
#     std::printf("LOCKED CODON SIGNATURES analysis finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# echo "[DNA-L17] Compiling locked codon signatures (CPU-only)..."
# nvcc -O3 -std=c++17 warpfrac_dna_codon_lock_signatures.cu -o warpfrac_dna_codon_lock_signatures
# 
# echo
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo "RUNNING DNA-L17 — LOCKED CODON SIGNATURES (CPU-only)"
# echo "----------------------------------------------------------------------------------------------------------------------"
# ./warpfrac_dna_codon_lock_signatures | tee DNA-L17_codon_lock_signatures.out
# 
# echo
# echo "[DNA-L17] SHA256(stdout) ="
# sha256sum DNA-L17_codon_lock_signatures.out
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# # ---------------------------------------------------------------------------
# # MODULE DNA-L18 — LOCK RAILS INSIDE GC3-HYPER GENES (CPU-only)
# #   Identify how much of GC3 is carried by a specific set of "lock codons",
# #   and how long contiguous runs ("rails") of these codons are inside genes.
# # ---------------------------------------------------------------------------
# 
# if [ ! -f /content/ecoli_U00096_3.fna ]; then
#   echo "[DNA-L18] MG1655 FASTA not found, fetching..."
#   curl -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna.gz" -o /content/mg1655.fna.gz
#   gunzip -c /content/mg1655.fna.gz > /content/ecoli_U00096_3.fna
# fi
# 
# if [ ! -f /content/ecoli_U00096_3.gff ]; then
#   echo "[DNA-L18] MG1655 GFF not found, fetching..."
#   curl -L "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.gff.gz" -o /content/mg1655.gff.gz
#   gunzip -c /content/mg1655.gff.gz > /content/ecoli_U00096_3.gff
# fi
# 
# cat > warpfrac_dna_lock_rails.cu << 'CPP'
# // warpfrac_dna_lock_rails.cu
# // DNA-L18 — Lock rails inside GC3-hyper genes (CPU-only)
# //
# // Uses the "lock codon" signature discovered in DNA-L17:
# //   TCG, TTC, GTG, CTC, GGC, CAC, CGC, CCG, CTG,
# //   TAC, ACC, TCC, GAC, GCG, GCC, TGC, TGG, ATC, GAG
# //
# // For each CDS:
# //   - Count codons, GC3 codons, lock codons.
# //   - Track longest contiguous run of lock codons.
# //   - Compute gc3_frac, lock_frac, lock_share_of_gc3.
# // Then:
# //   - Compute GC3 mean/sd and define hyper-GC3 genes as gc3 >= mean+2*sd.
# //   - Summarize lock usage in all genes vs hyper-GC3 genes.
# //   - Print top hyper genes by lock_share_of_gc3 and detailed stats
# //     for key loci (yag cluster, rhsD, mdtB/C, mutS, phnD/K/M).
# //
# // CPU-only: compiled with nvcc as a C++17 program, but no CUDA.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# #include <map>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# struct GeneRailStats {
#     CDSFeature f;
#     int codons;
#     long gc3_codons;
#     long lock_codons;
#     int max_lock_run;
#     double gc3_frac;
#     double lock_frac;
#     double lock_share_of_gc3;
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     std::string seq;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (std::isalpha((unsigned char)c)) {
#                 seq.push_back((char)std::toupper((unsigned char)c));
#             }
#         }
#     }
#     return seq;
# }
# 
# static void revcomp(std::string &s) {
#     auto comp = [](char c)->char {
#         switch (c) {
#             case 'A': return 'T';
#             case 'C': return 'G';
#             case 'G': return 'C';
#             case 'T': return 'A';
#             default:  return 'N';
#         }
#     };
#     std::reverse(s.begin(), s.end());
#     for (char &c : s) c = comp(c);
# }
# 
# static void parse_gff_cds(const std::string &path, std::vector<CDSFeature> &out) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string cols[9];
#         bool ok = true;
#         for (int i = 0; i < 9; ++i) {
#             if (!std::getline(ss, cols[i], '\t')) { ok = false; break; }
#         }
#         if (!ok) continue;
#         if (cols[2] != "CDS") continue;
# 
#         int start1 = std::atoi(cols[3].c_str());
#         int end1   = std::atoi(cols[4].c_str());
#         if (start1 <= 0 || end1 <= 0) continue;
#         int start0 = start1 - 1;
#         int end0   = end1 - 1;
#         if (end0 < start0) std::swap(end0, start0);
#         char strand = cols[6].empty() ? '+' : cols[6][0];
# 
#         std::string attrs = cols[8];
#         std::string name;
#         {
#             std::size_t p = attrs.find("gene=");
#             if (p != std::string::npos) {
#                 std::size_t q = attrs.find_first_of(";\t\r\n", p+5);
#                 if (q == std::string::npos) q = attrs.size();
#                 name = attrs.substr(p+5, q-(p+5));
#             }
#         }
#         if (name.empty()) {
#             std::size_t p = attrs.find("Name=");
#             if (p != std::string::npos) {
#                 std::size_t q = attrs.find_first_of(";\t\r\n", p+5);
#                 if (q == std::string::npos) q = attrs.size();
#                 name = attrs.substr(p+5, q-(p+5));
#             }
#         }
#         if (name.empty()) continue;
# 
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start0;
#         f.end0   = end0;
#         f.strand = strand;
#         out.push_back(f);
#     }
# }
# 
# static bool is_acgt(char c) {
#     return (c=='A' || c=='C' || c=='G' || c=='T');
# }
# 
# // Lock codon set (from DNA-L17 enrichment, excluding TGA stop)
# static const char* LOCK_CODONS[] = {
#     "TCG","TTC","GTG","CTC","GGC","CAC","CGC","CCG","CTG",
#     "TAC","ACC","TCC","GAC","GCG","GCC","TGC","TGG","ATC","GAG"
# };
# static const int N_LOCK = sizeof(LOCK_CODONS)/sizeof(LOCK_CODONS[0]);
# 
# static bool is_lock_codon(const std::string &cod) {
#     for (int i = 0; i < N_LOCK; ++i) {
#         if (cod == LOCK_CODONS[i]) return true;
#     }
#     return false;
# }
# 
# static bool scan_cds_rails(const std::string &genome,
#                            const CDSFeature &f,
#                            GeneRailStats &out)
# {
#     int len = f.end0 - f.start0 + 1;
#     if (len <= 3) return false;
#     if (f.start0 < 0 || f.end0 >= (int)genome.size()) return false;
# 
#     std::string seq = genome.substr(f.start0, len);
#     if (f.strand == '-') {
#         revcomp(seq);
#     }
#     for (char &c : seq) c = (char)std::toupper((unsigned char)c);
# 
#     int max_codons = len / 3;
#     int codons = 0;
#     long gc3 = 0;
#     long lock = 0;
#     int cur_run = 0;
#     int max_run = 0;
# 
#     for (int i = 0; i < max_codons; ++i) {
#         int pos = i*3;
#         char b1 = seq[pos];
#         char b2 = seq[pos+1];
#         char b3 = seq[pos+2];
#         if (!is_acgt(b1) || !is_acgt(b2) || !is_acgt(b3)) {
#             cur_run = 0; // break lock run on ambiguous codon
#             continue;
#         }
#         std::string cod;
#         cod.push_back(b1);
#         cod.push_back(b2);
#         cod.push_back(b3);
# 
#         codons++;
#         bool is_gc3 = (b3=='G' || b3=='C');
#         if (is_gc3) gc3++;
#         bool is_lock = is_lock_codon(cod);
#         if (is_lock) {
#             lock++;
#             cur_run++;
#             if (cur_run > max_run) max_run = cur_run;
#         } else {
#             cur_run = 0;
#         }
#     }
# 
#     if (codons == 0) return false;
# 
#     out.f = f;
#     out.codons = codons;
#     out.gc3_codons = gc3;
#     out.lock_codons = lock;
#     out.max_lock_run = max_run;
#     out.gc3_frac = (double)gc3 / (double)codons;
#     out.lock_frac = (double)lock / (double)codons;
#     out.lock_share_of_gc3 = (gc3 > 0) ? (double)lock / (double)gc3 : 0.0;
#     return true;
# }
# 
# int main() {
#     const char *fasta_path = "/content/ecoli_U00096_3.fna";
#     const char *gff_path   = "/content/ecoli_U00096_3.gff";
# 
#     std::printf("=====================================================================================\n");
#     std::printf("LOCK RAILS INSIDE GC3-HYPER GENES — E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n");
#     std::printf("We use a fixed set of enriched \"lock codons\" (from DNA-L17) and, for each CDS,\n");
#     std::printf("measure how much of its GC3 is carried by these codons and how long the\n");
#     std::printf("longest contiguous run of lock codons is.\n\n");
# 
#     std::printf("Lock codon set (%d codons): ", N_LOCK);
#     for (int i = 0; i < N_LOCK; ++i) {
#         std::printf("%s%s", LOCK_CODONS[i], (i+1<N_LOCK?", ":"\n"));
#     }
#     std::printf("\n");
# 
#     std::printf("Loading FASTA from: %s\n", fasta_path);
#     std::string genome = read_fasta(fasta_path);
#     std::printf("Genome length: %zu bases\n\n", genome.size());
# 
#     std::printf("Loading GFF CDS from: %s\n", gff_path);
#     std::vector<CDSFeature> cds;
#     parse_gff_cds(gff_path, cds);
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     // Scan all CDS and collect rail stats
#     std::vector<GeneRailStats> genes;
#     genes.reserve(cds.size());
# 
#     double sum_gc3 = 0.0;
#     double sum_gc3_sq = 0.0;
#     int gene_count = 0;
# 
#     long sum_codons = 0;
#     long sum_gc3_codons = 0;
#     long sum_lock_codons = 0;
# 
#     double min_gc3 = 1e9, max_gc3 = -1e9;
#     double min_lock_frac = 1e9, max_lock_frac = -1e9;
#     double min_lock_share = 1e9, max_lock_share = -1e9;
#     int min_max_run = 999999, max_max_run = -1;
# 
#     for (const auto &f : cds) {
#         GeneRailStats st;
#         if (!scan_cds_rails(genome, f, st)) continue;
#         genes.push_back(st);
# 
#         sum_gc3 += st.gc3_frac;
#         sum_gc3_sq += st.gc3_frac * st.gc3_frac;
#         gene_count++;
# 
#         sum_codons += st.codons;
#         sum_gc3_codons += st.gc3_codons;
#         sum_lock_codons += st.lock_codons;
# 
#         if (st.gc3_frac < min_gc3) min_gc3 = st.gc3_frac;
#         if (st.gc3_frac > max_gc3) max_gc3 = st.gc3_frac;
#         if (st.lock_frac < min_lock_frac) min_lock_frac = st.lock_frac;
#         if (st.lock_frac > max_lock_frac) max_lock_frac = st.lock_frac;
#         if (st.lock_share_of_gc3 < min_lock_share) min_lock_share = st.lock_share_of_gc3;
#         if (st.lock_share_of_gc3 > max_lock_share) max_lock_share = st.lock_share_of_gc3;
#         if (st.max_lock_run < min_max_run) min_max_run = st.max_lock_run;
#         if (st.max_lock_run > max_max_run) max_max_run = st.max_lock_run;
#     }
# 
#     if (gene_count == 0) {
#         std::printf("No valid CDS found. Exiting.\n");
#         return 0;
#     }
# 
#     double mean_gc3 = sum_gc3 / (double)gene_count;
#     double var_gc3  = (sum_gc3_sq / (double)gene_count) - (mean_gc3 * mean_gc3);
#     if (var_gc3 < 0.0) var_gc3 = 0.0;
#     double sd_gc3   = std::sqrt(var_gc3);
#     double thr_gc3  = mean_gc3 + 2.0 * sd_gc3;
# 
#     std::printf("--- Global CDS-wise lock rail stats ---\n");
#     std::printf("  Genes analyzed (valid)          : %d\n", gene_count);
#     std::printf("  Sum codons                      : %ld\n", sum_codons);
#     std::printf("  Sum GC3 codons                  : %ld (GC3_frac=%.4f)\n",
#                 sum_gc3_codons, (double)sum_gc3_codons/(double)sum_codons);
#     std::printf("  Sum lock codons                 : %ld (lock_frac=%.4f)\n",
#                 sum_lock_codons, (double)sum_lock_codons/(double)sum_codons);
#     std::printf("  GC3 per CDS (unweighted)        : mean=%.4f, sd=%.4f, min=%.4f, max=%.4f\n",
#                 mean_gc3, sd_gc3, min_gc3, max_gc3);
#     std::printf("  Lock_frac per CDS               : min=%.4f, max=%.4f\n",
#                 min_lock_frac, max_lock_frac);
#     std::printf("  Lock_share_of_GC3 per CDS       : min=%.4f, max=%.4f\n",
#                 min_lock_share, max_lock_share);
#     std::printf("  Max lock run length (codons)    : min=%d, max=%d\n",
#                 min_max_run, max_max_run);
#     std::printf("  Hyper-GC3 threshold (mean+2sd)  : %.4f\n\n", thr_gc3);
# 
#     // Split into hyper-GC3 and others
#     std::vector<GeneRailStats> hyper;
#     std::vector<GeneRailStats> nonhyper;
#     hyper.reserve(genes.size());
#     nonhyper.reserve(genes.size());
# 
#     for (const auto &g : genes) {
#         if (g.gc3_frac >= thr_gc3) hyper.push_back(g);
#         else nonhyper.push_back(g);
#     }
# 
#     long h_codons = 0, h_gc3 = 0, h_lock = 0;
#     long nh_codons = 0, nh_gc3 = 0, nh_lock = 0;
#     double h_sum_lock_share = 0.0;
#     double h_sum_gc3 = 0.0;
#     double h_sum_lock_frac = 0.0;
#     double h_sum_max_run = 0.0;
# 
#     for (const auto &g : hyper) {
#         h_codons += g.codons;
#         h_gc3    += g.gc3_codons;
#         h_lock   += g.lock_codons;
#         h_sum_lock_share += g.lock_share_of_gc3;
#         h_sum_gc3        += g.gc3_frac;
#         h_sum_lock_frac  += g.lock_frac;
#         h_sum_max_run    += g.max_lock_run;
#     }
# 
#     for (const auto &g : nonhyper) {
#         nh_codons += g.codons;
#         nh_gc3    += g.gc3_codons;
#         nh_lock   += g.lock_codons;
#     }
# 
#     std::printf("--- Hyper-GC3 vs other genes (using GC3 >= mean+2sd) ---\n");
#     std::printf("  Hyper-GC3 genes                 : %zu\n", hyper.size());
#     std::printf("  Non-hyper genes                 : %zu\n\n", nonhyper.size());
# 
#     if (!hyper.empty()) {
#         std::printf("  Hyper-GC3 genes (aggregate):\n");
#         std::printf("    codons               : %ld\n", h_codons);
#         std::printf("    GC3 codons           : %ld (GC3_frac=%.4f)\n",
#                     h_gc3, (double)h_gc3/(double)h_codons);
#         std::printf("    lock codons          : %ld (lock_frac=%.4f)\n",
#                     h_lock, (double)h_lock/(double)h_codons);
#         std::printf("    lock_share_of_GC3    : mean=%.4f\n",
#                     h_sum_lock_share/(double)hyper.size());
#         std::printf("    gc3_frac per gene    : mean=%.4f\n",
#                     h_sum_gc3/(double)hyper.size());
#         std::printf("    lock_frac per gene   : mean=%.4f\n",
#                     h_sum_lock_frac/(double)hyper.size());
#         std::printf("    max_lock_run per gene: mean=%.2f codons\n\n",
#                     h_sum_max_run/(double)hyper.size());
#     }
# 
#     if (!nonhyper.empty()) {
#         std::printf("  Non-hyper genes (aggregate):\n");
#         std::printf("    codons               : %ld\n", nh_codons);
#         std::printf("    GC3 codons           : %ld (GC3_frac=%.4f)\n",
#                     nh_gc3, (double)nh_gc3/(double)nh_codons);
#         std::printf("    lock codons          : %ld (lock_frac=%.4f)\n\n",
#                     nh_lock, (double)nh_lock/(double)nh_codons);
#     }
# 
#     // Sort hyper genes by lock_share_of_gc3 descending
#     std::vector<GeneRailStats> hyper_sorted = hyper;
#     std::sort(hyper_sorted.begin(), hyper_sorted.end(),
#               [](const GeneRailStats &a, const GeneRailStats &b){
#                   if (a.lock_share_of_gc3 != b.lock_share_of_gc3)
#                       return a.lock_share_of_gc3 > b.lock_share_of_gc3;
#                   if (a.lock_frac != b.lock_frac)
#                       return a.lock_frac > b.lock_frac;
#                   return a.f.name < b.f.name;
#               });
# 
#     std::printf("--- Top hyper-GC3 genes by lock_share_of_GC3 ---\n");
#     int max_print = 15;
#     for (int i = 0; i < max_print && i < (int)hyper_sorted.size(); ++i) {
#         const auto &g = hyper_sorted[i];
#         std::printf("  [%2d] %s | codons=%4d | GC3=%.4f | lock_frac=%.4f | lock_share_GC3=%.4f | max_lock_run=%d\n",
#                     i+1,
#                     g.f.name.c_str(),
#                     g.codons,
#                     g.gc3_frac,
#                     g.lock_frac,
#                     g.lock_share_of_gc3,
#                     g.max_lock_run);
#     }
#     std::printf("\n");
# 
#     // Build a map from name to stats for quick lookup
#     std::map<std::string,GeneRailStats> by_name;
#     for (const auto &g : genes) {
#         by_name[g.f.name] = g;
#     }
# 
#     auto print_gene = [&](const char* label){
#         auto it = by_name.find(label);
#         if (it == by_name.end()) {
#             std::printf("  [%s] not found.\n", label);
#             return;
#         }
#         const auto &g = it->second;
#         std::printf("  [%s]\n", label);
#         std::printf("    codons              : %d\n", g.codons);
#         std::printf("    GC3_frac            : %.4f\n", g.gc3_frac);
#         std::printf("    lock_frac           : %.4f\n", g.lock_frac);
#         std::printf("    lock_share_of_GC3   : %.4f\n", g.lock_share_of_gc3);
#         std::printf("    max_lock_run        : %d codons\n", g.max_lock_run);
#         std::printf("    coords (0-based)    : %d - %d (strand=%c)\n",
#                     g.f.start0, g.f.end0, g.f.strand);
#     };
# 
#     std::printf("--- Lock rail stats for selected loci ---\n");
#     print_gene("yagE");
#     print_gene("yagF");
#     print_gene("yagG");
#     print_gene("yagH");
#     print_gene("yagA");
#     print_gene("rhsD");
#     print_gene("mdtB");
#     print_gene("mdtC");
#     print_gene("mutS");
#     print_gene("phnD");
#     print_gene("phnK");
#     print_gene("phnM");
#     std::printf("\n");
# 
#     std::printf("LOCK RAILS INSIDE GC3-HYPER GENES analysis finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# echo "[DNA-L18] Compiling lock rails (CPU-only)..."
# nvcc -O3 -std=c++17 warpfrac_dna_lock_rails.cu -o warpfrac_dna_lock_rails
# 
# echo
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo "RUNNING DNA-L18 — LOCK RAILS INSIDE GC3-HYPER GENES (CPU-only)"
# echo "----------------------------------------------------------------------------------------------------------------------"
# ./warpfrac_dna_lock_rails | tee DNA-L18_lock_rails.out
# 
# echo
# echo "[DNA-L18] SHA256(stdout) ="
# sha256sum DNA-L18_lock_rails.out
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_gc3_lock_potential.cu << 'CPP'
# // warpfrac_dna_gc3_lock_potential.cu
# // DNA-L19 — Amino-acid-constrained GC3 lock potential (CPU-only)
# //
# // For each CDS (len % 3 == 0, clean A/C/G/T) we:
# //   • Translate codons to amino acids using the standard genetic code.
# //   • Count real GC3 codons: bases with G or C at codon position 3.
# //   • For each amino acid position, ask whether there exists a synonymous
# //     codon with G/C at position 3. If yes, that position can be GC3-locked.
# //   • Sum these to get max_GC3_codons (AA-constrained max).
# //
# // Then per CDS we compute:
# //   real_GC3_frac = real_GC3_codons / total_codons
# //   max_GC3_frac  = max_GC3_codons  / total_codons
# //   used_frac     = real_GC3_codons / max_GC3_codons (if max>0)
# //
# // Note: under the standard genetic code, every amino acid (including stop)
# // has at least one synonymous codon whose 3rd base is G or C, so in this
# // E. coli genome max_GC3_frac ≈ 1.0 for almost all genes. The interesting
# // quantity is how close real_GC3_frac gets to that ceiling.
# //
# // CPU-only: compiled with nvcc as a C++17 program, no CUDA kernels.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# #include <map>
# 
# struct CDSFeature {
#     std::string gene;     // gene symbol if available
#     std::string display;  // preferred display name (gene, then locus_tag, then Name)
#     int start0;           // 0-based inclusive
#     int end0;             // 0-based inclusive
#     char strand;          // '+' or '-'
# };
# 
# struct LockStats {
#     std::string gene;
#     std::string display;
#     int start0;
#     int end0;
#     char strand;
# 
#     int length;            // bases
#     int codons;            // length/3
#     int real_gc3_codons;
#     int max_gc3_codons;
# 
#     double real_gc3_frac;
#     double max_gc3_frac;
#     double used_frac;      // fraction of available GC3 potential that's used
# };
# 
# // ---------- utility -----------
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) return std::string();
#     std::string line, seq;
#     bool header_seen = false;
#     while (std::getline(in, line)) {
#         if (!header_seen) {
#             if (!line.empty() && line[0] == '>') header_seen = true;
#             continue;
#         }
#         for (char c : line) {
#             if (!std::isspace((unsigned char)c)) {
#                 seq.push_back(std::toupper((unsigned char)c));
#             }
#         }
#     }
#     return seq;
# }
# 
# static std::string trim(const std::string &s) {
#     size_t b = 0, e = s.size();
#     while (b < e && std::isspace((unsigned char)s[b])) ++b;
#     while (e > b && std::isspace((unsigned char)s[e-1])) --e;
#     return s.substr(b, e-b);
# }
# 
# static std::vector<std::string> split(const std::string &s, char delim) {
#     std::vector<std::string> out;
#     std::string cur;
#     for (char c : s) {
#         if (c == delim) {
#             out.push_back(cur);
#             cur.clear();
#         } else {
#             cur.push_back(c);
#         }
#     }
#     out.push_back(cur);
#     return out;
# }
# 
# struct AttrFields {
#     std::string gene;
#     std::string locus_tag;
#     std::string name;
# };
# 
# static AttrFields parse_attrs(const std::string &attr) {
#     AttrFields a;
#     std::vector<std::string> parts = split(attr, ';');
#     for (const std::string &p0 : parts) {
#         std::string p = trim(p0);
#         if (p.empty()) continue;
#         size_t eq = p.find('=');
#         if (eq == std::string::npos) continue;
#         std::string key = p.substr(0, eq);
#         std::string val = p.substr(eq+1);
#         if (key == "gene")       a.gene = val;
#         else if (key == "locus_tag") a.locus_tag = val;
#         else if (key == "Name")  a.name = val;
#     }
#     return a;
# }
# 
# static std::vector<CDSFeature> read_gff_cds(const std::string &path) {
#     std::ifstream in(path.c_str());
#     std::vector<CDSFeature> cds;
#     if (!in) return cds;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::vector<std::string> fields = split(line, '\t');
#         if (fields.size() < 9) continue;
#         if (fields[2] != "CDS") continue;
#         int start = std::atoi(fields[3].c_str());
#         int end   = std::atoi(fields[4].c_str());
#         char strand = (fields[6].empty() ? '+' : fields[6][0]);
# 
#         AttrFields attrs = parse_attrs(fields[8]);
#         CDSFeature f;
#         f.gene = attrs.gene;
#         if (!attrs.gene.empty()) {
#             f.display = attrs.gene;
#         } else if (!attrs.locus_tag.empty()) {
#             f.display = attrs.locus_tag;
#         } else if (!attrs.name.empty()) {
#             f.display = attrs.name;
#         } else {
#             f.display = "CDS";
#         }
# 
#         f.start0 = start - 1;
#         f.end0   = end   - 1;
#         f.strand = strand;
#         cds.push_back(f);
#     }
#     return cds;
# }
# 
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         case 'T': return 'A';
#         default:  return 'N';
#     }
# }
# 
# static std::string revcomp(const std::string &s) {
#     std::string out;
#     out.reserve(s.size());
#     for (int i = (int)s.size() - 1; i >= 0; --i) {
#         out.push_back(comp_base(s[i]));
#     }
#     return out;
# }
# 
# // ---------- genetic code ----------
# 
# static std::map<std::string,char> make_codon_table() {
#     std::map<std::string,char> m;
#     // Standard genetic code (NCBI translation table 11) for bacteria
#     m["TTT"]='F'; m["TTC"]='F';
#     m["TTA"]='L'; m["TTG"]='L';
#     m["CTT"]='L'; m["CTC"]='L'; m["CTA"]='L'; m["CTG"]='L';
#     m["ATT"]='I'; m["ATC"]='I'; m["ATA"]='I';
#     m["ATG"]='M';
#     m["GTT"]='V'; m["GTC"]='V'; m["GTA"]='V'; m["GTG"]='V';
# 
#     m["TCT"]='S'; m["TCC"]='S'; m["TCA"]='S'; m["TCG"]='S';
#     m["CCT"]='P'; m["CCC"]='P'; m["CCA"]='P'; m["CCG"]='P';
#     m["ACT"]='T'; m["ACC"]='T'; m["ACA"]='T'; m["ACG"]='T';
#     m["GCT"]='A'; m["GCC"]='A'; m["GCA"]='A'; m["GCG"]='A';
# 
#     m["TAT"]='Y'; m["TAC"]='Y';
#     m["TAA"]='*'; m["TAG"]='*';
#     m["CAT"]='H'; m["CAC"]='H';
#     m["CAA"]='Q'; m["CAG"]='Q';
#     m["AAT"]='N'; m["AAC"]='N';
#     m["AAA"]='K'; m["AAG"]='K';
#     m["GAT"]='D'; m["GAC"]='D';
#     m["GAA"]='E'; m["GAG"]='E';
# 
#     m["TGT"]='C'; m["TGC"]='C';
#     m["TGA"]='*';
#     m["TGG"]='W';
#     m["CGT"]='R'; m["CGC"]='R'; m["CGA"]='R'; m["CGG"]='R';
#     m["AGT"]='S'; m["AGC"]='S';
#     m["AGA"]='R'; m["AGG"]='R';
#     m["GGT"]='G'; m["GGC"]='G'; m["GGA"]='G'; m["GGG"]='G';
#     return m;
# }
# 
# // ---------- main ----------
# 
# int main() {
#     const std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     const std::string gff_path   = "/content/ecoli_U00096_3.gff";
# 
#     std::printf("======================================================================================================================\n");
#     std::printf("MODULE DNA-L19 — AMINO-ACID-CONSTRAINED GC3 LOCK POTENTIAL (E. coli MG1655, CDS-level)\n");
#     std::printf("======================================================================================================================\n\n");
# 
#     std::printf("[DNA-L19] FASTA path: %s\n", fasta_path.c_str());
#     std::printf("[DNA-L19] GFF path  : %s\n\n", gff_path.c_str());
# 
#     std::string genome = read_fasta(fasta_path);
#     if (genome.empty()) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", fasta_path.c_str());
#         return 1;
#     }
#     std::printf("Genome loaded: length = %zu bases\n", genome.size());
# 
#     std::vector<CDSFeature> cds = read_gff_cds(gff_path);
#     if (cds.empty()) {
#         std::fprintf(stderr, "ERROR: could not load CDS from GFF %s\n", gff_path.c_str());
#         return 1;
#     }
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     auto codon_table = make_codon_table();
#     // For each amino acid, does there exist a codon with GC at 3rd base?
#     std::map<char,bool> aa_has_gc3;
#     for (const auto &kv : codon_table) {
#         const std::string &cod = kv.first;
#         char aa = kv.second;
#         char b3 = cod[2];
#         if (b3 == 'G' || b3 == 'C') {
#             aa_has_gc3[aa] = true;
#         }
#     }
# 
#     std::vector<LockStats> genes;
#     genes.reserve(cds.size());
#     std::map<std::string,int> gene_index;
# 
#     long sum_codons = 0;
#     long sum_real_gc3 = 0;
#     long sum_max_gc3  = 0;
# 
#     double sum_real_frac = 0.0, sum_real_frac2 = 0.0;
#     double sum_max_frac  = 0.0, sum_max_frac2  = 0.0;
#     double sum_used_frac = 0.0, sum_used_frac2 = 0.0;
# 
#     int n_valid = 0;
#     int n_skipped_len = 0;
#     int n_skipped_ambig = 0;
#     int n_skipped_translate = 0;
# 
#     for (const CDSFeature &f : cds) {
#         if (f.start0 < 0 || f.end0 >= (int)genome.size() || f.end0 < f.start0) continue;
#         int len = f.end0 - f.start0 + 1;
#         if (len <= 0) continue;
# 
#         std::string seq = genome.substr(f.start0, len);
#         for (char &c : seq) c = std::toupper((unsigned char)c);
#         if (f.strand == '-') seq = revcomp(seq);
# 
#         if ((int)seq.size() % 3 != 0) {
#             ++n_skipped_len;
#             continue;
#         }
#         int codons = seq.size() / 3;
#         if (codons <= 0) {
#             ++n_skipped_len;
#             continue;
#         }
# 
#         // reject if any ambiguous base
#         if (seq.find_first_not_of("ACGT") != std::string::npos) {
#             ++n_skipped_ambig;
#             continue;
#         }
# 
#         int real_gc3_codons = 0;
#         int max_gc3_codons  = 0;
#         bool translate_ok = true;
# 
#         for (int i = 0; i < codons; ++i) {
#             std::string cod = seq.substr(i*3, 3);
#             auto it = codon_table.find(cod);
#             if (it == codon_table.end()) {
#                 translate_ok = false;
#                 break;
#             }
#             char aa = it->second;
#             char b3 = cod[2];
#             if (b3 == 'G' || b3 == 'C') {
#                 ++real_gc3_codons;
#             }
#             if (aa_has_gc3[aa]) {
#                 ++max_gc3_codons;
#             }
#         }
# 
#         if (!translate_ok) {
#             ++n_skipped_translate;
#             continue;
#         }
# 
#         LockStats s;
#         s.gene    = f.gene;
#         s.display = f.display;
#         s.start0  = f.start0;
#         s.end0    = f.end0;
#         s.strand  = f.strand;
#         s.length  = len;
#         s.codons  = codons;
#         s.real_gc3_codons = real_gc3_codons;
#         s.max_gc3_codons  = max_gc3_codons;
# 
#         s.real_gc3_frac = (double)real_gc3_codons / (double)codons;
#         s.max_gc3_frac  = (double)max_gc3_codons  / (double)codons;
#         if (max_gc3_codons > 0) {
#             s.used_frac = (double)real_gc3_codons / (double)max_gc3_codons;
#         } else {
#             s.used_frac = 0.0;
#         }
# 
#         genes.push_back(s);
#         int idx = (int)genes.size() - 1;
#         if (!f.gene.empty() && gene_index.find(f.gene) == gene_index.end()) {
#             gene_index[f.gene] = idx;
#         }
# 
#         ++n_valid;
#         sum_codons    += codons;
#         sum_real_gc3  += real_gc3_codons;
#         sum_max_gc3   += max_gc3_codons;
# 
#         sum_real_frac += s.real_gc3_frac;
#         sum_real_frac2+= s.real_gc3_frac * s.real_gc3_frac;
#         sum_max_frac  += s.max_gc3_frac;
#         sum_max_frac2 += s.max_gc3_frac * s.max_gc3_frac;
#         sum_used_frac += s.used_frac;
#         sum_used_frac2+= s.used_frac * s.used_frac;
#     }
# 
#     std::printf("=====================================================================================\n");
#     std::printf("AMINO-ACID-CONSTRAINED GC3 LOCK POTENTIAL — E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n\n");
# 
#     std::printf("CDS summary:\n");
#     std::printf("  CDS features in GFF          : %zu\n", cds.size());
#     std::printf("  CDS with valid lock stats    : %d\n", n_valid);
#     std::printf("  CDS skipped (len %% 3 != 0)   : %d\n", n_skipped_len);
#     std::printf("  CDS skipped (ambiguous bases): %d\n", n_skipped_ambig);
#     std::printf("  CDS skipped (translation err): %d\n\n", n_skipped_translate);
# 
#     if (n_valid == 0) {
#         std::printf("No valid CDS; exiting.\n");
#         return 0;
#     }
# 
#     double mean_real = sum_real_frac / n_valid;
#     double mean_max  = sum_max_frac  / n_valid;
#     double mean_used = sum_used_frac / n_valid;
# 
#     double sd_real = 0.0, sd_max = 0.0, sd_used = 0.0;
#     if (n_valid > 1) {
#         sd_real = std::sqrt(std::max(0.0,
#             (sum_real_frac2 / n_valid) - mean_real * mean_real));
#         sd_max  = std::sqrt(std::max(0.0,
#             (sum_max_frac2  / n_valid) - mean_max  * mean_max));
#         sd_used = std::sqrt(std::max(0.0,
#             (sum_used_frac2 / n_valid) - mean_used * mean_used));
#     }
# 
#     std::printf("--- Global lock potential stats (CDS-level) ---\n");
#     std::printf("  Sum codons                      : %ld\n", sum_codons);
#     std::printf("  Total real GC3 codons           : %ld\n", sum_real_gc3);
#     std::printf("  Total max GC3 codons (AA-based) : %ld\n", sum_max_gc3);
#     std::printf("  Codon-weighted real GC3_frac    : %.4f\n",
#                 (double)sum_real_gc3 / (double)sum_codons);
#     std::printf("  Codon-weighted max GC3_frac     : %.4f\n",
#                 (double)sum_max_gc3 / (double)sum_codons);
#     std::printf("\n");
#     std::printf("  Real GC3_frac per CDS: mean = %.4f, sd = %.4f\n", mean_real, sd_real);
#     std::printf("  Max  GC3_frac per CDS: mean = %.4f, sd = %.4f\n", mean_max,  sd_max);
#     std::printf("  Used_frac (real/max) : mean = %.4f, sd = %.4f\n\n", mean_used, sd_used);
# 
#     // Sort by used_frac (fraction of potential used)
#     std::vector<LockStats> by_used = genes;
#     std::sort(by_used.begin(), by_used.end(),
#               [](const LockStats &a, const LockStats &b) {
#                   if (a.used_frac != b.used_frac)
#                       return a.used_frac > b.used_frac;
#                   return a.real_gc3_frac > b.real_gc3_frac;
#               });
# 
#     int topN = std::min<int>(10, (int)by_used.size());
#     std::printf("--- Top 10 genes by GC3 lock usage (used_frac = real / max) ---\n");
#     for (int i = 0; i < topN; ++i) {
#         const auto &g = by_used[i];
#         std::printf("  [%2d] %-10s | len=%4d codons=%4d | real_GC3=%.4f | max_GC3=%.4f | used=%.4f\n",
#                     i+1,
#                     (g.gene.empty() ? g.display.c_str() : g.gene.c_str()),
#                     g.length, g.codons,
#                     g.real_gc3_frac, g.max_gc3_frac, g.used_frac);
#     }
#     std::printf("\n");
# 
#     // Sort by unused potential: gap = max_real - real
#     std::vector<LockStats> by_gap = genes;
#     std::sort(by_gap.begin(), by_gap.end(),
#               [](const LockStats &a, const LockStats &b) {
#                   double gap_a = a.max_gc3_frac - a.real_gc3_frac;
#                   double gap_b = b.max_gc3_frac - b.real_gc3_frac;
#                   if (gap_a != gap_b)
#                       return gap_a > gap_b;
#                   return a.codons > b.codons;
#               });
# 
#     std::printf("--- Top 10 genes with largest unused GC3 lock potential (max - real) ---\n");
#     for (int i = 0; i < topN; ++i) {
#         const auto &g = by_gap[i];
#         double gap = g.max_gc3_frac - g.real_gc3_frac;
#         std::printf("  [%2d] %-10s | codons=%4d | real_GC3=%.4f | max_GC3=%.4f | gap=%.4f | used=%.4f\n",
#                     i+1,
#                     (g.gene.empty() ? g.display.c_str() : g.gene.c_str()),
#                     g.codons,
#                     g.real_gc3_frac, g.max_gc3_frac, gap, g.used_frac);
#     }
#     std::printf("\n");
# 
#     // Highlight a set of well-known hyper-lock loci by gene name
#     std::vector<std::string> highlights = {
#         "yagA","yagE","yagF","yagG","yagH",
#         "rhsD","mdtB","mdtC","mutS","phnD","phnK","phnM"
#     };
# 
#     std::printf("--- Lock potential vs realized for selected loci (by gene name) ---\n");
#     for (const std::string &gname : highlights) {
#         auto it = gene_index.find(gname);
#         if (it == gene_index.end()) {
#             std::printf("  [%s] not found in CDS set.\n", gname.c_str());
#             continue;
#         }
#         const auto &g = genes[it->second];
#         std::printf("  [%s] lock potential:\n", gname.c_str());
#         std::printf("    length         : %d\n", g.length);
#         std::printf("    codons         : %d\n", g.codons);
#         std::printf("    real_GC3_frac  : %.4f\n", g.real_gc3_frac);
#         std::printf("    max_GC3_frac   : %.4f\n", g.max_gc3_frac);
#         std::printf("    used_frac      : %.4f\n", g.used_frac);
#     }
#     std::printf("\n");
# 
#     std::printf("AMINO-ACID-CONSTRAINED GC3 LOCK POTENTIAL analysis finished.\n");
#     std::printf("=====================================================================================\n");
# 
#     return 0;
# }
# CPP
# 
# echo "[DNA-L19] Compiling amino-acid-constrained GC3 lock potential (CPU-only)..."
# nvcc -O3 -std=c++17 warpfrac_dna_gc3_lock_potential.cu -o warpfrac_dna_gc3_lock_potential
# 
# echo
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo "RUNNING DNA-L19 — AMINO-ACID-CONSTRAINED GC3 LOCK POTENTIAL (CPU-only)"
# echo "----------------------------------------------------------------------------------------------------------------------"
# 
# ./warpfrac_dna_gc3_lock_potential | tee DNA-L19_lock_potential.out
# 
# echo
# echo "[DNA-L19] SHA256(stdout) ="
# sha256sum DNA-L19_lock_potential.out
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_cpg_bridges_gc3.cu << 'CPP'
# // warpfrac_dna_cpg_bridges_gc3.cu
# // DNA-L20 — Codon-boundary CpG bridges vs GC3 locks (CPU-only)
# //
# // For each CDS (len % 3 == 0, clean A/C/G/T) in E. coli MG1655 we compute:
# //
# //   - GC3_frac       = (# codons with G or C at 3rd base) / total_codons
# //   - C3_frac        = (# codons with C at 3rd base) / total_codons
# //   - CpG_per_kb     = (# 'CG' dinucleotides) * 1000 / (len-1)
# //   - bridge_CpG     = CpG where C is codon pos3 and G is next codon's pos1
# //   - bridge_per_kb  = bridge_CpG * 1000 / (len-1)
# //   - bridge_share_CpG = bridge_CpG / total_CpG (if total_CpG>0)
# //   - bridge_share_C3  = bridge_CpG / (# C3 codons) (if C3>0)
# //
# // We then print global stats, correlations, and top bridge-heavy genes.
# //
# // CPU-only, compiled with nvcc as C++17.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;
# };
# 
# struct BridgeStats {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;
#     int length;
#     int codons;
#     int gc3_codons;
#     int c3_codons;
#     int total_cpg;
#     int bridge_cpg;   // CpG at codon boundary (pos3 -> pos1)
# 
#     double gc3_frac;
#     double c3_frac;
#     double cpg_per_kb;
#     double bridge_per_kb;
#     double bridge_share_cpg;
#     double bridge_share_c3;
# };
# 
# // ---------- utility -----------
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) return std::string();
#     std::string line, seq;
#     bool header_seen = false;
#     while (std::getline(in, line)) {
#         if (!header_seen) {
#             if (!line.empty() && line[0] == '>') header_seen = true;
#             continue;
#         }
#         for (char c : line) {
#             if (!std::isspace((unsigned char)c)) {
#                 seq.push_back(std::toupper((unsigned char)c));
#             }
#         }
#     }
#     return seq;
# }
# 
# static std::string trim(const std::string &s) {
#     size_t b = 0, e = s.size();
#     while (b < e && std::isspace((unsigned char)s[b])) ++b;
#     while (e > b && std::isspace((unsigned char)s[e-1])) --e;
#     return s.substr(b, e-b);
# }
# 
# static std::vector<std::string> split(const std::string &s, char delim) {
#     std::vector<std::string> out;
#     std::string cur;
#     for (char c : s) {
#         if (c == delim) {
#             out.push_back(cur);
#             cur.clear();
#         } else {
#             cur.push_back(c);
#         }
#     }
#     out.push_back(cur);
#     return out;
# }
# 
# static std::string parse_cds_name(const std::string &attr) {
#     // Similar to earlier modules: try gene=, then Name=, then locus_tag=
#     std::string best;
#     std::vector<std::string> parts = split(attr, ';');
#     for (const std::string &p0 : parts) {
#         std::string p = trim(p0);
#         if (p.empty()) continue;
#         size_t eq = p.find('=');
#         if (eq == std::string::npos) continue;
#         std::string key = p.substr(0, eq);
#         std::string val = p.substr(eq+1);
#         if (key == "gene") return val;
#         if (key == "Name" && best.empty()) best = val;
#         if (key == "locus_tag" && best.empty()) best = val;
#     }
#     if (best.empty()) best = "CDS";
#     return best;
# }
# 
# static std::vector<CDSFeature> read_gff_cds(const std::string &path) {
#     std::ifstream in(path.c_str());
#     std::vector<CDSFeature> cds;
#     if (!in) return cds;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::vector<std::string> fields = split(line, '\t');
#         if (fields.size() < 9) continue;
#         if (fields[2] != "CDS") continue;
#         int start = std::atoi(fields[3].c_str());
#         int end   = std::atoi(fields[4].c_str());
#         char strand = (fields[6].empty() ? '+' : fields[6][0]);
#         std::string name = parse_cds_name(fields[8]);
#         CDSFeature f;
#         f.name = name;
#         f.start0 = start - 1;
#         f.end0   = end   - 1;
#         f.strand = strand;
#         cds.push_back(f);
#     }
#     return cds;
# }
# 
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         case 'T': return 'A';
#         default:  return 'N';
#     }
# }
# 
# static std::string revcomp(const std::string &s) {
#     std::string out;
#     out.reserve(s.size());
#     for (int i = (int)s.size() - 1; i >= 0; --i) {
#         out.push_back(comp_base(s[i]));
#     }
#     return out;
# }
# 
# // ---------- main -----------
# 
# int main() {
#     const std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     const std::string gff_path   = "/content/ecoli_U00096_3.gff";
# 
#     std::printf("======================================================================================================================\n");
#     std::printf("MODULE DNA-L20 — CODON-BOUNDARY CpG BRIDGES vs GC3 LOCKS (E. coli MG1655, CDS-level)\n");
#     std::printf("======================================================================================================================\n\n");
# 
#     std::printf("[DNA-L20] FASTA path: %s\n", fasta_path.c_str());
#     std::printf("[DNA-L20] GFF path  : %s\n\n", gff_path.c_str());
# 
#     std::string genome = read_fasta(fasta_path);
#     if (genome.empty()) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", fasta_path.c_str());
#         return 1;
#     }
#     std::printf("Genome loaded: length = %zu bases\n", genome.size());
# 
#     std::vector<CDSFeature> cds = read_gff_cds(gff_path);
#     if (cds.empty()) {
#         std::fprintf(stderr, "ERROR: could not load CDS from GFF %s\n", gff_path.c_str());
#         return 1;
#     }
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     std::vector<BridgeStats> genes;
#     genes.reserve(cds.size());
# 
#     long sum_codons = 0;
#     long sum_gc3_codons = 0;
#     long sum_c3_codons = 0;
#     long sum_cpg = 0;
#     long sum_bridge = 0;
# 
#     double sum_gc3_frac = 0.0, sum_gc3_frac2 = 0.0;
#     double sum_c3_frac  = 0.0, sum_c3_frac2  = 0.0;
#     double sum_cpg_kb   = 0.0, sum_cpg_kb2   = 0.0;
#     double sum_bridge_kb= 0.0, sum_bridge_kb2= 0.0;
#     double sum_bridge_share_cpg = 0.0, sum_bridge_share_cpg2 = 0.0;
# 
#     int n_genes = 0;
#     int n_skipped_len = 0;
#     int n_skipped_ambig = 0;
# 
#     for (const CDSFeature &f : cds) {
#         if (f.start0 < 0 || f.end0 >= (int)genome.size() || f.end0 < f.start0) continue;
#         int len = f.end0 - f.start0 + 1;
#         if (len <= 0) continue;
# 
#         std::string seq = genome.substr(f.start0, len);
#         for (char &c : seq) c = std::toupper((unsigned char)c);
#         if (f.strand == '-') seq = revcomp(seq);
# 
#         if (seq.size() % 3 != 0) {
#             ++n_skipped_len;
#             continue;
#         }
#         int codons = seq.size() / 3;
#         if (codons <= 0) {
#             ++n_skipped_len;
#             continue;
#         }
# 
#         // Check ambiguous bases
#         if (seq.find_first_not_of("ACGT") != std::string::npos) {
#             ++n_skipped_ambig;
#             continue;
#         }
# 
#         int gc3_codons = 0;
#         int c3_codons  = 0;
# 
#         for (int i = 0; i < codons; ++i) {
#             char b3 = seq[i*3 + 2];
#             if (b3 == 'G' || b3 == 'C') {
#                 ++gc3_codons;
#             }
#             if (b3 == 'C') {
#                 ++c3_codons;
#             }
#         }
# 
#         int total_cpg = 0;
#         int bridge_cpg = 0;
# 
#         for (int i = 0; i < (int)seq.size() - 1; ++i) {
#             if (seq[i] == 'C' && seq[i+1] == 'G') {
#                 ++total_cpg;
#                 int codon_idx = i / 3;
#                 int pos_in_codon = i % 3;
#                 if (pos_in_codon == 2 && codon_idx + 1 < codons) {
#                     // C at pos3 of codon_idx, G at pos1 of codon_idx+1
#                     ++bridge_cpg;
#                 }
#             }
#         }
# 
#         double gc3_frac = (double)gc3_codons / (double)codons;
#         double c3_frac  = (double)c3_codons  / (double)codons;
#         double cpg_per_kb    = (len > 1) ? (double)total_cpg   * 1000.0 / (double)(len - 1) : 0.0;
#         double bridge_per_kb = (len > 1) ? (double)bridge_cpg  * 1000.0 / (double)(len - 1) : 0.0;
#         double bridge_share_cpg = (total_cpg > 0) ? (double)bridge_cpg / (double)total_cpg : 0.0;
#         double bridge_share_c3  = (c3_codons > 0) ? (double)bridge_cpg / (double)c3_codons : 0.0;
# 
#         BridgeStats g;
#         g.name = f.name;
#         g.start0 = f.start0;
#         g.end0   = f.end0;
#         g.strand = f.strand;
#         g.length = len;
#         g.codons = codons;
#         g.gc3_codons = gc3_codons;
#         g.c3_codons  = c3_codons;
#         g.total_cpg  = total_cpg;
#         g.bridge_cpg = bridge_cpg;
#         g.gc3_frac   = gc3_frac;
#         g.c3_frac    = c3_frac;
#         g.cpg_per_kb = cpg_per_kb;
#         g.bridge_per_kb = bridge_per_kb;
#         g.bridge_share_cpg = bridge_share_cpg;
#         g.bridge_share_c3  = bridge_share_c3;
# 
#         genes.push_back(g);
#         ++n_genes;
# 
#         sum_codons      += codons;
#         sum_gc3_codons  += gc3_codons;
#         sum_c3_codons   += c3_codons;
#         sum_cpg         += total_cpg;
#         sum_bridge      += bridge_cpg;
# 
#         sum_gc3_frac    += gc3_frac;
#         sum_gc3_frac2   += gc3_frac * gc3_frac;
#         sum_c3_frac     += c3_frac;
#         sum_c3_frac2    += c3_frac * c3_frac;
#         sum_cpg_kb      += cpg_per_kb;
#         sum_cpg_kb2     += cpg_per_kb * cpg_per_kb;
#         sum_bridge_kb   += bridge_per_kb;
#         sum_bridge_kb2  += bridge_per_kb * bridge_per_kb;
#         sum_bridge_share_cpg  += bridge_share_cpg;
#         sum_bridge_share_cpg2 += bridge_share_cpg * bridge_share_cpg;
#     }
# 
#     std::printf("=====================================================================================\n");
#     std::printf("CODON-BOUNDARY CpG BRIDGES vs GC3 LOCKS — E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n\n");
# 
#     std::printf("CDS summary:\n");
#     std::printf("  CDS features in GFF            : %zu\n", cds.size());
#     std::printf("  CDS analyzed (valid)           : %d\n", n_genes);
#     std::printf("  CDS skipped (len %% 3 != 0)     : %d\n", n_skipped_len);
#     std::printf("  CDS skipped (ambiguous bases)  : %d\n\n", n_skipped_ambig);
# 
#     if (n_genes == 0) {
#         std::printf("No valid CDS; exiting.\n");
#         return 0;
#     }
# 
#     double mean_gc3 = sum_gc3_frac / n_genes;
#     double mean_c3  = sum_c3_frac  / n_genes;
#     double mean_cpg_kb = sum_cpg_kb / n_genes;
#     double mean_bridge_kb = sum_bridge_kb / n_genes;
#     double mean_bridge_share_cpg = sum_bridge_share_cpg / n_genes;
# 
#     double sd_gc3 = 0.0, sd_c3 = 0.0, sd_cpg_kb = 0.0, sd_bridge_kb = 0.0, sd_bridge_share_cpg = 0.0;
# 
#     if (n_genes > 1) {
#         sd_gc3 = std::sqrt(std::max(0.0,
#             (sum_gc3_frac2 / n_genes) - mean_gc3 * mean_gc3));
#         sd_c3  = std::sqrt(std::max(0.0,
#             (sum_c3_frac2 / n_genes) - mean_c3 * mean_c3));
#         sd_cpg_kb = std::sqrt(std::max(0.0,
#             (sum_cpg_kb2 / n_genes) - mean_cpg_kb * mean_cpg_kb));
#         sd_bridge_kb = std::sqrt(std::max(0.0,
#             (sum_bridge_kb2 / n_genes) - mean_bridge_kb * mean_bridge_kb));
#         sd_bridge_share_cpg = std::sqrt(std::max(0.0,
#             (sum_bridge_share_cpg2 / n_genes) - mean_bridge_share_cpg * mean_bridge_share_cpg));
#     }
# 
#     std::printf("--- Global bridge vs GC3 stats ---\n");
#     std::printf("  Sum codons                : %ld\n", sum_codons);
#     std::printf("  Sum GC3 codons            : %ld (GC3_frac=%.4f)\n",
#                 sum_gc3_codons, (double)sum_gc3_codons / (double)sum_codons);
#     std::printf("  Sum C3 codons             : %ld (C3_frac=%.4f)\n",
#                 sum_c3_codons, (double)sum_c3_codons / (double)sum_codons);
#     std::printf("  Total CpG dinucleotides   : %ld\n", sum_cpg);
#     std::printf("  Total bridge CpG (3->1)   : %ld\n", sum_bridge);
#     std::printf("  Bridge share of all CpG   : %.4f\n",
#                 (sum_cpg > 0) ? (double)sum_bridge / (double)sum_cpg : 0.0);
#     std::printf("\n");
# 
#     std::printf("  GC3_frac per CDS          : mean=%.4f, sd=%.4f\n", mean_gc3, sd_gc3);
#     std::printf("  C3_frac per CDS           : mean=%.4f, sd=%.4f\n", mean_c3, sd_c3);
#     std::printf("  CpG_per_kb per CDS        : mean=%.4f, sd=%.4f\n", mean_cpg_kb, sd_cpg_kb);
#     std::printf("  bridge_per_kb per CDS     : mean=%.4f, sd=%.4f\n", mean_bridge_kb, sd_bridge_kb);
#     std::printf("  bridge_share_CpG per CDS  : mean=%.4f, sd=%.4f\n\n",
#                 mean_bridge_share_cpg, sd_bridge_share_cpg);
# 
#     // Top genes by bridge_per_kb
#     std::vector<BridgeStats> by_bridge = genes;
#     std::sort(by_bridge.begin(), by_bridge.end(),
#               [](const BridgeStats &a, const BridgeStats &b) {
#                   if (a.bridge_per_kb != b.bridge_per_kb)
#                       return a.bridge_per_kb > b.bridge_per_kb;
#                   return a.cpg_per_kb > b.cpg_per_kb;
#               });
# 
#     int topN = std::min<int>(10, (int)by_bridge.size());
#     std::printf("--- Top 10 genes by CpG bridges per kb ---\n");
#     for (int i = 0; i < topN; ++i) {
#         const auto &g = by_bridge[i];
#         std::printf("  [%2d] %-10s | len=%4d codons=%4d | GC3=%.4f | CpG/kb=%.2f | bridge/kb=%.2f | bridge_share_CpG=%.3f\n",
#                     i+1, g.name.c_str(), g.length, g.codons,
#                     g.gc3_frac, g.cpg_per_kb, g.bridge_per_kb, g.bridge_share_cpg);
#     }
# 
#     std::printf("\n");
#     std::printf("CODON-BOUNDARY CpG BRIDGES vs GC3 LOCKS analysis finished.\n");
#     std::printf("=====================================================================================\n");
# 
#     return 0;
# }
# CPP
# 
# echo "[DNA-L20] Compiling CpG bridge vs GC3 module (CPU-only)..."
# nvcc -O3 -std=c++17 warpfrac_dna_cpg_bridges_gc3.cu -o warpfrac_dna_cpg_bridges_gc3
# 
# echo
# echo "----------------------------------------------------------------------------------------------------------------------"
# echo "RUNNING DNA-L20 — CODON-BOUNDARY CpG BRIDGES vs GC3 LOCKS (CPU-only)"
# echo "----------------------------------------------------------------------------------------------------------------------"
# 
# ./warpfrac_dna_cpg_bridges_gc3 | tee DNA-L20_cpg_bridges_gc3.out
# 
# echo
# echo "[DNA-L20] SHA256(stdout) ="
# sha256sum DNA-L20_cpg_bridges_gc3.out
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_cpg_bridge_gc3_coupling.cu << 'CPP'
# // warpfrac_dna_cpg_bridge_gc3_coupling.cu
# // DNA-L21 — GC3–BRIDGE COUPLING & OUTLIERS (CPU-only)
# //
# // For each CDS (len % 3 == 0, clean A/C/G/T) we compute:
# //   • GC3_frac       = (#codons with G/C at 3rd base) / codons
# //   • C3_frac        = (#codons with C at 3rd base) / codons
# //   • CpG_total      = total 'CG' dinucleotides inside CDS
# //   • CpG_bridge     = 'CG' that cross a codon boundary (3rd->1st base)
# //   • CpG_per_kb     = CpG_total * 1000 / (len-1)
# //   • bridge_per_kb  = CpG_bridge * 1000 / (len-1)
# //   • bridge_share   = CpG_bridge / CpG_total  (0 if CpG_total==0)
# //
# // Then we:
# //   • Summarize global bridge vs GC3 stats.
# //   • Compute per-CDS means/SDs and Pearson correlations:
# //       corr(GC3, bridge_per_kb), corr(GC3, bridge_share),
# //       corr(CpG_per_kb, bridge_share).
# //   • Identify:
# //       - GC3-hyper genes with low bridge_share (GC3 >> bridges).
# //       - bridge-hyper genes with modest GC3 (bridges >> GC3).
# //   • Print detailed stats for a focus set of loci (yag*, phn*, etc.).
# //
# // CPU-only: compiled with nvcc as C++17 but no CUDA kernels.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# #include <unordered_map>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# struct GeneStats {
#     std::string name;
#     int length;
#     long codons;
#     long gc3_codons;
#     long c3_codons;
#     long cpg_total;
#     long cpg_bridge;
# 
#     double gc3_frac;
#     double c3_frac;
#     double cpg_per_kb;
#     double bridge_per_kb;
#     double bridge_share; // fraction of CpG that are bridges
# 
#     double z_gc3;
#     double z_bridge_share;
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     std::string seq;
#     seq.reserve(5000000);
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (!std::isalpha((unsigned char)c)) continue;
#             char u = std::toupper((unsigned char)c);
#             if (u == 'A' || u == 'C' || u == 'G' || u == 'T' || u == 'N')
#                 seq.push_back(u);
#         }
#     }
#     return seq;
# }
# 
# static std::string extract_attr_value(const std::string &attr, const std::string &key) {
#     std::string token = key + "=";
#     size_t pos = attr.find(token);
#     if (pos == std::string::npos) return "";
#     pos += token.size();
#     size_t end = pos;
#     while (end < attr.size() && attr[end] != ';' && !std::isspace((unsigned char)attr[end])) {
#         ++end;
#     }
#     return attr.substr(pos, end - pos);
# }
# 
# static std::string choose_name(const std::string &attr,
#                                const std::string &seqid,
#                                const std::string &start,
#                                const std::string &end) {
#     const char* keys[] = {"gene", "locus_tag", "Name", "ID", "protein_id"};
#     for (const char* k : keys) {
#         std::string val = extract_attr_value(attr, k);
#         if (!val.empty()) return val;
#     }
#     // Fallback: synthetic name
#     return seqid + ":" + start + "-" + end;
# }
# 
# static std::vector<CDSFeature> load_cds(const std::string &gff_path) {
#     std::ifstream in(gff_path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", gff_path.c_str());
#         std::exit(1);
#     }
#     std::vector<CDSFeature> cds;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string cols[9];
#         int col_idx = 0;
#         while (col_idx < 9 && std::getline(ss, cols[col_idx], '\t')) {
#             ++col_idx;
#         }
#         if (col_idx < 9) continue;
#         if (cols[2] != "CDS") continue;
#         int start = std::atoi(cols[3].c_str());
#         int end   = std::atoi(cols[4].c_str());
#         if (start <= 0 || end <= 0) continue;
#         char strand = cols[6].empty() ? '+' : cols[6][0];
#         std::string name = choose_name(cols[8], cols[0], cols[3], cols[4]);
# 
#         CDSFeature f;
#         if (start <= end) {
#             f.start0 = start - 1;
#             f.end0   = end   - 1;
#         } else {
#             f.start0 = end   - 1;
#             f.end0   = start - 1;
#         }
#         f.strand = strand;
#         f.name   = name;
#         cds.push_back(f);
#     }
#     return cds;
# }
# 
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'T': return 'A';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         default:  return 'N';
#     }
# }
# 
# static void mean_sd(const std::vector<double> &v, double &mean, double &sd) {
#     if (v.empty()) {
#         mean = sd = 0.0;
#         return;
#     }
#     double sum = 0.0, sum2 = 0.0;
#     for (double x : v) {
#         sum  += x;
#         sum2 += x * x;
#     }
#     double n = (double)v.size();
#     mean = sum / n;
#     double var = sum2 / n - mean * mean;
#     if (var < 0.0) var = 0.0;
#     sd = std::sqrt(var);
# }
# 
# static double pearson(const std::vector<double> &x, const std::vector<double> &y) {
#     size_t n = x.size();
#     if (n == 0 || y.size() != n) return 0.0;
#     double sumx = 0.0, sumy = 0.0, sumx2 = 0.0, sumy2 = 0.0, sumxy = 0.0;
#     for (size_t i = 0; i < n; ++i) {
#         double a = x[i];
#         double b = y[i];
#         sumx  += a;
#         sumy  += b;
#         sumx2 += a * a;
#         sumy2 += b * b;
#         sumxy += a * b;
#     }
#     double dn = (double)n;
#     double num  = sumxy - (sumx * sumy) / dn;
#     double denx = sumx2 - (sumx * sumx) / dn;
#     double deny = sumy2 - (sumy * sumy) / dn;
#     if (denx <= 0.0 || deny <= 0.0) return 0.0;
#     return num / std::sqrt(denx * deny);
# }
# 
# int main(int argc, char** argv) {
#     std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     std::string gff_path   = "/content/ecoli_U00096_3.gff";
#     if (argc >= 3) {
#         fasta_path = argv[1];
#         gff_path   = argv[2];
#     }
# 
#     std::printf("[DNA-L21] FASTA path: %s\n", fasta_path.c_str());
#     std::printf("[DNA-L21] GFF path  : %s\n\n", gff_path.c_str());
# 
#     std::string genome = read_fasta(fasta_path);
#     if (genome.empty()) {
#         std::fprintf(stderr, "ERROR: FASTA genome sequence is empty.\n");
#         return 1;
#     }
#     std::printf("Genome loaded: length = %zu bases\n", genome.size());
# 
#     std::vector<CDSFeature> cds = load_cds(gff_path);
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     std::vector<GeneStats> genes;
#     genes.reserve(cds.size());
# 
#     int cds_lenmod3_skip = 0;
#     int cds_ambig_skip   = 0;
# 
#     long long sum_codons = 0;
#     long long sum_gc3    = 0;
#     long long sum_c3     = 0;
#     long long sum_cpg    = 0;
#     long long sum_bridge = 0;
# 
#     std::vector<double> gc3_list;
#     std::vector<double> c3_list;
#     std::vector<double> cpgkb_list;
#     std::vector<double> bridgekb_list;
#     std::vector<double> bridge_share_list;
# 
#     for (const CDSFeature &f : cds) {
#         int len = f.end0 - f.start0 + 1;
#         if (len <= 0) continue;
#         if (len % 3 != 0) {
#             ++cds_lenmod3_skip;
#             continue;
#         }
#         std::string cds_seq;
#         cds_seq.resize(len);
#         if (f.strand == '+') {
#             for (int i = 0; i < len; ++i) {
#                 char u = std::toupper((unsigned char)genome[f.start0 + i]);
#                 cds_seq[i] = u;
#             }
#         } else {
#             for (int i = 0; i < len; ++i) {
#                 char u = std::toupper((unsigned char)genome[f.end0 - i]);
#                 cds_seq[i] = comp_base(u);
#             }
#         }
# 
#         bool ambig = false;
#         for (char c : cds_seq) {
#             if (c != 'A' && c != 'C' && c != 'G' && c != 'T') {
#                 ambig = true;
#                 break;
#             }
#         }
#         if (ambig) {
#             ++cds_ambig_skip;
#             continue;
#         }
# 
#         int n_codons = len / 3;
#         if (n_codons <= 0) continue;
# 
#         long gc3_codons = 0;
#         long c3_codons  = 0;
# 
#         for (int i = 0; i < n_codons; ++i) {
#             char b3 = cds_seq[i*3 + 2];
#             if (b3 == 'G' || b3 == 'C') gc3_codons++;
#             if (b3 == 'C') c3_codons++;
#         }
# 
#         long cpg_total = 0;
#         for (int i = 0; i + 1 < len; ++i) {
#             if (cds_seq[i] == 'C' && cds_seq[i+1] == 'G') cpg_total++;
#         }
# 
#         long cpg_bridge = 0;
#         for (int i = 0; i + 1 < n_codons; ++i) {
#             char b3 = cds_seq[i*3 + 2];
#             char b1 = cds_seq[(i+1)*3];
#             if (b3 == 'C' && b1 == 'G') cpg_bridge++;
#         }
# 
#         double gc3_frac = (double)gc3_codons / (double)n_codons;
#         double c3_frac  = (double)c3_codons  / (double)n_codons;
#         double denom    = (len > 1 ? (double)(len - 1) : 1.0);
#         double cpg_per_kb    = (double)cpg_total * 1000.0 / denom;
#         double bridge_per_kb = (double)cpg_bridge * 1000.0 / denom;
#         double bridge_share  = (cpg_total > 0 ? (double)cpg_bridge / (double)cpg_total : 0.0);
# 
#         GeneStats g;
#         g.name         = f.name;
#         g.length       = len;
#         g.codons       = n_codons;
#         g.gc3_codons   = gc3_codons;
#         g.c3_codons    = c3_codons;
#         g.cpg_total    = cpg_total;
#         g.cpg_bridge   = cpg_bridge;
#         g.gc3_frac     = gc3_frac;
#         g.c3_frac      = c3_frac;
#         g.cpg_per_kb   = cpg_per_kb;
#         g.bridge_per_kb= bridge_per_kb;
#         g.bridge_share = bridge_share;
#         g.z_gc3        = 0.0;
#         g.z_bridge_share = 0.0;
# 
#         genes.push_back(g);
# 
#         sum_codons += n_codons;
#         sum_gc3    += gc3_codons;
#         sum_c3     += c3_codons;
#         sum_cpg    += cpg_total;
#         sum_bridge += cpg_bridge;
# 
#         gc3_list.push_back(gc3_frac);
#         c3_list.push_back(c3_frac);
#         cpgkb_list.push_back(cpg_per_kb);
#         bridgekb_list.push_back(bridge_per_kb);
#         bridge_share_list.push_back(bridge_share);
#     }
# 
#     std::printf("CDS summary:\n");
#     std::printf("  CDS features in GFF            : %zu\n", cds.size());
#     std::printf("  CDS analyzed (valid)           : %zu\n", genes.size());
#     std::printf("  CDS skipped (len %% 3 != 0)     : %d\n", cds_lenmod3_skip);
#     std::printf("  CDS skipped (ambiguous bases)  : %d\n\n", cds_ambig_skip);
# 
#     double gc3_mean, gc3_sd;
#     double c3_mean, c3_sd;
#     double cpgkb_mean, cpgkb_sd;
#     double bridgekb_mean, bridgekb_sd;
#     double share_mean, share_sd;
# 
#     mean_sd(gc3_list, gc3_mean, gc3_sd);
#     mean_sd(c3_list, c3_mean, c3_sd);
#     mean_sd(cpgkb_list, cpgkb_mean, cpgkb_sd);
#     mean_sd(bridgekb_list, bridgekb_mean, bridgekb_sd);
#     mean_sd(bridge_share_list, share_mean, share_sd);
# 
#     double gc3_frac_global = (sum_codons > 0 ? (double)sum_gc3 / (double)sum_codons : 0.0);
#     double c3_frac_global  = (sum_codons > 0 ? (double)sum_c3  / (double)sum_codons : 0.0);
#     double bridge_share_global = (sum_cpg > 0 ? (double)sum_bridge / (double)sum_cpg : 0.0);
# 
#     std::printf("--- Global bridge vs GC3 stats ---\n");
#     std::printf("  Sum codons                : %lld\n", sum_codons);
#     std::printf("  Sum GC3 codons            : %lld (GC3_frac=%.4f)\n", sum_gc3, gc3_frac_global);
#     std::printf("  Sum C3 codons             : %lld (C3_frac=%.4f)\n", sum_c3,  c3_frac_global);
#     std::printf("  Total CpG dinucleotides   : %lld\n", sum_cpg);
#     std::printf("  Total bridge CpG (3->1)   : %lld\n", sum_bridge);
#     std::printf("  Bridge share of all CpG   : %.4f\n\n", bridge_share_global);
# 
#     std::printf("  GC3_frac per CDS          : mean=%.4f, sd=%.4f\n", gc3_mean, gc3_sd);
#     std::printf("  C3_frac per CDS           : mean=%.4f, sd=%.4f\n", c3_mean, c3_sd);
#     std::printf("  CpG_per_kb per CDS        : mean=%.4f, sd=%.4f\n", cpgkb_mean, cpgkb_sd);
#     std::printf("  bridge_per_kb per CDS     : mean=%.4f, sd=%.4f\n", bridgekb_mean, bridgekb_sd);
#     std::printf("  bridge_share_CpG per CDS  : mean=%.4f, sd=%.4f\n\n", share_mean, share_sd);
# 
#     double corr_gc3_bridgekb   = pearson(gc3_list, bridgekb_list);
#     double corr_gc3_share      = pearson(gc3_list, bridge_share_list);
#     double corr_cpgkb_share    = pearson(cpgkb_list, bridge_share_list);
# 
#     std::printf("--- Pearson correlations (CDS-level) ---\n");
#     std::printf("  corr(GC3_frac, bridge_per_kb)   = %.4f\n", corr_gc3_bridgekb);
#     std::printf("  corr(GC3_frac, bridge_share)    = %.4f\n", corr_gc3_share);
#     std::printf("  corr(CpG_per_kb, bridge_share)  = %.4f\n\n", corr_cpgkb_share);
# 
#     // Compute z-scores for GC3 and bridge_share
#     for (auto &g : genes) {
#         g.z_gc3 = (gc3_sd > 0.0 ? (g.gc3_frac - gc3_mean) / gc3_sd : 0.0);
#         g.z_bridge_share = (share_sd > 0.0 ? (g.bridge_share - share_mean) / share_sd : 0.0);
#     }
# 
#     // Outlier sets
#     std::vector<size_t> gc3_high_bridge_low;
#     std::vector<size_t> bridge_high_gc3_modest;
# 
#     for (size_t i = 0; i < genes.size(); ++i) {
#         const auto &g = genes[i];
#         // GC3-high, under-bridged
#         if (g.z_gc3 >= 2.5 && g.z_bridge_share <= -0.5) {
#             gc3_high_bridge_low.push_back(i);
#         }
#         // bridge-high, GC3 not particularly extreme
#         if (g.z_bridge_share >= 2.0 && g.z_gc3 <= 0.5) {
#             bridge_high_gc3_modest.push_back(i);
#         }
#     }
# 
#     std::sort(gc3_high_bridge_low.begin(), gc3_high_bridge_low.end(),
#               [&](size_t a, size_t b) {
#                   return genes[a].z_gc3 > genes[b].z_gc3;
#               });
# 
#     std::sort(bridge_high_gc3_modest.begin(), bridge_high_gc3_modest.end(),
#               [&](size_t a, size_t b) {
#                   return genes[a].z_bridge_share > genes[b].z_bridge_share;
#               });
# 
#     std::printf("--- Genes where GC3 lock >> CpG bridges (high z(GC3), low z(bridge_share)) ---\n");
#     if (gc3_high_bridge_low.empty()) {
#         std::printf("  (none above chosen z-thresholds)\n\n");
#     } else {
#         size_t limit = std::min<size_t>(10, gc3_high_bridge_low.size());
#         for (size_t k = 0; k < limit; ++k) {
#             const auto &g = genes[gc3_high_bridge_low[k]];
#             std::printf("  [%2zu] %-10s | codons=%4ld | GC3=%.4f (z=%.2f) | bridge_share=%.3f (z=%.2f) | CpG/kb=%.2f | bridge/kb=%.2f\n",
#                         k+1, g.name.c_str(), g.codons,
#                         g.gc3_frac, g.z_gc3,
#                         g.bridge_share, g.z_bridge_share,
#                         g.cpg_per_kb, g.bridge_per_kb);
#         }
#         std::printf("\n");
#     }
# 
#     std::printf("--- Genes where CpG bridges >> GC3 lock (high z(bridge_share), modest z(GC3)) ---\n");
#     if (bridge_high_gc3_modest.empty()) {
#         std::printf("  (none above chosen z-thresholds)\n\n");
#     } else {
#         size_t limit = std::min<size_t>(10, bridge_high_gc3_modest.size());
#         for (size_t k = 0; k < limit; ++k) {
#             const auto &g = genes[bridge_high_gc3_modest[k]];
#             std::printf("  [%2zu] %-10s | codons=%4ld | GC3=%.4f (z=%.2f) | bridge_share=%.3f (z=%.2f) | CpG/kb=%.2f | bridge/kb=%.2f\n",
#                         k+1, g.name.c_str(), g.codons,
#                         g.gc3_frac, g.z_gc3,
#                         g.bridge_share, g.z_bridge_share,
#                         g.cpg_per_kb, g.bridge_per_kb);
#         }
#         std::printf("\n");
#     }
# 
#     // Focus loci
#     std::unordered_map<std::string, size_t> index_by_name;
#     for (size_t i = 0; i < genes.size(); ++i) {
#         // If duplicates, keep first occurrence
#         if (!index_by_name.count(genes[i].name)) {
#             index_by_name[genes[i].name] = i;
#         }
#     }
# 
#     const char* focus_names[] = {
#         "yagA","yagE","yagF","yagG","yagH",
#         "rhsD","mdtB","mdtC","mutS",
#         "phnD","phnK","phnM","phnI",
#         "nikB","nikC",
#         "phnG","phnL"
#     };
# 
#     std::printf("--- Bridge vs GC3 for selected loci (by gene name) ---\n");
#     for (const char* fname : focus_names) {
#         auto it = index_by_name.find(fname);
#         if (it == index_by_name.end()) {
#             std::printf("  [%s] not found in CDS set.\n", fname);
#         } else {
#             const auto &g = genes[it->second];
#             std::printf("  [%s]\n", fname);
#             std::printf("    length          : %d\n", g.length);
#             std::printf("    codons          : %ld\n", g.codons);
#             std::printf("    GC3_frac        : %.4f (z=%.2f)\n", g.gc3_frac, g.z_gc3);
#             std::printf("    CpG_per_kb      : %.2f\n", g.cpg_per_kb);
#             std::printf("    bridge_per_kb   : %.2f\n", g.bridge_per_kb);
#             std::printf("    bridge_share    : %.3f (z=%.2f)\n", g.bridge_share, g.z_bridge_share);
#         }
#     }
# 
#     std::printf("\nCODON-BOUNDARY CpG BRIDGES vs GC3 LOCKS (COUPLING) analysis finished.\n");
#     std::printf("=====================================================================================\n");
# 
#     return 0;
# }
# CPP
# 
# nvcc -O3 -std=c++17 warpfrac_dna_cpg_bridge_gc3_coupling.cu -o warpfrac_dna_cpg_bridge_gc3_coupling
# 
# ./warpfrac_dna_cpg_bridge_gc3_coupling /content/ecoli_U00096_3.fna /content/ecoli_U00096_3.gff | tee DNA-L21_cpg_bridge_gc3_coupling.out
# 
# echo
# echo "[DNA-L21] SHA256(stdout) ="
# sha256sum DNA-L21_cpg_bridge_gc3_coupling.out
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_gc3_lock_islands.cu << 'CPP'
# // warpfrac_dna_gc3_lock_islands.cu
# // DNA-L22 — GC3 LOCK ISLANDS (operon-scale clusters, CDS-level, CPU-only)
# //
# // For each CDS (len % 3 == 0, clean A/C/G/T) we compute:
# //   • GC3_frac      = (#codons with G/C at 3rd base) / codons
# //   • GC_frac       = (#G/#C in CDS) / length
# //   • CpG_total     = # 'CG' dinucleotides inside CDS
# //   • CpG_per_kb    = CpG_total * 1000 / (len-1)
# //
# // Then we:
# //   • Compute GC3 mean/sd over CDS and define a "hyper-GC3" threshold:
# //        GC3_thresh = mean + 2*sd.
# //   • Sort genes by genomic coordinate.
# //   • Build "lock islands":
# //        - consecutive genes,
# //        - same strand,
# //        - each with GC3_frac >= GC3_thresh,
# //        - and gaps between CDSs <= max_gap_bp (here 300 bp).
# //   • Report:
# //        - global GC3 distribution and threshold,
# //        - counts / sizes of islands,
# //        - top islands by mean GC3 (and length),
# //        - membership of a focus set (yag*, phn*, nik*, etc.).
# //
# // CPU-only: compiled with nvcc as C++17 program, but no CUDA kernels.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# #include <unordered_map>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# struct GeneStats {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;
# 
#     int length;
#     long codons;
#     long gc_bases;
#     long gc3_codons;
#     long cpg_total;
# 
#     double gc_frac;
#     double gc3_frac;
#     double cpg_per_kb;
# 
#     double z_gc3;
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     std::string seq;
#     seq.reserve(5000000);
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (!std::isalpha((unsigned char)c)) continue;
#             char u = std::toupper((unsigned char)c);
#             if (u == 'A' || u == 'C' || u == 'G' || u == 'T' || u == 'N')
#                 seq.push_back(u);
#         }
#     }
#     return seq;
# }
# 
# static std::string extract_attr_value(const std::string &attr, const std::string &key) {
#     std::string token = key + "=";
#     size_t pos = attr.find(token);
#     if (pos == std::string::npos) return "";
#     pos += token.size();
#     size_t end = pos;
#     while (end < attr.size() && attr[end] != ';' && !std::isspace((unsigned char)attr[end])) {
#         ++end;
#     }
#     return attr.substr(pos, end - pos);
# }
# 
# static std::string choose_name(const std::string &attr,
#                                const std::string &seqid,
#                                const std::string &start,
#                                const std::string &end) {
#     const char* keys[] = {"gene", "locus_tag", "Name", "ID", "protein_id"};
#     for (const char* k : keys) {
#         std::string val = extract_attr_value(attr, k);
#         if (!val.empty()) return val;
#     }
#     return seqid + ":" + start + "-" + end;
# }
# 
# static std::vector<CDSFeature> load_cds(const std::string &gff_path) {
#     std::ifstream in(gff_path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", gff_path.c_str());
#         std::exit(1);
#     }
#     std::vector<CDSFeature> cds;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string cols[9];
#         int col_idx = 0;
#         while (col_idx < 9 && std::getline(ss, cols[col_idx], '\t')) {
#             ++col_idx;
#         }
#         if (col_idx < 9) continue;
#         if (cols[2] != "CDS") continue;
#         int start = std::atoi(cols[3].c_str());
#         int end   = std::atoi(cols[4].c_str());
#         if (start <= 0 || end <= 0) continue;
#         char strand = cols[6].empty() ? '+' : cols[6][0];
#         std::string name = choose_name(cols[8], cols[0], cols[3], cols[4]);
# 
#         CDSFeature f;
#         if (start <= end) {
#             f.start0 = start - 1;
#             f.end0   = end   - 1;
#         } else {
#             f.start0 = end   - 1;
#             f.end0   = start - 1;
#         }
#         f.strand = strand;
#         f.name   = name;
#         cds.push_back(f);
#     }
#     return cds;
# }
# 
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'T': return 'A';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         default:  return 'N';
#     }
# }
# 
# static void mean_sd(const std::vector<double> &v, double &mean, double &sd) {
#     if (v.empty()) {
#         mean = sd = 0.0;
#         return;
#     }
#     double sum = 0.0, sum2 = 0.0;
#     for (double x : v) {
#         sum  += x;
#         sum2 += x * x;
#     }
#     double n = (double)v.size();
#     mean = sum / n;
#     double var = sum2 / n - mean * mean;
#     if (var < 0.0) var = 0.0;
#     sd = std::sqrt(var);
# }
# 
# int main(int argc, char** argv) {
#     std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     std::string gff_path   = "/content/ecoli_U00096_3.gff";
#     if (argc >= 3) {
#         fasta_path = argv[1];
#         gff_path   = argv[2];
#     }
# 
#     std::printf("[DNA-L22] FASTA path: %s\n", fasta_path.c_str());
#     std::printf("[DNA-L22] GFF path  : %s\n\n", gff_path.c_str());
# 
#     std::string genome = read_fasta(fasta_path);
#     if (genome.empty()) {
#         std::fprintf(stderr, "ERROR: FASTA genome sequence is empty.\n");
#         return 1;
#     }
#     std::printf("Genome loaded: length = %zu bases\n", genome.size());
# 
#     std::vector<CDSFeature> cds = load_cds(gff_path);
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     std::vector<GeneStats> genes;
#     genes.reserve(cds.size());
# 
#     int cds_lenmod3_skip = 0;
#     int cds_ambig_skip   = 0;
# 
#     long long sum_len    = 0;
#     long long sum_codons = 0;
#     long long sum_gc3    = 0;
#     long long sum_gc     = 0;
#     long long sum_cpg    = 0;
# 
#     std::vector<double> gc3_list;
# 
#     for (const CDSFeature &f : cds) {
#         int len = f.end0 - f.start0 + 1;
#         if (len <= 0) continue;
#         if (len % 3 != 0) {
#             ++cds_lenmod3_skip;
#             continue;
#         }
# 
#         std::string cds_seq;
#         cds_seq.resize(len);
#         if (f.strand == '+') {
#             for (int i = 0; i < len; ++i) {
#                 char u = std::toupper((unsigned char)genome[f.start0 + i]);
#                 cds_seq[i] = u;
#             }
#         } else {
#             for (int i = 0; i < len; ++i) {
#                 char u = std::toupper((unsigned char)genome[f.end0 - i]);
#                 cds_seq[i] = comp_base(u);
#             }
#         }
# 
#         bool ambig = false;
#         for (char c : cds_seq) {
#             if (c != 'A' && c != 'C' && c != 'G' && c != 'T') {
#                 ambig = true;
#                 break;
#             }
#         }
#         if (ambig) {
#             ++cds_ambig_skip;
#             continue;
#         }
# 
#         int n_codons = len / 3;
#         if (n_codons <= 0) continue;
# 
#         long gc3_codons = 0;
#         long gc_bases   = 0;
#         long cpg_total  = 0;
# 
#         for (int i = 0; i < n_codons; ++i) {
#             char b3 = cds_seq[i*3 + 2];
#             if (b3 == 'G' || b3 == 'C') gc3_codons++;
#         }
#         for (int i = 0; i < len; ++i) {
#             char b = cds_seq[i];
#             if (b == 'G' || b == 'C') gc_bases++;
#             if (i + 1 < len && b == 'C' && cds_seq[i+1] == 'G') cpg_total++;
#         }
# 
#         double gc3_frac = (double)gc3_codons / (double)n_codons;
#         double gc_frac  = (double)gc_bases / (double)len;
#         double denom    = (len > 1 ? (double)(len - 1) : 1.0);
#         double cpg_per_kb = (double)cpg_total * 1000.0 / denom;
# 
#         GeneStats g;
#         g.name        = f.name;
#         g.start0      = f.start0;
#         g.end0        = f.end0;
#         g.strand      = f.strand;
#         g.length      = len;
#         g.codons      = n_codons;
#         g.gc_bases    = gc_bases;
#         g.gc3_codons  = gc3_codons;
#         g.cpg_total   = cpg_total;
#         g.gc_frac     = gc_frac;
#         g.gc3_frac    = gc3_frac;
#         g.cpg_per_kb  = cpg_per_kb;
#         g.z_gc3       = 0.0;
# 
#         genes.push_back(g);
# 
#         sum_len    += len;
#         sum_codons += n_codons;
#         sum_gc3    += gc3_codons;
#         sum_gc     += gc_bases;
#         sum_cpg    += cpg_total;
# 
#         gc3_list.push_back(gc3_frac);
#     }
# 
#     std::printf("CDS summary:\n");
#     std::printf("  CDS features in GFF            : %zu\n", cds.size());
#     std::printf("  CDS analyzed (valid)           : %zu\n", genes.size());
#     std::printf("  CDS skipped (len %% 3 != 0)     : %d\n", cds_lenmod3_skip);
#     std::printf("  CDS skipped (ambiguous bases)  : %d\n\n", cds_ambig_skip);
# 
#     double gc3_mean, gc3_sd;
#     mean_sd(gc3_list, gc3_mean, gc3_sd);
#     double gc_frac_global = (sum_len > 0 ? (double)sum_gc / (double)sum_len : 0.0);
#     double gc3_frac_global = (sum_codons > 0 ? (double)sum_gc3 / (double)sum_codons : 0.0);
#     double cpg_per_kb_global = (sum_len > 1 ? (double)sum_cpg * 1000.0 / (double)(sum_len - 1) : 0.0);
# 
#     double gc3_thresh = gc3_mean + 2.0 * gc3_sd;
# 
#     std::printf("--- Global GC and GC3 lock stats (CDS-level) ---\n");
#     std::printf("  Sum CDS length           : %lld bases\n", sum_len);
#     std::printf("  Sum codons               : %lld\n", sum_codons);
#     std::printf("  Total GC bases           : %lld (GC_frac_global=%.4f)\n", sum_gc, gc_frac_global);
#     std::printf("  Total GC3 codons         : %lld (GC3_frac_global=%.4f)\n", sum_gc3, gc3_frac_global);
#     std::printf("  Total CpG dinucleotides  : %lld (CpG_per_kb_global=%.2f)\n", sum_cpg, cpg_per_kb_global);
#     std::printf("\n");
#     std::printf("  GC3_frac per CDS         : mean=%.4f, sd=%.4f\n", gc3_mean, gc3_sd);
#     std::printf("  Hyper-GC3 threshold      : %.4f (mean+2*sd)\n\n", gc3_thresh);
# 
#     // Compute z-scores and count hyper-GC3
#     int n_hyper = 0;
#     for (auto &g : genes) {
#         g.z_gc3 = (gc3_sd > 0.0 ? (g.gc3_frac - gc3_mean) / gc3_sd : 0.0);
#         if (g.gc3_frac >= gc3_thresh) ++n_hyper;
#     }
#     std::printf("  Hyper-GC3 genes (GC3 >= thr): %d / %zu\n\n", n_hyper, genes.size());
# 
#     // Sort genes by coordinate (single chromosome assumed)
#     std::sort(genes.begin(), genes.end(),
#               [](const GeneStats &a, const GeneStats &b) {
#                   if (a.start0 != b.start0) return a.start0 < b.start0;
#                   if (a.end0 != b.end0)     return a.end0 < b.end0;
#                   return a.name < b.name;
#               });
# 
#     // Build islands: consecutive high-GC3, same strand, gap <= max_gap_bp
#     const int max_gap_bp = 300;
#     struct Island {
#         int idx_start;  // index in 'genes'
#         int idx_end;    // inclusive
#         char strand;
#         int start0;
#         int end0;
#         int n_genes;
#         double mean_gc3;
#         double mean_gc;
#         double mean_cpgkb;
#     };
# 
#     std::vector<Island> islands;
#     int N = (int)genes.size();
# 
#     int i = 0;
#     while (i < N) {
#         if (genes[i].gc3_frac < gc3_thresh) {
#             ++i;
#             continue;
#         }
#         int island_start = i;
#         int island_end   = i;
#         char strand      = genes[i].strand;
#         int cur_end0     = genes[i].end0;
# 
#         ++i;
#         while (i < N) {
#             if (genes[i].gc3_frac < gc3_thresh) break;
#             if (genes[i].strand != strand) break;
#             int gap = genes[i].start0 - cur_end0 - 1; // could be negative if overlapping
#             if (gap > max_gap_bp) break;
#             island_end = i;
#             cur_end0 = genes[i].end0;
#             ++i;
#         }
# 
#         if (island_end > island_start) {
#             Island isl;
#             isl.idx_start = island_start;
#             isl.idx_end   = island_end;
#             isl.strand    = strand;
#             isl.start0    = genes[island_start].start0;
#             isl.end0      = genes[island_end].end0;
#             isl.n_genes   = island_end - island_start + 1;
# 
#             double sum_gc3_isl = 0.0;
#             double sum_gc_isl  = 0.0;
#             double sum_cpgkb_isl = 0.0;
#             int    n_isl       = isl.n_genes;
# 
#             for (int j = island_start; j <= island_end; ++j) {
#                 sum_gc3_isl   += genes[j].gc3_frac;
#                 sum_gc_isl    += genes[j].gc_frac;
#                 sum_cpgkb_isl += genes[j].cpg_per_kb;
#             }
#             isl.mean_gc3   = sum_gc3_isl   / (double)n_isl;
#             isl.mean_gc    = sum_gc_isl    / (double)n_isl;
#             isl.mean_cpgkb = sum_cpgkb_isl / (double)n_isl;
# 
#             islands.push_back(isl);
#         }
#     }
# 
#     std::printf("--- GC3 lock islands (operon-scale) ---\n");
#     std::printf("  max_gap between CDS in island : %d bp\n", max_gap_bp);
#     std::printf("  Islands with >=2 hyper-GC3 genes : %zu\n\n", islands.size());
# 
#     if (!islands.empty()) {
#         std::vector<int> order(islands.size());
#         for (size_t k = 0; k < islands.size(); ++k) order[k] = (int)k;
#         std::sort(order.begin(), order.end(),
#                   [&](int a, int b) {
#                       if (islands[a].mean_gc3 != islands[b].mean_gc3)
#                           return islands[a].mean_gc3 > islands[b].mean_gc3;
#                       return islands[a].n_genes > islands[b].n_genes;
#                   });
# 
#         std::printf("--- Top GC3 lock islands ---\n");
#         size_t limit = std::min<size_t>(10, islands.size());
#         for (size_t r = 0; r < limit; ++r) {
#             const Island &isl = islands[order[r]];
#             std::printf("[ISLAND %2zu] strand=%c | genes=%d | coords=%d-%d\n",
#                         r+1, isl.strand, isl.n_genes, isl.start0, isl.end0);
#             std::printf("  mean GC3=%.4f | mean GC=%.4f | mean CpG/kb=%.2f\n",
#                         isl.mean_gc3, isl.mean_gc, isl.mean_cpgkb);
#             std::printf("  members:\n");
#             for (int j = isl.idx_start; j <= isl.idx_end; ++j) {
#                 const auto &g = genes[j];
#                 std::printf("    %-10s | GC3=%.4f (z=%.2f) | GC=%.4f | CpG/kb=%.2f | len=%d\n",
#                             g.name.c_str(), g.gc3_frac, g.z_gc3, g.gc_frac, g.cpg_per_kb, g.length);
#             }
#             std::printf("\n");
#         }
#     } else {
#         std::printf("  (no multi-gene GC3 lock islands found at this threshold)\n\n");
#     }
# 
#     // Map gene name -> index for convenience
#     std::unordered_map<std::string, int> index_by_name;
#     for (int idx = 0; idx < N; ++idx) {
#         if (!index_by_name.count(genes[idx].name)) {
#             index_by_name[genes[idx].name] = idx;
#         }
#     }
# 
#     const char* focus[] = {
#         "yagA","yagE","yagF","yagG","yagH",
#         "rhsD","mdtB","mdtC","mutS",
#         "phnD","phnK","phnM","phnI","phnG","phnL",
#         "nikB","nikC","ugpA","ugpE"
#     };
# 
#     std::printf("--- GC3 lock island context for selected loci ---\n");
#     for (const char* fname : focus) {
#         auto it = index_by_name.find(fname);
#         if (it == index_by_name.end()) {
#             std::printf("  [%s] not found in CDS set.\n", fname);
#             continue;
#         }
#         int idx = it->second;
#         const auto &g = genes[idx];
#         std::printf("  [%s]\n", fname);
#         std::printf("    coords       : %d-%d (strand=%c)\n", g.start0, g.end0, g.strand);
#         std::printf("    GC3_frac     : %.4f (z=%.2f)\n", g.gc3_frac, g.z_gc3);
#         std::printf("    GC_frac      : %.4f\n", g.gc_frac);
#         std::printf("    CpG_per_kb   : %.2f\n", g.cpg_per_kb);
# 
#         int island_id = -1;
#         for (size_t k = 0; k < islands.size(); ++k) {
#             if (idx >= islands[k].idx_start && idx <= islands[k].idx_end) {
#                 island_id = (int)k;
#                 break;
#             }
#         }
#         if (island_id < 0) {
#             std::printf("    island       : (not in a multi-gene lock island at current threshold)\n");
#         } else {
#             const auto &isl = islands[island_id];
#             std::printf("    island       : #%d (genes=%d, mean_GC3=%.4f, coords=%d-%d)\n",
#                         island_id+1, isl.n_genes, isl.mean_gc3, isl.start0, isl.end0);
#         }
#     }
# 
#     std::printf("\nGC3 LOCK ISLANDS analysis finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# nvcc -O3 -std=c++17 warpfrac_dna_gc3_lock_islands.cu -o warpfrac_dna_gc3_lock_islands
# 
# ./warpfrac_dna_gc3_lock_islands /content/ecoli_U00096_3.fna /content/ecoli_U00096_3.gff | tee DNA-L22_gc3_lock_islands.out
# 
# echo
# echo "[DNA-L22] SHA256(stdout) ="
# sha256sum DNA-L22_gc3_lock_islands.out
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_lock_scoreboard.cu << 'CPP'
# // warpfrac_dna_lock_scoreboard.cu
# // DNA-L23 — LOCK SCOREBOARD & HYPER-LOCK RANKING (CPU-only)
# //
# // For each CDS (len % 3 == 0, clean A/C/G/T) we compute:
# //   • GC_frac          = GC / length
# //   • GC3_frac         = (#codons with G/C at 3rd base) / codons
# //   • CpG_per_kb       = (#CG) * 1000 / (len-1)
# //   • GC_heavy_frac    = (#codons with >=2 GC bases) / codons
# //   • lock_codon_frac  = (#codons in pre-defined "lock codon" set) / codons
# //
# // Lock codon set is the 19 enriched GC3 codons from DNA-L18:
# //   TCG, TTC, GTG, CTC, GGC, CAC, CGC, CCG, CTG, TAC,
# //   ACC, TCC, GAC, GCG, GCC, TGC, TGG, ATC, GAG.
# //
# // Then we:
# //   • compute per-metric mean/sd across CDS,
# //   • assign z-scores for each metric,
# //   • define a composite lock_score:
# //       lock_score = z(GC3) + z(CpG_per_kb) + z(GC_heavy) + z(lock_frac)
# //   • print global stats, metric correlations,
# //   • print top-ranked hyper-locked genes by lock_score,
# //   • show lock scoreboard entries for a focus set (yag*, phn*, nik*, ugp*, rhsD, mdt*, mutS).
# //
# // CPU-only C++17, compiled via nvcc (no CUDA kernels).
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# #include <unordered_map>
# #include <unordered_set>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# struct GeneStats {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;
# 
#     int length;
#     long codons;
# 
#     long gc_bases;
#     long gc3_codons;
#     long cpg_total;
#     long gc_heavy_codons;
#     long lock_codons;
# 
#     double gc_frac;
#     double gc3_frac;
#     double cpg_per_kb;
#     double gc_heavy_frac;
#     double lock_frac;
# 
#     double z_gc;
#     double z_gc3;
#     double z_cpg;
#     double z_heavy;
#     double z_lock;
# 
#     double lock_score;
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     std::string seq;
#     seq.reserve(5000000);
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (!std::isalpha((unsigned char)c)) continue;
#             char u = std::toupper((unsigned char)c);
#             if (u == 'A' || u == 'C' || u == 'G' || u == 'T' || u == 'N')
#                 seq.push_back(u);
#         }
#     }
#     return seq;
# }
# 
# static std::string extract_attr_value(const std::string &attr, const std::string &key) {
#     std::string token = key + "=";
#     size_t pos = attr.find(token);
#     if (pos == std::string::npos) return "";
#     pos += token.size();
#     size_t end = pos;
#     while (end < attr.size() && attr[end] != ';' && !std::isspace((unsigned char)attr[end])) {
#         ++end;
#     }
#     return attr.substr(pos, end - pos);
# }
# 
# static std::string choose_name(const std::string &attr,
#                                const std::string &seqid,
#                                const std::string &start,
#                                const std::string &end) {
#     const char* keys[] = {"gene", "locus_tag", "Name", "ID", "protein_id"};
#     for (const char* k : keys) {
#         std::string val = extract_attr_value(attr, k);
#         if (!val.empty()) return val;
#     }
#     return seqid + ":" + start + "-" + end;
# }
# 
# static std::vector<CDSFeature> load_cds(const std::string &gff_path) {
#     std::ifstream in(gff_path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", gff_path.c_str());
#         std::exit(1);
#     }
#     std::vector<CDSFeature> cds;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string cols[9];
#         int col_idx = 0;
#         while (col_idx < 9 && std::getline(ss, cols[col_idx], '\t')) {
#             ++col_idx;
#         }
#         if (col_idx < 9) continue;
#         if (cols[2] != "CDS") continue;
# 
#         int start = std::atoi(cols[3].c_str());
#         int end   = std::atoi(cols[4].c_str());
#         if (start <= 0 || end <= 0) continue;
# 
#         char strand = cols[6].empty() ? '+' : cols[6][0];
#         std::string name = choose_name(cols[8], cols[0], cols[3], cols[4]);
# 
#         CDSFeature f;
#         if (start <= end) {
#             f.start0 = start - 1;
#             f.end0   = end   - 1;
#         } else {
#             f.start0 = end   - 1;
#             f.end0   = start - 1;
#         }
#         f.strand = strand;
#         f.name   = name;
#         cds.push_back(f);
#     }
#     return cds;
# }
# 
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'T': return 'A';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         default:  return 'N';
#     }
# }
# 
# static void mean_sd(const std::vector<double> &v, double &mean, double &sd) {
#     if (v.empty()) {
#         mean = sd = 0.0;
#         return;
#     }
#     double sum = 0.0, sum2 = 0.0;
#     for (double x : v) {
#         sum  += x;
#         sum2 += x * x;
#     }
#     double n = (double)v.size();
#     mean = sum / n;
#     double var = sum2 / n - mean * mean;
#     if (var < 0.0) var = 0.0;
#     sd = std::sqrt(var);
# }
# 
# static double pearson_corr(const std::vector<double> &a,
#                            const std::vector<double> &b) {
#     size_t n = a.size();
#     if (n == 0 || b.size() != n) return 0.0;
#     double mean_a, sd_a, mean_b, sd_b;
#     mean_sd(a, mean_a, sd_a);
#     mean_sd(b, mean_b, sd_b);
#     if (sd_a == 0.0 || sd_b == 0.0) return 0.0;
#     double num = 0.0;
#     for (size_t i = 0; i < n; ++i) {
#         num += (a[i] - mean_a) * (b[i] - mean_b);
#     }
#     return num / ((double)n * sd_a * sd_b);
# }
# 
# int main(int argc, char** argv) {
#     std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     std::string gff_path   = "/content/ecoli_U00096_3.gff";
#     if (argc >= 3) {
#         fasta_path = argv[1];
#         gff_path   = argv[2];
#     }
# 
#     std::printf("[DNA-L23] FASTA path: %s\n", fasta_path.c_str());
#     std::printf("[DNA-L23] GFF path  : %s\n\n", gff_path.c_str());
# 
#     std::string genome = read_fasta(fasta_path);
#     if (genome.empty()) {
#         std::fprintf(stderr, "ERROR: FASTA genome sequence is empty.\n");
#         return 1;
#     }
#     std::printf("Genome loaded: length = %zu bases\n", genome.size());
# 
#     std::vector<CDSFeature> cds = load_cds(gff_path);
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     // Lock codon set from DNA-L18
#     std::unordered_set<std::string> lock_codons_set = {
#         "TCG","TTC","GTG","CTC","GGC","CAC","CGC","CCG","CTG",
#         "TAC","ACC","TCC","GAC","GCG","GCC","TGC","TGG","ATC","GAG"
#     };
# 
#     std::vector<GeneStats> genes;
#     genes.reserve(cds.size());
# 
#     int cds_lenmod3_skip = 0;
#     int cds_ambig_skip   = 0;
# 
#     long long sum_len    = 0;
#     long long sum_codons = 0;
#     long long sum_gc     = 0;
#     long long sum_gc3    = 0;
#     long long sum_cpg    = 0;
#     long long sum_gc_heavy = 0;
#     long long sum_lock   = 0;
# 
#     std::vector<double> v_gc, v_gc3, v_cpg, v_heavy, v_lock;
# 
#     for (const CDSFeature &f : cds) {
#         int len = f.end0 - f.start0 + 1;
#         if (len <= 0) continue;
#         if (len % 3 != 0) {
#             ++cds_lenmod3_skip;
#             continue;
#         }
# 
#         std::string cds_seq;
#         cds_seq.resize(len);
#         if (f.strand == '+') {
#             for (int i = 0; i < len; ++i) {
#                 char u = std::toupper((unsigned char)genome[f.start0 + i]);
#                 cds_seq[i] = u;
#             }
#         } else {
#             for (int i = 0; i < len; ++i) {
#                 char u = std::toupper((unsigned char)genome[f.end0 - i]);
#                 cds_seq[i] = comp_base(u);
#             }
#         }
# 
#         bool ambig = false;
#         for (char c : cds_seq) {
#             if (c != 'A' && c != 'C' && c != 'G' && c != 'T') {
#                 ambig = true;
#                 break;
#             }
#         }
#         if (ambig) {
#             ++cds_ambig_skip;
#             continue;
#         }
# 
#         int n_codons = len / 3;
#         if (n_codons <= 0) continue;
# 
#         long gc_bases      = 0;
#         long gc3_codons    = 0;
#         long cpg_total     = 0;
#         long gc_heavy_cod  = 0;
#         long lock_codons   = 0;
# 
#         for (int i = 0; i < len; ++i) {
#             char b = cds_seq[i];
#             if (b == 'G' || b == 'C') gc_bases++;
#             if (i + 1 < len && b == 'C' && cds_seq[i+1] == 'G') cpg_total++;
#         }
# 
#         for (int i = 0; i < n_codons; ++i) {
#             char b1 = cds_seq[i*3 + 0];
#             char b2 = cds_seq[i*3 + 1];
#             char b3 = cds_seq[i*3 + 2];
#             if (b3 == 'G' || b3 == 'C') gc3_codons++;
# 
#             int gc_count = 0;
#             if (b1 == 'G' || b1 == 'C') gc_count++;
#             if (b2 == 'G' || b2 == 'C') gc_count++;
#             if (b3 == 'G' || b3 == 'C') gc_count++;
#             if (gc_count >= 2) gc_heavy_cod++;
# 
#             std::string codon;
#             codon.push_back(b1);
#             codon.push_back(b2);
#             codon.push_back(b3);
#             if (lock_codons_set.find(codon) != lock_codons_set.end()) {
#                 lock_codons++;
#             }
#         }
# 
#         double gc_frac        = (double)gc_bases / (double)len;
#         double gc3_frac       = (double)gc3_codons / (double)n_codons;
#         double gc_heavy_frac  = (double)gc_heavy_cod / (double)n_codons;
#         double lock_frac      = (double)lock_codons / (double)n_codons;
#         double denom          = (len > 1 ? (double)(len - 1) : 1.0);
#         double cpg_per_kb     = (double)cpg_total * 1000.0 / denom;
# 
#         GeneStats g;
#         g.name          = f.name;
#         g.start0        = f.start0;
#         g.end0          = f.end0;
#         g.strand        = f.strand;
#         g.length        = len;
#         g.codons        = n_codons;
#         g.gc_bases      = gc_bases;
#         g.gc3_codons    = gc3_codons;
#         g.cpg_total     = cpg_total;
#         g.gc_heavy_codons = gc_heavy_cod;
#         g.lock_codons   = lock_codons;
# 
#         g.gc_frac       = gc_frac;
#         g.gc3_frac      = gc3_frac;
#         g.cpg_per_kb    = cpg_per_kb;
#         g.gc_heavy_frac = gc_heavy_frac;
#         g.lock_frac     = lock_frac;
# 
#         g.z_gc   = 0.0;
#         g.z_gc3  = 0.0;
#         g.z_cpg  = 0.0;
#         g.z_heavy= 0.0;
#         g.z_lock = 0.0;
#         g.lock_score = 0.0;
# 
#         genes.push_back(g);
# 
#         sum_len    += len;
#         sum_codons += n_codons;
#         sum_gc     += gc_bases;
#         sum_gc3    += gc3_codons;
#         sum_cpg    += cpg_total;
#         sum_gc_heavy += gc_heavy_cod;
#         sum_lock   += lock_codons;
# 
#         v_gc.push_back(gc_frac);
#         v_gc3.push_back(gc3_frac);
#         v_cpg.push_back(cpg_per_kb);
#         v_heavy.push_back(gc_heavy_frac);
#         v_lock.push_back(lock_frac);
#     }
# 
#     std::printf("CDS summary:\n");
#     std::printf("  CDS features in GFF            : %zu\n", cds.size());
#     std::printf("  CDS analyzed (valid)           : %zu\n", genes.size());
#     std::printf("  CDS skipped (len %% 3 != 0)     : %d\n", cds_lenmod3_skip);
#     std::printf("  CDS skipped (ambiguous bases)  : %d\n\n", cds_ambig_skip);
# 
#     double mean_gc, sd_gc, mean_gc3, sd_gc3, mean_cpg, sd_cpg, mean_heavy, sd_heavy, mean_lock, sd_lock;
#     mean_gc    = sd_gc    = 0.0;
#     mean_gc3   = sd_gc3   = 0.0;
#     mean_cpg   = sd_cpg   = 0.0;
#     mean_heavy = sd_heavy = 0.0;
#     mean_lock  = sd_lock  = 0.0;
# 
#     mean_sd(v_gc,    mean_gc,    sd_gc);
#     mean_sd(v_gc3,   mean_gc3,   sd_gc3);
#     mean_sd(v_cpg,   mean_cpg,   sd_cpg);
#     mean_sd(v_heavy, mean_heavy, sd_heavy);
#     mean_sd(v_lock,  mean_lock,  sd_lock);
# 
#     double gc_frac_global   = (sum_len > 0 ? (double)sum_gc / (double)sum_len       : 0.0);
#     double gc3_frac_global  = (sum_codons > 0 ? (double)sum_gc3 / (double)sum_codons: 0.0);
#     double cpg_per_kb_global= (sum_len > 1 ? (double)sum_cpg * 1000.0 / (double)(sum_len - 1) : 0.0);
#     double gc_heavy_global  = (sum_codons > 0 ? (double)sum_gc_heavy / (double)sum_codons : 0.0);
#     double lock_global      = (sum_codons > 0 ? (double)sum_lock / (double)sum_codons : 0.0);
# 
#     std::printf("--- Global lock metrics (CDS-level) ---\n");
#     std::printf("  Sum CDS length           : %lld bases\n", sum_len);
#     std::printf("  Sum codons               : %lld\n", sum_codons);
#     std::printf("  Total GC bases           : %lld (GC_frac_global=%.4f)\n", sum_gc, gc_frac_global);
#     std::printf("  Total GC3 codons         : %lld (GC3_frac_global=%.4f)\n", sum_gc3, gc3_frac_global);
#     std::printf("  Total CpG dinucleotides  : %lld (CpG_per_kb_global=%.2f)\n", sum_cpg, cpg_per_kb_global);
#     std::printf("  Total GC-heavy codons    : %lld (GC-heavy_frac_global=%.4f)\n", sum_gc_heavy, gc_heavy_global);
#     std::printf("  Total lock codons        : %lld (lock_frac_global=%.4f)\n\n", sum_lock, lock_global);
# 
#     std::printf("  GC_frac per CDS          : mean=%.4f, sd=%.4f\n", mean_gc, sd_gc);
#     std::printf("  GC3_frac per CDS         : mean=%.4f, sd=%.4f\n", mean_gc3, sd_gc3);
#     std::printf("  CpG_per_kb per CDS       : mean=%.4f, sd=%.4f\n", mean_cpg, sd_cpg);
#     std::printf("  GC-heavy_frac per CDS    : mean=%.4f, sd=%.4f\n", mean_heavy, sd_heavy);
#     std::printf("  lock_codon_frac per CDS  : mean=%.4f, sd=%.4f\n\n", mean_lock, sd_lock);
# 
#     // Compute z-scores and composite lock_score
#     for (size_t i = 0; i < genes.size(); ++i) {
#         GeneStats &g = genes[i];
#         g.z_gc    = (sd_gc    > 0.0 ? (g.gc_frac       - mean_gc)    / sd_gc   : 0.0);
#         g.z_gc3   = (sd_gc3   > 0.0 ? (g.gc3_frac      - mean_gc3)   / sd_gc3  : 0.0);
#         g.z_cpg   = (sd_cpg   > 0.0 ? (g.cpg_per_kb    - mean_cpg)   / sd_cpg  : 0.0);
#         g.z_heavy = (sd_heavy > 0.0 ? (g.gc_heavy_frac - mean_heavy) / sd_heavy: 0.0);
#         g.z_lock  = (sd_lock  > 0.0 ? (g.lock_frac     - mean_lock)  / sd_lock : 0.0);
# 
#         g.lock_score = g.z_gc3 + g.z_cpg + g.z_heavy + g.z_lock;
#     }
# 
#     // Correlations between metrics
#     double corr_gc_gc3   = pearson_corr(v_gc,   v_gc3);
#     double corr_gc_cpg   = pearson_corr(v_gc,   v_cpg);
#     double corr_gc_heavy = pearson_corr(v_gc,   v_heavy);
#     double corr_gc_lock  = pearson_corr(v_gc,   v_lock);
#     double corr_gc3_cpg  = pearson_corr(v_gc3,  v_cpg);
#     double corr_gc3_heavy= pearson_corr(v_gc3,  v_heavy);
#     double corr_gc3_lock = pearson_corr(v_gc3,  v_lock);
#     double corr_cpg_heavy= pearson_corr(v_cpg,  v_heavy);
#     double corr_cpg_lock = pearson_corr(v_cpg,  v_lock);
#     double corr_heavy_lock = pearson_corr(v_heavy, v_lock);
# 
#     std::printf("--- Pearson correlations between lock metrics (CDS-level) ---\n");
#     std::printf("  corr(GC_frac,   GC3_frac      ) = %.4f\n", corr_gc_gc3);
#     std::printf("  corr(GC_frac,   CpG_per_kb    ) = %.4f\n", corr_gc_cpg);
#     std::printf("  corr(GC_frac,   GC-heavy_frac ) = %.4f\n", corr_gc_heavy);
#     std::printf("  corr(GC_frac,   lock_frac     ) = %.4f\n", corr_gc_lock);
#     std::printf("  corr(GC3_frac,  CpG_per_kb    ) = %.4f\n", corr_gc3_cpg);
#     std::printf("  corr(GC3_frac,  GC-heavy_frac ) = %.4f\n", corr_gc3_heavy);
#     std::printf("  corr(GC3_frac,  lock_frac     ) = %.4f\n", corr_gc3_lock);
#     std::printf("  corr(CpG_per_kb,GC-heavy_frac ) = %.4f\n", corr_cpg_heavy);
#     std::printf("  corr(CpG_per_kb,lock_frac     ) = %.4f\n", corr_cpg_lock);
#     std::printf("  corr(GC-heavy_frac,lock_frac  ) = %.4f\n\n", corr_heavy_lock);
# 
#     // Rank genes by lock_score
#     std::vector<int> order(genes.size());
#     for (size_t i = 0; i < genes.size(); ++i) order[i] = (int)i;
#     std::sort(order.begin(), order.end(),
#               [&](int a, int b) {
#                   if (genes[a].lock_score != genes[b].lock_score)
#                       return genes[a].lock_score > genes[b].lock_score;
#                   return genes[a].gc3_frac > genes[b].gc3_frac;
#               });
# 
#     std::printf("--- Top 20 genes by composite lock_score ---\n");
#     size_t topN = std::min<size_t>(20, genes.size());
#     for (size_t r = 0; r < topN; ++r) {
#         const GeneStats &g = genes[order[r]];
#         std::printf("  [%2zu] %-10s | len=%4d codons=%4ld | lock_score=%6.2f\n",
#                     r+1, g.name.c_str(), g.length, g.codons, g.lock_score);
#         std::printf("       GC=%.4f (z=%5.2f) | GC3=%.4f (z=%5.2f)\n",
#                     g.gc_frac, g.z_gc, g.gc3_frac, g.z_gc3);
#         std::printf("       CpG/kb=%.2f (z=%5.2f) | GC-heavy=%.4f (z=%5.2f) | lock_frac=%.4f (z=%5.2f)\n",
#                     g.cpg_per_kb, g.z_cpg, g.gc_heavy_frac, g.z_heavy, g.lock_frac, g.z_lock);
#     }
#     std::printf("\n");
# 
#     // Map name -> index
#     std::unordered_map<std::string,int> idx_by_name;
#     for (size_t i = 0; i < genes.size(); ++i) {
#         if (!idx_by_name.count(genes[i].name)) {
#             idx_by_name[genes[i].name] = (int)i;
#         }
#     }
# 
#     const char* focus[] = {
#         "yagA","yagE","yagF","yagG","yagH",
#         "rhsD","mdtB","mdtC","mutS",
#         "phnD","phnK","phnM","phnI","phnG","phnL",
#         "nikB","nikC","ugpA","ugpE"
#     };
# 
#     std::printf("--- Lock scoreboard for selected loci ---\n");
#     for (const char* fname : focus) {
#         auto it = idx_by_name.find(fname);
#         if (it == idx_by_name.end()) {
#             std::printf("  [%s] not found in CDS set.\n", fname);
#             continue;
#         }
#         const GeneStats &g = genes[it->second];
#         std::printf("  [%s]\n", fname);
#         std::printf("    coords        : %d-%d (strand=%c)\n", g.start0, g.end0, g.strand);
#         std::printf("    len/codons    : %d / %ld\n", g.length, g.codons);
#         std::printf("    GC_frac       : %.4f (z=%5.2f)\n", g.gc_frac, g.z_gc);
#         std::printf("    GC3_frac      : %.4f (z=%5.2f)\n", g.gc3_frac, g.z_gc3);
#         std::printf("    CpG_per_kb    : %.2f (z=%5.2f)\n", g.cpg_per_kb, g.z_cpg);
#         std::printf("    GC-heavy_frac : %.4f (z=%5.2f)\n", g.gc_heavy_frac, g.z_heavy);
#         std::printf("    lock_codon_fr : %.4f (z=%5.2f)\n", g.lock_frac, g.z_lock);
#         std::printf("    composite lock_score : %6.2f\n", g.lock_score);
#     }
# 
#     std::printf("\nLOCK SCOREBOARD & HYPER-LOCK RANKING analysis finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# nvcc -O3 -std=c++17 warpfrac_dna_lock_scoreboard.cu -o warpfrac_dna_lock_scoreboard
# 
# ./warpfrac_dna_lock_scoreboard /content/ecoli_U00096_3.fna /content/ecoli_U00096_3.gff | tee DNA-L23_lock_scoreboard.out
# 
# echo
# echo "[DNA-L23] SHA256(stdout) ="
# sha256sum DNA-L23_lock_scoreboard.out
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_lock_vs_aa.cu << 'CPP'
# // warpfrac_dna_lock_vs_aa.cu
# // DNA-L24 — LOCK vs AMINO-ACID COMPOSITION & HYDROPHOBICITY (CPU-only)
# //
# // For each CDS (len % 3 == 0, A/C/G/T only) we:
# //   • translate to amino acids (standard genetic code);
# //   • compute classic lock metrics:
# //       GC_frac, GC3_frac, CpG_per_kb, lock_codon_frac
# //     (lock codon set = enriched codons from DNA-L18);
# //   • compute amino-acid group fractions:
# //       frac_hydrophobic = (A,V,I,L,M,F,W,Y) / aa_len
# //       frac_positive    = (K,R,H) / aa_len
# //       frac_negative    = (D,E) / aa_len
# //       frac_polar       = (S,T,N,Q,C) / aa_len
# //       frac_small       = (A,G,S) / aa_len
# //
# // Then we:
# //   • compute mean/sd per metric;
# //   • compute Pearson correlations between GC3_frac / lock_frac and AA groups;
# //   • rank genes by joint GC3 + hydrophobic z-score;
# //   • print top hydrophobic GC3-locked proteins;
# //   • print AA-side lock profiles for key loci.
# //
# // CPU-only: compiled with nvcc as C++17, but no CUDA kernels.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# #include <unordered_map>
# #include <unordered_set>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;
# };
# 
# struct GeneAA {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;
# 
#     int length_nt;
#     long codons;
#     long aa_len;
# 
#     long gc_bases;
#     long gc3_codons;
#     long cpg_total;
#     long lock_codons;
# 
#     double gc_frac;
#     double gc3_frac;
#     double cpg_per_kb;
#     double lock_frac;
# 
#     double frac_hydro;
#     double frac_pos;
#     double frac_neg;
#     double frac_polar;
#     double frac_small;
# 
#     double z_gc3;
#     double z_lock;
#     double z_hydro;
#     double z_pos;
#     double z_neg;
#     double z_polar;
#     double z_small;
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     std::string seq;
#     seq.reserve(5000000);
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (!std::isalpha((unsigned char)c)) continue;
#             char u = std::toupper((unsigned char)c);
#             if (u == 'A' || u == 'C' || u == 'G' || u == 'T' || u == 'N')
#                 seq.push_back(u);
#         }
#     }
#     return seq;
# }
# 
# static std::string extract_attr_value(const std::string &attr, const std::string &key) {
#     std::string token = key + "=";
#     size_t pos = attr.find(token);
#     if (pos == std::string::npos) return "";
#     pos += token.size();
#     size_t end = pos;
#     while (end < attr.size() && attr[end] != ';' && !std::isspace((unsigned char)attr[end])) {
#         ++end;
#     }
#     return attr.substr(pos, end - pos);
# }
# 
# static std::string choose_name(const std::string &attr,
#                                const std::string &seqid,
#                                const std::string &start,
#                                const std::string &end) {
#     const char* keys[] = {"gene", "locus_tag", "Name", "ID", "protein_id"};
#     for (const char* k : keys) {
#         std::string val = extract_attr_value(attr, k);
#         if (!val.empty()) return val;
#     }
#     return seqid + ":" + start + "-" + end;
# }
# 
# static std::vector<CDSFeature> load_cds(const std::string &gff_path) {
#     std::ifstream in(gff_path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", gff_path.c_str());
#         std::exit(1);
#     }
#     std::vector<CDSFeature> cds;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string cols[9];
#         int col_idx = 0;
#         while (col_idx < 9 && std::getline(ss, cols[col_idx], '\t')) {
#             ++col_idx;
#         }
#         if (col_idx < 9) continue;
#         if (cols[2] != "CDS") continue;
# 
#         int start = std::atoi(cols[3].c_str());
#         int end   = std::atoi(cols[4].c_str());
#         if (start <= 0 || end <= 0) continue;
#         char strand = cols[6].empty() ? '+' : cols[6][0];
#         std::string name = choose_name(cols[8], cols[0], cols[3], cols[4]);
# 
#         CDSFeature f;
#         if (start <= end) {
#             f.start0 = start - 1;
#             f.end0   = end   - 1;
#         } else {
#             f.start0 = end   - 1;
#             f.end0   = start - 1;
#         }
#         f.strand = strand;
#         f.name   = name;
#         cds.push_back(f);
#     }
#     return cds;
# }
# 
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'T': return 'A';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         default:  return 'N';
#     }
# }
# 
# static void mean_sd(const std::vector<double> &v, double &mean, double &sd) {
#     if (v.empty()) {
#         mean = sd = 0.0;
#         return;
#     }
#     double sum = 0.0, sum2 = 0.0;
#     for (double x : v) {
#         sum  += x;
#         sum2 += x * x;
#     }
#     double n = (double)v.size();
#     mean = sum / n;
#     double var = sum2 / n - mean * mean;
#     if (var < 0.0) var = 0.0;
#     sd = std::sqrt(var);
# }
# 
# static double pearson_corr(const std::vector<double> &a,
#                            const std::vector<double> &b) {
#     size_t n = a.size();
#     if (n == 0 || b.size() != n) return 0.0;
#     double ma, sa, mb, sb;
#     mean_sd(a, ma, sa);
#     mean_sd(b, mb, sb);
#     if (sa == 0.0 || sb == 0.0) return 0.0;
#     double num = 0.0;
#     for (size_t i = 0; i < n; ++i) {
#         num += (a[i] - ma) * (b[i] - mb);
#     }
#     return num / ((double)n * sa * sb);
# }
# 
# static char translate_codon(const std::string &codon) {
#     // Standard genetic code
#     static std::unordered_map<std::string,char> table = {
#         {"TTT",'F'},{"TTC",'F'},{"TTA",'L'},{"TTG",'L'},
#         {"CTT",'L'},{"CTC",'L'},{"CTA",'L'},{"CTG",'L'},
#         {"ATT",'I'},{"ATC",'I'},{"ATA",'I'},{"ATG",'M'},
#         {"GTT",'V'},{"GTC",'V'},{"GTA",'V'},{"GTG",'V'},
#         {"TCT",'S'},{"TCC",'S'},{"TCA",'S'},{"TCG",'S'},
#         {"CCT",'P'},{"CCC",'P'},{"CCA",'P'},{"CCG",'P'},
#         {"ACT",'T'},{"ACC",'T'},{"ACA",'T'},{"ACG",'T'},
#         {"GCT",'A'},{"GCC",'A'},{"GCA",'A'},{"GCG",'A'},
#         {"TAT",'Y'},{"TAC",'Y'},{"TAA",'*'},{"TAG",'*'},
#         {"CAT",'H'},{"CAC",'H'},{"CAA",'Q'},{"CAG",'Q'},
#         {"AAT",'N'},{"AAC",'N'},{"AAA",'K'},{"AAG",'K'},
#         {"GAT",'D'},{"GAC",'D'},{"GAA",'E'},{"GAG",'E'},
#         {"TGT",'C'},{"TGC",'C'},{"TGA",'*'},{"TGG",'W'},
#         {"CGT",'R'},{"CGC",'R'},{"CGA",'R'},{"CGG",'R'},
#         {"AGT",'S'},{"AGC",'S'},{"AGA",'R'},{"AGG",'R'},
#         {"GGT",'G'},{"GGC",'G'},{"GGA",'G'},{"GGG",'G'}
#     };
#     auto it = table.find(codon);
#     if (it == table.end()) return 'X';
#     return it->second;
# }
# 
# // Group membership helpers
# static bool is_hydrophobic(char aa) {
#     switch (aa) {
#         case 'A': case 'V': case 'I': case 'L':
#         case 'M': case 'F': case 'W': case 'Y':
#             return true;
#         default: return false;
#     }
# }
# static bool is_positive(char aa) {
#     switch (aa) {
#         case 'K': case 'R': case 'H': return true;
#         default: return false;
#     }
# }
# static bool is_negative(char aa) {
#     switch (aa) {
#         case 'D': case 'E': return true;
#         default: return false;
#     }
# }
# static bool is_polar(char aa) {
#     switch (aa) {
#         case 'S': case 'T': case 'N': case 'Q': case 'C':
#             return true;
#         default: return false;
#     }
# }
# static bool is_small(char aa) {
#     switch (aa) {
#         case 'A': case 'G': case 'S': return true;
#         default: return false;
#     }
# }
# 
# int main(int argc, char** argv) {
#     std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     std::string gff_path   = "/content/ecoli_U00096_3.gff";
#     if (argc >= 3) {
#         fasta_path = argv[1];
#         gff_path   = argv[2];
#     }
# 
#     std::printf("[DNA-L24] FASTA path: %s\n", fasta_path.c_str());
#     std::printf("[DNA-L24] GFF path  : %s\n\n", gff_path.c_str());
# 
#     std::string genome = read_fasta(fasta_path);
#     if (genome.empty()) {
#         std::fprintf(stderr, "ERROR: FASTA genome sequence is empty.\n");
#         return 1;
#     }
#     std::printf("Genome loaded: length = %zu bases\n", genome.size());
# 
#     std::vector<CDSFeature> cds = load_cds(gff_path);
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     // Lock codon set from DNA-L18
#     std::unordered_set<std::string> lock_codons_set = {
#         "TCG","TTC","GTG","CTC","GGC","CAC","CGC","CCG","CTG",
#         "TAC","ACC","TCC","GAC","GCG","GCC","TGC","TGG","ATC","GAG"
#     };
# 
#     std::vector<GeneAA> genes;
#     genes.reserve(cds.size());
# 
#     int cds_lenmod3_skip = 0;
#     int cds_ambig_skip   = 0;
# 
#     long long sum_len_nt    = 0;
#     long long sum_codons    = 0;
#     long long sum_gc        = 0;
#     long long sum_gc3       = 0;
#     long long sum_cpg       = 0;
#     long long sum_lock      = 0;
# 
#     std::vector<double> v_gc3, v_lock;
#     std::vector<double> v_hydro, v_pos, v_neg, v_polar, v_small;
# 
#     for (const CDSFeature &f : cds) {
#         int len = f.end0 - f.start0 + 1;
#         if (len <= 0) continue;
#         if (len % 3 != 0) {
#             ++cds_lenmod3_skip;
#             continue;
#         }
# 
#         std::string cds_seq;
#         cds_seq.resize(len);
#         if (f.strand == '+') {
#             for (int i = 0; i < len; ++i) {
#                 char u = std::toupper((unsigned char)genome[f.start0 + i]);
#                 cds_seq[i] = u;
#             }
#         } else {
#             for (int i = 0; i < len; ++i) {
#                 char u = std::toupper((unsigned char)genome[f.end0 - i]);
#                 cds_seq[i] = comp_base(u);
#             }
#         }
# 
#         bool ambig = false;
#         for (char c : cds_seq) {
#             if (c != 'A' && c != 'C' && c != 'G' && c != 'T') {
#                 ambig = true;
#                 break;
#             }
#         }
#         if (ambig) {
#             ++cds_ambig_skip;
#             continue;
#         }
# 
#         int n_codons = len / 3;
#         if (n_codons <= 0) continue;
# 
#         long gc_bases   = 0;
#         long gc3_codons = 0;
#         long cpg_total  = 0;
#         long lock_cod   = 0;
# 
#         for (int i = 0; i < len; ++i) {
#             char b = cds_seq[i];
#             if (b == 'G' || b == 'C') gc_bases++;
#             if (i + 1 < len && b == 'C' && cds_seq[i+1] == 'G') cpg_total++;
#         }
# 
#         // codon-level
#         for (int i = 0; i < n_codons; ++i) {
#             char b1 = cds_seq[i*3 + 0];
#             char b2 = cds_seq[i*3 + 1];
#             char b3 = cds_seq[i*3 + 2];
#             if (b3 == 'G' || b3 == 'C') gc3_codons++;
#             std::string codon;
#             codon.push_back(b1);
#             codon.push_back(b2);
#             codon.push_back(b3);
#             if (lock_codons_set.find(codon) != lock_codons_set.end())
#                 lock_cod++;
#         }
# 
#         // Translate and count AA groups
#         long aa_len = 0;
#         long cnt_hydro = 0, cnt_pos = 0, cnt_neg = 0, cnt_polar = 0, cnt_small = 0;
#         for (int i = 0; i < n_codons; ++i) {
#             std::string codon;
#             codon.push_back(cds_seq[i*3+0]);
#             codon.push_back(cds_seq[i*3+1]);
#             codon.push_back(cds_seq[i*3+2]);
#             char aa = translate_codon(codon);
#             if (aa == 'X') {
#                 // unknown codon, still count as aa to keep denominator consistent
#                 aa_len++;
#                 continue;
#             }
#             // treat stop '*' as generic residue for counting denominator
#             aa_len++;
#             if (is_hydrophobic(aa)) cnt_hydro++;
#             if (is_positive(aa))    cnt_pos++;
#             if (is_negative(aa))    cnt_neg++;
#             if (is_polar(aa))       cnt_polar++;
#             if (is_small(aa))       cnt_small++;
#         }
#         if (aa_len <= 0) continue;
# 
#         double gc_frac      = (double)gc_bases   / (double)len;
#         double gc3_frac     = (double)gc3_codons / (double)n_codons;
#         double lock_frac    = (double)lock_cod   / (double)n_codons;
#         double denom_nt     = (len > 1 ? (double)(len - 1) : 1.0);
#         double cpg_per_kb   = (double)cpg_total  * 1000.0 / denom_nt;
# 
#         double frac_hydro   = (double)cnt_hydro  / (double)aa_len;
#         double frac_pos     = (double)cnt_pos    / (double)aa_len;
#         double frac_neg     = (double)cnt_neg    / (double)aa_len;
#         double frac_polar   = (double)cnt_polar  / (double)aa_len;
#         double frac_small   = (double)cnt_small  / (double)aa_len;
# 
#         GeneAA g;
#         g.name       = f.name;
#         g.start0     = f.start0;
#         g.end0       = f.end0;
#         g.strand     = f.strand;
#         g.length_nt  = len;
#         g.codons     = n_codons;
#         g.aa_len     = aa_len;
#         g.gc_bases   = gc_bases;
#         g.gc3_codons = gc3_codons;
#         g.cpg_total  = cpg_total;
#         g.lock_codons= lock_cod;
# 
#         g.gc_frac    = gc_frac;
#         g.gc3_frac   = gc3_frac;
#         g.cpg_per_kb = cpg_per_kb;
#         g.lock_frac  = lock_frac;
# 
#         g.frac_hydro = frac_hydro;
#         g.frac_pos   = frac_pos;
#         g.frac_neg   = frac_neg;
#         g.frac_polar = frac_polar;
#         g.frac_small = frac_small;
# 
#         g.z_gc3   = 0.0;
#         g.z_lock  = 0.0;
#         g.z_hydro = g.z_pos = g.z_neg = g.z_polar = g.z_small = 0.0;
# 
#         genes.push_back(g);
# 
#         sum_len_nt += len;
#         sum_codons += n_codons;
#         sum_gc     += gc_bases;
#         sum_gc3    += gc3_codons;
#         sum_cpg    += cpg_total;
#         sum_lock   += lock_cod;
# 
#         v_gc3.push_back(gc3_frac);
#         v_lock.push_back(lock_frac);
#         v_hydro.push_back(frac_hydro);
#         v_pos.push_back(frac_pos);
#         v_neg.push_back(frac_neg);
#         v_polar.push_back(frac_polar);
#         v_small.push_back(frac_small);
#     }
# 
#     std::printf("CDS summary:\n");
#     std::printf("  CDS features in GFF            : %zu\n", cds.size());
#     std::printf("  CDS analyzed (valid)           : %zu\n", genes.size());
#     std::printf("  CDS skipped (len %% 3 != 0)     : %d\n", cds_lenmod3_skip);
#     std::printf("  CDS skipped (ambiguous bases)  : %d\n\n", cds_ambig_skip);
# 
#     double gc3_frac_global  = (sum_codons > 0 ? (double)sum_gc3 / (double)sum_codons : 0.0);
#     double lock_frac_global = (sum_codons > 0 ? (double)sum_lock / (double)sum_codons : 0.0);
#     double cpg_per_kb_global= (sum_len_nt > 1 ? (double)sum_cpg * 1000.0 / (double)(sum_len_nt - 1) : 0.0);
# 
#     std::printf("--- Global GC3 & lock vs AA composition ---\n");
#     std::printf("  Sum CDS length           : %lld bases\n", sum_len_nt);
#     std::printf("  Sum codons               : %lld\n", sum_codons);
#     std::printf("  Total GC3 codons         : %lld (GC3_frac_global=%.4f)\n", sum_gc3, gc3_frac_global);
#     std::printf("  Total lock codons        : %lld (lock_frac_global=%.4f)\n", sum_lock, lock_frac_global);
#     std::printf("  Total CpG dinucleotides  : %lld (CpG_per_kb_global=%.2f)\n\n", sum_cpg, cpg_per_kb_global);
# 
#     double mean_gc3, sd_gc3, mean_lock, sd_lock;
#     double mean_h, sd_h, mean_pos, sd_pos, mean_neg, sd_neg, mean_pol, sd_pol, mean_small, sd_small;
# 
#     mean_sd(v_gc3,   mean_gc3,   sd_gc3);
#     mean_sd(v_lock,  mean_lock,  sd_lock);
#     mean_sd(v_hydro, mean_h,     sd_h);
#     mean_sd(v_pos,   mean_pos,   sd_pos);
#     mean_sd(v_neg,   mean_neg,   sd_neg);
#     mean_sd(v_polar, mean_pol,   sd_pol);
#     mean_sd(v_small, mean_small, sd_small);
# 
#     std::printf("  GC3_frac per CDS         : mean=%.4f, sd=%.4f\n", mean_gc3, sd_gc3);
#     std::printf("  lock_frac per CDS        : mean=%.4f, sd=%.4f\n", mean_lock, sd_lock);
#     std::printf("  frac_hydrophobic per CDS : mean=%.4f, sd=%.4f\n", mean_h, sd_h);
#     std::printf("  frac_positive per CDS    : mean=%.4f, sd=%.4f\n", mean_pos, sd_pos);
#     std::printf("  frac_negative per CDS    : mean=%.4f, sd=%.4f\n", mean_neg, sd_neg);
#     std::printf("  frac_polar per CDS       : mean=%.4f, sd=%.4f\n", mean_pol, sd_pol);
#     std::printf("  frac_small per CDS       : mean=%.4f, sd=%.4f\n\n", mean_small, sd_small);
# 
#     // Correlations
#     double corr_gc3_h      = pearson_corr(v_gc3,  v_hydro);
#     double corr_gc3_pos    = pearson_corr(v_gc3,  v_pos);
#     double corr_gc3_neg    = pearson_corr(v_gc3,  v_neg);
#     double corr_gc3_pol    = pearson_corr(v_gc3,  v_polar);
#     double corr_gc3_small  = pearson_corr(v_gc3,  v_small);
# 
#     double corr_lock_h     = pearson_corr(v_lock, v_hydro);
#     double corr_lock_pos   = pearson_corr(v_lock, v_pos);
#     double corr_lock_neg   = pearson_corr(v_lock, v_neg);
#     double corr_lock_pol   = pearson_corr(v_lock, v_polar);
#     double corr_lock_small = pearson_corr(v_lock, v_small);
# 
#     std::printf("--- Pearson correlations: GC3 / lock vs AA groups ---\n");
#     std::printf("  corr(GC3_frac,  frac_hydrophobic) = %.4f\n", corr_gc3_h);
#     std::printf("  corr(GC3_frac,  frac_positive   ) = %.4f\n", corr_gc3_pos);
#     std::printf("  corr(GC3_frac,  frac_negative   ) = %.4f\n", corr_gc3_neg);
#     std::printf("  corr(GC3_frac,  frac_polar      ) = %.4f\n", corr_gc3_pol);
#     std::printf("  corr(GC3_frac,  frac_small      ) = %.4f\n", corr_gc3_small);
#     std::printf("  corr(lock_frac, frac_hydrophobic) = %.4f\n", corr_lock_h);
#     std::printf("  corr(lock_frac, frac_positive   ) = %.4f\n", corr_lock_pos);
#     std::printf("  corr(lock_frac, frac_negative   ) = %.4f\n", corr_lock_neg);
#     std::printf("  corr(lock_frac, frac_polar      ) = %.4f\n", corr_lock_pol);
#     std::printf("  corr(lock_frac, frac_small      ) = %.4f\n\n", corr_lock_small);
# 
#     // z-scores for GC3, lock_frac, and hydrophobic fraction
#     for (auto &g : genes) {
#         g.z_gc3   = (sd_gc3   > 0.0 ? (g.gc3_frac   - mean_gc3)   / sd_gc3   : 0.0);
#         g.z_lock  = (sd_lock  > 0.0 ? (g.lock_frac  - mean_lock)  / sd_lock  : 0.0);
#         g.z_hydro = (sd_h     > 0.0 ? (g.frac_hydro - mean_h)     / sd_h     : 0.0);
#         g.z_pos   = (sd_pos   > 0.0 ? (g.frac_pos   - mean_pos)   / sd_pos   : 0.0);
#         g.z_neg   = (sd_neg   > 0.0 ? (g.frac_neg   - mean_neg)   / sd_neg   : 0.0);
#         g.z_polar = (sd_pol   > 0.0 ? (g.frac_polar - mean_pol)   / sd_pol   : 0.0);
#         g.z_small = (sd_small > 0.0 ? (g.frac_small - mean_small) / sd_small : 0.0);
#     }
# 
#     // Rank by "GC3 + hydrophobic" joint score, but only for GC3-high genes
#     std::vector<int> order(genes.size());
#     for (size_t i = 0; i < genes.size(); ++i) order[i] = (int)i;
# 
#     std::sort(order.begin(), order.end(),
#               [&](int a, int b) {
#                   double sa = genes[a].z_gc3 + genes[a].z_hydro;
#                   double sb = genes[b].z_gc3 + genes[b].z_hydro;
#                   if (sa != sb) return sa > sb;
#                   return genes[a].gc3_frac > genes[b].gc3_frac;
#               });
# 
#     double gc3_thr = mean_gc3 + 2.0 * sd_gc3;
# 
#     std::printf("--- Top 15 GC3-locked & hydrophobic proteins (by z(GC3)+z(hydro)) ---\n");
#     int printed = 0;
#     for (size_t r = 0; r < order.size() && printed < 15; ++r) {
#         const GeneAA &g = genes[order[r]];
#         if (g.gc3_frac < gc3_thr) continue;
#         double joint = g.z_gc3 + g.z_hydro;
#         std::printf("  [%2d] %-10s | GC3=%.4f (z=%5.2f) | frac_hydrophobic=%.3f (z=%5.2f) | joint=%.2f\n",
#                     printed+1, g.name.c_str(), g.gc3_frac, g.z_gc3,
#                     g.frac_hydro, g.z_hydro, joint);
#         printed++;
#     }
#     if (printed == 0) {
#         std::printf("  (no genes exceeded GC3 high-lock threshold in this scoring)\n");
#     }
#     std::printf("\n");
# 
#     // Name -> index map
#     std::unordered_map<std::string,int> idx;
#     for (size_t i = 0; i < genes.size(); ++i) {
#         if (!idx.count(genes[i].name))
#             idx[genes[i].name] = (int)i;
#     }
# 
#     const char* focus[] = {
#         "yagA","yagE","yagF","yagG","yagH",
#         "rhsD","mdtB","mdtC","mutS",
#         "phnD","phnK","phnM","phnI","phnG","phnL",
#         "nikB","nikC","ugpA","ugpE"
#     };
# 
#     std::printf("--- Lock vs AA composition for selected loci ---\n");
#     for (const char* fname : focus) {
#         auto it = idx.find(fname);
#         if (it == idx.end()) {
#             std::printf("  [%s] not found in CDS set.\n", fname);
#             continue;
#         }
#         const GeneAA &g = genes[it->second];
#         std::printf("  [%s]\n", fname);
#         std::printf("    coords         : %d-%d (strand=%c)\n", g.start0, g.end0, g.strand);
#         std::printf("    nt_len/codons  : %d / %ld | aa_len=%ld\n",
#                     g.length_nt, g.codons, g.aa_len);
#         std::printf("    GC3_frac       : %.4f (z=%5.2f)\n", g.gc3_frac, g.z_gc3);
#         std::printf("    lock_frac      : %.4f (z=%5.2f)\n", g.lock_frac, g.z_lock);
#         std::printf("    frac_hydrophobic: %.3f (z=%5.2f)\n", g.frac_hydro, g.z_hydro);
#         std::printf("    frac_positive   : %.3f (z=%5.2f)\n", g.frac_pos, g.z_pos);
#         std::printf("    frac_negative   : %.3f (z=%5.2f)\n", g.frac_neg, g.z_neg);
#         std::printf("    frac_polar      : %.3f (z=%5.2f)\n", g.frac_polar, g.z_polar);
#         std::printf("    frac_small      : %.3f (z=%5.2f)\n", g.frac_small, g.z_small);
#     }
# 
#     std::printf("\nLOCK vs AMINO-ACID COMPOSITION analysis finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# nvcc -O3 -std=c++17 warpfrac_dna_lock_vs_aa.cu -o warpfrac_dna_lock_vs_aa
# 
# ./warpfrac_dna_lock_vs_aa /content/ecoli_U00096_3.fna /content/ecoli_U00096_3.gff | tee DNA-L24_lock_vs_aa.out
# 
# echo
# echo "[DNA-L24] SHA256(stdout) ="
# sha256sum DNA-L24_lock_vs_aa.out
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_gc3_ring.cu << 'CPP'
# // warpfrac_dna_gc3_ring.cu
# // DNA-L25 — GENOME-WIDE GC3 LOCK RING vs REPLICATION ORIGIN (E. coli MG1655, CDS-level)
# //
# // For each CDS (len % 3 == 0, A/C/G/T only) we:
# //   * compute GC_frac, GC3_frac, CpG_per_kb;
# //   * find an approximate oriC as the midpoint of the dnaA CDS;
# //   * map each gene onto a circular coordinate around oriC:
# //       rel_frac   in [0,1)   (0 = ori, 0.5 = opposite side)
# //       signed_rel in [-0.5,0.5] (negative just before ori).
# //
# // We then:
# //   * bin the genome ring into 100 bins;
# //   * compute mean GC3 per bin, fraction of hyper-GC3 genes per bin;
# //   * compute correlation between GC3 and signed position;
# //   * report the top GC3 "ridge" bins;
# //   * show ring positions for key hyper-locked loci.
# //
# // CPU-only: compiled with nvcc as C++17, but no CUDA kernels.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <cmath>
# #include <unordered_map>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;
# };
# 
# struct GeneRing {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;
# 
#     int length_nt;
#     int codons;
# 
#     long gc_bases;
#     long gc3_codons;
#     long cpg_total;
# 
#     double gc_frac;
#     double gc3_frac;
#     double cpg_per_kb;
# 
#     double mid_nt;      // midpoint coord (0..L-1)
#     double rel_frac;    // [0,1) around ori
#     double signed_rel;  // [-0.5,0.5]
# };
# 
# static std::string read_fasta(const std::string &path) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         std::exit(1);
#     }
#     std::string line;
#     std::string seq;
#     seq.reserve(5000000);
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (!std::isalpha((unsigned char)c)) continue;
#             char u = std::toupper((unsigned char)c);
#             if (u == 'A' || u == 'C' || u == 'G' || u == 'T' || u == 'N')
#                 seq.push_back(u);
#         }
#     }
#     return seq;
# }
# 
# static std::string extract_attr_value(const std::string &attr, const std::string &key) {
#     std::string token = key + "=";
#     size_t pos = attr.find(token);
#     if (pos == std::string::npos) return "";
#     pos += token.size();
#     size_t end = pos;
#     while (end < attr.size() && attr[end] != ';' && !std::isspace((unsigned char)attr[end])) {
#         ++end;
#     }
#     return attr.substr(pos, end - pos);
# }
# 
# static std::string choose_name(const std::string &attr,
#                                const std::string &seqid,
#                                const std::string &start,
#                                const std::string &end) {
#     const char* keys[] = {"gene", "locus_tag", "Name", "ID", "protein_id"};
#     for (const char* k : keys) {
#         std::string val = extract_attr_value(attr, k);
#         if (!val.empty()) return val;
#     }
#     return seqid + ":" + start + "-" + end;
# }
# 
# static std::vector<CDSFeature> load_cds(const std::string &gff_path) {
#     std::ifstream in(gff_path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", gff_path.c_str());
#         std::exit(1);
#     }
#     std::vector<CDSFeature> cds;
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string cols[9];
#         int col_idx = 0;
#         while (col_idx < 9 && std::getline(ss, cols[col_idx], '\t')) {
#             ++col_idx;
#         }
#         if (col_idx < 9) continue;
#         if (cols[2] != "CDS") continue;
# 
#         int start = std::atoi(cols[3].c_str());
#         int end   = std::atoi(cols[4].c_str());
#         if (start <= 0 || end <= 0) continue;
#         char strand = cols[6].empty() ? '+' : cols[6][0];
#         std::string name = choose_name(cols[8], cols[0], cols[3], cols[4]);
# 
#         CDSFeature f;
#         if (start <= end) {
#             f.start0 = start - 1;
#             f.end0   = end   - 1;
#         } else {
#             f.start0 = end   - 1;
#             f.end0   = start - 1;
#         }
#         f.strand = strand;
#         f.name   = name;
#         cds.push_back(f);
#     }
#     return cds;
# }
# 
# int main(int argc, char** argv) {
#     std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     std::string gff_path   = "/content/ecoli_U00096_3.gff";
#     if (argc >= 3) {
#         fasta_path = argv[1];
#         gff_path   = argv[2];
#     }
# 
#     std::printf("[DNA-L25] FASTA path: %s\n", fasta_path.c_str());
#     std::printf("[DNA-L25] GFF path  : %s\n\n", gff_path.c_str());
# 
#     std::string genome = read_fasta(fasta_path);
#     if (genome.empty()) {
#         std::fprintf(stderr, "ERROR: FASTA genome sequence is empty.\n");
#         return 1;
#     }
#     const double L = (double)genome.size();
#     std::printf("Genome loaded: length = %zu bases\n", genome.size());
# 
#     std::vector<CDSFeature> cds = load_cds(gff_path);
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     int cds_lenmod3_skip = 0;
#     int cds_ambig_skip   = 0;
# 
#     std::vector<GeneRing> genes;
#     genes.reserve(cds.size());
# 
#     long long sum_len_nt = 0;
#     long long sum_codons = 0;
#     long long sum_gc3    = 0;
#     long long sum_gc     = 0;
#     long long sum_cpg    = 0;
# 
#     std::vector<double> v_gc3;
#     std::vector<double> v_gc;
#     std::vector<double> v_coord_signed;
# 
#     // Per-gene processing
#     for (const CDSFeature &f : cds) {
#         int len = f.end0 - f.start0 + 1;
#         if (len <= 0) continue;
#         if (len % 3 != 0) {
#             ++cds_lenmod3_skip;
#             continue;
#         }
# 
#         std::string seq;
#         seq.resize(len);
#         for (int i = 0; i < len; ++i) {
#             char u = std::toupper((unsigned char)genome[f.start0 + i]);
#             if (u != 'A' && u != 'C' && u != 'G' && u != 'T') {
#                 // We'll reject ambiguous CDS later
#             }
#             seq[i] = u;
#         }
# 
#         bool ambig = false;
#         for (char c : seq) {
#             if (c != 'A' && c != 'C' && c != 'G' && c != 'T') {
#                 ambig = true;
#                 break;
#             }
#         }
#         if (ambig) {
#             ++cds_ambig_skip;
#             continue;
#         }
# 
#         int n_codons = len / 3;
#         if (n_codons <= 0) continue;
# 
#         long gc_bases   = 0;
#         long gc3_codons = 0;
#         long cpg_total  = 0;
# 
#         for (int i = 0; i < len; ++i) {
#             char b = seq[i];
#             if (b == 'G' || b == 'C') gc_bases++;
#             if (i + 1 < len && b == 'C' && seq[i+1] == 'G') cpg_total++;
#         }
# 
#         for (int i = 0; i < n_codons; ++i) {
#             char b3 = seq[i*3 + 2];
#             if (b3 == 'G' || b3 == 'C') gc3_codons++;
#         }
# 
#         double gc_frac  = (double)gc_bases   / (double)len;
#         double gc3_frac = (double)gc3_codons / (double)n_codons;
#         double denom_nt = (len > 1 ? (double)(len - 1) : 1.0);
#         double cpg_per_kb = (double)cpg_total * 1000.0 / denom_nt;
# 
#         GeneRing g;
#         g.name      = f.name;
#         g.start0    = f.start0;
#         g.end0      = f.end0;
#         g.strand    = f.strand;
#         g.length_nt = len;
#         g.codons    = n_codons;
#         g.gc_bases  = gc_bases;
#         g.gc3_codons= gc3_codons;
#         g.cpg_total = cpg_total;
#         g.gc_frac   = gc_frac;
#         g.gc3_frac  = gc3_frac;
#         g.cpg_per_kb= cpg_per_kb;
#         g.mid_nt    = 0.5 * ((double)f.start0 + (double)f.end0);
#         g.rel_frac  = 0.0;
#         g.signed_rel= 0.0;
# 
#         genes.push_back(g);
# 
#         sum_len_nt += len;
#         sum_codons += n_codons;
#         sum_gc3    += gc3_codons;
#         sum_gc     += gc_bases;
#         sum_cpg    += cpg_total;
# 
#         v_gc3.push_back(gc3_frac);
#         v_gc.push_back(gc_frac);
#         // coord vector filled later, after oriC is known
#     }
# 
#     std::printf("CDS summary:\n");
#     std::printf("  CDS features in GFF            : %zu\n", cds.size());
#     std::printf("  CDS analyzed (valid)           : %zu\n", genes.size());
#     std::printf("  CDS skipped (len %% 3 != 0)     : %d\n", cds_lenmod3_skip);
#     std::printf("  CDS skipped (ambiguous bases)  : %d\n\n", cds_ambig_skip);
# 
#     double gc_frac_global  = (sum_len_nt > 0 ? (double)sum_gc  / (double)sum_len_nt : 0.0);
#     double gc3_frac_global = (sum_codons > 0 ? (double)sum_gc3 / (double)sum_codons : 0.0);
#     double cpg_per_kb_global = (sum_len_nt > 1 ? (double)sum_cpg * 1000.0 / (double)(sum_len_nt - 1) : 0.0);
# 
#     // Compute mean & SD for GC3 to define hyper-GC3 threshold
#     auto mean_sd = [](const std::vector<double> &v, double &mean, double &sd) {
#         if (v.empty()) { mean = sd = 0.0; return; }
#         double sum = 0.0, sum2 = 0.0;
#         for (double x : v) {
#             sum  += x;
#             sum2 += x*x;
#         }
#         double n = (double)v.size();
#         mean = sum / n;
#         double var = sum2 / n - mean*mean;
#         if (var < 0.0) var = 0.0;
#         sd = std::sqrt(var);
#     };
# 
#     double mean_gc3, sd_gc3;
#     mean_sd(v_gc3, mean_gc3, sd_gc3);
#     double hyper_thr = mean_gc3 + 2.0 * sd_gc3;
# 
#     std::printf("--- Global GC & GC3 lock stats (CDS-level) ---\n");
#     std::printf("  Sum CDS length           : %lld bases\n", sum_len_nt);
#     std::printf("  Sum codons               : %lld\n", sum_codons);
#     std::printf("  Total GC bases           : %lld (GC_frac_global=%.4f)\n", sum_gc, gc_frac_global);
#     std::printf("  Total GC3 codons         : %lld (GC3_frac_global=%.4f)\n", sum_gc3, gc3_frac_global);
#     std::printf("  Total CpG dinucleotides  : %lld (CpG_per_kb_global=%.2f)\n", sum_cpg, cpg_per_kb_global);
#     std::printf("  GC3_frac per CDS         : mean=%.4f, sd=%.4f\n", mean_gc3, sd_gc3);
#     std::printf("  Hyper-GC3 threshold      : %.4f (mean+2*sd)\n\n", hyper_thr);
# 
#     // Locate dnaA as oriC proxy
#     int dnaA_idx = -1;
#     double ori_pos = 0.0;
#     for (size_t i = 0; i < genes.size(); ++i) {
#         std::string n = genes[i].name;
#         std::string lower;
#         lower.reserve(n.size());
#         for (char c : n) lower.push_back(std::tolower((unsigned char)c));
#         if (lower == "dnaa" || lower.find("dnaa") != std::string::npos) {
#             dnaA_idx = (int)i;
#             ori_pos = genes[i].mid_nt;
#             break;
#         }
#     }
#     if (dnaA_idx < 0) {
#         std::printf("  WARNING: dnaA not found by name; using 0 as oriC proxy.\n");
#         ori_pos = 0.0;
#     }
# 
#     if (dnaA_idx >= 0) {
#         const GeneRing &d = genes[dnaA_idx];
#         std::printf("--- Approximate oriC proxy (dnaA) ---\n");
#         std::printf("  dnaA gene name           : %s\n", d.name.c_str());
#         std::printf("  dnaA coords (0-based)    : %d-%d (strand=%c)\n", d.start0, d.end0, d.strand);
#         std::printf("  dnaA midpoint            : %.1f / %.0f (%.4f of chromosome)\n\n",
#                     d.mid_nt, L, d.mid_nt / L);
#     }
# 
#     // Now assign ring coordinates
#     v_coord_signed.clear();
#     v_coord_signed.reserve(genes.size());
#     long hyper_count = 0;
# 
#     for (auto &g : genes) {
#         double rel = g.mid_nt - ori_pos;
#         if (rel < 0.0) rel += L;
#         // Now rel in [0, L)
#         double rel_frac = rel / L;
#         double signed_rel = rel_frac;
#         if (signed_rel > 0.5) signed_rel -= 1.0; // now in [-0.5,0.5]
#         g.rel_frac   = rel_frac;
#         g.signed_rel = signed_rel;
#         v_coord_signed.push_back(signed_rel);
#         if (g.gc3_frac >= hyper_thr) hyper_count++;
#     }
# 
#     std::printf("--- GC3 lock vs oriC-centered ring ---\n");
#     std::printf("  Hyper-GC3 genes (GC3 >= thr): %ld / %zu\n\n",
#                 hyper_count, genes.size());
# 
#     // Pearson correlation between GC3 and signed position
#     auto pearson_corr = [&](const std::vector<double> &a,
#                             const std::vector<double> &b) -> double {
#         size_t n = a.size();
#         if (n == 0 || b.size() != n) return 0.0;
#         double ma, sa, mb, sb;
#         mean_sd(a, ma, sa);
#         mean_sd(b, mb, sb);
#         if (sa == 0.0 || sb == 0.0) return 0.0;
#         double num = 0.0;
#         for (size_t i = 0; i < n; ++i)
#             num += (a[i] - ma) * (b[i] - mb);
#         return num / ((double)n * sa * sb);
#     };
# 
#     double corr_gc3_pos = pearson_corr(v_gc3, v_coord_signed);
#     double corr_gc_pos  = pearson_corr(v_gc,  v_coord_signed);
# 
#     std::printf("  corr(GC3_frac, signed_rel) = %.4f\n", corr_gc3_pos);
#     std::printf("  corr(GC_frac,  signed_rel) = %.4f\n\n", corr_gc_pos);
# 
#     // Bin genome ring
#     const int NBINS = 100;
#     struct BinStats {
#         long count = 0;
#         double sum_gc3 = 0.0;
#         double sum_gc  = 0.0;
#         long hyper = 0;
#     };
#     std::vector<BinStats> bins(NBINS);
# 
#     for (const auto &g : genes) {
#         int bin = (int)std::floor(g.rel_frac * NBINS);
#         if (bin < 0) bin = 0;
#         if (bin >= NBINS) bin = NBINS - 1;
#         bins[bin].count++;
#         bins[bin].sum_gc3 += g.gc3_frac;
#         bins[bin].sum_gc  += g.gc_frac;
#         if (g.gc3_frac >= hyper_thr) bins[bin].hyper++;
#     }
# 
#     // Compute per-bin means and collect into vector for ridge stats
#     std::vector<double> bin_mean_gc3;
#     bin_mean_gc3.reserve(NBINS);
#     for (int i = 0; i < NBINS; ++i) {
#         if (bins[i].count > 0) {
#             bin_mean_gc3.push_back(bins[i].sum_gc3 / (double)bins[i].count);
#         }
#     }
# 
#     double mean_bin_gc3, sd_bin_gc3;
#     mean_sd(bin_mean_gc3, mean_bin_gc3, sd_bin_gc3);
# 
#     std::printf("--- GC3 lock ring bins (NBINS=%d) ---\n", NBINS);
#     std::printf("  Bin GC3 mean across occupied bins: mean=%.4f, sd=%.4f\n\n",
#                 mean_bin_gc3, sd_bin_gc3);
# 
#     // Identify top 10 bins by mean GC3
#     struct BinRank {
#         int idx;
#         double mean_gc3;
#     };
#     std::vector<BinRank> ranking;
#     for (int i = 0; i < NBINS; ++i) {
#         if (bins[i].count == 0) continue;
#         double m = bins[i].sum_gc3 / (double)bins[i].count;
#         ranking.push_back({i, m});
#     }
#     std::sort(ranking.begin(), ranking.end(),
#               [](const BinRank &a, const BinRank &b) {
#                   return a.mean_gc3 > b.mean_gc3;
#               });
# 
#     int topN = (int)std::min<size_t>(10, ranking.size());
#     std::printf("--- Top GC3 lock bins around the chromosome ---\n");
#     for (int r = 0; r < topN; ++r) {
#         int i = ranking[r].idx;
#         double m_gc3 = ranking[r].mean_gc3;
#         double frac_start = (double)i / (double)NBINS;
#         double frac_mid   = ((double)i + 0.5) / (double)NBINS;
#         double coord_mid  = frac_mid * L;
#         long cnt = bins[i].count;
#         long hyp = bins[i].hyper;
#         double hyp_frac = (cnt > 0 ? (double)hyp / (double)cnt : 0.0);
#         std::printf("  [BIN %3d] ring_pos=%.3f (mid, %.1f kb) | mean GC3=%.4f | genes=%ld | hyper_frac=%.3f\n",
#                     i, frac_mid, coord_mid / 1000.0, m_gc3, cnt, hyp_frac);
#     }
#     if (topN == 0) {
#         std::printf("  (no bins populated?)\n");
#     }
#     std::printf("\n");
# 
#     // Map name -> index for key loci
#     std::unordered_map<std::string,int> idx;
#     for (size_t i = 0; i < genes.size(); ++i) {
#         if (!idx.count(genes[i].name))
#             idx[genes[i].name] = (int)i;
#     }
# 
#     const char* focus[] = {
#         "yagA","yagE","yagF","yagG","yagH",
#         "rhsD","mdtB","mdtC","mutS",
#         "phnC","phnD","phnE","phnF","phnG","phnH","phnI","phnJ","phnK","phnL","phnM","phnN",
#         "nikB","nikC","ugpA","ugpE"
#     };
# 
#     std::printf("--- Ring positions for key hyper-locked loci (oriC-centered) ---\n");
#     for (const char* name : focus) {
#         auto it = idx.find(name);
#         if (it == idx.end()) {
#             std::printf("  [%s] not found in CDS set.\n", name);
#             continue;
#         }
#         const GeneRing &g = genes[it->second];
#         double bin_pos = g.rel_frac * NBINS;
#         int bin = (int)std::floor(bin_pos);
#         if (bin < 0) bin = 0;
#         if (bin >= NBINS) bin = NBINS - 1;
#         double bin_mean = (bins[bin].count > 0 ?
#                            bins[bin].sum_gc3 / (double)bins[bin].count : 0.0);
#         std::printf("  [%s]\n", name);
#         std::printf("    coords (0-based) : %d-%d (strand=%c)\n", g.start0, g.end0, g.strand);
#         std::printf("    mid position     : %.1f kb (%.4f of chromosome)\n",
#                     g.mid_nt / 1000.0, g.mid_nt / L);
#         std::printf("    rel_frac (0..1)  : %.4f (0=ori, 0.5=opposite side)\n", g.rel_frac);
#         std::printf("    signed_rel       : %.4f (negative just before ori)\n", g.signed_rel);
#         std::printf("    GC3_frac         : %.4f (thr=%.4f)\n", g.gc3_frac, hyper_thr);
#         std::printf("    bin index        : %d / %d | bin_mean_GC3=%.4f | bin_genes=%ld\n",
#                     bin, NBINS, bin_mean, bins[bin].count);
#     }
# 
#     std::printf("\nGENOME-WIDE GC3 LOCK RING analysis finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# nvcc -O3 -std=c++17 warpfrac_dna_gc3_ring.cu -o warpfrac_dna_gc3_ring
# 
# ./warpfrac_dna_gc3_ring /content/ecoli_U00096_3.fna /content/ecoli_U00096_3.gff | tee DNA-L25_gc3_ring.out
# 
# echo
# echo "[DNA-L25] SHA256(stdout) ="
# sha256sum DNA-L25_gc3_ring.out
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_L26_gc3_floor_excess.cu << 'CPP'
# // warpfrac_dna_L26_gc3_floor_excess.cu
# // DNA-L26 — Amino-acid-constrained GC3 lock *floor* vs chosen excess (E. coli MG1655)
# //
# // FIXED VERSION:
# //   * Allow a single stop codon at the LAST codon of the CDS (ignored in GC3 stats).
# //   * Still treat internal stops or unknown codons as translation errors.
# //   * This restores ~all CDS and makes yag*/phn*/nik*/ugp* loci visible again.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <unordered_map>
# #include <cmath>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# static bool read_fasta(const std::string &path, std::string &genome) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         return false;
#     }
#     genome.clear();
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (std::isalpha(static_cast<unsigned char>(c))) {
#                 genome.push_back(std::toupper(static_cast<unsigned char>(c)));
#             }
#         }
#     }
#     return true;
# }
# 
# static std::string extract_attr(const std::string &attr, const char *key) {
#     std::string pat = std::string(key) + "=";
#     size_t pos = attr.find(pat);
#     if (pos == std::string::npos) return "";
#     size_t start = pos + pat.size();
#     size_t end = start;
#     while (end < attr.size() && attr[end] != ';' && attr[end] != '\t' &&
#            attr[end] != '\n' && attr[end] != ' ')
#         ++end;
#     return attr.substr(start, end - start);
# }
# 
# static bool parse_gff_cds(const std::string &path, std::vector<CDSFeature> &cds) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         return false;
#     }
#     cds.clear();
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string col[9];
#         int i = 0;
#         while (i < 9 && std::getline(ss, col[i], '\t')) ++i;
#         if (i < 9) continue;
#         if (col[2] != "CDS") continue;
# 
#         int start = std::atoi(col[3].c_str()); // 1-based
#         int end   = std::atoi(col[4].c_str()); // 1-based
#         if (start <= 0 || end <= 0 || end < start) continue;
# 
#         char strand = col[6].empty() ? '+' : col[6][0];
# 
#         std::string attr = col[8];
#         std::string name;
#         name = extract_attr(attr, "gene");
#         if (name.empty()) name = extract_attr(attr, "locus_tag");
#         if (name.empty()) name = extract_attr(attr, "Name");
#         if (name.empty()) name = extract_attr(attr, "ID");
#         if (name.empty()) {
#             name = col[0] + ":" + col[3] + "-" + col[4];
#         }
# 
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start - 1;
#         f.end0   = end   - 1;
#         f.strand = strand;
#         cds.push_back(f);
#     }
#     return true;
# }
# 
# // Standard genetic code: DNA codons (T instead of U)
# static std::unordered_map<std::string,char> make_codon_table() {
#     std::unordered_map<std::string,char> t;
#     t["TTT"]='F'; t["TTC"]='F'; t["TTA"]='L'; t["TTG"]='L';
#     t["TCT"]='S'; t["TCC"]='S'; t["TCA"]='S'; t["TCG"]='S';
#     t["TAT"]='Y'; t["TAC"]='Y'; t["TAA"]='*'; t["TAG"]='*';
#     t["TGT"]='C'; t["TGC"]='C'; t["TGA"]='*'; t["TGG"]='W';
#     t["CTT"]='L'; t["CTC"]='L'; t["CTA"]='L'; t["CTG"]='L';
#     t["CCT"]='P'; t["CCC"]='P'; t["CCA"]='P'; t["CCG"]='P';
#     t["CAT"]='H'; t["CAC"]='H'; t["CAA"]='Q'; t["CAG"]='Q';
#     t["CGT"]='R'; t["CGC"]='R'; t["CGA"]='R'; t["CGG"]='R';
#     t["ATT"]='I'; t["ATC"]='I'; t["ATA"]='I'; t["ATG"]='M';
#     t["ACT"]='T'; t["ACC"]='T'; t["ACA"]='T'; t["ACG"]='T';
#     t["AAT"]='N'; t["AAC"]='N'; t["AAA"]='K'; t["AAG"]='K';
#     t["AGT"]='S'; t["AGC"]='S'; t["AGA"]='R'; t["AGG"]='R';
#     t["GTT"]='V'; t["GTC"]='V'; t["GTA"]='V'; t["GTG"]='V';
#     t["GCT"]='A'; t["GCC"]='A'; t["GCA"]='A'; t["GCG"]='A';
#     t["GAT"]='D'; t["GAC"]='D'; t["GAA"]='E'; t["GAG"]='E';
#     t["GGT"]='G'; t["GGC"]='G'; t["GGA"]='G'; t["GGG"]='G';
#     return t;
# }
# 
# // Per-amino-acid: does this AA have any AT3 codon? any GC3 codon?
# static void build_aa_AT3_GC3_flags(const std::unordered_map<std::string,char> &table,
#                                    bool has_AT3[26],
#                                    bool has_GC3[26]) {
#     for (int i = 0; i < 26; ++i) { has_AT3[i] = false; has_GC3[i] = false; }
#     for (const auto &kv : table) {
#         const std::string &codon = kv.first;
#         char aa = kv.second;
#         if (aa == '*') continue;
#         int idx = aa - 'A';
#         if (idx < 0 || idx >= 26) continue;
#         char b3 = codon[2];
#         if (b3 == 'A' || b3 == 'T') has_AT3[idx] = true;
#         if (b3 == 'G' || b3 == 'C') has_GC3[idx] = true;
#     }
# }
# 
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'T': return 'A';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         default:  return 'N';
#     }
# }
# 
# struct GeneMetrics {
#     std::string name;
#     int start0, end0;
#     char strand;
#     int nt_len;
#     int codons;            // effective codons used (excluding stop)
#     long real_gc3;
#     long floor_gc3;
#     double real_gc3_frac;
#     double floor_gc3_frac;
#     double excess_gc3_frac;
#     double excess_norm;    // (real - floor)/(1 - floor)
# };
# 
# static double safe_mean(const std::vector<double> &v) {
#     if (v.empty()) return 0.0;
#     double s = 0.0;
#     for (double x : v) s += x;
#     return s / v.size();
# }
# 
# static double safe_sd(const std::vector<double> &v, double mean) {
#     if (v.size() < 2) return 0.0;
#     double s2 = 0.0;
#     for (double x : v) {
#         double d = x - mean;
#         s2 += d * d;
#     }
#     return std::sqrt(s2 / (v.size() - 1));
# }
# 
# int main(int argc, char **argv) {
#     std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     std::string gff_path   = "/content/ecoli_U00096_3.gff";
#     if (argc >= 3) {
#         fasta_path = argv[1];
#         gff_path   = argv[2];
#     }
# 
#     std::printf("----------------------------------------------------------------------------------------------------------------------\n");
#     std::printf("RUNNING DNA-L26 \u2014 GC3 LOCK FLOOR vs CHOSEN EXCESS (AA-constrained, CDS-level)\n");
#     std::printf("----------------------------------------------------------------------------------------------------------------------\n");
#     std::printf("======================================================================================================================\n");
#     std::printf("MODULE DNA-L26 \u2014 AMINO-ACID-CONSTRAINED GC3 LOCK FLOOR vs EXCESS (E. coli MG1655, CDS-level)\n");
#     std::printf("======================================================================================================================\n\n");
# 
#     std::printf("[DNA-L26] FASTA path: %s\n", fasta_path.c_str());
#     std::printf("[DNA-L26] GFF path  : %s\n\n", gff_path.c_str());
# 
#     std::string genome;
#     if (!read_fasta(fasta_path, genome)) return 1;
#     std::printf("Genome loaded: length = %zu bases\n", genome.size());
# 
#     std::vector<CDSFeature> cds;
#     if (!parse_gff_cds(gff_path, cds)) return 1;
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     auto codon_table = make_codon_table();
#     bool aa_has_AT3[26], aa_has_GC3[26];
#     build_aa_AT3_GC3_flags(codon_table, aa_has_AT3, aa_has_GC3);
# 
#     long sum_nt_len = 0;
#     long sum_codons = 0;
#     long sum_real_gc3 = 0;
#     long sum_floor_gc3 = 0;
# 
#     int cds_analyzed = 0;
#     int cds_len_not3 = 0;
#     int cds_ambig = 0;
#     int cds_trans_err = 0;
# 
#     std::vector<GeneMetrics> gm;
#     gm.reserve(cds.size());
# 
#     for (const auto &f : cds) {
#         if (f.start0 < 0 || f.end0 < f.start0 || f.end0 >= (int)genome.size()) continue;
#         int len = f.end0 - f.start0 + 1;
#         if (len <= 0) continue;
#         if (len % 3 != 0) {
#             cds_len_not3++;
#             continue;
#         }
# 
#         std::string seq;
#         seq.reserve(len);
#         bool ambig = false;
#         if (f.strand == '+') {
#             for (int i = f.start0; i <= f.end0; ++i) {
#                 char b = std::toupper(static_cast<unsigned char>(genome[i]));
#                 if (b != 'A' && b != 'C' && b != 'G' && b != 'T') ambig = true;
#                 seq.push_back(b);
#             }
#         } else {
#             for (int i = f.end0; i >= f.start0; --i) {
#                 char b = std::toupper(static_cast<unsigned char>(genome[i]));
#                 if (b != 'A' && b != 'C' && b != 'G' && b != 'T') ambig = true;
#                 seq.push_back(comp_base(b));
#             }
#         }
#         if (ambig) {
#             cds_ambig++;
#             continue;
#         }
# 
#         int n_codons = len / 3;
#         long real_gc3 = 0;
#         long floor_gc3 = 0;
#         bool trans_err = false;
#         int effective_codons = 0;
# 
#         for (int i = 0; i < n_codons; ++i) {
#             char c1 = seq[3*i+0];
#             char c2 = seq[3*i+1];
#             char c3 = seq[3*i+2];
#             std::string codon;
#             codon.push_back(c1);
#             codon.push_back(c2);
#             codon.push_back(c3);
# 
#             auto it = codon_table.find(codon);
#             if (it == codon_table.end()) {
#                 trans_err = true;
#                 break;
#             }
#             char aa = it->second;
# 
#             if (aa == '*') {
#                 // Allow a stop ONLY at the final codon; ignore it in GC3 stats.
#                 if (i != n_codons - 1) {
#                     trans_err = true;
#                 }
#                 break;
#             }
# 
#             effective_codons++;
# 
#             if (c3 == 'G' || c3 == 'C') {
#                 real_gc3++;
#             }
#             int idx = aa - 'A';
#             if (idx >= 0 && idx < 26) {
#                 if (!aa_has_AT3[idx]) {
#                     // This AA has no AT3 codon at all → intrinsically GC3-locked.
#                     floor_gc3++;
#                 }
#             }
#         }
# 
#         if (trans_err || effective_codons == 0) {
#             cds_trans_err++;
#             continue;
#         }
# 
#         cds_analyzed++;
#         sum_nt_len   += len;
#         sum_codons   += effective_codons;
#         sum_real_gc3 += real_gc3;
#         sum_floor_gc3 += floor_gc3;
# 
#         GeneMetrics g;
#         g.name   = f.name;
#         g.start0 = f.start0;
#         g.end0   = f.end0;
#         g.strand = f.strand;
#         g.nt_len = len;
#         g.codons = effective_codons;
#         g.real_gc3 = real_gc3;
#         g.floor_gc3 = floor_gc3;
#         g.real_gc3_frac  = (double)real_gc3  / (double)effective_codons;
#         g.floor_gc3_frac = (double)floor_gc3 / (double)effective_codons;
#         g.excess_gc3_frac = g.real_gc3_frac - g.floor_gc3_frac;
#         if (g.floor_gc3_frac >= 1.0 - 1e-9) {
#             g.excess_norm = 0.0;
#         } else {
#             double denom = 1.0 - g.floor_gc3_frac;
#             g.excess_norm = denom > 0 ? g.excess_gc3_frac / denom : 0.0;
#         }
#         gm.push_back(g);
#     }
# 
#     std::printf("=====================================================================================\n");
#     std::printf("GC3 LOCK FLOOR vs CHOSEN EXCESS \u2014 E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n\n");
# 
#     std::printf("CDS summary:\n");
#     std::printf("  CDS features in GFF             : %zu\n", cds.size());
#     std::printf("  CDS with valid AA-locked stats  : %d\n", cds_analyzed);
#     std::printf("  CDS skipped (len %% 3 != 0)      : %d\n", cds_len_not3);
#     std::printf("  CDS skipped (ambiguous bases)   : %d\n", cds_ambig);
#     std::printf("  CDS skipped (translation errors): %d\n\n", cds_trans_err);
# 
#     std::printf("--- Global GC3 lock floor stats (CDS-level) ---\n");
#     std::printf("  Sum CDS length                 : %ld bases\n", sum_nt_len);
#     std::printf("  Sum codons                     : %ld\n", sum_codons);
#     std::printf("  Total real GC3 codons         : %ld\n", sum_real_gc3);
#     std::printf("  Total min GC3 codons (AA-floor): %ld\n", sum_floor_gc3);
#     double real_gc3_global  = (sum_codons > 0) ? (double)sum_real_gc3  / (double)sum_codons : 0.0;
#     double floor_gc3_global = (sum_codons > 0) ? (double)sum_floor_gc3 / (double)sum_codons : 0.0;
#     std::printf("  Codon-weighted real GC3_frac   : %.4f\n", real_gc3_global);
#     std::printf("  Codon-weighted min  GC3_frac   : %.4f\n", floor_gc3_global);
#     std::printf("  Codon-weighted excess GC3_frac : %.4f\n\n", real_gc3_global - floor_gc3_global);
# 
#     std::vector<double> real_v, floor_v, excess_v, excess_norm_v;
#     real_v.reserve(gm.size());
#     floor_v.reserve(gm.size());
#     excess_v.reserve(gm.size());
#     excess_norm_v.reserve(gm.size());
# 
#     int genes_floor_zero = 0;
#     int genes_floor_gt0  = 0;
#     int genes_floor_gt_0_1 = 0;
#     int genes_floor_gt_0_2 = 0;
# 
#     for (const auto &g : gm) {
#         real_v.push_back(g.real_gc3_frac);
#         floor_v.push_back(g.floor_gc3_frac);
#         excess_v.push_back(g.excess_gc3_frac);
#         excess_norm_v.push_back(g.excess_norm);
#         if (g.floor_gc3_frac <= 1e-9) genes_floor_zero++;
#         else genes_floor_gt0++;
#         if (g.floor_gc3_frac > 0.10) genes_floor_gt_0_1++;
#         if (g.floor_gc3_frac > 0.20) genes_floor_gt_0_2++;
#     }
# 
#     double mean_real   = safe_mean(real_v);
#     double sd_real     = safe_sd(real_v, mean_real);
#     double mean_floor  = safe_mean(floor_v);
#     double sd_floor    = safe_sd(floor_v, mean_floor);
#     double mean_excess = safe_mean(excess_v);
#     double sd_excess   = safe_sd(excess_v, mean_excess);
#     double mean_exn    = safe_mean(excess_norm_v);
#     double sd_exn      = safe_sd(excess_norm_v, mean_exn);
# 
#     std::printf("  Real GC3_frac per CDS   : mean = %.4f, sd = %.4f\n", mean_real,  sd_real);
#     std::printf("  Min  GC3_frac per CDS   : mean = %.4f, sd = %.4f\n", mean_floor, sd_floor);
#     std::printf("  Excess GC3_frac per CDS : mean = %.4f, sd = %.4f\n", mean_excess, sd_excess);
#     std::printf("  Norm. excess (0..1)     : mean = %.4f, sd = %.4f\n\n", mean_exn, sd_exn);
# 
#     std::printf("  Genes with GC3_floor == 0        : %d\n", genes_floor_zero);
#     std::printf("  Genes with GC3_floor > 0         : %d\n", genes_floor_gt0);
#     std::printf("  Genes with GC3_floor > 0.10      : %d\n", genes_floor_gt_0_1);
#     std::printf("  Genes with GC3_floor > 0.20      : %d\n\n", genes_floor_gt_0_2);
# 
#     // Top 10 by intrinsic floor
#     std::vector<GeneMetrics> gm_floor = gm;
#     std::sort(gm_floor.begin(), gm_floor.end(),
#               [](const GeneMetrics &a, const GeneMetrics &b){
#                   if (a.floor_gc3_frac != b.floor_gc3_frac)
#                       return a.floor_gc3_frac > b.floor_gc3_frac;
#                   return a.real_gc3_frac > b.real_gc3_frac;
#               });
# 
#     std::printf("--- Top 10 genes by intrinsic GC3 lock floor (AA-constrained min_GC3_frac) ---\n");
#     int topN = std::min<int>(10, gm_floor.size());
#     for (int i = 0; i < topN; ++i) {
#         const auto &g = gm_floor[i];
#         std::printf("  [%2d] %-10s | codons=%4d | real_GC3=%.4f | min_GC3=%.4f | excess=%.4f | norm_excess=%.4f\n",
#                     i+1, g.name.c_str(), g.codons,
#                     g.real_gc3_frac, g.floor_gc3_frac,
#                     g.excess_gc3_frac, g.excess_norm);
#     }
#     std::printf("\n");
# 
#     // Top 10 by chosen excess
#     std::vector<GeneMetrics> gm_excess = gm;
#     std::sort(gm_excess.begin(), gm_excess.end(),
#               [](const GeneMetrics &a, const GeneMetrics &b){
#                   if (a.excess_gc3_frac != b.excess_gc3_frac)
#                       return a.excess_gc3_frac > b.excess_gc3_frac;
#                   return a.real_gc3_frac > b.real_gc3_frac;
#               });
# 
#     std::printf("--- Top 10 genes by chosen GC3 lock excess (real_GC3_frac - min_GC3_frac) ---\n");
#     topN = std::min<int>(10, gm_excess.size());
#     for (int i = 0; i < topN; ++i) {
#         const auto &g = gm_excess[i];
#         std::printf("  [%2d] %-10s | codons=%4d | real_GC3=%.4f | min_GC3=%.4f | excess=%.4f | norm_excess=%.4f\n",
#                     i+1, g.name.c_str(), g.codons,
#                     g.real_gc3_frac, g.floor_gc3_frac,
#                     g.excess_gc3_frac, g.excess_norm);
#     }
#     std::printf("\n");
# 
#     // Lookup for key loci
#     std::unordered_map<std::string,const GeneMetrics*> by_name;
#     for (const auto &g : gm) {
#         by_name[g.name] = &g;
#     }
# 
#     auto print_locus = [&](const char *gene){
#         auto it = by_name.find(gene);
#         if (it == by_name.end()) {
#             std::printf("  [%s] not found in CDS set.\n", gene);
#             return;
#         }
#         const GeneMetrics &g = *it->second;
#         double z_real   = (sd_real   > 0 ? (g.real_gc3_frac   - mean_real)   / sd_real   : 0.0);
#         double z_excess = (sd_excess > 0 ? (g.excess_gc3_frac - mean_excess) / sd_excess : 0.0);
#         std::printf("  [%s] GC3 lock floor vs excess:\n", gene);
#         std::printf("    coords            : %d-%d (strand=%c)\n", g.start0, g.end0, g.strand);
#         std::printf("    nt_len / codons   : %d / %d\n", g.nt_len, g.codons);
#         std::printf("    real_GC3_frac     : %.4f (z= %.2f)\n", g.real_gc3_frac, z_real);
#         std::printf("    min_GC3_floor     : %.4f\n", g.floor_gc3_frac);
#         std::printf("    excess_GC3        : %.4f (z= %.2f)\n", g.excess_gc3_frac, z_excess);
#         std::printf("    excess_norm (0..1): %.4f\n", g.excess_norm);
#     };
# 
#     std::printf("--- GC3 lock floor vs chosen excess for selected loci ---\n");
#     const char* loci[] = {
#         "yagA","yagE","yagF","yagG","yagH",
#         "rhsD","mdtB","mdtC","mutS",
#         "phnC","phnD","phnE","phnF","phnG","phnH","phnI","phnJ","phnK","phnL","phnM","phnN",
#         "nikB","nikC","ugpA","ugpE",
#         nullptr
#     };
#     for (int i = 0; loci[i] != nullptr; ++i) {
#         print_locus(loci[i]);
#     }
# 
#     std::printf("\nGC3 LOCK FLOOR vs CHOSEN EXCESS analysis finished.\n");
#     std::printf("=====================================================================================\n");
# 
#     return 0;
# }
# CPP
# 
# nvcc -std=c++17 -O3 warpfrac_dna_L26_gc3_floor_excess.cu -o dna_L26_gc3_floor_excess
# 
# ./dna_L26_gc3_floor_excess /content/ecoli_U00096_3.fna /content/ecoli_U00096_3.gff
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_L27_gc3_excess_coupling.cu << 'CPP'
# // warpfrac_dna_L27_gc3_excess_coupling.cu
# // DNA-L27 — GC3 excess coupling to lock codon rails & CpG (E. coli MG1655, CDS-level)
# //
# // For each CDS we compute:
# //   - real_GC3_frac (GC at 3rd codon position)
# //   - AA-based GC3_floor (min_GC3_frac given its AA sequence)
# //   - excess_GC3_frac = real - floor
# //   - excess_norm = (real - floor)/(1 - floor)
# //   - lock_codon_frac using the 19 lock codons from DNA-L18
# //   - CpG_per_kb within the CDS
# //
# // Then we compute correlations:
# //   - corr(excess_GC3, lock_codon_frac)
# //   - corr(excess_GC3, CpG_per_kb)
# //   - corr(real_GC3, lock_codon_frac), corr(real_GC3, CpG_per_kb)
# // And print a top-10 hyper-excess set plus detailed stats for key loci.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <unordered_map>
# #include <unordered_set>
# #include <cmath>
# 
# struct CDSFeature {
#     std::string name;
#     int start0;   // 0-based inclusive
#     int end0;     // 0-based inclusive
#     char strand;  // '+' or '-'
# };
# 
# static bool read_fasta(const std::string &path, std::string &genome) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         return false;
#     }
#     genome.clear();
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (std::isalpha(static_cast<unsigned char>(c))) {
#                 genome.push_back(std::toupper(static_cast<unsigned char>(c)));
#             }
#         }
#     }
#     return true;
# }
# 
# static std::string extract_attr(const std::string &attr, const char *key) {
#     std::string pat = std::string(key) + "=";
#     size_t pos = attr.find(pat);
#     if (pos == std::string::npos) return "";
#     size_t start = pos + pat.size();
#     size_t end = start;
#     while (end < attr.size() && attr[end] != ';' && attr[end] != '\t' &&
#            attr[end] != '\n' && attr[end] != ' ')
#         ++end;
#     return attr.substr(start, end - start);
# }
# 
# static bool parse_gff_cds(const std::string &path, std::vector<CDSFeature> &cds) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         return false;
#     }
#     cds.clear();
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string col[9];
#         int i = 0;
#         while (i < 9 && std::getline(ss, col[i], '\t')) ++i;
#         if (i < 9) continue;
#         if (col[2] != "CDS") continue;
# 
#         int start = std::atoi(col[3].c_str());
#         int end   = std::atoi(col[4].c_str());
#         if (start <= 0 || end <= 0 || end < start) continue;
# 
#         char strand = col[6].empty() ? '+' : col[6][0];
# 
#         std::string attr = col[8];
#         std::string name;
#         name = extract_attr(attr, "gene");
#         if (name.empty()) name = extract_attr(attr, "locus_tag");
#         if (name.empty()) name = extract_attr(attr, "Name");
#         if (name.empty()) name = extract_attr(attr, "ID");
#         if (name.empty()) name = col[0] + ":" + col[3] + "-" + col[4];
# 
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start - 1;
#         f.end0   = end   - 1;
#         f.strand = strand;
#         cds.push_back(f);
#     }
#     return true;
# }
# 
# // Standard genetic code for DNA (T instead of U)
# static std::unordered_map<std::string,char> make_codon_table() {
#     std::unordered_map<std::string,char> t;
#     t["TTT"]='F'; t["TTC"]='F'; t["TTA"]='L'; t["TTG"]='L';
#     t["TCT"]='S'; t["TCC"]='S'; t["TCA"]='S'; t["TCG"]='S';
#     t["TAT"]='Y'; t["TAC"]='Y'; t["TAA"]='*'; t["TAG"]='*';
#     t["TGT"]='C'; t["TGC"]='C'; t["TGA"]='*'; t["TGG"]='W';
#     t["CTT"]='L'; t["CTC"]='L'; t["CTA"]='L'; t["CTG"]='L';
#     t["CCT"]='P'; t["CCC"]='P'; t["CCA"]='P'; t["CCG"]='P';
#     t["CAT"]='H'; t["CAC"]='H'; t["CAA"]='Q'; t["CAG"]='Q';
#     t["CGT"]='R'; t["CGC"]='R'; t["CGA"]='R'; t["CGG"]='R';
#     t["ATT"]='I'; t["ATC"]='I'; t["ATA"]='I'; t["ATG"]='M';
#     t["ACT"]='T'; t["ACC"]='T'; t["ACA"]='T'; t["ACG"]='T';
#     t["AAT"]='N'; t["AAC"]='N'; t["AAA"]='K'; t["AAG"]='K';
#     t["AGT"]='S'; t["AGC"]='S'; t["AGA"]='R'; t["AGG"]='R';
#     t["GTT"]='V'; t["GTC"]='V'; t["GTA"]='V'; t["GTG"]='V';
#     t["GCT"]='A'; t["GCC"]='A'; t["GCA"]='A'; t["GCG"]='A';
#     t["GAT"]='D'; t["GAC"]='D'; t["GAA"]='E'; t["GAG"]='E';
#     t["GGT"]='G'; t["GGC"]='G'; t["GGA"]='G'; t["GGG"]='G';
#     return t;
# }
# 
# static void build_aa_AT3_flags(const std::unordered_map<std::string,char> &table,
#                                bool has_AT3[26]) {
#     for (int i = 0; i < 26; ++i) has_AT3[i] = false;
#     for (const auto &kv : table) {
#         const std::string &codon = kv.first;
#         char aa = kv.second;
#         if (aa == '*') continue;
#         int idx = aa - 'A';
#         if (idx < 0 || idx >= 26) continue;
#         char b3 = codon[2];
#         if (b3 == 'A' || b3 == 'T') has_AT3[idx] = true;
#     }
# }
# 
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'T': return 'A';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         default:  return 'N';
#     }
# }
# 
# struct GeneMetrics {
#     std::string name;
#     int start0, end0;
#     char strand;
#     int nt_len;
#     int codons;            // effective codons (excluding terminal stop)
#     long real_gc3;
#     long floor_gc3;
#     long lock_codons;
#     long cpg_count;
#     double real_gc3_frac;
#     double floor_gc3_frac;
#     double excess_gc3_frac;
#     double excess_norm;
#     double lock_frac;
#     double cpg_per_kb;
# };
# 
# static double safe_mean(const std::vector<double> &v) {
#     if (v.empty()) return 0.0;
#     double s = 0.0;
#     for (double x : v) s += x;
#     return s / v.size();
# }
# 
# static double safe_sd(const std::vector<double> &v, double mean) {
#     if (v.size() < 2) return 0.0;
#     double s2 = 0.0;
#     for (double x : v) {
#         double d = x - mean;
#         s2 += d * d;
#     }
#     return std::sqrt(s2 / (v.size() - 1));
# }
# 
# static double safe_corr(const std::vector<double> &x, const std::vector<double> &y) {
#     size_t n = x.size();
#     if (n != y.size() || n < 2) return 0.0;
#     double mx = safe_mean(x);
#     double my = safe_mean(y);
#     double sx2 = 0.0, sy2 = 0.0, sxy = 0.0;
#     for (size_t i = 0; i < n; ++i) {
#         double dx = x[i] - mx;
#         double dy = y[i] - my;
#         sx2 += dx * dx;
#         sy2 += dy * dy;
#         sxy += dx * dy;
#     }
#     if (sx2 <= 0.0 || sy2 <= 0.0) return 0.0;
#     return sxy / std::sqrt(sx2 * sy2);
# }
# 
# int main(int argc, char **argv) {
#     std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     std::string gff_path   = "/content/ecoli_U00096_3.gff";
#     if (argc >= 3) {
#         fasta_path = argv[1];
#         gff_path   = argv[2];
#     }
# 
#     std::printf("----------------------------------------------------------------------------------------------------------------------\n");
#     std::printf("RUNNING DNA-L27 \u2014 GC3 EXCESS COUPLING TO LOCK RAILS & CpG (CDS-level)\n");
#     std::printf("----------------------------------------------------------------------------------------------------------------------\n");
#     std::printf("======================================================================================================================\n");
#     std::printf("MODULE DNA-L27 \u2014 GC3 EXCESS COUPLING TO LOCK CODONS & CpG (E. coli MG1655, CDS-level)\n");
#     std::printf("======================================================================================================================\n\n");
# 
#     std::printf("[DNA-L27] FASTA path: %s\n", fasta_path.c_str());
#     std::printf("[DNA-L27] GFF path  : %s\n\n", gff_path.c_str());
# 
#     std::string genome;
#     if (!read_fasta(fasta_path, genome)) return 1;
#     std::printf("Genome loaded: length = %zu bases\n", genome.size());
# 
#     std::vector<CDSFeature> cds;
#     if (!parse_gff_cds(gff_path, cds)) return 1;
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     auto codon_table = make_codon_table();
#     bool aa_has_AT3[26];
#     build_aa_AT3_flags(codon_table, aa_has_AT3);
# 
#     // Lock codon set from DNA-L18
#     std::unordered_set<std::string> lock_codons = {
#         "TCG","TTC","GTG","CTC","GGC","CAC","CGC","CCG","CTG",
#         "TAC","ACC","TCC","GAC","GCG","GCC","TGC","TGG","ATC","GAG"
#     };
# 
#     long sum_nt_len = 0;
#     long sum_codons = 0;
#     long sum_real_gc3 = 0;
#     long sum_floor_gc3 = 0;
#     long sum_lock_codons = 0;
#     long sum_cpg = 0;
# 
#     int cds_analyzed = 0;
#     int cds_len_not3 = 0;
#     int cds_ambig = 0;
#     int cds_trans_err = 0;
# 
#     std::vector<GeneMetrics> gm;
#     gm.reserve(cds.size());
# 
#     for (const auto &f : cds) {
#         if (f.start0 < 0 || f.end0 < f.start0 || f.end0 >= (int)genome.size()) continue;
#         int len = f.end0 - f.start0 + 1;
#         if (len <= 0) continue;
#         if (len % 3 != 0) {
#             cds_len_not3++;
#             continue;
#         }
# 
#         std::string seq;
#         seq.reserve(len);
#         bool ambig = false;
#         if (f.strand == '+') {
#             for (int i = f.start0; i <= f.end0; ++i) {
#                 char b = std::toupper(static_cast<unsigned char>(genome[i]));
#                 if (b != 'A' && b != 'C' && b != 'G' && b != 'T') ambig = true;
#                 seq.push_back(b);
#             }
#         } else {
#             for (int i = f.end0; i >= f.start0; --i) {
#                 char b = std::toupper(static_cast<unsigned char>(genome[i]));
#                 if (b != 'A' && b != 'C' && b != 'G' && b != 'T') ambig = true;
#                 seq.push_back(comp_base(b));
#             }
#         }
#         if (ambig) {
#             cds_ambig++;
#             continue;
#         }
# 
#         // count CpG inside CDS (nucleotide-level)
#         long cpg = 0;
#         for (int i = 0; i + 1 < len; ++i) {
#             if (seq[i] == 'C' && seq[i+1] == 'G') cpg++;
#         }
# 
#         int n_codons = len / 3;
#         long real_gc3 = 0;
#         long floor_gc3 = 0;
#         long lock_count = 0;
# 
#         bool trans_err = false;
#         int effective_codons = 0;
# 
#         for (int i = 0; i < n_codons; ++i) {
#             char c1 = seq[3*i+0];
#             char c2 = seq[3*i+1];
#             char c3 = seq[3*i+2];
#             std::string codon;
#             codon.push_back(c1);
#             codon.push_back(c2);
#             codon.push_back(c3);
# 
#             auto it = codon_table.find(codon);
#             if (it == codon_table.end()) {
#                 trans_err = true;
#                 break;
#             }
#             char aa = it->second;
# 
#             if (aa == '*') {
#                 // allow stop ONLY at terminal codon; ignore it in all stats
#                 if (i != n_codons - 1) {
#                     trans_err = true;
#                 }
#                 break;
#             }
# 
#             effective_codons++;
# 
#             if (c3 == 'G' || c3 == 'C') {
#                 real_gc3++;
#             }
#             if (lock_codons.count(codon)) {
#                 lock_count++;
#             }
# 
#             int idx = aa - 'A';
#             if (idx >= 0 && idx < 26) {
#                 if (!aa_has_AT3[idx]) {
#                     floor_gc3++;
#                 }
#             }
#         }
# 
#         if (trans_err || effective_codons == 0) {
#             cds_trans_err++;
#             continue;
#         }
# 
#         cds_analyzed++;
#         sum_nt_len      += len;
#         sum_codons      += effective_codons;
#         sum_real_gc3    += real_gc3;
#         sum_floor_gc3   += floor_gc3;
#         sum_lock_codons += lock_count;
#         sum_cpg         += cpg;
# 
#         GeneMetrics g;
#         g.name   = f.name;
#         g.start0 = f.start0;
#         g.end0   = f.end0;
#         g.strand = f.strand;
#         g.nt_len = len;
#         g.codons = effective_codons;
#         g.real_gc3 = real_gc3;
#         g.floor_gc3 = floor_gc3;
#         g.lock_codons = lock_count;
#         g.cpg_count = cpg;
# 
#         g.real_gc3_frac  = (double)real_gc3  / (double)effective_codons;
#         g.floor_gc3_frac = (double)floor_gc3 / (double)effective_codons;
#         g.excess_gc3_frac = g.real_gc3_frac - g.floor_gc3_frac;
#         if (g.floor_gc3_frac >= 1.0 - 1e-9) {
#             g.excess_norm = 0.0;
#         } else {
#             double denom = 1.0 - g.floor_gc3_frac;
#             g.excess_norm = denom > 0 ? g.excess_gc3_frac / denom : 0.0;
#         }
#         g.lock_frac   = (double)lock_count / (double)effective_codons;
#         g.cpg_per_kb  = (len > 0) ? (double)cpg * 1000.0 / (double)len : 0.0;
# 
#         gm.push_back(g);
#     }
# 
#     std::printf("=====================================================================================\n");
#     std::printf("GC3 EXCESS COUPLING TO LOCK CODONS & CpG \u2014 E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n\n");
# 
#     std::printf("CDS summary:\n");
#     std::printf("  CDS features in GFF             : %zu\n", cds.size());
#     std::printf("  CDS with valid excess stats     : %d\n", cds_analyzed);
#     std::printf("  CDS skipped (len %% 3 != 0)      : %d\n", cds_len_not3);
#     std::printf("  CDS skipped (ambiguous bases)   : %d\n", cds_ambig);
#     std::printf("  CDS skipped (translation errors): %d\n\n", cds_trans_err);
# 
#     std::printf("--- Global GC3 excess + rails/CpG stats (CDS-level) ---\n");
#     std::printf("  Sum CDS length           : %ld bases\n", sum_nt_len);
#     std::printf("  Sum codons               : %ld\n", sum_codons);
#     std::printf("  Total real GC3 codons    : %ld\n", sum_real_gc3);
#     std::printf("  Total min GC3 codons     : %ld\n", sum_floor_gc3);
#     std::printf("  Total lock codons        : %ld\n", sum_lock_codons);
#     std::printf("  Total CpG dinucleotides  : %ld\n", sum_cpg);
#     double real_gc3_global  = (sum_codons > 0) ? (double)sum_real_gc3  / (double)sum_codons : 0.0;
#     double floor_gc3_global = (sum_codons > 0) ? (double)sum_floor_gc3 / (double)sum_codons : 0.0;
#     double lock_frac_global = (sum_codons > 0) ? (double)sum_lock_codons / (double)sum_codons : 0.0;
#     double cpg_per_kb_global = (sum_nt_len > 0) ? (double)sum_cpg * 1000.0 / (double)sum_nt_len : 0.0;
#     std::printf("  Codon-weighted real GC3_frac    : %.4f\n", real_gc3_global);
#     std::printf("  Codon-weighted min  GC3_frac    : %.4f\n", floor_gc3_global);
#     std::printf("  Codon-weighted excess GC3_frac  : %.4f\n", real_gc3_global - floor_gc3_global);
#     std::printf("  Codon-weighted lock_codon_frac  : %.4f\n", lock_frac_global);
#     std::printf("  Genome CpG_per_kb (CDS)         : %.2f\n\n", cpg_per_kb_global);
# 
#     std::vector<double> real_v, floor_v, excess_v, excess_norm_v, lock_v, cpg_v;
#     real_v.reserve(gm.size());
#     floor_v.reserve(gm.size());
#     excess_v.reserve(gm.size());
#     excess_norm_v.reserve(gm.size());
#     lock_v.reserve(gm.size());
#     cpg_v.reserve(gm.size());
# 
#     for (const auto &g : gm) {
#         real_v.push_back(g.real_gc3_frac);
#         floor_v.push_back(g.floor_gc3_frac);
#         excess_v.push_back(g.excess_gc3_frac);
#         excess_norm_v.push_back(g.excess_norm);
#         lock_v.push_back(g.lock_frac);
#         cpg_v.push_back(g.cpg_per_kb);
#     }
# 
#     double mean_real   = safe_mean(real_v);
#     double sd_real     = safe_sd(real_v, mean_real);
#     double mean_floor  = safe_mean(floor_v);
#     double sd_floor    = safe_sd(floor_v, mean_floor);
#     double mean_excess = safe_mean(excess_v);
#     double sd_excess   = safe_sd(excess_v, mean_excess);
#     double mean_exnorm = safe_mean(excess_norm_v);
#     double sd_exnorm   = safe_sd(excess_norm_v, mean_exnorm);
#     double mean_lock   = safe_mean(lock_v);
#     double sd_lock     = safe_sd(lock_v, mean_lock);
#     double mean_cpg    = safe_mean(cpg_v);
#     double sd_cpg      = safe_sd(cpg_v, mean_cpg);
# 
#     std::printf("  real_GC3_frac per CDS    : mean=%.4f, sd=%.4f\n", mean_real,   sd_real);
#     std::printf("  floor_GC3_frac per CDS   : mean=%.4f, sd=%.4f\n", mean_floor,  sd_floor);
#     std::printf("  excess_GC3_frac per CDS  : mean=%.4f, sd=%.4f\n", mean_excess, sd_excess);
#     std::printf("  norm_excess (0..1) per CDS: mean=%.4f, sd=%.4f\n", mean_exnorm, sd_exnorm);
#     std::printf("  lock_codon_frac per CDS  : mean=%.4f, sd=%.4f\n", mean_lock,   sd_lock);
#     std::printf("  CpG_per_kb per CDS       : mean=%.4f, sd=%.4f\n\n", mean_cpg,  sd_cpg);
# 
#     // Correlations
#     double corr_real_lock   = safe_corr(real_v, lock_v);
#     double corr_real_cpg    = safe_corr(real_v, cpg_v);
#     double corr_floor_real  = safe_corr(floor_v, real_v);
#     double corr_excess_lock = safe_corr(excess_v, lock_v);
#     double corr_excess_cpg  = safe_corr(excess_v, cpg_v);
# 
#     std::printf("--- Pearson correlations (CDS-level) ---\n");
#     std::printf("  corr(real_GC3_frac, floor_GC3_frac)  = %.4f\n", corr_floor_real);
#     std::printf("  corr(real_GC3_frac, lock_codon_frac) = %.4f\n", corr_real_lock);
#     std::printf("  corr(real_GC3_frac, CpG_per_kb)      = %.4f\n", corr_real_cpg);
#     std::printf("  corr(excess_GC3_frac, lock_frac)     = %.4f\n", corr_excess_lock);
#     std::printf("  corr(excess_GC3_frac, CpG_per_kb)    = %.4f\n\n", corr_excess_cpg);
# 
#     // Top 10 by GC3 excess (z_excess)
#     std::vector<GeneMetrics> gm_excess = gm;
#     std::sort(gm_excess.begin(), gm_excess.end(),
#               [](const GeneMetrics &a, const GeneMetrics &b){
#                   if (a.excess_gc3_frac != b.excess_gc3_frac)
#                       return a.excess_gc3_frac > b.excess_gc3_frac;
#                   return a.real_gc3_frac > b.real_gc3_frac;
#               });
# 
#     std::printf("--- Top 10 genes by GC3 lock excess (real_GC3_frac - floor_GC3_frac) ---\n");
#     int topN = std::min<int>(10, gm_excess.size());
#     for (int i = 0; i < topN; ++i) {
#         const auto &g = gm_excess[i];
#         double z_excess = (sd_excess > 0 ? (g.excess_gc3_frac - mean_excess) / sd_excess : 0.0);
#         std::printf("  [%2d] %-10s | codons=%4d | real_GC3=%.4f | floor_GC3=%.4f | excess=%.4f (z= %.2f)\n",
#                     i+1, g.name.c_str(), g.codons,
#                     g.real_gc3_frac, g.floor_gc3_frac,
#                     g.excess_gc3_frac, z_excess);
#         std::printf("       lock_frac=%.4f | CpG_per_kb=%.2f\n",
#                     g.lock_frac, g.cpg_per_kb);
#     }
#     std::printf("\n");
# 
#     // Build lookup by name for selected loci
#     std::unordered_map<std::string,const GeneMetrics*> by_name;
#     for (const auto &g : gm) {
#         by_name[g.name] = &g;
#     }
# 
#     auto print_locus = [&](const char *gene){
#         auto it = by_name.find(gene);
#         if (it == by_name.end()) {
#             std::printf("  [%s] not found in CDS set.\n", gene);
#             return;
#         }
#         const GeneMetrics &g = *it->second;
#         double z_real   = (sd_real   > 0 ? (g.real_gc3_frac   - mean_real)   / sd_real   : 0.0);
#         double z_excess = (sd_excess > 0 ? (g.excess_gc3_frac - mean_excess) / sd_excess : 0.0);
#         double z_lock   = (sd_lock   > 0 ? (g.lock_frac       - mean_lock)   / sd_lock   : 0.0);
#         double z_cpg    = (sd_cpg    > 0 ? (g.cpg_per_kb      - mean_cpg)    / sd_cpg    : 0.0);
#         std::printf("  [%s] GC3 excess vs rails/CpG:\n", gene);
#         std::printf("    coords           : %d-%d (strand=%c)\n", g.start0, g.end0, g.strand);
#         std::printf("    nt_len / codons  : %d / %d\n", g.nt_len, g.codons);
#         std::printf("    real_GC3_frac    : %.4f (z= %.2f)\n", g.real_gc3_frac, z_real);
#         std::printf("    floor_GC3_frac   : %.4f\n", g.floor_gc3_frac);
#         std::printf("    excess_GC3_frac  : %.4f (z= %.2f)\n", g.excess_gc3_frac, z_excess);
#         std::printf("    excess_norm (0..1): %.4f\n", g.excess_norm);
#         std::printf("    lock_codon_frac  : %.4f (z= %.2f)\n", g.lock_frac, z_lock);
#         std::printf("    CpG_per_kb       : %.2f (z= %.2f)\n", g.cpg_per_kb, z_cpg);
#     };
# 
#     std::printf("--- GC3 excess vs rails/CpG for selected loci ---\n");
#     const char* loci[] = {
#         "yagA","yagE","yagF","yagG","yagH",
#         "rhsD","mdtB","mdtC","mutS",
#         "phnC","phnD","phnE","phnF","phnG","phnH","phnI","phnJ","phnK","phnL","phnM","phnN",
#         "nikB","nikC","ugpA","ugpE",
#         nullptr
#     };
#     for (int i = 0; loci[i] != nullptr; ++i) {
#         print_locus(loci[i]);
#     }
# 
#     std::printf("\nGC3 EXCESS COUPLING TO LOCK CODONS & CpG analysis finished.\n");
#     std::printf("=====================================================================================\n");
# 
#     return 0;
# }
# CPP
# 
# nvcc -std=c++17 -O3 warpfrac_dna_L27_gc3_excess_coupling.cu -o dna_L27_gc3_excess_coupling
# 
# ./dna_L27_gc3_excess_coupling /content/ecoli_U00096_3.fna /content/ecoli_U00096_3.gff
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_L28_synonymous_rails_cpg_control.cu << 'CPP'
# // warpfrac_dna_L28_synonymous_rails_cpg_control.cu
# // DNA-L28 — Synonymous randomization control for lock codons & CpG (E. coli MG1655, CDS-level)
# //
# // For each CDS:
# //   - Extract AA sequence (ignoring terminal stop).
# //   - For each AA, get list of synonymous codons from the standard code.
# //   - Real metrics (already familiar):
# //       * lock_codon_frac_real
# //       * CpG_per_kb_real
# //   - Random control:
# //       * For N_SHUFFLES iterations, for each AA position,
# //         choose a random synonymous codon, build a randomized CDS,
# //         compute lock_codon_frac_rand and CpG_per_kb_rand.
# //   - From these, compute per gene:
# //       * exp_lock_frac, sd_lock_frac
# //       * exp_CpG_per_kb, sd_CpG_per_kb
# //       * z_lock_excess  = (real - exp) / sd (if sd>0, else 0)
# //       * z_CpG_excess   = (real - exp) / sd (if sd>0, else 0)
# //
# // Prints:
# //   - Global summary.
# //   - Correlations real vs expected.
# //   - Top 10 genes by z_lock_excess and z_CpG_excess.
# //   - Detailed block for key loci.
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <unordered_map>
# #include <unordered_set>
# #include <random>
# #include <cmath>
# 
# // ----------------- Shared helpers (FASTA, GFF, codon table) -----------------
# 
# struct CDSFeature {
#     std::string name;
#     int start0;
#     int end0;
#     char strand;  // '+' or '-'
# };
# 
# static bool read_fasta(const std::string &path, std::string &genome) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         return false;
#     }
#     genome.clear();
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty()) continue;
#         if (line[0] == '>') continue;
#         for (char c : line) {
#             if (std::isalpha(static_cast<unsigned char>(c))) {
#                 genome.push_back(std::toupper(static_cast<unsigned char>(c)));
#             }
#         }
#     }
#     return true;
# }
# 
# static std::string extract_attr(const std::string &attr, const char *key) {
#     std::string pat = std::string(key) + "=";
#     size_t pos = attr.find(pat);
#     if (pos == std::string::npos) return "";
#     size_t start = pos + pat.size();
#     size_t end = start;
#     while (end < attr.size() && attr[end] != ';' && attr[end] != '\t' &&
#            attr[end] != '\n' && attr[end] != ' ')
#         ++end;
#     return attr.substr(start, end - start);
# }
# 
# static bool parse_gff_cds(const std::string &path, std::vector<CDSFeature> &cds) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         return false;
#     }
#     cds.clear();
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string col[9];
#         int i = 0;
#         while (i < 9 && std::getline(ss, col[i], '\t')) ++i;
#         if (i < 9) continue;
#         if (col[2] != "CDS") continue;
# 
#         int start = std::atoi(col[3].c_str());
#         int end   = std::atoi(col[4].c_str());
#         if (start <= 0 || end <= 0 || end < start) continue;
#         char strand = col[6].empty() ? '+' : col[6][0];
# 
#         std::string attr = col[8];
#         std::string name;
#         name = extract_attr(attr, "gene");
#         if (name.empty()) name = extract_attr(attr, "locus_tag");
#         if (name.empty()) name = extract_attr(attr, "Name");
#         if (name.empty()) name = extract_attr(attr, "ID");
#         if (name.empty()) name = col[0] + ":" + col[3] + "-" + col[4];
# 
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start - 1;
#         f.end0   = end   - 1;
#         f.strand = strand;
#         cds.push_back(f);
#     }
#     return true;
# }
# 
# static std::unordered_map<std::string,char> make_codon_table() {
#     std::unordered_map<std::string,char> t;
#     t["TTT"]='F'; t["TTC"]='F'; t["TTA"]='L'; t["TTG"]='L';
#     t["TCT"]='S'; t["TCC"]='S'; t["TCA"]='S'; t["TCG"]='S';
#     t["TAT"]='Y'; t["TAC"]='Y'; t["TAA"]='*'; t["TAG"]='*';
#     t["TGT"]='C'; t["TGC"]='C'; t["TGA"]='*'; t["TGG"]='W';
#     t["CTT"]='L'; t["CTC"]='L'; t["CTA"]='L'; t["CTG"]='L';
#     t["CCT"]='P'; t["CCC"]='P'; t["CCA"]='P'; t["CCG"]='P';
#     t["CAT"]='H'; t["CAC"]='H'; t["CAA"]='Q'; t["CAG"]='Q';
#     t["CGT"]='R'; t["CGC"]='R'; t["CGA"]='R'; t["CGG"]='R';
#     t["ATT"]='I'; t["ATC"]='I'; t["ATA"]='I'; t["ATG"]='M';
#     t["ACT"]='T'; t["ACC"]='T'; t["ACA"]='T'; t["ACG"]='T';
#     t["AAT"]='N'; t["AAC"]='N'; t["AAA"]='K'; t["AAG"]='K';
#     t["AGT"]='S'; t["AGC"]='S'; t["AGA"]='R'; t["AGG"]='R';
#     t["GTT"]='V'; t["GTC"]='V'; t["GTA"]='V'; t["GTG"]='V';
#     t["GCT"]='A'; t["GCC"]='A'; t["GCA"]='A'; t["GCG"]='A';
#     t["GAT"]='D'; t["GAC"]='D'; t["GAA"]='E'; t["GAG"]='E';
#     t["GGT"]='G'; t["GGC"]='G'; t["GGA"]='G'; t["GGG"]='G';
#     return t;
# }
# 
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'T': return 'A';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         default:  return 'N';
#     }
# }
# 
# // ----------------- Data structures -----------------
# 
# struct GeneReal {
#     std::string name;
#     int start0, end0;
#     char strand;
#     int nt_len;
#     int codons;  // effective codons (excluding terminal stop)
#     std::vector<char> aa_seq; // size = codons
#     double lock_frac_real;
#     double cpg_per_kb_real;
# };
# 
# struct GeneControlStats {
#     double exp_lock_frac;
#     double sd_lock_frac;
#     double exp_cpg_per_kb;
#     double sd_cpg_per_kb;
#     double z_lock_excess;
#     double z_cpg_excess;
# };
# 
# static double safe_mean(const std::vector<double> &v) {
#     if (v.empty()) return 0.0;
#     double s = 0.0;
#     for (double x : v) s += x;
#     return s / v.size();
# }
# 
# static double safe_sd(const std::vector<double> &v, double mean) {
#     if (v.size() < 2) return 0.0;
#     double s2 = 0.0;
#     for (double x : v) {
#         double d = x - mean;
#         s2 += d*d;
#     }
#     return std::sqrt(s2 / (v.size() - 1));
# }
# 
# static double safe_corr(const std::vector<double> &x, const std::vector<double> &y) {
#     size_t n = x.size();
#     if (n != y.size() || n < 2) return 0.0;
#     double mx = safe_mean(x);
#     double my = safe_mean(y);
#     double sx2 = 0.0, sy2 = 0.0, sxy = 0.0;
#     for (size_t i = 0; i < n; ++i) {
#         double dx = x[i] - mx;
#         double dy = y[i] - my;
#         sx2 += dx*dx;
#         sy2 += dy*dy;
#         sxy += dx*dy;
#     }
#     if (sx2 <= 0.0 || sy2 <= 0.0) return 0.0;
#     return sxy / std::sqrt(sx2 * sy2);
# }
# 
# int main(int argc, char **argv) {
#     std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     std::string gff_path   = "/content/ecoli_U00096_3.gff";
#     if (argc >= 3) {
#         fasta_path = argv[1];
#         gff_path   = argv[2];
#     }
# 
#     std::printf("----------------------------------------------------------------------------------------------------------------------\n");
#     std::printf("RUNNING DNA-L28 \u2014 SYNONYMOUS RANDOMIZATION CONTROL (LOCK RAILS & CpG)\n");
#     std::printf("----------------------------------------------------------------------------------------------------------------------\n");
#     std::printf("======================================================================================================================\n");
#     std::printf("MODULE DNA-L28 \u2014 AA-ONLY BASELINE FOR LOCK CODONS & CpG (E. coli MG1655, CDS-level)\n");
#     std::printf("======================================================================================================================\n\n");
# 
#     std::printf("[DNA-L28] FASTA path: %s\n", fasta_path.c_str());
#     std::printf("[DNA-L28] GFF path  : %s\n\n", gff_path.c_str());
# 
#     std::string genome;
#     if (!read_fasta(fasta_path, genome)) return 1;
#     std::printf("Genome loaded: length = %zu bases\n", genome.size());
# 
#     std::vector<CDSFeature> cds;
#     if (!parse_gff_cds(gff_path, cds)) return 1;
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     auto codon_table = make_codon_table();
# 
#     // Invert codon table: AA -> list of codons
#     std::unordered_map<char, std::vector<std::string>> aa_to_codons;
#     for (const auto &kv : codon_table) {
#         const std::string &codon = kv.first;
#         char aa = kv.second;
#         if (aa == '*') continue;
#         aa_to_codons[aa].push_back(codon);
#     }
# 
#     // Lock codon set (same as DNA-L18)
#     std::unordered_set<std::string> lock_codons = {
#         "TCG","TTC","GTG","CTC","GGC","CAC","CGC","CCG","CTG",
#         "TAC","ACC","TCC","GAC","GCG","GCC","TGC","TGG","ATC","GAG"
#     };
# 
#     int cds_analyzed = 0;
#     int cds_len_not3 = 0;
#     int cds_ambig = 0;
#     int cds_trans_err = 0;
# 
#     std::vector<GeneReal> genes;
#     genes.reserve(cds.size());
# 
#     // ----------------- Pass 1: collect real AA and rails/CpG -----------------
#     for (const auto &f : cds) {
#         if (f.start0 < 0 || f.end0 < f.start0 || f.end0 >= (int)genome.size()) continue;
#         int len = f.end0 - f.start0 + 1;
#         if (len <= 0) continue;
#         if (len % 3 != 0) {
#             cds_len_not3++;
#             continue;
#         }
# 
#         std::string seq;
#         seq.reserve(len);
#         bool ambig = false;
#         if (f.strand == '+') {
#             for (int i = f.start0; i <= f.end0; ++i) {
#                 char b = std::toupper(static_cast<unsigned char>(genome[i]));
#                 if (b != 'A' && b != 'C' && b != 'G' && b != 'T') ambig = true;
#                 seq.push_back(b);
#             }
#         } else {
#             for (int i = f.end0; i >= f.start0; --i) {
#                 char b = std::toupper(static_cast<unsigned char>(genome[i]));
#                 if (b != 'A' && b != 'C' && b != 'G' && b != 'T') ambig = true;
#                 seq.push_back(comp_base(b));
#             }
#         }
#         if (ambig) {
#             cds_ambig++;
#             continue;
#         }
# 
#         // CpG in real CDS
#         long cpg = 0;
#         for (int i = 0; i + 1 < len; ++i) {
#             if (seq[i] == 'C' && seq[i+1] == 'G') cpg++;
#         }
# 
#         int n_codons = len / 3;
#         std::vector<char> aa_seq;
#         aa_seq.reserve(n_codons);
#         long lock_count = 0;
#         bool trans_err = false;
#         int effective_codons = 0;
# 
#         for (int i = 0; i < n_codons; ++i) {
#             std::string codon;
#             codon.push_back(seq[3*i+0]);
#             codon.push_back(seq[3*i+1]);
#             codon.push_back(seq[3*i+2]);
# 
#             auto it = codon_table.find(codon);
#             if (it == codon_table.end()) {
#                 trans_err = true;
#                 break;
#             }
#             char aa = it->second;
#             if (aa == '*') {
#                 // allow terminal stop only, ignore it in stats
#                 if (i != n_codons - 1) {
#                     trans_err = true;
#                 }
#                 break;
#             }
#             effective_codons++;
#             aa_seq.push_back(aa);
# 
#             if (lock_codons.count(codon)) {
#                 lock_count++;
#             }
#         }
# 
#         if (trans_err || effective_codons == 0) {
#             cds_trans_err++;
#             continue;
#         }
# 
#         cds_analyzed++;
# 
#         GeneReal g;
#         g.name   = f.name;
#         g.start0 = f.start0;
#         g.end0   = f.end0;
#         g.strand = f.strand;
#         g.nt_len = len;
#         g.codons = effective_codons;
#         g.aa_seq = std::move(aa_seq);
#         g.lock_frac_real   = (double)lock_count / (double)effective_codons;
#         g.cpg_per_kb_real  = (double)cpg * 1000.0 / (double)len;
# 
#         genes.push_back(std::move(g));
#     }
# 
#     std::printf("=====================================================================================\n");
#     std::printf("AA-ONLY BASELINE FOR LOCK CODONS & CpG \u2014 E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n\n");
# 
#     std::printf("CDS summary:\n");
#     std::printf("  CDS features in GFF             : %zu\n", cds.size());
#     std::printf("  CDS with valid AA baseline      : %d\n", cds_analyzed);
#     std::printf("  CDS skipped (len %% 3 != 0)      : %d\n", cds_len_not3);
#     std::printf("  CDS skipped (ambiguous bases)   : %d\n", cds_ambig);
#     std::printf("  CDS skipped (translation errors): %d\n\n", cds_trans_err);
# 
#     // ----------------- Pass 2: synonymous randomization -----------------
#     const int N_SHUFFLES = 32;
#     std::mt19937_64 rng(42);
# 
#     std::vector<GeneControlStats> control(genes.size());
# 
#     long long total_nt_len = 0;
#     long long total_cpg_real = 0;
#     long long total_lock_real = 0;
# 
#     for (size_t gi = 0; gi < genes.size(); ++gi) {
#         const GeneReal &g = genes[gi];
#         total_nt_len += g.nt_len;
#         total_cpg_real += (long long)(g.cpg_per_kb_real * g.nt_len / 1000.0 + 0.5); // rough back-calc
#         total_lock_real += (long long)(g.lock_frac_real * g.codons + 0.5);
# 
#         std::vector<double> lock_vals;
#         std::vector<double> cpg_vals;
#         lock_vals.reserve(N_SHUFFLES);
#         cpg_vals.reserve(N_SHUFFLES);
# 
#         // precalc AE's random CDS length in nt will be 3*codons, same as g.nt_len
#         int len_nt = g.codons * 3;
# 
#         // prepare distributions for each AA position
#         std::vector<std::uniform_int_distribution<int>> dists;
#         dists.reserve(g.aa_seq.size());
#         for (char aa : g.aa_seq) {
#             auto it = aa_to_codons.find(aa);
#             if (it == aa_to_codons.end() || it->second.empty()) {
#                 // should not happen for standard code; fall back to degenerate case
#                 dists.emplace_back(0, 0);
#             } else {
#                 int k = (int)it->second.size();
#                 dists.emplace_back(0, k - 1);
#             }
#         }
# 
#         for (int r = 0; r < N_SHUFFLES; ++r) {
#             std::string rnd_seq;
#             rnd_seq.reserve(len_nt);
#             long lock_count_r = 0;
# 
#             for (size_t pos = 0; pos < g.aa_seq.size(); ++pos) {
#                 char aa = g.aa_seq[pos];
#                 auto it = aa_to_codons.find(aa);
#                 if (it == aa_to_codons.end() || it->second.empty()) {
#                     // This should not occur; as a safe fallback, just use "NNN"
#                     rnd_seq.push_back('N'); rnd_seq.push_back('N'); rnd_seq.push_back('N');
#                     continue;
#                 }
#                 const auto &codons = it->second;
#                 int idx = dists[pos](rng);
#                 const std::string &codon = codons[idx];
#                 rnd_seq.push_back(codon[0]);
#                 rnd_seq.push_back(codon[1]);
#                 rnd_seq.push_back(codon[2]);
#                 if (lock_codons.count(codon)) lock_count_r++;
#             }
# 
#             // CpG in randomized CDS
#             long cpg_r = 0;
#             for (int i = 0; i + 1 < (int)rnd_seq.size(); ++i) {
#                 if (rnd_seq[i] == 'C' && rnd_seq[i+1] == 'G') cpg_r++;
#             }
#             double lock_frac_r  = (double)lock_count_r / (double)g.codons;
#             double cpg_per_kb_r = (double)cpg_r * 1000.0 / (double)len_nt;
# 
#             lock_vals.push_back(lock_frac_r);
#             cpg_vals.push_back(cpg_per_kb_r);
#         }
# 
#         double mean_lock = safe_mean(lock_vals);
#         double sd_lock   = safe_sd(lock_vals, mean_lock);
#         double mean_cpg  = safe_mean(cpg_vals);
#         double sd_cpg    = safe_sd(cpg_vals, mean_cpg);
# 
#         GeneControlStats st;
#         st.exp_lock_frac   = mean_lock;
#         st.sd_lock_frac    = sd_lock;
#         st.exp_cpg_per_kb  = mean_cpg;
#         st.sd_cpg_per_kb   = sd_cpg;
# 
#         st.z_lock_excess = 0.0;
#         st.z_cpg_excess  = 0.0;
#         if (sd_lock > 0.0) {
#             st.z_lock_excess = (g.lock_frac_real - mean_lock) / sd_lock;
#         }
#         if (sd_cpg > 0.0) {
#             st.z_cpg_excess = (g.cpg_per_kb_real - mean_cpg) / sd_cpg;
#         }
# 
#         control[gi] = st;
#     }
# 
#     // Global summary
#     std::printf("--- Global lock & CpG vs AA-only random baseline ---\n");
#     std::vector<double> real_lock_all, exp_lock_all, real_cpg_all, exp_cpg_all;
#     real_lock_all.reserve(genes.size());
#     exp_lock_all.reserve(genes.size());
#     real_cpg_all.reserve(genes.size());
#     exp_cpg_all.reserve(genes.size());
# 
#     for (size_t i = 0; i < genes.size(); ++i) {
#         real_lock_all.push_back(genes[i].lock_frac_real);
#         exp_lock_all.push_back(control[i].exp_lock_frac);
#         real_cpg_all.push_back(genes[i].cpg_per_kb_real);
#         exp_cpg_all.push_back(control[i].exp_cpg_per_kb);
#     }
# 
#     double mean_real_lock = safe_mean(real_lock_all);
#     double mean_exp_lock  = safe_mean(exp_lock_all);
#     double mean_real_cpg  = safe_mean(real_cpg_all);
#     double mean_exp_cpg   = safe_mean(exp_cpg_all);
# 
#     std::printf("  Mean real lock_codon_frac    : %.4f\n", mean_real_lock);
#     std::printf("  Mean expected lock_codon_frac: %.4f\n", mean_exp_lock);
#     std::printf("  Mean real CpG_per_kb         : %.2f\n",  mean_real_cpg);
#     std::printf("  Mean expected CpG_per_kb     : %.2f\n\n", mean_exp_cpg);
# 
#     double corr_lock_real_exp = safe_corr(real_lock_all, exp_lock_all);
#     double corr_cpg_real_exp  = safe_corr(real_cpg_all, exp_cpg_all);
#     std::printf("--- Pearson correlations (real vs AA-baseline expectations) ---\n");
#     std::printf("  corr(real_lock_frac, exp_lock_frac) = %.4f\n", corr_lock_real_exp);
#     std::printf("  corr(real_CpG_per_kb, exp_CpG_per_kb) = %.4f\n\n", corr_cpg_real_exp);
# 
#     // Collect z-scores for global stats
#     std::vector<double> z_lock_all, z_cpg_all;
#     z_lock_all.reserve(genes.size());
#     z_cpg_all.reserve(genes.size());
#     for (size_t i = 0; i < genes.size(); ++i) {
#         z_lock_all.push_back(control[i].z_lock_excess);
#         z_cpg_all.push_back(control[i].z_cpg_excess);
#     }
#     double mean_z_lock = safe_mean(z_lock_all);
#     double sd_z_lock   = safe_sd(z_lock_all, mean_z_lock);
#     double mean_z_cpg  = safe_mean(z_cpg_all);
#     double sd_z_cpg    = safe_sd(z_cpg_all, mean_z_cpg);
# 
#     std::printf("  z_lock_excess per CDS : mean=%.4f, sd=%.4f\n", mean_z_lock, sd_z_lock);
#     std::printf("  z_CpG_excess per CDS  : mean=%.4f, sd=%.4f\n\n", mean_z_cpg, sd_z_cpg);
# 
#     // ----------------- Top genes by z_lock_excess and z_CpG_excess -----------------
#     struct GeneWithZ {
#         const GeneReal *g;
#         const GeneControlStats *st;
#     };
#     std::vector<GeneWithZ> gw;
#     gw.reserve(genes.size());
#     for (size_t i = 0; i < genes.size(); ++i) {
#         gw.push_back(GeneWithZ{&genes[i], &control[i]});
#     }
# 
#     std::vector<GeneWithZ> by_lock = gw;
#     std::sort(by_lock.begin(), by_lock.end(),
#               [](const GeneWithZ &a, const GeneWithZ &b) {
#                   return a.st->z_lock_excess > b.st->z_lock_excess;
#               });
# 
#     std::printf("--- Top 10 genes by lock_codon_frac excess over AA baseline (z_lock_excess) ---\n");
#     int topN = std::min<int>(10, by_lock.size());
#     for (int i = 0; i < topN; ++i) {
#         const auto &g = *by_lock[i].g;
#         const auto &st = *by_lock[i].st;
#         std::printf("  [%2d] %-10s | codons=%4d | lock_real=%.4f | lock_exp=%.4f | z_lock= %.2f\n",
#                     i+1, g.name.c_str(), g.codons,
#                     g.lock_frac_real, st.exp_lock_frac, st.z_lock_excess);
#         std::printf("       CpG_real=%.2f | CpG_exp=%.2f | z_CpG= %.2f\n",
#                     g.cpg_per_kb_real, st.exp_cpg_per_kb, st.z_cpg_excess);
#     }
#     std::printf("\n");
# 
#     std::vector<GeneWithZ> by_cpg = gw;
#     std::sort(by_cpg.begin(), by_cpg.end(),
#               [](const GeneWithZ &a, const GeneWithZ &b) {
#                   return a.st->z_cpg_excess > b.st->z_cpg_excess;
#               });
# 
#     std::printf("--- Top 10 genes by CpG_per_kb excess over AA baseline (z_CpG_excess) ---\n");
#     topN = std::min<int>(10, by_cpg.size());
#     for (int i = 0; i < topN; ++i) {
#         const auto &g = *by_cpg[i].g;
#         const auto &st = *by_cpg[i].st;
#         std::printf("  [%2d] %-10s | codons=%4d | CpG_real=%.2f | CpG_exp=%.2f | z_CpG= %.2f\n",
#                     i+1, g.name.c_str(), g.codons,
#                     g.cpg_per_kb_real, st.exp_cpg_per_kb, st.z_cpg_excess);
#         std::printf("       lock_real=%.4f | lock_exp=%.4f | z_lock= %.2f\n",
#                     g.lock_frac_real, st.exp_lock_frac, st.z_lock_excess);
#     }
#     std::printf("\n");
# 
#     // ----------------- Detailed report for selected loci -----------------
#     std::unordered_map<std::string,size_t> name_to_idx;
#     for (size_t i = 0; i < genes.size(); ++i) {
#         name_to_idx[genes[i].name] = i;
#     }
# 
#     auto print_locus = [&](const char *gene){
#         auto it = name_to_idx.find(gene);
#         if (it == name_to_idx.end()) {
#             std::printf("  [%s] not found in CDS set.\n", gene);
#             return;
#         }
#         size_t idx = it->second;
#         const GeneReal &g = genes[idx];
#         const GeneControlStats &st = control[idx];
# 
#         std::printf("  [%s] AA-baseline vs real rails/CpG:\n", gene);
#         std::printf("    coords          : %d-%d (strand=%c)\n", g.start0, g.end0, g.strand);
#         std::printf("    nt_len / codons : %d / %d\n", g.nt_len, g.codons);
#         std::printf("    lock_real       : %.4f | lock_exp=%.4f | z_lock= %.2f\n",
#                     g.lock_frac_real, st.exp_lock_frac, st.z_lock_excess);
#         std::printf("    CpG_real        : %.2f | CpG_exp=%.2f | z_CpG= %.2f\n",
#                     g.cpg_per_kb_real, st.exp_cpg_per_kb, st.z_cpg_excess);
#     };
# 
#     std::printf("--- AA-baseline vs real rails/CpG for selected loci ---\n");
#     const char* loci[] = {
#         "yagA","yagE","yagF","yagG","yagH",
#         "rhsD","mdtB","mdtC","mutS",
#         "phnC","phnD","phnE","phnF","phnG","phnH","phnI","phnJ","phnK","phnL","phnM","phnN",
#         "nikB","nikC","ugpA","ugpE",
#         nullptr
#     };
#     for (int i = 0; loci[i] != nullptr; ++i) {
#         print_locus(loci[i]);
#     }
# 
#     std::printf("\nSYNONYMOUS RANDOMIZATION CONTROL (LOCK RAILS & CpG) analysis finished.\n");
#     std::printf("=====================================================================================\n");
# 
#     return 0;
# }
# CPP
# 
# nvcc -std=c++17 -O3 warpfrac_dna_L28_synonymous_rails_cpg_control.cu -o dna_L28_synonymous_rails_cpg_control
# 
# ./dna_L28_synonymous_rails_cpg_control /content/ecoli_U00096_3.fna /content/ecoli_U00096_3.gff
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# set -euo pipefail
# 
# cat > warpfrac_dna_L29_gc3_conditioned_rails_cpg_control.cu << 'CPP'
# // warpfrac_dna_L29_gc3_conditioned_rails_cpg_control.cu
# // DNA-L29 — GC3-conditioned synonymous randomization control for lock codons & CpG
# //
# // For each CDS:
# //   - Extract real CDS sequence (on correct strand).
# //   - Translate to AA (ignore terminal stop).
# //   - Record for each codon position: AA, codon, and whether the 3rd base is GC3 (G/C) or AT3 (A/T).
# //   - Compute real metrics:
# //       * lock_codon_frac_real  (for fixed lock codon set)
# //       * CpG_per_kb_real       (within coding region of effective codons)
# //   - Build AA->synonymous codon lists split by GC3 vs AT3:
# //       * aa_to_gc3_codons[AA]
# //       * aa_to_at3_codons[AA]
# //   - GC3-conditioned randomization (N_SHUFFLES per CDS):
# //       * For each codon position i, keep AA[i] and GC3/AT3 label fixed.
# //       * If position is GC3 in real, sample codons from aa_to_gc3_codons[AA[i]].
# //         If that list is empty (should be rare/impossible for real GC3), fall back to the opposite bin.
# //       * Same for AT3.
# //       * Build randomized CDS, compute lock_codon_frac_rand and CpG_per_kb_rand.
# //   - From all shuffles, compute per gene:
# //       * exp_lock_frac_gc3, sd_lock_frac_gc3
# //       * exp_CpG_per_kb_gc3, sd_CpG_per_kb_gc3
# //       * z_lock_gc3  = (lock_real - exp_lock_frac_gc3) / sd_lock_frac_gc3
# //       * z_CpG_gc3   = (CpG_real - exp_CpG_per_kb_gc3) / sd_CpG_per_kb_gc3
# //
# // Outputs:
# //   - Global summary of real vs GC3-conditioned expectations.
# //   - Correlations real vs expected under GC3-conditioned model.
# //   - Top 10 genes by z_lock_gc3 and z_CpG_gc3.
# //   - Detailed GC3-conditioned report for chosen loci (yag*, phn*, nik, ugp, rhsD, mdtB/C, mutS).
# 
# #include <cstdio>
# #include <cstdlib>
# #include <cctype>
# #include <cstring>
# #include <string>
# #include <vector>
# #include <fstream>
# #include <sstream>
# #include <algorithm>
# #include <unordered_map>
# #include <unordered_set>
# #include <random>
# #include <cmath>
# 
# // ----------------- Basic structures -----------------
# 
# struct CDSFeature {
#     std::string name;
#     int start0;
#     int end0;
#     char strand; // '+' or '-'
# };
# 
# struct GeneReal {
#     std::string name;
#     int start0, end0;
#     char strand;
#     int nt_len_eff;     // effective nt length (codons*3, excluding terminal stop)
#     int codons;
#     double lock_frac_real;
#     double cpg_per_kb_real;
# };
# 
# // ----------------- IO helpers -----------------
# 
# static bool read_fasta(const std::string &path, std::string &genome) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open FASTA %s\n", path.c_str());
#         return false;
#     }
#     genome.clear();
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '>') continue;
#         for (char c : line) {
#             if (std::isalpha(static_cast<unsigned char>(c))) {
#                 genome.push_back(std::toupper(static_cast<unsigned char>(c)));
#             }
#         }
#     }
#     return true;
# }
# 
# static std::string extract_attr(const std::string &attr, const char *key) {
#     std::string pat = std::string(key) + "=";
#     size_t pos = attr.find(pat);
#     if (pos == std::string::npos) return "";
#     size_t start = pos + pat.size();
#     size_t end = start;
#     while (end < attr.size() && attr[end] != ';' && attr[end] != '\t' &&
#            attr[end] != '\n' && attr[end] != ' ')
#         ++end;
#     return attr.substr(start, end - start);
# }
# 
# static bool parse_gff_cds(const std::string &path, std::vector<CDSFeature> &cds) {
#     std::ifstream in(path.c_str());
#     if (!in) {
#         std::fprintf(stderr, "ERROR: could not open GFF %s\n", path.c_str());
#         return false;
#     }
#     cds.clear();
#     std::string line;
#     while (std::getline(in, line)) {
#         if (line.empty() || line[0] == '#') continue;
#         std::stringstream ss(line);
#         std::string col[9];
#         int i = 0;
#         while (i < 9 && std::getline(ss, col[i], '\t')) ++i;
#         if (i < 9) continue;
#         if (col[2] != "CDS") continue;
# 
#         int start = std::atoi(col[3].c_str());
#         int end   = std::atoi(col[4].c_str());
#         if (start <= 0 || end <= 0 || end < start) continue;
#         char strand = col[6].empty() ? '+' : col[6][0];
# 
#         std::string attr = col[8];
#         std::string name;
#         name = extract_attr(attr, "gene");
#         if (name.empty()) name = extract_attr(attr, "locus_tag");
#         if (name.empty()) name = extract_attr(attr, "Name");
#         if (name.empty()) name = extract_attr(attr, "ID");
#         if (name.empty()) name = col[0] + ":" + col[3] + "-" + col[4];
# 
#         CDSFeature f;
#         f.name   = name;
#         f.start0 = start - 1;
#         f.end0   = end   - 1;
#         f.strand = strand;
#         cds.push_back(f);
#     }
#     return true;
# }
# 
# static std::unordered_map<std::string,char> make_codon_table() {
#     std::unordered_map<std::string,char> t;
#     t["TTT"]='F'; t["TTC"]='F'; t["TTA"]='L'; t["TTG"]='L';
#     t["TCT"]='S'; t["TCC"]='S'; t["TCA"]='S'; t["TCG"]='S';
#     t["TAT"]='Y'; t["TAC"]='Y'; t["TAA"]='*'; t["TAG"]='*';
#     t["TGT"]='C'; t["TGC"]='C'; t["TGA"]='*'; t["TGG"]='W';
#     t["CTT"]='L'; t["CTC"]='L'; t["CTA"]='L'; t["CTG"]='L';
#     t["CCT"]='P'; t["CCC"]='P'; t["CCA"]='P'; t["CCG"]='P';
#     t["CAT"]='H'; t["CAC"]='H'; t["CAA"]='Q'; t["CAG"]='Q';
#     t["CGT"]='R'; t["CGC"]='R'; t["CGA"]='R'; t["CGG"]='R';
#     t["ATT"]='I'; t["ATC"]='I'; t["ATA"]='I'; t["ATG"]='M';
#     t["ACT"]='T'; t["ACC"]='T'; t["ACA"]='T'; t["ACG"]='T';
#     t["AAT"]='N'; t["AAC"]='N'; t["AAA"]='K'; t["AAG"]='K';
#     t["AGT"]='S'; t["AGC"]='S'; t["AGA"]='R'; t["AGG"]='R';
#     t["GTT"]='V'; t["GTC"]='V'; t["GTA"]='V'; t["GTG"]='V';
#     t["GCT"]='A'; t["GCC"]='A'; t["GCA"]='A'; t["GCG"]='A';
#     t["GAT"]='D'; t["GAC"]='D'; t["GAA"]='E'; t["GAG"]='E';
#     t["GGT"]='G'; t["GGC"]='G'; t["GGA"]='G'; t["GGG"]='G';
#     return t;
# }
# 
# static char comp_base(char b) {
#     switch (b) {
#         case 'A': return 'T';
#         case 'T': return 'A';
#         case 'C': return 'G';
#         case 'G': return 'C';
#         default:  return 'N';
#     }
# }
# 
# // ----------------- Small math helpers -----------------
# 
# static double safe_mean(const std::vector<double> &v) {
#     if (v.empty()) return 0.0;
#     double s = 0.0;
#     for (double x : v) s += x;
#     return s / v.size();
# }
# 
# static double safe_sd(const std::vector<double> &v, double mean) {
#     if (v.size() < 2) return 0.0;
#     double s2 = 0.0;
#     for (double x : v) {
#         double d = x - mean;
#         s2 += d*d;
#     }
#     return std::sqrt(s2 / (v.size() - 1));
# }
# 
# static double safe_corr(const std::vector<double> &x, const std::vector<double> &y) {
#     size_t n = x.size();
#     if (n != y.size() || n < 2) return 0.0;
#     double mx = safe_mean(x);
#     double my = safe_mean(y);
#     double sx2 = 0.0, sy2 = 0.0, sxy = 0.0;
#     for (size_t i = 0; i < n; ++i) {
#         double dx = x[i] - mx;
#         double dy = y[i] - my;
#         sx2 += dx*dx;
#         sy2 += dy*dy;
#         sxy += dx*dy;
#     }
#     if (sx2 <= 0.0 || sy2 <= 0.0) return 0.0;
#     return sxy / std::sqrt(sx2 * sy2);
# }
# 
# // ----------------- Main -----------------
# 
# int main(int argc, char **argv) {
#     std::string fasta_path = "/content/ecoli_U00096_3.fna";
#     std::string gff_path   = "/content/ecoli_U00096_3.gff";
#     if (argc >= 3) {
#         fasta_path = argv[1];
#         gff_path   = argv[2];
#     }
# 
#     std::printf("----------------------------------------------------------------------------------------------------------------------\n");
#     std::printf("RUNNING DNA-L29 \u2014 GC3-CONDITIONED SYNONYMOUS CONTROL (LOCK RAILS & CpG)\n");
#     std::printf("----------------------------------------------------------------------------------------------------------------------\n");
#     std::printf("======================================================================================================================\n");
#     std::printf("MODULE DNA-L29 \u2014 GC3-FIXED AA-BASELINE FOR LOCK CODONS & CpG (E. coli MG1655, CDS-level)\n");
#     std::printf("======================================================================================================================\n\n");
# 
#     std::printf("[DNA-L29] FASTA path: %s\n", fasta_path.c_str());
#     std::printf("[DNA-L29] GFF path  : %s\n\n", gff_path.c_str());
# 
#     std::string genome;
#     if (!read_fasta(fasta_path, genome)) return 1;
#     std::printf("Genome loaded: length = %zu bases\n", genome.size());
# 
#     std::vector<CDSFeature> cds;
#     if (!parse_gff_cds(gff_path, cds)) return 1;
#     std::printf("CDS features loaded: %zu\n\n", cds.size());
# 
#     auto codon_table = make_codon_table();
# 
#     // Lock codon set (same as previous lock modules)
#     std::unordered_set<std::string> lock_codons = {
#         "TCG","TTC","GTG","CTC","GGC","CAC","CGC","CCG","CTG",
#         "TAC","ACC","TCC","GAC","GCG","GCC","TGC","TGG","ATC","GAG"
#     };
# 
#     // Build AA->codon lists split by GC3 vs AT3
#     std::unordered_map<char, std::vector<std::string>> aa_to_gc3_codons;
#     std::unordered_map<char, std::vector<std::string>> aa_to_at3_codons;
#     for (const auto &kv : codon_table) {
#         const std::string &codon = kv.first;
#         char aa = kv.second;
#         if (aa == '*') continue;
#         char third = codon[2];
#         if (third == 'G' || third == 'C') {
#             aa_to_gc3_codons[aa].push_back(codon);
#         } else {
#             aa_to_at3_codons[aa].push_back(codon);
#         }
#     }
# 
#     // Per-gene data
#     std::vector<GeneReal> genes;
#     genes.reserve(cds.size());
# 
#     // For GC3-conditioned shuffles: per gene arrays
#     std::vector<std::vector<char>> gene_aa;
#     std::vector<std::vector<bool>> gene_is_gc3;
# 
#     int cds_analyzed   = 0;
#     int cds_len_not3   = 0;
#     int cds_ambig      = 0;
#     int cds_trans_err  = 0;
# 
#     // ----------------- Pass 1: real metrics and position labels -----------------
#     for (const auto &f : cds) {
#         if (f.start0 < 0 || f.end0 < f.start0 || f.end0 >= (int)genome.size()) continue;
#         int len_nt = f.end0 - f.start0 + 1;
#         if (len_nt <= 0) continue;
#         if (len_nt % 3 != 0) {
#             cds_len_not3++;
#             continue;
#         }
# 
#         std::string seq;
#         seq.reserve(len_nt);
#         bool ambig = false;
#         if (f.strand == '+') {
#             for (int i = f.start0; i <= f.end0; ++i) {
#                 char b = std::toupper(static_cast<unsigned char>(genome[i]));
#                 if (b != 'A' && b != 'C' && b != 'G' && b != 'T') ambig = true;
#                 seq.push_back(b);
#             }
#         } else {
#             for (int i = f.end0; i >= f.start0; --i) {
#                 char b = std::toupper(static_cast<unsigned char>(genome[i]));
#                 if (b != 'A' && b != 'C' && b != 'G' && b != 'T') ambig = true;
#                 seq.push_back(comp_base(b));
#             }
#         }
#         if (ambig) {
#             cds_ambig++;
#             continue;
#         }
# 
#         int n_codons = len_nt / 3;
#         std::vector<char> aa_seq;
#         std::vector<bool> is_gc3;
#         aa_seq.reserve(n_codons);
#         is_gc3.reserve(n_codons);
# 
#         bool trans_err = false;
#         int eff_codons = 0;
#         long lock_count = 0;
#         long gc3_count  = 0;
# 
#         // Translate, drop internal stops, ignore terminal stop codon
#         for (int i = 0; i < n_codons; ++i) {
#             std::string codon;
#             codon.push_back(seq[3*i+0]);
#             codon.push_back(seq[3*i+1]);
#             codon.push_back(seq[3*i+2]);
#             auto it = codon_table.find(codon);
#             if (it == codon_table.end()) {
#                 trans_err = true;
#                 break;
#             }
#             char aa = it->second;
#             if (aa == '*') {
#                 if (i != n_codons - 1) {
#                     trans_err = true; // internal stop
#                 }
#                 break; // ignore terminal stop in metrics
#             }
#             eff_codons++;
#             aa_seq.push_back(aa);
#             bool gc3 = (codon[2] == 'G' || codon[2] == 'C');
#             is_gc3.push_back(gc3);
#             if (gc3) gc3_count++;
#             if (lock_codons.count(codon)) lock_count++;
#         }
# 
#         if (trans_err || eff_codons == 0) {
#             cds_trans_err++;
#             continue;
#         }
# 
#         // Effective nt segment for CpG (exclude terminal stop if present)
#         int nt_len_eff = eff_codons * 3;
#         long cpg_count = 0;
#         for (int i = 0; i + 1 < nt_len_eff; ++i) {
#             if (seq[i] == 'C' && seq[i+1] == 'G') cpg_count++;
#         }
# 
#         cds_analyzed++;
# 
#         GeneReal g;
#         g.name         = f.name;
#         g.start0       = f.start0;
#         g.end0         = f.end0;
#         g.strand       = f.strand;
#         g.nt_len_eff   = nt_len_eff;
#         g.codons       = eff_codons;
#         g.lock_frac_real  = (double)lock_count / (double)eff_codons;
#         g.cpg_per_kb_real = (double)cpg_count * 1000.0 / (double)nt_len_eff;
# 
#         genes.push_back(g);
#         gene_aa.push_back(std::move(aa_seq));
#         gene_is_gc3.push_back(std::move(is_gc3));
#     }
# 
#     std::printf("=====================================================================================\n");
#     std::printf("GC3-FIXED AA-ONLY BASELINE FOR LOCK CODONS & CpG \u2014 E. coli K-12 MG1655 (CDS-level)\n");
#     std::printf("=====================================================================================\n\n");
#     std::printf("CDS summary:\n");
#     std::printf("  CDS features in GFF             : %zu\n", cds.size());
#     std::printf("  CDS with valid GC3-conditioned stats: %d\n", cds_analyzed);
#     std::printf("  CDS skipped (len %% 3 != 0)      : %d\n", cds_len_not3);
#     std::printf("  CDS skipped (ambiguous bases)   : %d\n", cds_ambig);
#     std::printf("  CDS skipped (translation errors): %d\n\n", cds_trans_err);
# 
#     if ((int)genes.size() != cds_analyzed) {
#         std::fprintf(stderr, "INTERNAL WARNING: genes.size() != cds_analyzed\n");
#     }
# 
#     // ----------------- Pass 2: GC3-conditioned randomization -----------------
#     struct GeneGC3Ctrl {
#         double exp_lock_frac;
#         double sd_lock_frac;
#         double exp_cpg_per_kb;
#         double sd_cpg_per_kb;
#         double z_lock_gc3;
#         double z_cpg_gc3;
#     };
#     std::vector<GeneGC3Ctrl> ctrl(genes.size());
# 
#     const int N_SHUFFLES = 32;
#     std::mt19937_64 rng(12345);
# 
#     for (size_t gi = 0; gi < genes.size(); ++gi) {
#         const GeneReal &g = genes[gi];
#         const auto &aa_seq = gene_aa[gi];
#         const auto &is_gc3 = gene_is_gc3[gi];
# 
#         std::vector<double> lock_vals;
#         std::vector<double> cpg_vals;
#         lock_vals.reserve(N_SHUFFLES);
#         cpg_vals.reserve(N_SHUFFLES);
# 
#         for (int r = 0; r < N_SHUFFLES; ++r) {
#             std::string rnd_seq;
#             rnd_seq.reserve(g.nt_len_eff);
#             long lock_count_r = 0;
# 
#             for (int i = 0; i < g.codons; ++i) {
#                 char aa = aa_seq[i];
#                 bool gc3_here = is_gc3[i];
# 
#                 const std::vector<std::string> *cand = nullptr;
#                 if (gc3_here) {
#                     auto it = aa_to_gc3_codons.find(aa);
#                     if (it != aa_to_gc3_codons.end() && !it->second.empty()) {
#                         cand = &it->second;
#                     } else {
#                         auto it2 = aa_to_at3_codons.find(aa);
#                         if (it2 != aa_to_at3_codons.end() && !it2->second.empty())
#                             cand = &it2->second;
#                     }
#                 } else {
#                     auto it = aa_to_at3_codons.find(aa);
#                     if (it != aa_to_at3_codons.end() && !it->second.empty()) {
#                         cand = &it->second;
#                     } else {
#                         auto it2 = aa_to_gc3_codons.find(aa);
#                         if (it2 != aa_to_gc3_codons.end() && !it2->second.empty())
#                             cand = &it2->second;
#                     }
#                 }
#                 if (!cand || cand->empty()) {
#                     // Fallback: extremely unlikely, but keep sequence length consistent.
#                     rnd_seq.push_back('N'); rnd_seq.push_back('N'); rnd_seq.push_back('N');
#                     continue;
#                 }
#                 std::uniform_int_distribution<int> dist(0, (int)cand->size() - 1);
#                 const std::string &codon = (*cand)[dist(rng)];
#                 rnd_seq.push_back(codon[0]);
#                 rnd_seq.push_back(codon[1]);
#                 rnd_seq.push_back(codon[2]);
#                 if (lock_codons.count(codon)) lock_count_r++;
#             }
# 
#             long cpg_r = 0;
#             for (int i = 0; i + 1 < (int)rnd_seq.size(); ++i) {
#                 if (rnd_seq[i] == 'C' && rnd_seq[i+1] == 'G') cpg_r++;
#             }
#             double lock_frac_r  = (double)lock_count_r / (double)g.codons;
#             double cpg_per_kb_r = (double)cpg_r * 1000.0 / (double)g.nt_len_eff;
# 
#             lock_vals.push_back(lock_frac_r);
#             cpg_vals.push_back(cpg_per_kb_r);
#         }
# 
#         double mean_lock = safe_mean(lock_vals);
#         double sd_lock   = safe_sd(lock_vals, mean_lock);
#         double mean_cpg  = safe_mean(cpg_vals);
#         double sd_cpg    = safe_sd(cpg_vals, mean_cpg);
# 
#         GeneGC3Ctrl st;
#         st.exp_lock_frac   = mean_lock;
#         st.sd_lock_frac    = sd_lock;
#         st.exp_cpg_per_kb  = mean_cpg;
#         st.sd_cpg_per_kb   = sd_cpg;
# 
#         st.z_lock_gc3 = 0.0;
#         st.z_cpg_gc3  = 0.0;
#         if (sd_lock > 0.0) {
#             st.z_lock_gc3 = (genes[gi].lock_frac_real - mean_lock) / sd_lock;
#         }
#         if (sd_cpg > 0.0) {
#             st.z_cpg_gc3 = (genes[gi].cpg_per_kb_real - mean_cpg) / sd_cpg;
#         }
# 
#         ctrl[gi] = st;
#     }
# 
#     // ----------------- Global statistics -----------------
#     std::printf("--- Global GC3-conditioned lock & CpG expectations ---\n");
# 
#     std::vector<double> real_lock_all, exp_lock_all, real_cpg_all, exp_cpg_all;
#     std::vector<double> z_lock_all, z_cpg_all;
#     real_lock_all.reserve(genes.size());
#     exp_lock_all.reserve(genes.size());
#     real_cpg_all.reserve(genes.size());
#     exp_cpg_all.reserve(genes.size());
#     z_lock_all.reserve(genes.size());
#     z_cpg_all.reserve(genes.size());
# 
#     for (size_t i = 0; i < genes.size(); ++i) {
#         real_lock_all.push_back(genes[i].lock_frac_real);
#         exp_lock_all.push_back(ctrl[i].exp_lock_frac);
#         real_cpg_all.push_back(genes[i].cpg_per_kb_real);
#         exp_cpg_all.push_back(ctrl[i].exp_cpg_per_kb);
#         z_lock_all.push_back(ctrl[i].z_lock_gc3);
#         z_cpg_all.push_back(ctrl[i].z_cpg_gc3);
#     }
# 
#     double mean_real_lock = safe_mean(real_lock_all);
#     double mean_exp_lock  = safe_mean(exp_lock_all);
#     double mean_real_cpg  = safe_mean(real_cpg_all);
#     double mean_exp_cpg   = safe_mean(exp_cpg_all);
# 
#     std::printf("  Mean real lock_codon_frac         : %.4f\n", mean_real_lock);
#     std::printf("  Mean expected lock_codon_frac(GC3): %.4f\n", mean_exp_lock);
#     std::printf("  Mean real CpG_per_kb              : %.2f\n",  mean_real_cpg);
#     std::printf("  Mean expected CpG_per_kb(GC3)     : %.2f\n\n", mean_exp_cpg);
# 
#     double corr_lock = safe_corr(real_lock_all, exp_lock_all);
#     double corr_cpg  = safe_corr(real_cpg_all, exp_cpg_all);
#     std::printf("--- Pearson correlations (real vs GC3-conditioned expectations) ---\n");
#     std::printf("  corr(real_lock_frac, exp_lock_frac_GC3) = %.4f\n", corr_lock);
#     std::printf("  corr(real_CpG_per_kb, exp_CpG_per_kb_GC3) = %.4f\n\n", corr_cpg);
# 
#     double mean_z_lock = safe_mean(z_lock_all);
#     double sd_z_lock   = safe_sd(z_lock_all, mean_z_lock);
#     double mean_z_cpg  = safe_mean(z_cpg_all);
#     double sd_z_cpg    = safe_sd(z_cpg_all, mean_z_cpg);
# 
#     std::printf("  z_lock_excess(GC3-conditioned) per CDS : mean=%.4f, sd=%.4f\n",
#                 mean_z_lock, sd_z_lock);
#     std::printf("  z_CpG_excess(GC3-conditioned) per CDS  : mean=%.4f, sd=%.4f\n\n",
#                 mean_z_cpg, sd_z_cpg);
# 
#     // ----------------- Top genes by z_lock_gc3 and z_cpg_gc3 -----------------
#     struct GeneWithZ {
#         const GeneReal *g;
#         const GeneGC3Ctrl *st;
#     };
#     std::vector<GeneWithZ> gw;
#     gw.reserve(genes.size());
#     for (size_t i = 0; i < genes.size(); ++i) {
#         gw.push_back(GeneWithZ{&genes[i], &ctrl[i]});
#     }
# 
#     auto by_zlock = gw;
#     std::sort(by_zlock.begin(), by_zlock.end(),
#               [](const GeneWithZ &a, const GeneWithZ &b) {
#                   return a.st->z_lock_gc3 > b.st->z_lock_gc3;
#               });
#     std::printf("--- Top 10 genes by GC3-conditioned lock_codon_frac excess (z_lock_gc3) ---\n");
#     int topN = std::min<int>(10, by_zlock.size());
#     for (int i = 0; i < topN; ++i) {
#         const auto &g  = *by_zlock[i].g;
#         const auto &st = *by_zlock[i].st;
#         std::printf("  [%2d] %-10s | codons=%4d | lock_real=%.4f | lock_exp_GC3=%.4f | z_lock_GC3= %.2f\n",
#                     i+1, g.name.c_str(), g.codons,
#                     g.lock_frac_real, st.exp_lock_frac, st.z_lock_gc3);
#         std::printf("       CpG_real=%.2f | CpG_exp_GC3=%.2f | z_CpG_GC3= %.2f\n",
#                     g.cpg_per_kb_real, st.exp_cpg_per_kb, st.z_cpg_gc3);
#     }
#     std::printf("\n");
# 
#     auto by_zcpg = gw;
#     std::sort(by_zcpg.begin(), by_zcpg.end(),
#               [](const GeneWithZ &a, const GeneWithZ &b) {
#                   return a.st->z_cpg_gc3 > b.st->z_cpg_gc3;
#               });
#     std::printf("--- Top 10 genes by GC3-conditioned CpG_per_kb excess (z_CpG_gc3) ---\n");
#     topN = std::min<int>(10, by_zcpg.size());
#     for (int i = 0; i < topN; ++i) {
#         const auto &g  = *by_zcpg[i].g;
#         const auto &st = *by_zcpg[i].st;
#         std::printf("  [%2d] %-10s | codons=%4d | CpG_real=%.2f | CpG_exp_GC3=%.2f | z_CpG_GC3= %.2f\n",
#                     i+1, g.name.c_str(), g.codons,
#                     g.cpg_per_kb_real, st.exp_cpg_per_kb, st.z_cpg_gc3);
#         std::printf("       lock_real=%.4f | lock_exp_GC3=%.4f | z_lock_GC3= %.2f\n",
#                     g.lock_frac_real, st.exp_lock_frac, st.z_lock_gc3);
#     }
#     std::printf("\n");
# 
#     // ----------------- Detailed GC3-conditioned report for selected loci -----------------
#     std::unordered_map<std::string,size_t> name_to_idx;
#     for (size_t i = 0; i < genes.size(); ++i) {
#         name_to_idx[genes[i].name] = i;
#     }
# 
#     auto print_locus = [&](const char *gene){
#         auto it = name_to_idx.find(gene);
#         if (it == name_to_idx.end()) {
#             std::printf("  [%s] not found in CDS set.\n", gene);
#             return;
#         }
#         size_t idx = it->second;
#         const GeneReal &g = genes[idx];
#         const GeneGC3Ctrl &st = ctrl[idx];
#         std::printf("  [%s] GC3-conditioned rails/CpG:\n", gene);
#         std::printf("    coords          : %d-%d (strand=%c)\n", g.start0, g.end0, g.strand);
#         std::printf("    nt_len / codons : %d / %d\n", g.nt_len_eff, g.codons);
#         std::printf("    lock_real       : %.4f | lock_exp_GC3=%.4f | z_lock_GC3= %.2f\n",
#                     g.lock_frac_real, st.exp_lock_frac, st.z_lock_gc3);
#         std::printf("    CpG_real        : %.2f | CpG_exp_GC3=%.2f | z_CpG_GC3= %.2f\n",
#                     g.cpg_per_kb_real, st.exp_cpg_per_kb, st.z_cpg_gc3);
#     };
# 
#     std::printf("--- GC3-conditioned rails/CpG for selected loci ---\n");
#     const char* loci[] = {
#         "yagA","yagE","yagF","yagG","yagH",
#         "rhsD","mdtB","mdtC","mutS",
#         "phnC","phnD","phnE","phnF","phnG","phnH","phnI","phnJ","phnK","phnL","phnM","phnN",
#         "nikB","nikC","ugpA","ugpE",
#         nullptr
#     };
#     for (int i = 0; loci[i] != nullptr; ++i) {
#         print_locus(loci[i]);
#     }
# 
#     std::printf("\nGC3-CONDITIONED SYNONYMOUS CONTROL (LOCK RAILS & CpG) analysis finished.\n");
#     std::printf("=====================================================================================\n");
#     return 0;
# }
# CPP
# 
# nvcc -std=c++17 -O3 warpfrac_dna_L29_gc3_conditioned_rails_cpg_control.cu -o dna_L29_gc3_conditioned_rails_cpg_control
# 
# ./dna_L29_gc3_conditioned_rails_cpg_control /content/ecoli_U00096_3.fna /content/ecoli_U00096_3.gff
#

#!/usr/bin/env python3
# DNA-L30 — WITHIN-CDS GC3 & CpG GRADIENTS (CDS-level, MG1655)

import argparse
import sys
import math
from collections import defaultdict

# ------------------------------------------------------------
# Basic FASTA / GFF helpers
# ------------------------------------------------------------

def read_fasta(path):
    seqs = {}
    current = None
    chunks = []
    with open(path) as fh:
        for line in fh:
            line = line.strip()
            if not line:
                continue
            if line.startswith(">"):
                if current is not None:
                    seqs[current] = "".join(chunks).upper()
                current = line[1:].split()[0]
                chunks = []
            else:
                chunks.append(line)
    if current is not None:
        seqs[current] = "".join(chunks).upper()
    return seqs


def parse_gff(path):
    features = []
    with open(path) as fh:
        for line in fh:
            if not line.strip() or line.startswith("#"):
                continue
            parts = line.rstrip("\n").split("\t")
            if len(parts) != 9:
                continue
            seqid, source, ftype, start, end, score, strand, phase, attrs = parts
            if ftype != "CDS":
                continue
            start = int(start)
            end = int(end)
            attr_dict = {}
            for item in attrs.split(";"):
                if "=" in item:
                    k, v = item.split("=", 1)
                    attr_dict[k] = v
            gene = (
                attr_dict.get("gene")
                or attr_dict.get("locus_tag")
                or attr_dict.get("Name")
                or attr_dict.get("ID")
                or f"CDS_{start}_{end}"
            )
            features.append(
                {
                    "seqid": seqid,
                    "start": start,
                    "end": end,
                    "strand": strand,
                    "gene": gene,
                }
            )
    return features


def revcomp(seq):
    comp = str.maketrans("ACGTNacgtn", "TGCANtgcan")
    return seq.translate(comp)[::-1]


# ------------------------------------------------------------
# Core GC3 / CpG helpers
# ------------------------------------------------------------

def gc3_fraction(cds_seq):
    n_codons = len(cds_seq) // 3
    if n_codons == 0:
        return 0.0
    gc3 = 0
    for i in range(n_codons):
        b3 = cds_seq[3 * i + 2]
        if b3 in "GCgc":
            gc3 += 1
    return gc3 / n_codons


def within_cds_bins_all(genome, cds_list, nbins=10):
    """
    Two-pass:
      1. Build CDS sequences, GC3 per CDS, and hyper-GC3 threshold.
      2. Aggregate within-CDS GC3 and CpG profiles across all CDS and hyper-GC3 CDS.
    """
    gc3_values = []
    valid_cds = []

    # ---------- Pass 1: build sequences + GC3 per CDS ----------
    for cds in cds_list:
        seqid = cds["seqid"]
        if seqid not in genome:
            cds["valid"] = False
            continue
        start, end, strand = cds["start"], cds["end"], cds["strand"]
        length = end - start + 1
        if length % 3 != 0 or length <= 0:
            cds["valid"] = False
            continue

        subseq = genome[seqid][start - 1 : end]
        if strand == "-":
            subseq = revcomp(subseq)

        cds_seq = subseq
        cds["seq"] = cds_seq
        cds["codons"] = len(cds_seq) // 3
        cds["gc3"] = gc3_fraction(cds_seq)
        cds["valid"] = True
        valid_cds.append(cds)
        gc3_values.append(cds["gc3"])

    if not gc3_values:
        raise RuntimeError("No valid CDS features for GC3 analysis.")

    mean_gc3 = sum(gc3_values) / len(gc3_values)
    var_gc3 = sum((x - mean_gc3) ** 2 for x in gc3_values) / len(gc3_values)
    sd_gc3 = math.sqrt(var_gc3)
    hyper_thr = mean_gc3 + 2 * sd_gc3

    # ---------- Pass 2: within-CDS binning ----------
    bin_codons_all = [0] * nbins
    bin_gc3_all = [0] * nbins
    bin_cpg_all = [0] * nbins

    bin_codons_hyper = [0] * nbins
    bin_gc3_hyper = [0] * nbins
    bin_cpg_hyper = [0] * nbins

    for cds in valid_cds:
        seq = cds["seq"]
        n_codons = cds["codons"]
        if n_codons == 0:
            continue
        is_hyper = cds["gc3"] >= hyper_thr

        # GC3 contribution
        for i in range(n_codons):
            bin_idx = int(i * nbins / n_codons)
            if bin_idx >= nbins:
                bin_idx = nbins - 1
            bin_codons_all[bin_idx] += 1
            if seq[3 * i + 2] in "GCgc":
                bin_gc3_all[bin_idx] += 1
            if is_hyper:
                bin_codons_hyper[bin_idx] += 1
                if seq[3 * i + 2] in "GCgc":
                    bin_gc3_hyper[bin_idx] += 1

        # CpG contribution: map each CpG dinucleotide to bin via codon index
        L = len(seq)
        for pos in range(L - 1):
            if seq[pos] == "C" and seq[pos + 1] == "G":
                codon_idx = pos // 3
                if codon_idx >= n_codons:
                    codon_idx = n_codons - 1
                bin_idx = int(codon_idx * nbins / n_codons)
                if bin_idx >= nbins:
                    bin_idx = nbins - 1
                bin_cpg_all[bin_idx] += 1
                if is_hyper:
                    bin_cpg_hyper[bin_idx] += 1

    # ---------- Summaries ----------
    all_profile = []
    hyper_profile = []

    for b in range(nbins):
        mid_pos = (b + 0.5) / nbins

        # ALL CDS
        codons_all = bin_codons_all[b]
        if codons_all > 0:
            gc3_all = bin_gc3_all[b] / codons_all
            nt_all = 3 * codons_all
            cpg_kb_all = 1000.0 * bin_cpg_all[b] / nt_all
        else:
            gc3_all = float("nan")
            cpg_kb_all = float("nan")

        # HYPER-GC3 CDS
        codons_hy = bin_codons_hyper[b]
        if codons_hy > 0:
            gc3_hy = bin_gc3_hyper[b] / codons_hy
            nt_hy = 3 * codons_hy
            cpg_kb_hy = 1000.0 * bin_cpg_hyper[b] / nt_hy
        else:
            gc3_hy = float("nan")
            cpg_kb_hy = float("nan")

        all_profile.append((b, mid_pos, codons_all, gc3_all, cpg_kb_all))
        hyper_profile.append((b, mid_pos, codons_hy, gc3_hy, cpg_kb_hy))

    stats = {
        "mean_gc3": mean_gc3,
        "sd_gc3": sd_gc3,
        "hyper_thr": hyper_thr,
        "n_valid": len(valid_cds),
        "n_hyper": sum(1 for cds in valid_cds if cds["gc3"] >= hyper_thr),
    }
    return stats, all_profile, hyper_profile, valid_cds


def thirds_profile_for_gene(cds, nbins=3):
    """
    Split a CDS into 3 equal-ish segments (5', mid, 3'),
    and compute GC3_frac and CpG_per_kb in each.
    """
    seq = cds["seq"]
    n_codons = cds["codons"]
    if n_codons == 0:
        return [(float("nan"), float("nan"))] * nbins

    bounds = [0, n_codons // 3, (2 * n_codons) // 3, n_codons]

    # Precompute per-codon GC3 flags
    gc3_flags = [seq[3 * i + 2] in "GCgc" for i in range(n_codons)]

    # CpG per-segment (we map CpG to segment via codon index)
    L = len(seq)
    cpg_bins = [0] * nbins
    for pos in range(L - 1):
        if seq[pos] == "C" and seq[pos + 1] == "G":
            codon_idx = pos // 3
            if codon_idx >= n_codons:
                codon_idx = n_codons - 1
            if codon_idx >= bounds[2]:
                seg = 2
            elif codon_idx >= bounds[1]:
                seg = 1
            else:
                seg = 0
            cpg_bins[seg] += 1

    profiles = []
    for seg in range(nbins):
        start = bounds[seg]
        end = bounds[seg + 1]
        seg_codons = end - start
        if seg_codons <= 0:
            profiles.append((float("nan"), float("nan")))
            continue
        gc3_count = sum(1 for i in range(start, end) if gc3_flags[i])
        gc3_frac = gc3_count / seg_codons
        seg_nt = 3 * seg_codons
        seg_cpg = cpg_bins[seg]
        cpg_kb = 1000.0 * seg_cpg / seg_nt if seg_nt > 0 else float("nan")
        profiles.append((gc3_frac, cpg_kb))
    return profiles


# ------------------------------------------------------------
# Pretty printing wrapper for DNA-L30
# ------------------------------------------------------------

def print_dna_L30(fasta_path, gff_path):
    print("----------------------------------------------------------------------------------------------------------------------")
    print("RUNNING DNA-L30 — WITHIN-CDS GC3 & CpG GRADIENTS (CDS-level)")
    print("----------------------------------------------------------------------------------------------------------------------\n")

    print(f"[DNA-L30] FASTA path: {fasta_path}")
    print(f"[DNA-L30] GFF path  : {gff_path}\n")

    genome = read_fasta(fasta_path)
    print(f"Genome sequences loaded : {len(genome)}")
    cds_list = parse_gff(gff_path)
    print(f"CDS features loaded     : {len(cds_list)}\n")

    stats, all_prof, hyper_prof, valid_cds = within_cds_bins_all(genome, cds_list, nbins=10)

    print("CDS summary:")
    print(f"  CDS features in GFF        : {len(cds_list)}")
    print(f"  CDS analyzed (valid)       : {stats['n_valid']}")
    print(f"  CDS skipped (invalid/codon): {len(cds_list) - stats['n_valid']}\n")

    print("--- Global GC3 stats (CDS-level) ---")
    print(f"  GC3_frac per CDS           : mean={stats['mean_gc3']:.4f}, sd={stats['sd_gc3']:.4f}")
    print(f"  Hyper-GC3 threshold        : {stats['hyper_thr']:.4f} (mean+2*sd)")
    print(f"  Hyper-GC3 genes (>=thr)    : {stats['n_hyper']} / {stats['n_valid']}\n")

    print("=====================================================================================")
    print("WITHIN-CDS GC3 & CpG GRADIENTS — E. coli K-12 MG1655 (CDS-level, NBINS=10)")
    print("=====================================================================================\n")

    # ALL CDS
    print("--- Within-CDS profiles across ALL valid CDS ---")
    print("Bin | mid_pos | codons   | GC3_frac | CpG_per_kb")
    print("----+---------+----------+----------+-----------")
    for b, mid, codons, gc3, cpg in all_prof:
        print(f"{b:3d} | {mid:7.3f} | {codons:8d} | {gc3:8.4f} | {cpg:10.2f}")
    print()

    # HYPER-GC3 CDS
    print("--- Within-CDS profiles across HYPER-GC3 CDS ---")
    print("Bin | mid_pos | codons   | GC3_frac | CpG_per_kb")
    print("----+---------+----------+----------+-----------")
    for b, mid, codons, gc3, cpg in hyper_prof:
        print(f"{b:3d} | {mid:7.3f} | {codons:8d} | {gc3:8.4f} | {cpg:10.2f}")
    print()

    # Selected loci
    selected_gene_names = [
        "yagA", "yagE", "yagF", "yagG", "yagH",
        "rhsD", "mdtB", "mdtC", "mutS",
        "phnC", "phnD", "phnE", "phnF", "phnG", "phnH", "phnI", "phnJ", "phnK", "phnL", "phnM", "phnN",
        "nikB", "nikC", "ugpA", "ugpE",
    ]

    gene_to_cds = {}
    for cds in valid_cds:
        name = cds["gene"]
        # only keep the first instance per gene name
        if name not in gene_to_cds:
            gene_to_cds[name] = cds

    print("=====================================================================================")
    print("WITHIN-CDS 3-BIN GC3 & CpG PROFILES FOR SELECTED LOCI")
    print("=====================================================================================\n")

    for gene in selected_gene_names:
        if gene not in gene_to_cds:
            print(f"  [{gene}] not found in CDS set.")
            print()
            continue

        cds = gene_to_cds[gene]
        thirds = thirds_profile_for_gene(cds, nbins=3)
        coords_str = f"{cds['start']}-{cds['end']} (strand={cds['strand']})"
        nt_len = len(cds["seq"])
        codons = cds["codons"]

        print(f"  [{gene}] within-CDS GC3 & CpG (3 segments):")
        print(f"    coords         : {coords_str}")
        print(f"    nt_len/codons  : {nt_len} / {codons}")
        labels = ["5'-third  ", "mid-third ", "3'-third  "]
        for label, (gc3, cpg) in zip(labels, thirds):
            print(f"    {label}: GC3_frac={gc3:0.4f} | CpG_per_kb={cpg:7.2f}")
        print()

    print("WITHIN-CDS GC3 & CpG GRADIENT analysis finished.")
    print("=====================================================================================")


# ------------------------------------------------------------
# argparse wrapper that plays nice with Colab / Jupyter
# ------------------------------------------------------------

def main(argv=None):
    ap = argparse.ArgumentParser(
        description="DNA-L30 — WITHIN-CDS GC3 & CpG GRADIENTS (E. coli MG1655, CDS-level)"
    )
    ap.add_argument(
        "--fasta",
        help="Genome FASTA (e.g. U00096.3)",
        default="/content/ecoli_U00096_3.fna",
    )
    ap.add_argument(
        "--gff",
        help="Genome GFF3 with CDS annotations",
        default="/content/ecoli_U00096_3.gff",
    )
    # parse_known_args lets us IGNORE Jupyter/Colab's -f kernel.json etc.
    args, unknown = ap.parse_known_args(argv)

    print()
    print(f"[DNA-L30] Parsed arguments: FASTA={args.fasta}, GFF={args.gff}")
    print()

    print_dna_L30(args.fasta, args.gff)


if __name__ == "__main__":
    # In a notebook, just running this cell will hit here and work fine.
    main()

# ======================================================================
# DNA-L31 — WITHIN-CDS GC3, LOCK RAILS & CpG GRADIENTS (E. coli MG1655)
# ======================================================================

from collections import defaultdict

FASTA_PATH = "/content/ecoli_U00096_3.fna"
GFF_PATH   = "/content/ecoli_U00096_3.gff"

# ----------------------------------------------------------------------
# Helpers: FASTA / GFF loading
# ----------------------------------------------------------------------

def load_single_fasta(path):
    seq = []
    with open(path, "r") as fh:
        for line in fh:
            if not line:
                continue
            if line.startswith(">"):
                # single-sequence genome; ignore header text
                continue
            seq.append(line.strip())
    genome = "".join(seq).upper()
    return genome


def parse_gff_cds(path):
    """
    Minimal GFF3 CDS parser.
    Returns a list of CDS dicts:
      {
        'seqid': ...,
        'start': int (1-based, inclusive),
        'end'  : int (1-based, inclusive),
        'strand': '+' or '-',
        'gene' : gene name (best-effort),
      }
    """
    cds_list = []
    with open(path, "r") as fh:
        for line in fh:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split("\t")
            if len(parts) < 9:
                continue
            seqid, source, feature, start, end, score, strand, phase, attrs = parts
            if feature != "CDS":
                continue
            try:
                start_i = int(start)
                end_i = int(end)
            except ValueError:
                continue

            gene = None
            # Try gene= first
            for field in attrs.split(";"):
                if field.startswith("gene="):
                    gene = field.split("=", 1)[1]
                    break
            # Fallbacks
            if gene is None:
                for field in attrs.split(";"):
                    if field.startswith("Name="):
                        gene = field.split("=", 1)[1]
                        break
            if gene is None:
                for field in attrs.split(";"):
                    if field.startswith("locus_tag="):
                        gene = field.split("=", 1)[1]
                        break
            if gene is None:
                gene = f"CDS_{start}_{end}"

            cds_list.append(
                {
                    "seqid": seqid,
                    "start": start_i,
                    "end": end_i,
                    "strand": strand,
                    "gene": gene,
                }
            )
    return cds_list


# ----------------------------------------------------------------------
# Helper: reverse complement
# ----------------------------------------------------------------------

_COMP_TABLE = str.maketrans("ACGTacgtNn", "TGCAtgcaNn")

def revcomp(seq):
    return seq.translate(_COMP_TABLE)[::-1]


# ----------------------------------------------------------------------
# Lock codon definition
# ----------------------------------------------------------------------
# We try to reuse an existing is_lock_codon() from previous modules if present.
# If not defined, we provide a reasonable fallback.

try:
    is_lock_codon  # type: ignore[name-defined]
except NameError:
    def is_lock_codon(codon: str) -> bool:
        """
        Fallback 'lock' codon definition:
        - length 3, A/C/G/T only
        - 3rd base is G or C
        - codon has at least 2 G/C bases total
        This should be reasonably aligned with earlier lock-rail definitions,
        and will be overridden automatically if an is_lock_codon() already
        exists in the notebook (from DNA-L23/L28/L29 etc.).
        """
        codon = codon.upper()
        if len(codon) != 3:
            return False
        if any(b not in "ACGT" for b in codon):
            return False
        gc3 = codon[2] in "GC"
        gc_count = sum(1 for b in codon if b in "GC")
        return gc3 and gc_count >= 2


# ----------------------------------------------------------------------
# Core DNA-L31 analysis
# ----------------------------------------------------------------------

def run_dna_L31(fasta_path=FASTA_PATH, gff_path=GFF_PATH, nbins=10):
    print("----------------------------------------------------------------------------------------------------------------------")
    print("RUNNING DNA-L31 — WITHIN-CDS GC3, LOCK RAILS & CpG GRADIENTS (CDS-level)")
    print("----------------------------------------------------------------------------------------------------------------------")
    print()
    print(f"[DNA-L31] FASTA path: {fasta_path}")
    print(f"[DNA-L31] GFF path  : {gff_path}")
    print()

    genome = load_single_fasta(fasta_path)
    cds_features = parse_gff_cds(gff_path)

    print(f"Genome sequences loaded : 1")
    print(f"CDS features loaded     : {len(cds_features)}")
    print()

    # ------------------------------------------------------------------
    # Collect codon-level data per CDS and per-CDS GC3 (for hyper cutoff)
    # ------------------------------------------------------------------
    cds_data = []
    gc3_list = []

    invalid_cds = 0

    for feat in cds_features:
        start = feat["start"]
        end = feat["end"]
        strand = feat["strand"]
        gene = feat["gene"]

        # GFF is 1-based inclusive
        subseq = genome[start - 1 : end]
        if strand == "-":
            subseq = revcomp(subseq)

        # length must be multiple of 3
        if len(subseq) % 3 != 0 or len(subseq) == 0:
            invalid_cds += 1
            continue

        n_codons = len(subseq) // 3
        codons = [subseq[i*3:(i+1)*3] for i in range(n_codons)]

        gc3_count = 0
        valid_sites = 0
        for c in codons:
            if len(c) != 3:
                continue
            if any(b not in "ACGT" for b in c.upper()):
                # treat ambiguous codons as non-informative for GC3
                continue
            valid_sites += 1
            if c[2].upper() in "GC":
                gc3_count += 1

        if valid_sites == 0:
            invalid_cds += 1
            continue

        gc3_frac = gc3_count / valid_sites
        gc3_list.append(gc3_frac)

        cds_data.append(
            {
                "gene": gene,
                "start": start,
                "end": end,
                "strand": strand,
                "codons": codons,
                "gc3_frac": gc3_frac,
            }
        )

    n_valid = len(cds_data)
    n_total = len(cds_features)

    # GC3 stats & hyper-GC3 threshold
    mean_gc3 = sum(gc3_list) / len(gc3_list)
    var_gc3 = sum((x - mean_gc3) ** 2 for x in gc3_list) / len(gc3_list)
    sd_gc3 = var_gc3 ** 0.5
    hyper_thr = mean_gc3 + 2.0 * sd_gc3

    print("CDS summary:")
    print(f"  CDS features in GFF        : {n_total}")
    print(f"  CDS analyzed (valid)       : {n_valid}")
    print(f"  CDS skipped (invalid/codon): {n_total - n_valid}")
    print()
    print("--- Global GC3 stats (CDS-level) ---")
    print(f"  GC3_frac per CDS           : mean={mean_gc3:.4f}, sd={sd_gc3:.4f}")
    print(f"  Hyper-GC3 threshold        : {hyper_thr:.4f} (mean+2*sd)")
    n_hyper = sum(1 for d in cds_data if d['gc3_frac'] >= hyper_thr)
    print(f"  Hyper-GC3 genes (>=thr)    : {n_hyper} / {n_valid}")
    print()

    # ------------------------------------------------------------------
    # Within-CDS 10-bin profiles: GC3, lock rails, CpG (global + hyper)
    # ------------------------------------------------------------------
    NBINS = nbins
    bin_mid_pos = [(i + 0.5) / NBINS for i in range(NBINS)]

    # global accumulators
    g_codons   = [0] * NBINS
    g_gc3      = [0] * NBINS
    g_lock     = [0] * NBINS
    g_cpg      = [0] * NBINS

    # hyper-GC3 accumulators
    h_codons   = [0] * NBINS
    h_gc3      = [0] * NBINS
    h_lock     = [0] * NBINS
    h_cpg      = [0] * NBINS

    for d in cds_data:
        codons = d["codons"]
        n_codons = len(codons)
        if n_codons == 0:
            continue

        is_hyper = d["gc3_frac"] >= hyper_thr

        # bin indices for each codon
        bin_idx = [int(i * NBINS / n_codons) for i in range(n_codons)]
        # force last codon into last bin (safety)
        bin_idx[-1] = NBINS - 1

        # group codon indices per bin
        cds_bins = [[] for _ in range(NBINS)]
        for i, b in enumerate(bin_idx):
            cds_bins[b].append(i)

        for b in range(NBINS):
            idx_list = cds_bins[b]
            if not idx_list:
                continue

            # codon-level counts
            c_count = len(idx_list)
            gc3_count = 0
            lock_count = 0

            # build nucleotide segment for CpG
            segment_nt = []

            for i in idx_list:
                c = codons[i].upper()
                if len(c) != 3:
                    continue
                segment_nt.append(c)
                if c[2] in "GC":
                    gc3_count += 1
                if is_lock_codon(c):
                    lock_count += 1

            segment_nt = "".join(segment_nt)
            if len(segment_nt) >= 2:
                cpg_count = sum(
                    1 for j in range(len(segment_nt) - 1)
                    if segment_nt[j:j+2] == "CG"
                )
            else:
                cpg_count = 0

            # update global
            g_codons[b] += c_count
            g_gc3[b]    += gc3_count
            g_lock[b]   += lock_count
            g_cpg[b]    += cpg_count

            if is_hyper:
                h_codons[b] += c_count
                h_gc3[b]    += gc3_count
                h_lock[b]   += lock_count
                h_cpg[b]    += cpg_count

    # ------------------------------------------------------------------
    # Emit 10-bin global / hyper-GC3 tables
    # ------------------------------------------------------------------
    print("=====================================================================================")
    print("WITHIN-CDS GC3, LOCK RAILS & CpG GRADIENTS — E. coli K-12 MG1655 (CDS-level, NBINS=10)")
    print("=====================================================================================")
    print()

    print("--- Within-CDS profiles across ALL valid CDS ---")
    print("Bin | mid_pos | codons   | GC3_frac | lock_frac | CpG_per_kb")
    print("----+---------+----------+----------+-----------+-----------")

    for b in range(NBINS):
        c_total = g_codons[b]
        if c_total > 0:
            gc3_frac  = g_gc3[b]  / c_total
            lock_frac = g_lock[b] / c_total
            # CpG per kb: CpG_count / (nt_len / 1000)
            # nt_len ~= 3 * codons
            nt_len = 3 * c_total
            if nt_len > 0:
                cpg_per_kb = g_cpg[b] * 1000.0 / nt_len
            else:
                cpg_per_kb = 0.0
        else:
            gc3_frac = lock_frac = cpg_per_kb = 0.0

        print(f"{b:3d} | {bin_mid_pos[b]:7.3f} | {c_total:8d} | {gc3_frac:8.4f} | {lock_frac:9.4f} | {cpg_per_kb:9.2f}")

    print()
    print("--- Within-CDS profiles across HYPER-GC3 CDS ---")
    print("Bin | mid_pos | codons   | GC3_frac | lock_frac | CpG_per_kb")
    print("----+---------+----------+----------+-----------+-----------")

    for b in range(NBINS):
        c_total = h_codons[b]
        if c_total > 0:
            gc3_frac  = h_gc3[b]  / c_total
            lock_frac = h_lock[b] / c_total
            nt_len = 3 * c_total
            if nt_len > 0:
                cpg_per_kb = h_cpg[b] * 1000.0 / nt_len
            else:
                cpg_per_kb = 0.0
        else:
            gc3_frac = lock_frac = cpg_per_kb = 0.0

        print(f"{b:3d} | {bin_mid_pos[b]:7.3f} | {c_total:8d} | {gc3_frac:8.4f} | {lock_frac:9.4f} | {cpg_per_kb:9.2f}")

    print()

    # ------------------------------------------------------------------
    # 3-bin profiles (5'/mid/3') for selected loci
    # ------------------------------------------------------------------

    selected_genes = [
        "yagA", "yagE", "yagF", "yagG", "yagH",
        "rhsD",
        "mdtB", "mdtC",
        "mutS",
        "phnC", "phnD", "phnE", "phnF", "phnG", "phnH",
        "phnI", "phnJ", "phnK", "phnL", "phnM", "phnN",
        "nikB", "nikC",
        "ugpA", "ugpE",
    ]

    # index CDS by gene name (first occurrence wins)
    gene_index = {}
    for d in cds_data:
        gname = d["gene"]
        # exact match only; MG1655 gene names should match
        if gname not in gene_index:
            gene_index[gname] = d

    print("=====================================================================================")
    print("WITHIN-CDS 3-BIN GC3, LOCK RAILS & CpG PROFILES FOR SELECTED LOCI")
    print("=====================================================================================")
    print()

    for g in selected_genes:
        if g not in gene_index:
            print(f"  [{g}] not found in CDS set.")
            print()
            continue

        d = gene_index[g]
        codons = d["codons"]
        n_codons = len(codons)
        start = d["start"]
        end = d["end"]
        strand = d["strand"]

        # 3 bins: 0=5', 1=mid, 2=3'
        NB3 = 3
        bin_idx = [int(i * NB3 / n_codons) for i in range(n_codons)]
        bin_idx[-1] = NB3 - 1

        # accumulators for this CDS
        bin_codons = [0] * NB3
        bin_gc3    = [0] * NB3
        bin_lock   = [0] * NB3
        bin_cpg    = [0] * NB3

        # We'll build nucleotide segments per bin to count CpG
        nt_bins = [[] for _ in range(NB3)]

        for i, b in enumerate(bin_idx):
            c = codons[i].upper()
            if len(c) != 3:
                continue
            bin_codons[b] += 1
            if c[2] in "GC":
                bin_gc3[b] += 1
            if is_lock_codon(c):
                bin_lock[b] += 1
            nt_bins[b].append(c)

        for b in range(NB3):
            nt_seq = "".join(nt_bins[b])
            if len(nt_seq) >= 2:
                bin_cpg[b] = sum(
                    1 for j in range(len(nt_seq) - 1)
                    if nt_seq[j:j+2] == "CG"
                )
            else:
                bin_cpg[b] = 0

        # convert to fractions / per-kb
        gc3_seg    = [0.0] * NB3
        lock_seg   = [0.0] * NB3
        cpg_seg    = [0.0] * NB3

        for b in range(NB3):
            if bin_codons[b] > 0:
                gc3_seg[b]  = bin_gc3[b]  / bin_codons[b]
                lock_seg[b] = bin_lock[b] / bin_codons[b]
                nt_len = 3 * bin_codons[b]
                if nt_len > 0:
                    cpg_seg[b] = bin_cpg[b] * 1000.0 / nt_len
                else:
                    cpg_seg[b] = 0.0
            else:
                gc3_seg[b]  = 0.0
                lock_seg[b] = 0.0
                cpg_seg[b]  = 0.0

        print(f"  [{g}] within-CDS GC3, LOCK & CpG (3 segments):")
        print(f"    coords         : {start}-{end} (strand={strand})")
        print(f"    nt_len/codons  : {3*n_codons} / {n_codons}")
        print(f"    5'-third  : GC3_frac={gc3_seg[0]:.4f} | lock_frac={lock_seg[0]:.4f} | CpG_per_kb={cpg_seg[0]:7.2f}")
        print(f"    mid-third : GC3_frac={gc3_seg[1]:.4f} | lock_frac={lock_seg[1]:.4f} | CpG_per_kb={cpg_seg[1]:7.2f}")
        print(f"    3'-third  : GC3_frac={gc3_seg[2]:.4f} | lock_frac={lock_seg[2]:.4f} | CpG_per_kb={cpg_seg[2]:7.2f}")
        print()

    print("WITHIN-CDS GC3, LOCK RAILS & CpG GRADIENT analysis finished.")
    print("=====================================================================================")


# Run immediately when cell executes
run_dna_L31()

# ======================================================================
# DNA-L32 — CODON USAGE vs GC3, LOCK RAILS & HYPER-GC3 CONTEXT (CDS-level)
# ======================================================================

from collections import defaultdict

FASTA_PATH = "/content/ecoli_U00096_3.fna"
GFF_PATH   = "/content/ecoli_U00096_3.gff"

# ----------------------------------------------------------------------
# Helpers: FASTA / GFF loading (reuse-compatible with earlier modules)
# ----------------------------------------------------------------------

def load_single_fasta(path):
    seq = []
    with open(path, "r") as fh:
        for line in fh:
            if not line:
                continue
            if line.startswith(">"):
                continue
            seq.append(line.strip())
    return "".join(seq).upper()


def parse_gff_cds(path):
    cds_list = []
    with open(path, "r") as fh:
        for line in fh:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split("\t")
            if len(parts) < 9:
                continue
            seqid, source, feature, start, end, score, strand, phase, attrs = parts
            if feature != "CDS":
                continue
            try:
                start_i = int(start)
                end_i   = int(end)
            except ValueError:
                continue

            gene = None
            for field in attrs.split(";"):
                if field.startswith("gene="):
                    gene = field.split("=", 1)[1]
                    break
            if gene is None:
                for field in attrs.split(";"):
                    if field.startswith("Name="):
                        gene = field.split("=", 1)[1]
                        break
            if gene is None:
                for field in attrs.split(";"):
                    if field.startswith("locus_tag="):
                        gene = field.split("=", 1)[1]
                        break
            if gene is None:
                gene = f"CDS_{start}_{end}"

            cds_list.append(
                {
                    "seqid": seqid,
                    "start": start_i,
                    "end": end_i,
                    "strand": strand,
                    "gene": gene,
                }
            )
    return cds_list


# ----------------------------------------------------------------------
# Reverse complement
# ----------------------------------------------------------------------

_COMP_TABLE = str.maketrans("ACGTacgtNn", "TGCAtgcaNn")

def revcomp(seq):
    return seq.translate(_COMP_TABLE)[::-1]


# ----------------------------------------------------------------------
# Lock codon predicate: reuse if already defined, else fallback
# ----------------------------------------------------------------------

try:
    is_lock_codon  # type: ignore[name-defined]
except NameError:
    def is_lock_codon(codon: str) -> bool:
        """
        Fallback 'lock' codon definition:
        - 3 nt, A/C/G/T only
        - 3rd base is G or C
        - at least 2 GC bases total
        """
        codon = codon.upper()
        if len(codon) != 3:
            return False
        if any(b not in "ACGT" for b in codon):
            return False
        if codon[2] not in "GC":
            return False
        gc_count = sum(1 for b in codon if b in "GC")
        return gc_count >= 2


# ----------------------------------------------------------------------
# Standard genetic code (DNA codons -> one-letter AA; stops mapped to '*')
# ----------------------------------------------------------------------

CODON_TO_AA = {
    # T**
    "TTT":"F","TTC":"F","TTA":"L","TTG":"L",
    "TCT":"S","TCC":"S","TCA":"S","TCG":"S",
    "TAT":"Y","TAC":"Y","TAA":"*","TAG":"*",
    "TGT":"C","TGC":"C","TGA":"*","TGG":"W",
    # C**
    "CTT":"L","CTC":"L","CTA":"L","CTG":"L",
    "CCT":"P","CCC":"P","CCA":"P","CCG":"P",
    "CAT":"H","CAC":"H","CAA":"Q","CAG":"Q",
    "CGT":"R","CGC":"R","CGA":"R","CGG":"R",
    # A**
    "ATT":"I","ATC":"I","ATA":"I","ATG":"M",
    "ACT":"T","ACC":"T","ACA":"T","ACG":"T",
    "AAT":"N","AAC":"N","AAA":"K","AAG":"K",
    "AGT":"S","AGC":"S","AGA":"R","AGG":"R",
    # G**
    "GTT":"V","GTC":"V","GTA":"V","GTG":"V",
    "GCT":"A","GCC":"A","GCA":"A","GCG":"A",
    "GAT":"D","GAC":"D","GAA":"E","GAG":"E",
    "GGT":"G","GGC":"G","GGA":"G","GGG":"G",
}

AA_ORDER = [
    "A","R","N","D","C","Q","E","G","H","I",
    "L","K","M","F","P","S","T","W","Y","V"
]


# ----------------------------------------------------------------------
# Core DNA-L32
# ----------------------------------------------------------------------

def run_dna_L32(fasta_path=FASTA_PATH, gff_path=GFF_PATH):
    print("----------------------------------------------------------------------------------------------------------------------")
    print("RUNNING DNA-L32 — CODON USAGE vs GC3, LOCK RAILS & HYPER-GC3 CONTEXT (CDS-level)")
    print("----------------------------------------------------------------------------------------------------------------------")
    print()
    print(f"[DNA-L32] FASTA path: {fasta_path}")
    print(f"[DNA-L32] GFF path  : {gff_path}")
    print()

    genome = load_single_fasta(fasta_path)
    cds_features = parse_gff_cds(gff_path)

    print(f"Genome sequences loaded : 1")
    print(f"CDS features loaded     : {len(cds_features)}")
    print()

    cds_data = []
    gc3_list = []
    lock_list = []

    invalid = 0

    # ------------------------------------------------------------------
    # Parse CDS -> codons, compute per-CDS GC3_frac & lock_frac
    # ------------------------------------------------------------------
    for feat in cds_features:
        start  = feat["start"]
        end    = feat["end"]
        strand = feat["strand"]
        gene   = feat["gene"]

        subseq = genome[start-1:end]
        if strand == "-":
            subseq = revcomp(subseq)

        if len(subseq) == 0 or len(subseq) % 3 != 0:
            invalid += 1
            continue

        n_codons = len(subseq) // 3
        codons = [subseq[i*3:(i+1)*3] for i in range(n_codons)]

        gc3_count   = 0
        gc3_sites   = 0
        lock_count  = 0
        lock_sites  = 0

        for c in codons:
            c_u = c.upper()
            if len(c_u) != 3 or any(b not in "ACGT" for b in c_u):
                continue
            gc3_sites += 1
            if c_u[2] in "GC":
                gc3_count += 1
            lock_sites += 1
            if is_lock_codon(c_u):
                lock_count += 1

        if gc3_sites == 0 or lock_sites == 0:
            invalid += 1
            continue

        gc3_frac  = gc3_count  / gc3_sites
        lock_frac = lock_count / lock_sites

        gc3_list.append(gc3_frac)
        lock_list.append(lock_frac)

        cds_data.append(
            {
                "gene": gene,
                "start": start,
                "end": end,
                "strand": strand,
                "codons": codons,
                "gc3_frac": gc3_frac,
                "lock_frac": lock_frac,
            }
        )

    n_valid = len(cds_data)
    n_total = len(cds_features)

    # GC3 stats
    mean_gc3 = sum(gc3_list) / len(gc3_list)
    var_gc3  = sum((x - mean_gc3)**2 for x in gc3_list) / len(gc3_list)
    sd_gc3   = var_gc3**0.5
    hyper_gc3_thr = mean_gc3 + 2.0*sd_gc3

    # Lock stats
    mean_lock = sum(lock_list) / len(lock_list)
    var_lock  = sum((x - mean_lock)**2 for x in lock_list) / len(lock_list)
    sd_lock   = var_lock**0.5
    hyper_lock_thr = mean_lock + 2.0*sd_lock

    n_hyper_gc3  = sum(1 for d in cds_data if d["gc3_frac"]  >= hyper_gc3_thr)
    n_hyper_lock = sum(1 for d in cds_data if d["lock_frac"] >= hyper_lock_thr)

    print("CDS summary:")
    print(f"  CDS features in GFF        : {n_total}")
    print(f"  CDS analyzed (valid)       : {n_valid}")
    print(f"  CDS skipped (invalid/codon): {n_total - n_valid}")
    print()
    print("--- Per-CDS GC3 & lock stats ---")
    print(f"  GC3_frac per CDS           : mean={mean_gc3:.4f}, sd={sd_gc3:.4f}")
    print(f"  Hyper-GC3 threshold        : {hyper_gc3_thr:.4f} (mean+2*sd)")
    print(f"  Hyper-GC3 genes (>=thr)    : {n_hyper_gc3} / {n_valid}")
    print(f"  lock_frac per CDS          : mean={mean_lock:.4f}, sd={sd_lock:.4f}")
    print(f"  Hyper-lock threshold       : {hyper_lock_thr:.4f} (mean+2*sd)")
    print(f"  Hyper-lock genes (>=thr)   : {n_hyper_lock} / {n_valid}")
    print()

    # ------------------------------------------------------------------
    # Codon usage accumulators
    # ------------------------------------------------------------------
    codon_counts           = defaultdict(int)
    codon_counts_hyperGC3  = defaultdict(int)
    codon_counts_hyperLock = defaultdict(int)

    aa_counts              = defaultdict(int)
    aa_counts_hyperGC3     = defaultdict(int)
    aa_counts_hyperLock    = defaultdict(int)

    total_codons_global    = 0
    total_codons_hyperGC3  = 0
    total_codons_hyperLock = 0

    # Walk through all codons again with hyper labels
    for d in cds_data:
        codons = d["codons"]
        is_hg  = d["gc3_frac"]  >= hyper_gc3_thr
        is_hl  = d["lock_frac"] >= hyper_lock_thr

        for c in codons:
            c_u = c.upper()
            if len(c_u) != 3 or any(b not in "ACGT" for b in c_u):
                continue
            aa = CODON_TO_AA.get(c_u, None)
            if aa is None or aa == "*":
                continue

            total_codons_global += 1
            codon_counts[c_u]    += 1
            aa_counts[aa]        += 1

            if is_hg:
                total_codons_hyperGC3 += 1
                codon_counts_hyperGC3[c_u] += 1
                aa_counts_hyperGC3[aa]     += 1

            if is_hl:
                total_codons_hyperLock += 1
                codon_counts_hyperLock[c_u] += 1
                aa_counts_hyperLock[aa]     += 1

    # sanity
    print("=====================================================================================")
    print("GLOBAL CODON & LOCK USAGE SUMMARY — E. coli K-12 MG1655")
    print("=====================================================================================")
    print()
    print(f"  Total coding codons (AA, all CDS)          : {total_codons_global}")
    print(f"  Total coding codons in hyper-GC3 CDS       : {total_codons_hyperGC3}")
    print(f"  Total coding codons in hyper-lock CDS      : {total_codons_hyperLock}")
    print()

    # global lock fraction per codon position (should roughly match earlier modules)
    lock_codons_global = sum(codon_counts[c] for c in codon_counts if is_lock_codon(c))
    gc3_codons_global  = sum(codon_counts[c] for c in codon_counts if c[2] in "GC")

    print(f"  Global GC3 codon fraction  : {gc3_codons_global/total_codons_global: .4f}")
    print(f"  Global lock codon fraction : {lock_codons_global/total_codons_global: .4f}")
    print()

    # ------------------------------------------------------------------
    # Amino-acid-level lock usage
    # ------------------------------------------------------------------
    print("-------------------------------------------------------------------------------------")
    print("AMINO-ACID-LEVEL LOCK USAGE SUMMARY")
    print("-------------------------------------------------------------------------------------")
    print("AA | total_codons | lock_codons | lock_frac | lock_frac(hyperGC3) | lock_frac(hyperLock)")
    print("---+-------------+------------+----------+---------------------+----------------------")

    # precompute: for each AA, which codons are lock codons
    aa_to_codons = defaultdict(list)
    for codon, aa in CODON_TO_AA.items():
        if aa == "*":
            continue
        aa_to_codons[aa].append(codon)

    for aa in AA_ORDER:
        tot = aa_counts.get(aa, 0)
        if tot == 0:
            lock_tot = 0
            lock_frac = 0.0
            lock_frac_hg = 0.0
            lock_frac_hl = 0.0
        else:
            lock_tot = 0
            lock_tot_hg = 0
            lock_tot_hl = 0
            for codon in aa_to_codons.get(aa, []):
                if is_lock_codon(codon):
                    lock_tot    += codon_counts.get(codon, 0)
                    lock_tot_hg += codon_counts_hyperGC3.get(codon, 0)
                    lock_tot_hl += codon_counts_hyperLock.get(codon, 0)
            lock_frac    = lock_tot / tot if tot > 0 else 0.0

            tot_hg = aa_counts_hyperGC3.get(aa, 0)
            tot_hl = aa_counts_hyperLock.get(aa, 0)

            lock_frac_hg = lock_tot_hg / tot_hg if tot_hg > 0 else 0.0
            lock_frac_hl = lock_tot_hl / tot_hl if tot_hl > 0 else 0.0

        print(f"{aa:2s} | {tot:11d} | {lock_tot:10d} | {lock_frac:8.4f} |"
              f" {lock_frac_hg:19.4f} | {lock_frac_hl:20.4f}")

    print()

    # ------------------------------------------------------------------
    # Codon usage table by AA, then codon
    # ------------------------------------------------------------------
    print("-------------------------------------------------------------------------------------")
    print("CODON USAGE TABLE (sorted by amino acid, then codon)")
    print("-------------------------------------------------------------------------------------")
    print("AA | codon | count | frac_total | frac_within_AA | GC3 | lock | frac_in_hyperGC3 | frac_in_hyperLock")
    print("---+-------+-------+-----------+----------------+-----+------+------------------+-------------------")

    for aa in AA_ORDER:
        codon_list = sorted([c for c, a in CODON_TO_AA.items() if a == aa])
        aa_tot = aa_counts.get(aa, 0)
        for codon in codon_list:
            cnt = codon_counts.get(codon, 0)
            if cnt == 0:
                frac_t  = 0.0
                frac_aa = 0.0
            else:
                frac_t  = cnt / total_codons_global
                frac_aa = cnt / aa_tot if aa_tot > 0 else 0.0

            c_gc3  = 1 if codon[2] in "GC" else 0
            c_lock = 1 if is_lock_codon(codon) else 0

            cnt_hg = codon_counts_hyperGC3.get(codon, 0)
            cnt_hl = codon_counts_hyperLock.get(codon, 0)

            frac_hg = cnt_hg / cnt if cnt > 0 else 0.0
            frac_hl = cnt_hl / cnt if cnt > 0 else 0.0

            print(f"{aa:2s} | {codon:s} | {cnt:5d} | {frac_t:9.5f} | {frac_aa:14.5f} |"
                  f"  {c_gc3:d}  |  {c_lock:d}   | {frac_hg:16.4f} | {frac_hl:17.4f}")

    print()
    print("CODON USAGE vs GC3 & LOCK RAILS analysis finished.")
    print("=====================================================================================")


# Run immediately when cell executes
run_dna_L32()

# ======================================================================
# DNA-L33 — HYPER-GC3 & HYPER-LOCK CODON ENRICHMENT (AA-normalized)
# ======================================================================

from collections import defaultdict
import math

FASTA_PATH = "/content/ecoli_U00096_3.fna"
GFF_PATH   = "/content/ecoli_U00096_3.gff"

# ----------------------------------------------------------------------
# Reuse / fallback: FASTA + GFF loaders
# ----------------------------------------------------------------------

try:
    load_single_fasta  # type: ignore[name-defined]
except NameError:
    def load_single_fasta(path):
        seq = []
        with open(path, "r") as fh:
            for line in fh:
                if not line:
                    continue
                if line.startswith(">"):
                    continue
                seq.append(line.strip())
        return "".join(seq).upper()

try:
    parse_gff_cds  # type: ignore[name-defined]
except NameError:
    def parse_gff_cds(path):
        cds_list = []
        with open(path, "r") as fh:
            for line in fh:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                parts = line.split("\t")
                if len(parts) < 9:
                    continue
                seqid, source, feature, start, end, score, strand, phase, attrs = parts
                if feature != "CDS":
                    continue
                try:
                    start_i = int(start)
                    end_i   = int(end)
                except ValueError:
                    continue

                gene = None
                for field in attrs.split(";"):
                    if field.startswith("gene="):
                        gene = field.split("=", 1)[1]
                        break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("Name="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("locus_tag="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    gene = f"CDS_{start}_{end}"

                cds_list.append(
                    {
                        "seqid": seqid,
                        "start": start_i,
                        "end": end_i,
                        "strand": strand,
                        "gene": gene,
                    }
                )
        return cds_list

# ----------------------------------------------------------------------
# Reverse complement
# ----------------------------------------------------------------------

try:
    revcomp  # type: ignore[name-defined]
except NameError:
    _COMP_TABLE = str.maketrans("ACGTacgtNn", "TGCAtgcaNn")
    def revcomp(seq):
        return seq.translate(_COMP_TABLE)[::-1]

# ----------------------------------------------------------------------
# Lock codon predicate (reuse if present)
# ----------------------------------------------------------------------

try:
    is_lock_codon  # type: ignore[name-defined]
except NameError:
    def is_lock_codon(codon: str) -> bool:
        codon = codon.upper()
        if len(codon) != 3:
            return False
        if any(b not in "ACGT" for b in codon):
            return False
        if codon[2] not in "GC":
            return False
        gc_count = sum(1 for b in codon if b in "GC")
        return gc_count >= 2

# ----------------------------------------------------------------------
# Genetic code (DNA codons)
# ----------------------------------------------------------------------

try:
    CODON_TO_AA  # type: ignore[name-defined]
except NameError:
    CODON_TO_AA = {
        # T**
        "TTT":"F","TTC":"F","TTA":"L","TTG":"L",
        "TCT":"S","TCC":"S","TCA":"S","TCG":"S",
        "TAT":"Y","TAC":"Y","TAA":"*","TAG":"*",
        "TGT":"C","TGC":"C","TGA":"*","TGG":"W",
        # C**
        "CTT":"L","CTC":"L","CTA":"L","CTG":"L",
        "CCT":"P","CCC":"P","CCA":"P","CCG":"P",
        "CAT":"H","CAC":"H","CAA":"Q","CAG":"Q",
        "CGT":"R","CGC":"R","CGA":"R","CGG":"R",
        # A**
        "ATT":"I","ATC":"I","ATA":"I","ATG":"M",
        "ACT":"T","ACC":"T","ACA":"T","ACG":"T",
        "AAT":"N","AAC":"N","AAA":"K","AAG":"K",
        "AGT":"S","AGC":"S","AGA":"R","AGG":"R",
        # G**
        "GTT":"V","GTC":"V","GTA":"V","GTG":"V",
        "GCT":"A","GCC":"A","GCA":"A","GCG":"A",
        "GAT":"D","GAC":"D","GAA":"E","GAG":"E",
        "GGT":"G","GGC":"G","GGA":"G","GGG":"G",
    }

AA_ORDER = [
    "A","R","N","D","C","Q","E","G","H","I",
    "L","K","M","F","P","S","T","W","Y","V"
]

# map AA -> codons
AA_TO_CODONS = defaultdict(list)
for c, aa in CODON_TO_AA.items():
    if aa == "*":
        continue
    AA_TO_CODONS[aa].append(c)


# ----------------------------------------------------------------------
# Core DNA-L33
# ----------------------------------------------------------------------

def run_dna_L33(fasta_path=FASTA_PATH, gff_path=GFF_PATH):
    print("----------------------------------------------------------------------------------------------------------------------")
    print("RUNNING DNA-L33 — HYPER-GC3 & HYPER-LOCK CODON ENRICHMENT (AA-normalized)")
    print("----------------------------------------------------------------------------------------------------------------------")
    print()
    print(f"[DNA-L33] FASTA path: {fasta_path}")
    print(f"[DNA-L33] GFF path  : {gff_path}")
    print()

    genome = load_single_fasta(fasta_path)
    cds_features = parse_gff_cds(gff_path)

    print(f"Genome sequences loaded : 1")
    print(f"CDS features loaded     : {len(cds_features)}")
    print()

    cds_data = []
    gc3_list = []
    lock_list = []

    invalid = 0

    # --------------------------------------------------------------
    # Build per-CDS codons + GC3 and lock fractions
    # --------------------------------------------------------------
    for feat in cds_features:
        start  = feat["start"]
        end    = feat["end"]
        strand = feat["strand"]
        gene   = feat["gene"]

        subseq = genome[start-1:end]
        if strand == "-":
            subseq = revcomp(subseq)

        if len(subseq) == 0 or len(subseq) % 3 != 0:
            invalid += 1
            continue

        n_codons = len(subseq) // 3
        codons = [subseq[i*3:(i+1)*3] for i in range(n_codons)]

        gc3_count  = 0
        gc3_sites  = 0
        lock_count = 0
        lock_sites = 0

        for c in codons:
            cu = c.upper()
            if len(cu) != 3 or any(b not in "ACGT" for b in cu):
                continue
            gc3_sites += 1
            if cu[2] in "GC":
                gc3_count += 1
            lock_sites += 1
            if is_lock_codon(cu):
                lock_count += 1

        if gc3_sites == 0 or lock_sites == 0:
            invalid += 1
            continue

        gc3_frac  = gc3_count / gc3_sites
        lock_frac = lock_count / lock_sites

        gc3_list.append(gc3_frac)
        lock_list.append(lock_frac)

        cds_data.append(
            {
                "gene": gene,
                "start": start,
                "end": end,
                "strand": strand,
                "codons": codons,
                "gc3_frac": gc3_frac,
                "lock_frac": lock_frac,
            }
        )

    n_valid = len(cds_data)
    n_total = len(cds_features)

    mean_gc3 = sum(gc3_list) / len(gc3_list)
    var_gc3  = sum((x - mean_gc3)**2 for x in gc3_list) / len(gc3_list)
    sd_gc3   = var_gc3**0.5

    mean_lock = sum(lock_list) / len(lock_list)
    var_lock  = sum((x - mean_lock)**2 for x in lock_list) / len(lock_list)
    sd_lock   = var_lock**0.5

    thr_gc3  = mean_gc3  + 2.0*sd_gc3
    thr_lock = mean_lock + 2.0*sd_lock

    n_hg  = sum(1 for d in cds_data if d["gc3_frac"]  >= thr_gc3)
    n_hl  = sum(1 for d in cds_data if d["lock_frac"] >= thr_lock)

    print("CDS summary:")
    print(f"  CDS features in GFF        : {n_total}")
    print(f"  CDS analyzed (valid)       : {n_valid}")
    print(f"  CDS skipped (invalid/codon): {n_total - n_valid}")
    print()
    print("--- Per-CDS GC3 & lock thresholds (for enrichment groups) ---")
    print(f"  GC3_frac per CDS           : mean={mean_gc3:.4f}, sd={sd_gc3:.4f}")
    print(f"  Hyper-GC3 threshold        : {thr_gc3:.4f} (mean+2*sd)")
    print(f"  Hyper-GC3 genes (>=thr)    : {n_hg} / {n_valid}")
    print(f"  lock_frac per CDS          : mean={mean_lock:.4f}, sd={sd_lock:.4f}")
    print(f"  Hyper-lock threshold       : {thr_lock:.4f} (mean+2*sd)")
    print(f"  Hyper-lock genes (>=thr)   : {n_hl} / {n_valid}")
    print()

    # --------------------------------------------------------------
    # Codon counts in groups: ALL, hyper-GC3, hyper-lock, REST
    # --------------------------------------------------------------
    codon_all = defaultdict(int)
    codon_hg  = defaultdict(int)
    codon_hl  = defaultdict(int)

    aa_all    = defaultdict(int)
    aa_hg     = defaultdict(int)
    aa_hl     = defaultdict(int)

    for d in cds_data:
        codons = d["codons"]
        is_hg  = d["gc3_frac"]  >= thr_gc3
        is_hl  = d["lock_frac"] >= thr_lock

        for c in codons:
            cu = c.upper()
            if len(cu) != 3 or any(b not in "ACGT" for b in cu):
                continue
            aa = CODON_TO_AA.get(cu, None)
            if aa is None or aa == "*":
                continue

            codon_all[cu] += 1
            aa_all[aa]    += 1
            if is_hg:
                codon_hg[cu] += 1
                aa_hg[aa]    += 1
            if is_hl:
                codon_hl[cu] += 1
                aa_hl[aa]    += 1

    # REST = all minus hyper-GC3
    codon_rest_gc3 = defaultdict(int)
    codon_rest_lock = defaultdict(int)
    aa_rest_gc3 = defaultdict(int)
    aa_rest_lock = defaultdict(int)

    for aa in AA_ORDER:
        aa_rest_gc3[aa] = aa_all[aa] - aa_hg[aa]
        aa_rest_lock[aa] = aa_all[aa] - aa_hl[aa]

    for codon, aa in CODON_TO_AA.items():
        if aa == "*":
            continue
        codon_rest_gc3[codon]  = codon_all[codon] - codon_hg[codon]
        codon_rest_lock[codon] = codon_all[codon] - codon_hl[codon]

    total_codons_all = sum(codon_all.values())
    total_codons_hg  = sum(codon_hg.values())
    total_codons_hl  = sum(codon_hl.values())

    print("=====================================================================================")
    print("CODON ENRICHMENT IN HYPER-GC3 & HYPER-LOCK CDS (AA-normalized)")
    print("=====================================================================================")
    print()
    print(f"  Total AA-coding codons (all CDS)      : {total_codons_all}")
    print(f"  Total AA-coding codons (hyper-GC3)    : {total_codons_hg}")
    print(f"  Total AA-coding codons (hyper-lock)   : {total_codons_hl}")
    print()

    # --------------------------------------------------------------
    # Table: per codon, within-AA frequencies & log2 fold-change
    # --------------------------------------------------------------
    print("AA | codon | count_all | freq_AA_all | freq_AA_hyperGC3 | freq_AA_restGC3 | log2FC(hyperGC3/rest) | freq_AA_hyperLock | freq_AA_restLock | log2FC(hyperLock/rest)")
    print("---+-------+----------+------------+------------------+-----------------+------------------------+-------------------+------------------+------------------------")

    eps = 1e-9

    for aa in AA_ORDER:
        codons_for_aa = sorted(AA_TO_CODONS[aa])
        tot_all = aa_all[aa]
        tot_hg  = aa_hg[aa]
        tot_hl  = aa_hl[aa]
        tot_rest_gc3  = aa_rest_gc3[aa]
        tot_rest_lock = aa_rest_lock[aa]

        for codon in codons_for_aa:
            ca = codon_all[codon]
            chg = codon_hg[codon]
            chl = codon_hl[codon]
            crest_gc3  = codon_rest_gc3[codon]
            crest_lock = codon_rest_lock[codon]

            # within-AA frequencies
            f_all = ca / tot_all if tot_all > 0 else 0.0
            f_hg  = chg / tot_hg  if tot_hg  > 0 else 0.0
            f_hl  = chl / tot_hl  if tot_hl  > 0 else 0.0
            f_rest_gc3  = crest_gc3  / tot_rest_gc3  if tot_rest_gc3  > 0 else 0.0
            f_rest_lock = crest_lock / tot_rest_lock if tot_rest_lock > 0 else 0.0

            # log2 fold changes vs REST
            if f_rest_gc3 > 0:
                log2fc_hg = math.log2((f_hg + eps) / (f_rest_gc3 + eps))
            else:
                log2fc_hg = 0.0

            if f_rest_lock > 0:
                log2fc_hl = math.log2((f_hl + eps) / (f_rest_lock + eps))
            else:
                log2fc_hl = 0.0

            print(
                f"{aa:2s} | {codon:s} | {ca:8d} | {f_all:10.4f} |"
                f" {f_hg:16.4f} | {f_rest_gc3:15.4f} | {log2fc_hg:22.3f} |"
                f" {f_hl:17.4f} | {f_rest_lock:16.4f} | {log2fc_hl:22.3f}"
            )

    print()
    print("HYPER-GC3 & HYPER-LOCK CODON ENRICHMENT analysis finished.")
    print("=====================================================================================")


# auto-run on cell execution
run_dna_L33()

# ======================================================================
# DNA-L34 — HYPER-GC3 & HYPER-LOCK AMINO-ACID ENRICHMENT (CDS-level)
# ======================================================================

from collections import defaultdict
import math

FASTA_PATH = "/content/ecoli_U00096_3.fna"
GFF_PATH   = "/content/ecoli_U00096_3.gff"

# ----------------------------------------------------------------------
# Reuse loaders if already defined, else define minimal versions
# ----------------------------------------------------------------------

try:
    load_single_fasta  # type: ignore[name-defined]
except NameError:
    def load_single_fasta(path):
        seq = []
        with open(path, "r") as fh:
            for line in fh:
                if not line:
                    continue
                if line.startswith(">"):
                    continue
                seq.append(line.strip())
        return "".join(seq).upper()

try:
    parse_gff_cds  # type: ignore[name-defined]
except NameError:
    def parse_gff_cds(path):
        cds_list = []
        with open(path, "r") as fh:
            for line in fh:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                parts = line.split("\t")
                if len(parts) < 9:
                    continue
                seqid, source, feature, start, end, score, strand, phase, attrs = parts
                if feature != "CDS":
                    continue
                try:
                    start_i = int(start)
                    end_i   = int(end)
                except ValueError:
                    continue

                gene = None
                for field in attrs.split(";"):
                    if field.startswith("gene="):
                        gene = field.split("=", 1)[1]
                        break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("Name="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("locus_tag="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    gene = f"CDS_{start}_{end}"

                cds_list.append(
                    {
                        "seqid": seqid,
                        "start": start_i,
                        "end": end_i,
                        "strand": strand,
                        "gene": gene,
                    }
                )
        return cds_list

try:
    revcomp  # type: ignore[name-defined]
except NameError:
    _COMP_TABLE = str.maketrans("ACGTacgtNn", "TGCAtgcaNn")
    def revcomp(seq):
        return seq.translate(_COMP_TABLE)[::-1]

# genetic code (DNA codons)
try:
    CODON_TO_AA  # type: ignore[name-defined]
except NameError:
    CODON_TO_AA = {
        # T**
        "TTT":"F","TTC":"F","TTA":"L","TTG":"L",
        "TCT":"S","TCC":"S","TCA":"S","TCG":"S",
        "TAT":"Y","TAC":"Y","TAA":"*","TAG":"*",
        "TGT":"C","TGC":"C","TGA":"*","TGG":"W",
        # C**
        "CTT":"L","CTC":"L","CTA":"L","CTG":"L",
        "CCT":"P","CCC":"P","CCA":"P","CCG":"P",
        "CAT":"H","CAC":"H","CAA":"Q","CAG":"Q",
        "CGT":"R","CGC":"R","CGA":"R","CGG":"R",
        # A**
        "ATT":"I","ATC":"I","ATA":"I","ATG":"M",
        "ACT":"T","ACC":"T","ACA":"T","ACG":"T",
        "AAT":"N","AAC":"N","AAA":"K","AAG":"K",
        "AGT":"S","AGC":"S","AGA":"R","AGG":"R",
        # G**
        "GTT":"V","GTC":"V","GTA":"V","GTG":"V",
        "GCT":"A","GCC":"A","GCA":"A","GCG":"A",
        "GAT":"D","GAC":"D","GAA":"E","GAG":"E",
        "GGT":"G","GGC":"G","GGA":"G","GGG":"G",
    }

AA_ORDER = [
    "A","R","N","D","C","Q","E","G","H","I",
    "L","K","M","F","P","S","T","W","Y","V"
]

# lock-codon predicate (same as earlier modules)
try:
    is_lock_codon  # type: ignore[name-defined]
except NameError:
    def is_lock_codon(codon: str) -> bool:
        codon = codon.upper()
        if len(codon) != 3:
            return False
        if any(b not in "ACGT" for b in codon):
            return False
        if codon[2] not in "GC":
            return False
        gc_count = sum(1 for b in codon if b in "GC")
        return gc_count >= 2


def run_dna_L34(fasta_path=FASTA_PATH, gff_path=GFF_PATH):
    print("----------------------------------------------------------------------------------------------------------------------")
    print("RUNNING DNA-L34 — HYPER-GC3 & HYPER-LOCK AMINO-ACID ENRICHMENT (CDS-level)")
    print("----------------------------------------------------------------------------------------------------------------------")
    print()
    print(f"[DNA-L34] FASTA path: {fasta_path}")
    print(f"[DNA-L34] GFF path  : {gff_path}")
    print()

    genome = load_single_fasta(fasta_path)
    cds_features = parse_gff_cds(gff_path)

    print(f"Genome sequences loaded : 1")
    print(f"CDS features loaded     : {len(cds_features)}")
    print()

    cds_data = []
    gc3_list = []
    lock_list = []
    invalid = 0

    # --------------------------------------------------------------
    # Per-CDS codons + GC3 & lock fractions
    # --------------------------------------------------------------
    for feat in cds_features:
        start  = feat["start"]
        end    = feat["end"]
        strand = feat["strand"]
        gene   = feat["gene"]

        subseq = genome[start-1:end]
        if strand == "-":
            subseq = revcomp(subseq)

        if len(subseq) == 0 or len(subseq) % 3 != 0:
            invalid += 1
            continue

        n_codons = len(subseq) // 3
        codons = [subseq[i*3:(i+1)*3] for i in range(n_codons)]

        gc3_count  = 0
        gc3_sites  = 0
        lock_count = 0
        lock_sites = 0

        for c in codons:
            cu = c.upper()
            if len(cu) != 3 or any(b not in "ACGT" for b in cu):
                continue
            gc3_sites += 1
            if cu[2] in "GC":
                gc3_count += 1
            lock_sites += 1
            if is_lock_codon(cu):
                lock_count += 1

        if gc3_sites == 0 or lock_sites == 0:
            invalid += 1
            continue

        gc3_frac  = gc3_count / gc3_sites
        lock_frac = lock_count / lock_sites

        gc3_list.append(gc3_frac)
        lock_list.append(lock_frac)

        cds_data.append(
            {
                "gene": gene,
                "start": start,
                "end": end,
                "strand": strand,
                "codons": codons,
                "gc3_frac": gc3_frac,
                "lock_frac": lock_frac,
            }
        )

    n_valid = len(cds_data)
    n_total = len(cds_features)

    mean_gc3 = sum(gc3_list) / len(gc3_list)
    var_gc3  = sum((x - mean_gc3)**2 for x in gc3_list) / len(gc3_list)
    sd_gc3   = var_gc3**0.5

    mean_lock = sum(lock_list) / len(lock_list)
    var_lock  = sum((x - mean_lock)**2 for x in lock_list) / len(lock_list)
    sd_lock   = var_lock**0.5

    thr_gc3  = mean_gc3  + 2.0*sd_gc3
    thr_lock = mean_lock + 2.0*sd_lock

    n_hg = sum(1 for d in cds_data if d["gc3_frac"]  >= thr_gc3)
    n_hl = sum(1 for d in cds_data if d["lock_frac"] >= thr_lock)

    print("CDS summary:")
    print(f"  CDS features in GFF        : {n_total}")
    print(f"  CDS analyzed (valid)       : {n_valid}")
    print(f"  CDS skipped (invalid/codon): {n_total - n_valid}")
    print()
    print("--- Per-CDS GC3 & lock thresholds ---")
    print(f"  GC3_frac per CDS           : mean={mean_gc3:.4f}, sd={sd_gc3:.4f}")
    print(f"  Hyper-GC3 threshold        : {thr_gc3:.4f} (mean+2*sd)")
    print(f"  Hyper-GC3 genes (>=thr)    : {n_hg} / {n_valid}")
    print(f"  lock_frac per CDS          : mean={mean_lock:.4f}, sd={sd_lock:.4f}")
    print(f"  Hyper-lock threshold       : {thr_lock:.4f} (mean+2*sd)")
    print(f"  Hyper-lock genes (>=thr)   : {n_hl} / {n_valid}")
    print()

    # --------------------------------------------------------------
    # Count amino acids in ALL, hyper-GC3, hyper-lock, and REST sets
    # --------------------------------------------------------------
    aa_all   = defaultdict(int)
    aa_hg    = defaultdict(int)
    aa_hl    = defaultdict(int)

    for d in cds_data:
        codons = d["codons"]
        is_hg  = d["gc3_frac"]  >= thr_gc3
        is_hl  = d["lock_frac"] >= thr_lock

        for c in codons:
            cu = c.upper()
            if len(cu) != 3 or any(b not in "ACGT" for b in cu):
                continue
            aa = CODON_TO_AA.get(cu, None)
            if aa is None or aa == "*":
                continue
            aa_all[aa] += 1
            if is_hg:
                aa_hg[aa] += 1
            if is_hl:
                aa_hl[aa] += 1

    aa_rest_gc3  = {}
    aa_rest_lock = {}
    for aa in AA_ORDER:
        aa_rest_gc3[aa]  = aa_all[aa] - aa_hg[aa]
        aa_rest_lock[aa] = aa_all[aa] - aa_hl[aa]

    total_all = sum(aa_all[a] for a in AA_ORDER)
    total_hg  = sum(aa_hg[a] for a in AA_ORDER)
    total_hl  = sum(aa_hl[a] for a in AA_ORDER)
    total_rest_gc3  = sum(aa_rest_gc3[a] for a in AA_ORDER)
    total_rest_lock = sum(aa_rest_lock[a] for a in AA_ORDER)

    print("=====================================================================================")
    print("AMINO-ACID ENRICHMENT IN HYPER-GC3 & HYPER-LOCK CDS")
    print("=====================================================================================")
    print()
    print(f"  Total AA-coding residues (all CDS)    : {total_all}")
    print(f"  Total AA residues (hyper-GC3 CDS)     : {total_hg}")
    print(f"  Total AA residues (hyper-lock CDS)    : {total_hl}")
    print(f"  Total AA residues (rest GC3 CDS)      : {total_rest_gc3}")
    print(f"  Total AA residues (rest lock CDS)     : {total_rest_lock}")
    print()

    print("AA | count_all | freq_all | freq_hyperGC3 | freq_restGC3 | log2FC(hyperGC3/rest) | freq_hyperLock | freq_restLock | log2FC(hyperLock/rest)")
    print("---+-----------+----------+--------------+--------------+------------------------+----------------+---------------+------------------------")

    eps = 1e-9

    for aa in AA_ORDER:
        ca = aa_all[aa]
        chg = aa_hg[aa]
        chl = aa_hl[aa]
        crest_gc3  = aa_rest_gc3[aa]
        crest_lock = aa_rest_lock[aa]

        f_all        = ca / total_all if total_all > 0 else 0.0
        f_hg         = chg / total_hg if total_hg > 0 else 0.0
        f_hl         = chl / total_hl if total_hl > 0 else 0.0
        f_rest_gc3   = crest_gc3  / total_rest_gc3  if total_rest_gc3  > 0 else 0.0
        f_rest_lock  = crest_lock / total_rest_lock if total_rest_lock > 0 else 0.0

        if f_rest_gc3 > 0:
            log2fc_hg = math.log2((f_hg + eps) / (f_rest_gc3 + eps))
        else:
            log2fc_hg = 0.0

        if f_rest_lock > 0:
            log2fc_hl = math.log2((f_hl + eps) / (f_rest_lock + eps))
        else:
            log2fc_hl = 0.0

        print(
            f"{aa:2s} | {ca:9d} | {f_all:8.4f} |"
            f" {f_hg:12.4f} | {f_rest_gc3:12.4f} | {log2fc_hg:22.3f} |"
            f" {f_hl:14.4f} | {f_rest_lock:13.4f} | {log2fc_hl:22.3f}"
        )

    print()
    print("HYPER-GC3 & HYPER-LOCK AMINO-ACID ENRICHMENT analysis finished.")
    print("=====================================================================================")


# auto-run
run_dna_L34()

# ======================================================================
# DNA-L35 — LOCK CODON RUNS & CLUSTERING (CDS-level)
#   - quantifies runs of consecutive lock codons per CDS
#   - compares ALL vs hyper-GC3 vs hyper-lock gene sets
# ======================================================================

from collections import defaultdict
import math

FASTA_PATH = "/content/ecoli_U00096_3.fna"
GFF_PATH   = "/content/ecoli_U00096_3.gff"

# ----------------------------------------------------------------------
# Reuse loaders if already defined, else define minimal versions
# ----------------------------------------------------------------------

try:
    load_single_fasta  # type: ignore[name-defined]
except NameError:
    def load_single_fasta(path):
        seq = []
        with open(path, "r") as fh:
            for line in fh:
                if not line:
                    continue
                if line.startswith(">"):
                    continue
                seq.append(line.strip())
        return "".join(seq).upper()

try:
    parse_gff_cds  # type: ignore[name-defined]
except NameError:
    def parse_gff_cds(path):
        cds_list = []
        with open(path, "r") as fh:
            for line in fh:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                parts = line.split("\t")
                if len(parts) < 9:
                    continue
                seqid, source, feature, start, end, score, strand, phase, attrs = parts
                if feature != "CDS":
                    continue
                try:
                    start_i = int(start)
                    end_i   = int(end)
                except ValueError:
                    continue

                gene = None
                for field in attrs.split(";"):
                    if field.startswith("gene="):
                        gene = field.split("=", 1)[1]
                        break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("Name="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("locus_tag="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    gene = f"CDS_{start}_{end}"

                cds_list.append(
                    {
                        "seqid": seqid,
                        "start": start_i,
                        "end": end_i,
                        "strand": strand,
                        "gene": gene,
                    }
                )
        return cds_list

try:
    revcomp  # type: ignore[name-defined]
except NameError:
    _COMP_TABLE = str.maketrans("ACGTacgtNn", "TGCAtgcaNn")
    def revcomp(seq):
        return seq.translate(_COMP_TABLE)[::-1]

# lock-codon predicate as in earlier modules
try:
    is_lock_codon  # type: ignore[name-defined]
except NameError:
    def is_lock_codon(codon: str) -> bool:
        codon = codon.upper()
        if len(codon) != 3:
            return False
        if any(b not in "ACGT" for b in codon):
            return False
        if codon[2] not in "GC":
            return False
        gc_count = sum(1 for b in codon if b in "GC")
        return gc_count >= 2


def _compute_run_lengths(lock_flags):
    """
    lock_flags: list of bool (True = lock codon, False = non-lock)
    Returns: list of run lengths (>=1) of consecutive True segments.
    """
    runs = []
    current = 0
    for flag in lock_flags:
        if flag:
            current += 1
        else:
            if current > 0:
                runs.append(current)
                current = 0
    if current > 0:
        runs.append(current)
    return runs


def _histogram_runs(run_list, max_bucket=10):
    """
    Build histogram of run lengths.
    run lengths of 1..(max_bucket-1) explicit, and >=max_bucket into one bin.
    Returns dict: key is int 1..max_bucket, where key==max_bucket means '>=max_bucket'.
    """
    hist = {k: 0 for k in range(1, max_bucket+1)}
    for r in run_list:
        if r < 1:
            continue
        if r >= max_bucket:
            hist[max_bucket] += 1
        else:
            hist[r] += 1
    return hist


def run_dna_L35(fasta_path=FASTA_PATH, gff_path=GFF_PATH):
    print("----------------------------------------------------------------------------------------------------------------------")
    print("RUNNING DNA-L35 — LOCK CODON RUNS & CLUSTERING (CDS-level)")
    print("----------------------------------------------------------------------------------------------------------------------")
    print()
    print(f"[DNA-L35] FASTA path: {fasta_path}")
    print(f"[DNA-L35] GFF path  : {gff_path}")
    print()

    genome = load_single_fasta(fasta_path)
    cds_features = parse_gff_cds(gff_path)

    print(f"Genome sequences loaded : 1")
    print(f"CDS features loaded     : {len(cds_features)}")
    print()

    cds_data = []
    gc3_vals = []
    lock_vals = []

    n_total = len(cds_features)
    n_invalid = 0

    # --------------------------------------------------------------
    # Per-CDS GC3, lock frac, and lock run metrics
    # --------------------------------------------------------------
    for feat in cds_features:
        start  = feat["start"]
        end    = feat["end"]
        strand = feat["strand"]
        gene   = feat["gene"]

        subseq = genome[start-1:end]
        if strand == "-":
            subseq = revcomp(subseq)

        if len(subseq) == 0 or len(subseq) % 3 != 0:
            n_invalid += 1
            continue

        n_codons = len(subseq) // 3
        codons = [subseq[i*3:(i+1)*3] for i in range(n_codons)]

        gc3_count = 0
        gc3_sites = 0
        lock_count = 0
        lock_sites = 0

        lock_flags = []

        for c in codons:
            cu = c.upper()
            if len(cu) != 3 or any(b not in "ACGT" for b in cu):
                # ambiguous or invalid codon: treat as non-lock for runs,
                # but do not contribute to GC3/lock fractions
                lock_flags.append(False)
                continue

            # GC3 stats
            gc3_sites += 1
            if cu[2] in "GC":
                gc3_count += 1

            # lock stats
            lock_sites += 1
            is_lock = is_lock_codon(cu)
            if is_lock:
                lock_count += 1
            lock_flags.append(is_lock)

        if gc3_sites == 0 or lock_sites == 0:
            n_invalid += 1
            continue

        gc3_frac  = gc3_count / gc3_sites
        lock_frac = lock_count / lock_sites

        gc3_vals.append(gc3_frac)
        lock_vals.append(lock_frac)

        runs = _compute_run_lengths(lock_flags)
        longest_run = max(runs) if runs else 0
        n_runs = len(runs)
        mean_run = (sum(runs) / n_runs) if n_runs > 0 else 0.0

        cds_data.append(
            {
                "gene": gene,
                "start": start,
                "end": end,
                "strand": strand,
                "n_codons": n_codons,
                "gc3_frac": gc3_frac,
                "lock_frac": lock_frac,
                "lock_flags": lock_flags,
                "runs": runs,
                "longest_run": longest_run,
                "n_runs": n_runs,
                "mean_run": mean_run,
            }
        )

    n_valid = len(cds_data)

    # --------------------------------------------------------------
    # GC3 / lock thresholds (same style as L32–L34)
    # --------------------------------------------------------------
    mean_gc3 = sum(gc3_vals)/len(gc3_vals)
    var_gc3  = sum((x - mean_gc3)**2 for x in gc3_vals)/len(gc3_vals)
    sd_gc3   = var_gc3**0.5

    mean_lock = sum(lock_vals)/len(lock_vals)
    var_lock  = sum((x - mean_lock)**2 for x in lock_vals)/len(lock_vals)
    sd_lock   = var_lock**0.5

    thr_gc3  = mean_gc3  + 2.0*sd_gc3
    thr_lock = mean_lock + 2.0*sd_lock

    for d in cds_data:
        d["is_hyper_gc3"]  = d["gc3_frac"]  >= thr_gc3
        d["is_hyper_lock"] = d["lock_frac"] >= thr_lock

    n_hg = sum(1 for d in cds_data if d["is_hyper_gc3"])
    n_hl = sum(1 for d in cds_data if d["is_hyper_lock"])

    print("CDS summary:")
    print(f"  CDS features in GFF        : {n_total}")
    print(f"  CDS analyzed (valid)       : {n_valid}")
    print(f"  CDS skipped (invalid/codon): {n_total - n_valid}")
    print()
    print("--- Per-CDS GC3 & lock thresholds (for run-based groups) ---")
    print(f"  GC3_frac per CDS           : mean={mean_gc3:.4f}, sd={sd_gc3:.4f}")
    print(f"  Hyper-GC3 threshold        : {thr_gc3:.4f} (mean+2*sd)")
    print(f"  Hyper-GC3 genes (>=thr)    : {n_hg} / {n_valid}")
    print(f"  lock_frac per CDS          : mean={mean_lock:.4f}, sd={sd_lock:.4f}")
    print(f"  Hyper-lock threshold       : {thr_lock:.4f} (mean+2*sd)")
    print(f"  Hyper-lock genes (>=thr)   : {n_hl} / {n_valid}")
    print()

    # --------------------------------------------------------------
    # Global run collections
    # --------------------------------------------------------------
    all_runs_all = []
    all_runs_hg  = []
    all_runs_hl  = []

    longest_all = []
    longest_hg  = []
    longest_hl  = []

    total_codons = 0
    total_lock_codons = 0

    for d in cds_data:
        runs = d["runs"]
        if runs:
            all_runs_all.extend(runs)
            if d["is_hyper_gc3"]:
                all_runs_hg.extend(runs)
            if d["is_hyper_lock"]:
                all_runs_hl.extend(runs)

        if d["longest_run"] > 0:
            longest_all.append(d["longest_run"])
            if d["is_hyper_gc3"]:
                longest_hg.append(d["longest_run"])
            if d["is_hyper_lock"]:
                longest_hl.append(d["longest_run"])

        # codon & lock totals
        total_codons += d["n_codons"]
        total_lock_codons += sum(1 for f in d["lock_flags"] if f)

    global_lock_frac = total_lock_codons / total_codons if total_codons > 0 else 0.0

    def _mean(lst):
        return sum(lst)/len(lst) if lst else 0.0

    # --------------------------------------------------------------
    # Run length histograms
    # --------------------------------------------------------------
    max_bucket = 10
    hist_all = _histogram_runs(all_runs_all, max_bucket=max_bucket)
    hist_hg  = _histogram_runs(all_runs_hg,  max_bucket=max_bucket)
    hist_hl  = _histogram_runs(all_runs_hl,  max_bucket=max_bucket)

    total_runs_all = sum(hist_all.values())
    total_runs_hg  = sum(hist_hg.values())
    total_runs_hl  = sum(hist_hl.values())

    print("=====================================================================================")
    print("GLOBAL LOCK CODON RUN STATISTICS")
    print("=====================================================================================")
    print()
    print(f"  Total coding codons (all valid CDS)   : {total_codons}")
    print(f"  Total lock codons (all valid CDS)     : {total_lock_codons}")
    print(f"  Global lock codon fraction            : {global_lock_frac:.4f}")
    print()
    print(f"  Total lock runs (ALL CDS)             : {total_runs_all}")
    print(f"  Total lock runs (hyper-GC3 CDS only)  : {total_runs_hg}")
    print(f"  Total lock runs (hyper-lock CDS only) : {total_runs_hl}")
    print()
    print(f"  Mean longest lock-run length (ALL CDS with runs)        : {_mean(longest_all):.3f}")
    print(f"  Mean longest lock-run length (hyper-GC3 CDS with runs)  : {_mean(longest_hg):.3f}")
    print(f"  Mean longest lock-run length (hyper-lock CDS with runs) : {_mean(longest_hl):.3f}")
    print()

    print("Run-length histogram (lock codon runs; bucket 10 = runs >= 10 codons)")
    print("len | count_all | frac_all | count_hyperGC3 | frac_hyperGC3 | count_hyperLock | frac_hyperLock")
    print("----+-----------+----------+----------------+----------------+-----------------+----------------")
    for rlen in range(1, max_bucket+1):
        label = f"{rlen}" if rlen < max_bucket else f">={max_bucket}"
        ca = hist_all[rlen]
        chg = hist_hg[rlen]
        chl = hist_hl[rlen]
        fa  = ca/total_runs_all if total_runs_all > 0 else 0.0
        fhg = chg/total_runs_hg if total_runs_hg > 0 else 0.0
        fhl = chl/total_runs_hl if total_runs_hl > 0 else 0.0
        print(f"{label:>3s} | {ca:9d} | {fa:8.4f} | {chg:14d} | {fhg:14.4f} | {chl:15d} | {fhl:14.4f}")
    print()

    # --------------------------------------------------------------
    # Top genes by longest lock run
    # --------------------------------------------------------------
    cds_sorted = sorted(
        cds_data,
        key=lambda d: (d["longest_run"], d["lock_frac"], d["gc3_frac"]),
        reverse=True,
    )

    top_n = 10
    print("-------------------------------------------------------------------------------------")
    print(f"TOP {top_n} GENES BY LONGEST CONSECUTIVE LOCK CODON RUN")
    print("-------------------------------------------------------------------------------------")
    print("rank | gene        | codons | gc3_frac | lock_frac | longest_run | n_runs | hyperGC3 | hyperLock")
    print("-----+------------+--------+----------+-----------+-------------+--------+----------+----------")
    for i, d in enumerate(cds_sorted[:top_n], start=1):
        print(
            f"{i:4d} | {d['gene'][:10]:10s} | {d['n_codons']:6d} |"
            f" {d['gc3_frac']:8.4f} | {d['lock_frac']:9.4f} |"
            f" {d['longest_run']:11d} | {d['n_runs']:6d} |"
            f" {('Y' if d['is_hyper_gc3'] else 'N'):8s} |"
            f" {('Y' if d['is_hyper_lock'] else 'N'):8s}"
        )

    print()
    print("LOCK CODON RUNS & CLUSTERING analysis finished.")
    print("=====================================================================================")


# auto-run
run_dna_L35()

# ======================================================================
# DNA-L36 — LOCK CODON SPACING & CLUSTERING (INTER-LOCK DISTANCES, CDS-level)
#   - analyzes distances (in codons) between consecutive lock codons
#   - compares ALL vs hyper-GC3 vs hyper-lock CDS
#   - reports spacing histograms and top CDS with densest lock clustering
# ======================================================================

from collections import defaultdict

FASTA_PATH = "/content/ecoli_U00096_3.fna"
GFF_PATH   = "/content/ecoli_U00096_3.gff"

# ----------------------------------------------------------------------
# Reuse loaders if already defined, else define minimal versions
# ----------------------------------------------------------------------

try:
    load_single_fasta  # type: ignore[name-defined]
except NameError:
    def load_single_fasta(path):
        seq = []
        with open(path, "r") as fh:
            for line in fh:
                if not line:
                    continue
                if line.startswith(">"):
                    continue
                seq.append(line.strip())
        return "".join(seq).upper()

try:
    parse_gff_cds  # type: ignore[name-defined]
except NameError:
    def parse_gff_cds(path):
        cds_list = []
        with open(path, "r") as fh:
            for line in fh:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                parts = line.split("\t")
                if len(parts) < 9:
                    continue
                seqid, source, feature, start, end, score, strand, phase, attrs = parts
                if feature != "CDS":
                    continue
                try:
                    start_i = int(start)
                    end_i   = int(end)
                except ValueError:
                    continue

                gene = None
                for field in attrs.split(";"):
                    if field.startswith("gene="):
                        gene = field.split("=", 1)[1]
                        break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("Name="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("locus_tag="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    gene = f"CDS_{start}_{end}"

                cds_list.append(
                    {
                        "seqid": seqid,
                        "start": start_i,
                        "end": end_i,
                        "strand": strand,
                        "gene": gene,
                    }
                )
        return cds_list

try:
    revcomp  # type: ignore[name-defined]
except NameError:
    _COMP_TABLE = str.maketrans("ACGTacgtNn", "TGCAtgcaNn")
    def revcomp(seq):
        return seq.translate(_COMP_TABLE)[::-1]

# lock-codon predicate consistent with earlier modules
try:
    is_lock_codon  # type: ignore[name-defined]
except NameError:
    def is_lock_codon(codon: str) -> bool:
        codon = codon.upper()
        if len(codon) != 3:
            return False
        if any(b not in "ACGT" for b in codon):
            return False
        if codon[2] not in "GC":
            return False
        gc_count = sum(1 for b in codon if b in "GC")
        return gc_count >= 2


def _compute_inter_lock_spacings(lock_flags):
    """
    lock_flags: list[bool] (True = lock codon)
    Returns:
        spacings: list of ints, where each value is the number of
                  non-lock codons between consecutive lock codons.
                  Adjacent lock codons => spacing = 0.
    """
    positions = [i for i, f in enumerate(lock_flags) if f]
    if len(positions) < 2:
        return []
    return [positions[i+1] - positions[i] - 1 for i in range(len(positions)-1)]


def _histogram_spacings(spacings, max_bucket=10):
    """
    Build histogram for spacing lengths (0,1,...,max_bucket; where max_bucket bin
    is '>= max_bucket').
    Returns dict: key in {0,1,...,max_bucket}, with key==max_bucket meaning '>= max_bucket'.
    """
    hist = {k: 0 for k in range(0, max_bucket+1)}
    for s in spacings:
        if s < 0:
            continue
        if s >= max_bucket:
            hist[max_bucket] += 1
        else:
            hist[s] += 1
    return hist


def _mean(lst):
    return sum(lst)/len(lst) if lst else 0.0


def _pearson(x, y):
    """
    Simple Pearson correlation; returns 0.0 if degenerate.
    """
    n = len(x)
    if n == 0 or n != len(y):
        return 0.0
    mx = sum(x)/n
    my = sum(y)/n
    vx = sum((xi - mx)**2 for xi in x)
    vy = sum((yi - my)**2 for yi in y)
    if vx == 0 or vy == 0:
        return 0.0
    num = sum((xi - mx)*(yi - my) for xi, yi in zip(x, y))
    return num / (vx**0.5 * vy**0.5)


def run_dna_L36(fasta_path=FASTA_PATH, gff_path=GFF_PATH):
    print("----------------------------------------------------------------------------------------------------------------------")
    print("RUNNING DNA-L36 — LOCK CODON SPACING & CLUSTERING (INTER-LOCK DISTANCES, CDS-level)")
    print("----------------------------------------------------------------------------------------------------------------------")
    print()
    print(f"[DNA-L36] FASTA path: {fasta_path}")
    print(f"[DNA-L36] GFF path  : {gff_path}")
    print()

    genome = load_single_fasta(fasta_path)
    cds_features = parse_gff_cds(gff_path)

    print(f"Genome sequences loaded : 1")
    print(f"CDS features loaded     : {len(cds_features)}")
    print()

    cds_data = []
    gc3_vals = []
    lock_vals = []

    n_total = len(cds_features)

    # ----------------------------------------------------------
    # Per-CDS GC3, lock_frac, and inter-lock spacing metrics
    # ----------------------------------------------------------
    for feat in cds_features:
        start  = feat["start"]
        end    = feat["end"]
        strand = feat["strand"]
        gene   = feat["gene"]

        subseq = genome[start-1:end]
        if strand == "-":
            subseq = revcomp(subseq)

        if len(subseq) == 0 or len(subseq) % 3 != 0:
            continue

        n_codons = len(subseq) // 3
        codons = [subseq[i*3:(i+1)*3] for i in range(n_codons)]

        gc3_count = 0
        gc3_sites = 0
        lock_count = 0
        lock_sites = 0

        lock_flags = []

        for c in codons:
            cu = c.upper()
            if len(cu) != 3 or any(b not in "ACGT" for b in cu):
                # invalid/ambiguous codon: treat as non-lock, but do not
                # contribute to GC3/lock fraction denominators
                lock_flags.append(False)
                continue

            # GC3
            gc3_sites += 1
            if cu[2] in "GC":
                gc3_count += 1

            # lock
            lock_sites += 1
            is_lock = is_lock_codon(cu)
            if is_lock:
                lock_count += 1
            lock_flags.append(is_lock)

        if gc3_sites == 0 or lock_sites == 0:
            continue

        gc3_frac = gc3_count / gc3_sites
        lock_frac = lock_count / lock_sites

        gc3_vals.append(gc3_frac)
        lock_vals.append(lock_frac)

        spacings = _compute_inter_lock_spacings(lock_flags)
        if spacings:
            mean_spacing = _mean(spacings)
            min_spacing = min(spacings)
            max_spacing = max(spacings)
        else:
            mean_spacing = None
            min_spacing = None
            max_spacing = None

        cds_data.append(
            {
                "gene": gene,
                "start": start,
                "end": end,
                "strand": strand,
                "n_codons": n_codons,
                "gc3_frac": gc3_frac,
                "lock_frac": lock_frac,
                "lock_count": sum(1 for f in lock_flags if f),
                "lock_flags": lock_flags,
                "spacings": spacings,
                "mean_spacing": mean_spacing,
                "min_spacing": min_spacing,
                "max_spacing": max_spacing,
            }
        )

    n_valid = len(cds_data)

    # ----------------------------------------------------------
    # Thresholds for hyper-GC3 / hyper-lock
    # ----------------------------------------------------------
    mean_gc3 = sum(gc3_vals)/len(gc3_vals)
    var_gc3  = sum((x - mean_gc3)**2 for x in gc3_vals)/len(gc3_vals)
    sd_gc3   = var_gc3**0.5

    mean_lock = sum(lock_vals)/len(lock_vals)
    var_lock  = sum((x - mean_lock)**2 for x in lock_vals)/len(lock_vals)
    sd_lock   = var_lock**0.5

    thr_gc3  = mean_gc3  + 2.0*sd_gc3
    thr_lock = mean_lock + 2.0*sd_lock

    for d in cds_data:
        d["is_hyper_gc3"]  = d["gc3_frac"]  >= thr_gc3
        d["is_hyper_lock"] = d["lock_frac"] >= thr_lock

    n_hg = sum(1 for d in cds_data if d["is_hyper_gc3"])
    n_hl = sum(1 for d in cds_data if d["is_hyper_lock"])

    print("CDS summary:")
    print(f"  CDS features in GFF        : {n_total}")
    print(f"  CDS analyzed (valid)       : {n_valid}")
    print(f"  CDS skipped (invalid/codon): {n_total - n_valid}")
    print()
    print("--- Per-CDS GC3 & lock thresholds (for spacing-based groups) ---")
    print(f"  GC3_frac per CDS           : mean={mean_gc3:.4f}, sd={sd_gc3:.4f}")
    print(f"  Hyper-GC3 threshold        : {thr_gc3:.4f} (mean+2*sd)")
    print(f"  Hyper-GC3 genes (>=thr)    : {n_hg} / {n_valid}")
    print(f"  lock_frac per CDS          : mean={mean_lock:.4f}, sd={sd_lock:.4f}")
    print(f"  Hyper-lock threshold       : {thr_lock:.4f} (mean+2*sd)")
    print(f"  Hyper-lock genes (>=thr)   : {n_hl} / {n_valid}")
    print()

    # ----------------------------------------------------------
    # Global spacing collections & histograms
    # ----------------------------------------------------------
    spacings_all = []
    spacings_hg  = []
    spacings_hl  = []

    mean_spacing_per_cds = []
    gc3_for_corr = []
    lock_for_corr = []

    for d in cds_data:
        sps = d["spacings"]
        if not sps:
            continue
        spacings_all.extend(sps)
        mean_spacing_per_cds.append(d["mean_spacing"])
        gc3_for_corr.append(d["gc3_frac"])
        lock_for_corr.append(d["lock_frac"])

        if d["is_hyper_gc3"]:
            spacings_hg.extend(sps)
        if d["is_hyper_lock"]:
            spacings_hl.extend(sps)

    mean_spacing_all = _mean(spacings_all)
    mean_spacing_hg  = _mean(spacings_hg)
    mean_spacing_hl  = _mean(spacings_hl)

    corr_spacing_gc3  = _pearson(mean_spacing_per_cds, gc3_for_corr)
    corr_spacing_lock = _pearson(mean_spacing_per_cds, lock_for_corr)

    max_bucket = 10
    hist_all = _histogram_spacings(spacings_all, max_bucket=max_bucket)
    hist_hg  = _histogram_spacings(spacings_hg,  max_bucket=max_bucket)
    hist_hl  = _histogram_spacings(spacings_hl,  max_bucket=max_bucket)

    total_sp_all = sum(hist_all.values())
    total_sp_hg  = sum(hist_hg.values())
    total_sp_hl  = sum(hist_hl.values())

    print("=====================================================================================")
    print("GLOBAL INTER-LOCK CODON SPACING STATISTICS")
    print("=====================================================================================")
    print()
    print(f"  CDS with >=2 lock codons (for spacing stats): {len(mean_spacing_per_cds)} / {n_valid}")
    print()
    print(f"  Total inter-lock spacings (ALL CDS)          : {total_sp_all}")
    print(f"  Total inter-lock spacings (hyper-GC3 CDS)    : {total_sp_hg}")
    print(f"  Total inter-lock spacings (hyper-lock CDS)   : {total_sp_hl}")
    print()
    print(f"  Mean inter-lock spacing (ALL CDS)            : {mean_spacing_all:.3f} codons")
    print(f"  Mean inter-lock spacing (hyper-GC3 CDS)      : {mean_spacing_hg:.3f} codons")
    print(f"  Mean inter-lock spacing (hyper-lock CDS)     : {mean_spacing_hl:.3f} codons")
    print()
    print(f"  corr(mean_spacing_per_CDS, gc3_frac)         : {corr_spacing_gc3:.4f}")
    print(f"  corr(mean_spacing_per_CDS, lock_frac)        : {corr_spacing_lock:.4f}")
    print()

    print("Inter-lock spacing histogram (in codons; bucket 10 = spacings >= 10)")
    print("sp  | count_all | frac_all | count_hyperGC3 | frac_hyperGC3 | count_hyperLock | frac_hyperLock")
    print("----+-----------+----------+----------------+----------------+-----------------+----------------")
    for s in range(0, max_bucket+1):
        label = f"{s}" if s < max_bucket else f">={max_bucket}"
        ca = hist_all[s]
        chg = hist_hg[s]
        chl = hist_hl[s]
        fa  = ca/total_sp_all if total_sp_all > 0 else 0.0
        fhg = chg/total_sp_hg if total_sp_hg > 0 else 0.0
        fhl = chl/total_sp_hl if total_sp_hl > 0 else 0.0
        print(f"{label:>3s} | {ca:9d} | {fa:8.4f} | {chg:14d} | {fhg:14.4f} | {chl:15d} | {fhl:14.4f}")
    print()

    # ----------------------------------------------------------
    # Top genes by densest lock clustering (smallest mean spacing)
    #   - require at least 3 lock codons and at least 2 spacings
    # ----------------------------------------------------------
    candidates = [
        d for d in cds_data
        if d["spacings"] and len(d["spacings"]) >= 2 and d["lock_count"] >= 3
    ]

    cds_sorted = sorted(
        candidates,
        key=lambda d: (d["mean_spacing"], -d["lock_frac"], -d["gc3_frac"])
    )

    top_n = 10
    print("-------------------------------------------------------------------------------------")
    print(f"TOP {top_n} GENES BY TIGHTEST LOCK CODON SPACING (SMALLEST MEAN INTER-LOCK DISTANCE)")
    print("-------------------------------------------------------------------------------------")
    print("rank | gene        | codons | gc3_frac | lock_frac | n_lock | mean_sp | min_sp | max_sp | hyperGC3 | hyperLock")
    print("-----+------------+--------+----------+-----------+--------+---------+--------+--------+----------+----------")
    for i, d in enumerate(cds_sorted[:top_n], start=1):
        print(
            f"{i:4d} | {d['gene'][:10]:10s} | {d['n_codons']:6d} |"
            f" {d['gc3_frac']:8.4f} | {d['lock_frac']:9.4f} |"
            f" {d['lock_count']:6d} | {d['mean_spacing']:7.3f} |"
            f" {(-1 if d['min_spacing'] is None else d['min_spacing']):6d} |"
            f" {(-1 if d['max_spacing'] is None else d['max_spacing']):6d} |"
            f" {('Y' if d['is_hyper_gc3'] else 'N'):8s} |"
            f" {('Y' if d['is_hyper_lock'] else 'N'):8s}"
        )

    print()
    print("LOCK CODON SPACING & CLUSTERING analysis finished.")
    print("=====================================================================================")


# auto-run
run_dna_L36()

# ======================================================================
# DNA-L37 — LOCK CODON CLUSTER DENSITY & ISOLATION (RUN STRUCTURE, CDS-level)
#   - characterizes how lock codons are partitioned into singletons vs clusters
#   - per-CDS:
#       * number of lock runs, mean run length
#       * fraction of lock codons in multi-lock runs (len >= 2)
#       * fraction of lock codons as isolated singletons (len == 1)
#   - compares ALL vs hyper-GC3 vs hyper-lock CDS
#   - reports correlations with GC3, lock_frac & CpG
#   - lists top genes with most clustered vs most isolated lock usage
# ======================================================================

from collections import defaultdict

FASTA_PATH = "/content/ecoli_U00096_3.fna"
GFF_PATH   = "/content/ecoli_U00096_3.gff"

# ----------------------------------------------------------------------
# Reuse loaders/helpers if they already exist, otherwise define them
# ----------------------------------------------------------------------

try:
    load_single_fasta  # type: ignore[name-defined]
except NameError:
    def load_single_fasta(path):
        seq = []
        with open(path, "r") as fh:
            for line in fh:
                if not line:
                    continue
                if line.startswith(">"):
                    continue
                seq.append(line.strip())
        return "".join(seq).upper()

try:
    parse_gff_cds  # type: ignore[name-defined]
except NameError:
    def parse_gff_cds(path):
        cds_list = []
        with open(path, "r") as fh:
            for line in fh:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                parts = line.split("\t")
                if len(parts) < 9:
                    continue
                seqid, source, feature, start, end, score, strand, phase, attrs = parts
                if feature != "CDS":
                    continue
                try:
                    start_i = int(start)
                    end_i   = int(end)
                except ValueError:
                    continue

                gene = None
                for field in attrs.split(";"):
                    if field.startswith("gene="):
                        gene = field.split("=", 1)[1]
                        break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("Name="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("locus_tag="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    gene = f"CDS_{start}_{end}"

                cds_list.append(
                    {
                        "seqid": seqid,
                        "start": start_i,
                        "end": end_i,
                        "strand": strand,
                        "gene": gene,
                    }
                )
        return cds_list

try:
    revcomp  # type: ignore[name-defined]
except NameError:
    _COMP_TABLE = str.maketrans("ACGTacgtNn", "TGCAtgcaNn")
    def revcomp(seq):
        return seq.translate(_COMP_TABLE)[::-1]

# lock codon definition, same as earlier DNA-L modules
try:
    is_lock_codon  # type: ignore[name-defined]
except NameError:
    def is_lock_codon(codon: str) -> bool:
        codon = codon.upper()
        if len(codon) != 3:
            return False
        if any(b not in "ACGT" for b in codon):
            return False
        if codon[2] not in "GC":
            return False
        gc_count = sum(1 for b in codon if b in "GC")
        return gc_count >= 2


def _find_lock_runs(lock_flags):
    """
    lock_flags: list[bool]
    Returns list of (start_index, length) for each consecutive lock-codon run.
    """
    runs = []
    i = 0
    n = len(lock_flags)
    while i < n:
        if lock_flags[i]:
            j = i
            while j < n and lock_flags[j]:
                j += 1
            length = j - i
            runs.append((i, length))
            i = j
        else:
            i += 1
    return runs


def _mean(lst):
    return sum(lst)/len(lst) if lst else 0.0


def _pearson(x, y):
    n = len(x)
    if n == 0 or n != len(y):
        return 0.0
    mx = sum(x)/n
    my = sum(y)/n
    vx = sum((xi - mx)**2 for xi in x)
    vy = sum((yi - my)**2 for yi in y)
    if vx == 0 or vy == 0:
        return 0.0
    num = sum((xi - mx)*(yi - my) for xi, yi in zip(x, y))
    return num / (vx**0.5 * vy**0.5)


def run_dna_L37(fasta_path=FASTA_PATH, gff_path=GFF_PATH):
    print("----------------------------------------------------------------------------------------------------------------------")
    print("RUNNING DNA-L37 — LOCK CODON CLUSTER DENSITY & ISOLATION (RUN STRUCTURE, CDS-level)")
    print("----------------------------------------------------------------------------------------------------------------------")
    print()
    print(f"[DNA-L37] FASTA path: {fasta_path}")
    print(f"[DNA-L37] GFF path  : {gff_path}")
    print()

    genome = load_single_fasta(fasta_path)
    cds_features = parse_gff_cds(gff_path)

    print(f"Genome sequences loaded : 1")
    print(f"CDS features loaded     : {len(cds_features)}")
    print()

    cds_data = []
    gc3_vals = []
    lock_vals = []

    n_total = len(cds_features)

    # ----------------------------------------------------------
    # Per-CDS GC3, lock_frac, CpG, and lock-run structure
    # ----------------------------------------------------------
    for feat in cds_features:
        start  = feat["start"]
        end    = feat["end"]
        strand = feat["strand"]
        gene   = feat["gene"]

        subseq = genome[start-1:end]
        if strand == "-":
            subseq = revcomp(subseq)

        if len(subseq) == 0 or len(subseq) % 3 != 0:
            continue

        n_codons = len(subseq) // 3
        codons = [subseq[i*3:(i+1)*3] for i in range(n_codons)]

        gc3_count = 0
        gc3_sites = 0
        lock_count = 0
        lock_sites = 0

        lock_flags = []

        # CpG across entire CDS
        cpg_count = 0
        for i in range(len(subseq) - 1):
            if subseq[i:i+2].upper() == "CG":
                cpg_count += 1
        cpg_per_kb = (cpg_count / len(subseq)) * 1000.0 if len(subseq) > 0 else 0.0

        for c in codons:
            cu = c.upper()
            if len(cu) != 3 or any(b not in "ACGT" for b in cu):
                lock_flags.append(False)
                continue

            gc3_sites += 1
            if cu[2] in "GC":
                gc3_count += 1

            lock_sites += 1
            is_lock = is_lock_codon(cu)
            if is_lock:
                lock_count += 1
            lock_flags.append(is_lock)

        if gc3_sites == 0 or lock_sites == 0:
            continue

        gc3_frac  = gc3_count / gc3_sites
        lock_frac = lock_count / lock_sites

        gc3_vals.append(gc3_frac)
        lock_vals.append(lock_frac)

        runs = _find_lock_runs(lock_flags)
        n_runs = len(runs)
        if n_runs > 0:
            total_lock_in_runs = sum(L for _, L in runs)
            assert total_lock_in_runs == lock_count
            mean_run_len = total_lock_in_runs / n_runs
            max_run_len  = max(L for _, L in runs)
            min_run_len  = min(L for _, L in runs)
            single_runs  = [L for _, L in runs if L == 1]
            multi_runs   = [L for _, L in runs if L >= 2]
            n_single_runs = len(single_runs)
            n_multi_runs  = len(multi_runs)
            single_codons = sum(single_runs)       # == n_single_runs
            multi_codons  = sum(multi_runs) if multi_runs else 0
            frac_multi_codons   = multi_codons / lock_count if lock_count > 0 else 0.0
            frac_single_codons  = single_codons / lock_count if lock_count > 0 else 0.0
        else:
            mean_run_len = None
            max_run_len  = None
            min_run_len  = None
            n_single_runs = 0
            n_multi_runs  = 0
            frac_multi_codons  = 0.0
            frac_single_codons = 0.0

        cds_data.append(
            {
                "gene": gene,
                "start": start,
                "end": end,
                "strand": strand,
                "n_codons": n_codons,
                "gc3_frac": gc3_frac,
                "lock_frac": lock_frac,
                "lock_count": lock_count,
                "cpg_per_kb": cpg_per_kb,
                "n_runs": n_runs,
                "mean_run_len": mean_run_len,
                "min_run_len": min_run_len,
                "max_run_len": max_run_len,
                "n_single_runs": n_single_runs,
                "n_multi_runs": n_multi_runs,
                "frac_multi_codons": frac_multi_codons,
                "frac_single_codons": frac_single_codons,
            }
        )

    n_valid = len(cds_data)

    # ----------------------------------------------------------
    # Thresholds for hyper-GC3 / hyper-lock
    # ----------------------------------------------------------
    mean_gc3 = sum(gc3_vals)/len(gc3_vals)
    var_gc3  = sum((x - mean_gc3)**2 for x in gc3_vals)/len(gc3_vals)
    sd_gc3   = var_gc3**0.5

    mean_lock = sum(lock_vals)/len(lock_vals)
    var_lock  = sum((x - mean_lock)**2 for x in lock_vals)/len(lock_vals)
    sd_lock   = var_lock**0.5

    thr_gc3  = mean_gc3  + 2.0*sd_gc3
    thr_lock = mean_lock + 2.0*sd_lock

    for d in cds_data:
        d["is_hyper_gc3"]  = d["gc3_frac"]  >= thr_gc3
        d["is_hyper_lock"] = d["lock_frac"] >= thr_lock

    n_hg = sum(1 for d in cds_data if d["is_hyper_gc3"])
    n_hl = sum(1 for d in cds_data if d["is_hyper_lock"])

    print("CDS summary:")
    print(f"  CDS features in GFF        : {n_total}")
    print(f"  CDS analyzed (valid)       : {n_valid}")
    print(f"  CDS skipped (invalid/codon): {n_total - n_valid}")
    print()
    print("--- Per-CDS GC3 & lock thresholds (for run-structure groups) ---")
    print(f"  GC3_frac per CDS           : mean={mean_gc3:.4f}, sd={sd_gc3:.4f}")
    print(f"  Hyper-GC3 threshold        : {thr_gc3:.4f} (mean+2*sd)")
    print(f"  Hyper-GC3 genes (>=thr)    : {n_hg} / {n_valid}")
    print(f"  lock_frac per CDS          : mean={mean_lock:.4f}, sd={sd_lock:.4f}")
    print(f"  Hyper-lock threshold       : {thr_lock:.4f} (mean+2*sd)")
    print(f"  Hyper-lock genes (>=thr)   : {n_hl} / {n_valid}")
    print()

    # ----------------------------------------------------------
    # Global run-structure summaries
    # ----------------------------------------------------------
    # gene-weighted means (per CDS)
    def _collect(group_pred):
        return [d for d in cds_data if group_pred(d)]

    all_cds = cds_data
    hg_cds  = _collect(lambda d: d["is_hyper_gc3"])
    hl_cds  = _collect(lambda d: d["is_hyper_lock"])

    def _mean_attr(ds, key):
        vals = [d[key] for d in ds if d[key] is not None]
        return _mean(vals) if vals else 0.0

    def _mean_attr_nonneg(ds, key):
        vals = [d[key] for d in ds]
        return _mean(vals) if vals else 0.0

    mean_run_all = _mean_attr(all_cds, "mean_run_len")
    mean_run_hg  = _mean_attr(hg_cds, "mean_run_len")
    mean_run_hl  = _mean_attr(hl_cds, "mean_run_len")

    mean_frac_multi_all = _mean_attr_nonneg(all_cds, "frac_multi_codons")
    mean_frac_multi_hg  = _mean_attr_nonneg(hg_cds, "frac_multi_codons")
    mean_frac_multi_hl  = _mean_attr_nonneg(hl_cds, "frac_multi_codons")

    mean_frac_single_all = _mean_attr_nonneg(all_cds, "frac_single_codons")
    mean_frac_single_hg  = _mean_attr_nonneg(hg_cds, "frac_single_codons")
    mean_frac_single_hl  = _mean_attr_nonneg(hl_cds, "frac_single_codons")

    # correlations (gene-level) between clustering and GC3/lock/CpG
    cluster_vals = [d["frac_multi_codons"] for d in cds_data]
    gc3_for_corr = [d["gc3_frac"] for d in cds_data]
    lock_for_corr = [d["lock_frac"] for d in cds_data]
    cpg_for_corr  = [d["cpg_per_kb"] for d in cds_data]

    corr_cluster_gc3  = _pearson(cluster_vals, gc3_for_corr)
    corr_cluster_lock = _pearson(cluster_vals, lock_for_corr)
    corr_cluster_cpg  = _pearson(cluster_vals, cpg_for_corr)

    print("=====================================================================================")
    print("GLOBAL LOCK RUN STRUCTURE: CLUSTER DENSITY vs ISOLATION")
    print("=====================================================================================")
    print()
    print(f"  CDS with >=1 lock run                  : {sum(1 for d in cds_data if d['n_runs'] > 0)} / {n_valid}")
    print()
    print("  Mean run length (codons in lock runs per run):")
    print(f"    ALL CDS       : {mean_run_all:.3f}")
    print(f"    Hyper-GC3 CDS : {mean_run_hg:.3f}")
    print(f"    Hyper-lock CDS: {mean_run_hl:.3f}")
    print()
    print("  Fraction of lock codons in multi-lock runs (len >= 2):")
    print(f"    ALL CDS       : {mean_frac_multi_all:.3f}")
    print(f"    Hyper-GC3 CDS : {mean_frac_multi_hg:.3f}")
    print(f"    Hyper-lock CDS: {mean_frac_multi_hl:.3f}")
    print()
    print("  Fraction of lock codons as isolated singletons (len == 1):")
    print(f"    ALL CDS       : {mean_frac_single_all:.3f}")
    print(f"    Hyper-GC3 CDS : {mean_frac_single_hg:.3f}")
    print(f"    Hyper-lock CDS: {mean_frac_single_hl:.3f}")
    print()
    print("  Pearson correlations (per CDS):")
    print(f"    corr(frac_multi_codons, gc3_frac)  = {corr_cluster_gc3:.4f}")
    print(f"    corr(frac_multi_codons, lock_frac) = {corr_cluster_lock:.4f}")
    print(f"    corr(frac_multi_codons, CpG_per_kb)= {corr_cluster_cpg:.4f}")
    print()

    # ----------------------------------------------------------
    # Top genes: most clustered vs most isolated lock usage
    #   - require some minimum lock_count so it isn't trivial noise
    # ----------------------------------------------------------
    min_locks_for_ranking = 10

    clustered_candidates = [
        d for d in cds_data
        if d["lock_count"] >= min_locks_for_ranking and d["n_runs"] > 0
    ]

    # sort by descending frac_multi_codons, then lock_frac, then gc3_frac
    clustered_sorted = sorted(
        clustered_candidates,
        key=lambda d: (-d["frac_multi_codons"], -d["lock_frac"], -d["gc3_frac"], -d["lock_count"])
    )

    isolated_sorted = sorted(
        clustered_candidates,
        key=lambda d: (d["frac_multi_codons"], -d["lock_frac"], -d["gc3_frac"], -d["lock_count"])
    )

    top_n = 10
    print("-------------------------------------------------------------------------------------")
    print(f"TOP {top_n} GENES BY MOST CLUSTERED LOCK USAGE (HIGHEST FRACTION IN MULTI-LOCK RUNS)")
    print("-------------------------------------------------------------------------------------")
    print("rank | gene        | codons | gc3_frac | lock_frac | n_lock | n_runs | mean_run | frac_multi | frac_single | hyperGC3 | hyperLock")
    print("-----+------------+--------+----------+-----------+--------+--------+----------+------------+------------+----------+----------")
    for i, d in enumerate(clustered_sorted[:top_n], start=1):
        print(
            f"{i:4d} | {d['gene'][:10]:10s} | {d['n_codons']:6d} |"
            f" {d['gc3_frac']:8.4f} | {d['lock_frac']:9.4f} | {d['lock_count']:6d} |"
            f" {d['n_runs']:6d} |"
            f" {(-1 if d['mean_run_len'] is None else d['mean_run_len']):8.3f} |"
            f" {d['frac_multi_codons']:10.3f} |"
            f" {d['frac_single_codons']:10.3f} |"
            f" {('Y' if d['is_hyper_gc3'] else 'N'):8s} |"
            f" {('Y' if d['is_hyper_lock'] else 'N'):8s}"
        )

    print()
    print("-------------------------------------------------------------------------------------")
    print(f"TOP {top_n} GENES BY MOST ISOLATED LOCK USAGE (LOWEST FRACTION IN MULTI-LOCK RUNS)")
    print("-------------------------------------------------------------------------------------")
    print("rank | gene        | codons | gc3_frac | lock_frac | n_lock | n_runs | mean_run | frac_multi | frac_single | hyperGC3 | hyperLock")
    print("-----+------------+--------+----------+-----------+--------+--------+----------+------------+------------+----------+----------")
    for i, d in enumerate(isolated_sorted[:top_n], start=1):
        print(
            f"{i:4d} | {d['gene'][:10]:10s} | {d['n_codons']:6d} |"
            f" {d['gc3_frac']:8.4f} | {d['lock_frac']:9.4f} | {d['lock_count']:6d} |"
            f" {d['n_runs']:6d} |"
            f" {(-1 if d['mean_run_len'] is None else d['mean_run_len']):8.3f} |"
            f" {d['frac_multi_codons']:10.3f} |"
            f" {d['frac_single_codons']:10.3f} |"
            f" {('Y' if d['is_hyper_gc3'] else 'N'):8s} |"
            f" {('Y' if d['is_hyper_lock'] else 'N'):8s}"
        )

    # ----------------------------------------------------------
    # Targeted report for the usual suspect loci (yag/phn/mdt/etc.)
    # ----------------------------------------------------------
    target_genes = [
        "yagA", "yagE", "yagF", "yagG", "yagH",
        "rhsD", "mdtB", "mdtC", "mutS",
        "phnC", "phnD", "phnE", "phnF", "phnG", "phnH",
        "phnI", "phnJ", "phnK", "phnL", "phnM", "phnN",
        "nikB", "nikC", "ugpA", "ugpE",
    ]

    cds_by_gene = defaultdict(list)
    for d in cds_data:
        cds_by_gene[d["gene"]].append(d)

    print()
    print("=====================================================================================")
    print("LOCK RUN CLUSTERING FOR SELECTED LOCI (yag*, rhsD, mdt*, mutS, phn*, nik*, ugp*)")
    print("=====================================================================================")
    print()
    for g in target_genes:
        ds = cds_by_gene.get(g, [])
        if not ds:
            print(f"  [{g}] not found in CDS set.")
            continue
        # if multiple entries with same gene label, just print each
        for d in ds:
            print(f"  [{g}] lock run structure:")
            print(f"    coords          : {d['start']}-{d['end']} (strand={d['strand']})")
            print(f"    nt_len / codons : {d['n_codons']*3} / {d['n_codons']}")
            print(f"    gc3_frac        : {d['gc3_frac']:.4f}")
            print(f"    lock_frac       : {d['lock_frac']:.4f}")
            print(f"    CpG_per_kb      : {d['cpg_per_kb']:.2f}")
            print(f"    lock_codons     : {d['lock_count']}  | n_runs={d['n_runs']}")
            if d["n_runs"] > 0:
                print(f"    run_lengths     : min={d['min_run_len']}, max={d['max_run_len']}, mean={d['mean_run_len']:.3f}")
                print(f"    runs (len==1)   : {d['n_single_runs']}  | runs (len>=2)={d['n_multi_runs']}")
                print(f"    frac_multi_lock : {d['frac_multi_codons']:.3f}")
                print(f"    frac_single_lock: {d['frac_single_codons']:.3f}")
            else:
                print("    no lock runs detected.")
            print(f"    hyperGC3 / hyperLock: {('Y' if d['is_hyper_gc3'] else 'N')} / {('Y' if d['is_hyper_lock'] else 'N')}")
            print()

    print("LOCK CODON CLUSTER DENSITY & ISOLATION analysis finished.")
    print("=====================================================================================")


# auto-run
run_dna_L37()

# ======================================================================
# DNA-L38 — LOCK CODON RUN POSITION & TERMINAL ENRICHMENT (CDS-level)
#   - uses lock codon runs (as in L35/L37) but focuses on *where* they sit
#   - per-run:
#       * mid-position in CDS (0–1)
#       * length category (1, 2–3, 4–6, >=7)
#   - global:
#       * within-CDS positional histograms of run midpoints
#         for all runs and by length category
#       * enrichment of long runs (len >= 5) near 5' vs 3' ends
#         (e.g., first 20%, last 20% of CDS)
#       * separate summaries for ALL / hyper-GC3 / hyper-lock CDS
#   - gene-level:
#       * mean run midpoint per CDS
#       * mean midpoint of long runs (len >= 5)
#       * top genes with 5'-biased vs 3'-biased long-run clustering
#   - targeted report for yag*, rhsD, mdt*, mutS, phn*, nik*, ugp*
# ======================================================================

from collections import defaultdict

FASTA_PATH = "/content/ecoli_U00096_3.fna"
GFF_PATH   = "/content/ecoli_U00096_3.gff"

# ----------------------------------------------------------------------
# Reuse helpers from previous modules if present; otherwise define them
# ----------------------------------------------------------------------

try:
    load_single_fasta  # type: ignore[name-defined]
except NameError:
    def load_single_fasta(path):
        seq = []
        with open(path, "r") as fh:
            for line in fh:
                if not line:
                    continue
                if line.startswith(">"):
                    continue
                seq.append(line.strip())
        return "".join(seq).upper()

try:
    parse_gff_cds  # type: ignore[name-defined]
except NameError:
    def parse_gff_cds(path):
        cds_list = []
        with open(path, "r") as fh:
            for line in fh:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                parts = line.split("\t")
                if len(parts) < 9:
                    continue
                seqid, source, feature, start, end, score, strand, phase, attrs = parts
                if feature != "CDS":
                    continue
                try:
                    start_i = int(start)
                    end_i   = int(end)
                except ValueError:
                    continue

                gene = None
                for field in attrs.split(";"):
                    if field.startswith("gene="):
                        gene = field.split("=", 1)[1]
                        break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("Name="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("locus_tag="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    gene = f"CDS_{start}_{end}"

                cds_list.append(
                    {
                        "seqid": seqid,
                        "start": start_i,
                        "end": end_i,
                        "strand": strand,
                        "gene": gene,
                    }
                )
        return cds_list

try:
    revcomp  # type: ignore[name-defined]
except NameError:
    _COMP_TABLE = str.maketrans("ACGTacgtNn", "TGCAtgcaNn")
    def revcomp(seq):
        return seq.translate(_COMP_TABLE)[::-1]

try:
    is_lock_codon  # type: ignore[name-defined]
except NameError:
    def is_lock_codon(codon: str) -> bool:
        codon = codon.upper()
        if len(codon) != 3:
            return False
        if any(b not in "ACGT" for b in codon):
            return False
        if codon[2] not in "GC":
            return False
        gc_count = sum(1 for b in codon if b in "GC")
        return gc_count >= 2

try:
    _find_lock_runs  # type: ignore[name-defined]
except NameError:
    def _find_lock_runs(lock_flags):
        """
        lock_flags: list[bool]
        Returns list of (start_index, length) for each consecutive lock-codon run.
        """
        runs = []
        i = 0
        n = len(lock_flags)
        while i < n:
            if lock_flags[i]:
                j = i
                while j < n and lock_flags[j]:
                    j += 1
                length = j - i
                runs.append((i, length))
                i = j
            else:
                i += 1
        return runs


def _mean(lst):
    return sum(lst)/len(lst) if lst else 0.0


def _pearson(x, y):
    n = len(x)
    if n == 0 or n != len(y):
        return 0.0
    mx = sum(x)/n
    my = sum(y)/n
    vx = sum((xi - mx)**2 for xi in x)
    vy = sum((yi - my)**2 for yi in y)
    if vx == 0 or vy == 0:
        return 0.0
    num = sum((xi - mx)*(yi - my) for xi, yi in zip(x, y))
    return num / (vx**0.5 * vy**0.5)


def _bin_index(x, nbins):
    """
    x in [0,1]; returns integer bin index in [0, nbins-1]
    """
    if x <= 0.0:
        return 0
    if x >= 1.0:
        return nbins-1
    return int(x * nbins)


def _len_category(L):
    """
    Categorize run length:
      1   -> "1"
      2-3 -> "2-3"
      4-6 -> "4-6"
      >=7 -> ">=7"
    """
    if L <= 1:
        return "1"
    elif L <= 3:
        return "2-3"
    elif L <= 6:
        return "4-6"
    else:
        return ">=7"


def run_dna_L38(fasta_path=FASTA_PATH, gff_path=GFF_PATH, nbins=10,
                long_run_min_len=5, terminal_frac=0.2):
    print("----------------------------------------------------------------------------------------------------------------------")
    print("RUNNING DNA-L38 — LOCK CODON RUN POSITION & TERMINAL ENRICHMENT (CDS-level)")
    print("----------------------------------------------------------------------------------------------------------------------")
    print()
    print(f"[DNA-L38] FASTA path: {fasta_path}")
    print(f"[DNA-L38] GFF path  : {gff_path}")
    print()

    genome = load_single_fasta(fasta_path)
    cds_features = parse_gff_cds(gff_path)

    print(f"Genome sequences loaded : 1")
    print(f"CDS features loaded     : {len(cds_features)}")
    print()

    cds_data = []
    gc3_vals = []
    lock_vals = []

    n_total = len(cds_features)

    # For global run-position histograms
    bins_all = [0]*nbins
    bins_cat = {
        "1":    [0]*nbins,
        "2-3":  [0]*nbins,
        "4-6":  [0]*nbins,
        ">=7":  [0]*nbins,
    }

    bins_all_hg = [0]*nbins
    bins_cat_hg = {k: [0]*nbins for k in bins_cat}

    bins_all_hl = [0]*nbins
    bins_cat_hl = {k: [0]*nbins for k in bins_cat}

    # ------------------------------------------------------------------
    # Iterate CDS, compute GC3/lock, and run midpoints
    # ------------------------------------------------------------------
    for feat in cds_features:
        start  = feat["start"]
        end    = feat["end"]
        strand = feat["strand"]
        gene   = feat["gene"]

        subseq = genome[start-1:end]
        if strand == "-":
            subseq = revcomp(subseq)

        if len(subseq) == 0 or len(subseq) % 3 != 0:
            continue

        n_codons = len(subseq) // 3
        codons = [subseq[i*3:(i+1)*3] for i in range(n_codons)]

        gc3_count = 0
        gc3_sites = 0
        lock_count = 0
        lock_sites = 0
        lock_flags = []

        # CpG for potential correlation later
        cpg_count = 0
        for i in range(len(subseq) - 1):
            if subseq[i:i+2].upper() == "CG":
                cpg_count += 1
        cpg_per_kb = (cpg_count / len(subseq)) * 1000.0 if len(subseq) > 0 else 0.0

        for c in codons:
            cu = c.upper()
            if len(cu) != 3 or any(b not in "ACGT" for b in cu):
                lock_flags.append(False)
                continue

            gc3_sites += 1
            if cu[2] in "GC":
                gc3_count += 1

            lock_sites += 1
            is_lock = is_lock_codon(cu)
            if is_lock:
                lock_count += 1
            lock_flags.append(is_lock)

        if gc3_sites == 0 or lock_sites == 0:
            continue

        gc3_frac  = gc3_count / gc3_sites
        lock_frac = lock_count / lock_sites

        gc3_vals.append(gc3_frac)
        lock_vals.append(lock_frac)

        runs = _find_lock_runs(lock_flags)

        # Per-CDS run midpoint stats
        run_midpoints = []
        run_midpoints_long = []  # long runs only
        n_long_runs = 0

        # per-CDS counts of long runs in 5'/3'/middle
        n_long_5p = 0
        n_long_3p = 0
        n_long_mid = 0

        for (r_start, r_len) in runs:
            # center of the run in codon index space
            r_end = r_start + r_len - 1
            mid_idx = (r_start + r_end) / 2.0
            mid_pos = (mid_idx + 0.5) / n_codons  # map to ~[0,1]

            run_midpoints.append(mid_pos)

            cat = _len_category(r_len)

            # Temporarily store; actual hyper-GC3/hyper-lock bins will
            # be updated after thresholds are computed.
            bin_i = _bin_index(mid_pos, nbins)
            bins_all[bin_i] += 1
            bins_cat[cat][bin_i] += 1

            if r_len >= long_run_min_len:
                n_long_runs += 1
                run_midpoints_long.append(mid_pos)
                if mid_pos < terminal_frac:
                    n_long_5p += 1
                elif mid_pos > 1.0 - terminal_frac:
                    n_long_3p += 1
                else:
                    n_long_mid += 1

        cds_data.append(
            {
                "gene": gene,
                "start": start,
                "end": end,
                "strand": strand,
                "n_codons": n_codons,
                "gc3_frac": gc3_frac,
                "lock_frac": lock_frac,
                "lock_count": lock_count,
                "cpg_per_kb": cpg_per_kb,
                "runs": runs,
                "run_midpoints": run_midpoints,
                "run_midpoints_long": run_midpoints_long,
                "n_long_runs": n_long_runs,
                "n_long_5p": n_long_5p,
                "n_long_3p": n_long_3p,
                "n_long_mid": n_long_mid,
            }
        )

    n_valid = len(cds_data)

    # ------------------------------------------------------------------
    # Thresholds (recompute from this subset to stay consistent)
    # ------------------------------------------------------------------
    mean_gc3 = sum(gc3_vals)/len(gc3_vals)
    var_gc3  = sum((x - mean_gc3)**2 for x in gc3_vals)/len(gc3_vals)
    sd_gc3   = var_gc3**0.5

    mean_lock = sum(lock_vals)/len(lock_vals)
    var_lock  = sum((x - mean_lock)**2 for x in lock_vals)/len(lock_vals)
    sd_lock   = var_lock**0.5

    thr_gc3  = mean_gc3  + 2.0*sd_gc3
    thr_lock = mean_lock + 2.0*sd_lock

    for d in cds_data:
        d["is_hyper_gc3"]  = d["gc3_frac"]  >= thr_gc3
        d["is_hyper_lock"] = d["lock_frac"] >= thr_lock

    n_hg = sum(1 for d in cds_data if d["is_hyper_gc3"])
    n_hl = sum(1 for d in cds_data if d["is_hyper_lock"])

    print("CDS summary:")
    print(f"  CDS features in GFF          : {n_total}")
    print(f"  CDS analyzed (valid)         : {n_valid}")
    print(f"  CDS skipped (invalid/codon)  : {n_total - n_valid}")
    print()
    print("--- Per-CDS GC3 & lock thresholds (for positional groups) ---")
    print(f"  GC3_frac per CDS             : mean={mean_gc3:.4f}, sd={sd_gc3:.4f}")
    print(f"  Hyper-GC3 threshold          : {thr_gc3:.4f} (mean+2*sd)")
    print(f"  Hyper-GC3 genes (>=thr)      : {n_hg} / {n_valid}")
    print(f"  lock_frac per CDS            : mean={mean_lock:.4f}, sd={sd_lock:.4f}")
    print(f"  Hyper-lock threshold         : {thr_lock:.4f} (mean+2*sd)")
    print(f"  Hyper-lock genes (>=thr)     : {n_hl} / {n_valid}")
    print()

    # ------------------------------------------------------------------
    # Now that we know hyper-GC3/lock, fill hyper-specific hist bins
    # ------------------------------------------------------------------
    for d in cds_data:
        is_hg = d["is_hyper_gc3"]
        is_hl = d["is_hyper_lock"]
        for (r_start, r_len) in d["runs"]:
            if d["n_codons"] == 0:
                continue
            r_end = r_start + r_len - 1
            mid_idx = (r_start + r_end) / 2.0
            mid_pos = (mid_idx + 0.5) / d["n_codons"]
            cat = _len_category(r_len)
            bin_i = _bin_index(mid_pos, nbins)

            if is_hg:
                bins_all_hg[bin_i] += 1
                bins_cat_hg[cat][bin_i] += 1
            if is_hl:
                bins_all_hl[bin_i] += 1
                bins_cat_hl[cat][bin_i] += 1

    # ------------------------------------------------------------------
    # Summaries: run midpoint distributions & terminal enrichment
    # ------------------------------------------------------------------
    def _summarize_terminal(ds):
        long_total = sum(d["n_long_runs"] for d in ds)
        long_5p    = sum(d["n_long_5p"] for d in ds)
        long_3p    = sum(d["n_long_3p"] for d in ds)
        long_mid   = sum(d["n_long_mid"] for d in ds)
        if long_total == 0:
            return (0, 0, 0, 0, 0, 0)
        return (
            long_total,
            long_5p, long_3p, long_mid,
            long_5p/long_total,
            long_3p/long_total,
        )

    all_cds = cds_data
    hg_cds  = [d for d in cds_data if d["is_hyper_gc3"]]
    hl_cds  = [d for d in cds_data if d["is_hyper_lock"]]

    # gene-level mean midpoints for long runs
    def _mean_long_mid(ds):
        vals = []
        for d in ds:
            vals.extend(d["run_midpoints_long"])
        return _mean(vals) if vals else 0.0

    mean_mid_long_all = _mean_long_mid(all_cds)
    mean_mid_long_hg  = _mean_long_mid(hg_cds)
    mean_mid_long_hl  = _mean_long_mid(hl_cds)

    total_all, long5_all, long3_all, longmid_all, frac5_all, frac3_all = _summarize_terminal(all_cds)
    total_hg,  long5_hg,  long3_hg,  longmid_hg,  frac5_hg,  frac3_hg  = _summarize_terminal(hg_cds)
    total_hl,  long5_hl,  long3_hl,  longmid_hl,  frac5_hl,  frac3_hl  = _summarize_terminal(hl_cds)

    print("=====================================================================================")
    print("GLOBAL LOCK RUN POSITIONAL LANDSCAPE (RUN MIDPOINTS WITHIN CDS)")
    print("=====================================================================================")
    print()
    print(f"  NBINS (for midpoint histograms): {nbins}")
    print(f"  Long-run definition (len >= L)  : L = {long_run_min_len}")
    print(f"  Terminal fraction (5'/3' window): {terminal_frac:.2f} (first/last {int(terminal_frac*100)}%)")
    print()
    print("  Mean midpoint of long runs (len >= {L}):".format(L=long_run_min_len))
    print(f"    ALL CDS       : {mean_mid_long_all:.3f}")
    print(f"    Hyper-GC3 CDS : {mean_mid_long_hg:.3f}")
    print(f"    Hyper-lock CDS: {mean_mid_long_hl:.3f}")
    print()
    print("  Long-run (len >= {L}) terminal counts & fractions:".format(L=long_run_min_len))
    print("    Group        | long_runs | 5'-runs | 3'-runs | mid-runs | frac_5' | frac_3'")
    print("    -------------+-----------+---------+---------+----------+--------+--------")
    print(f"    ALL CDS      | {total_all:9d} | {long5_all:7d} | {long3_all:7d} | {longmid_all:8d} | {frac5_all:6.3f} | {frac3_all:6.3f}")
    print(f"    Hyper-GC3    | {total_hg:9d} | {long5_hg:7d} | {long3_hg:7d} | {longmid_hg:8d} | {frac5_hg:6.3f} | {frac3_hg:6.3f}")
    print(f"    Hyper-lock   | {total_hl:9d} | {long5_hl:7d} | {long3_hl:7d} | {longmid_hl:8d} | {frac5_hl:6.3f} | {frac3_hl:6.3f}")
    print()

    # Optional: correlations of gene-level mean long-run midpoint with GC3/lock/CpG
    cds_with_long = [d for d in cds_data if d["n_long_runs"] > 0]
    mean_mid_per_cds = []
    gc3_for_corr = []
    lock_for_corr = []
    cpg_for_corr  = []
    for d in cds_with_long:
        mean_mid_per_cds.append(_mean(d["run_midpoints_long"]))
        gc3_for_corr.append(d["gc3_frac"])
        lock_for_corr.append(d["lock_frac"])
        cpg_for_corr.append(d["cpg_per_kb"])

    corr_mid_gc3  = _pearson(mean_mid_per_cds, gc3_for_corr)
    corr_mid_lock = _pearson(mean_mid_per_cds, lock_for_corr)
    corr_mid_cpg  = _pearson(mean_mid_per_cds, cpg_for_corr)

    print("  Pearson correlations (per CDS with >=1 long run):")
    print(f"    corr(mean_long_run_mid, gc3_frac)  = {corr_mid_gc3:.4f}")
    print(f"    corr(mean_long_run_mid, lock_frac) = {corr_mid_lock:.4f}")
    print(f"    corr(mean_long_run_mid, CpG_per_kb)= {corr_mid_cpg:.4f}")
    print()

    # ------------------------------------------------------------------
    # Print midpoint histograms (ALL / hyper-GC3 / hyper-lock)
    # ------------------------------------------------------------------
    def _print_hist(title, bins_dict, total_label="all runs"):
        print(title)
        print("Bin | mid_pos | " + " | ".join(f"{cat:>6s}" for cat in ["ALL", "1", "2-3", "4-6", ">=7"]))
        print("----+---------+" + "+".join(["--------"]*5))
        total_all = float(sum(bins_dict["ALL"]))
        for i in range(nbins):
            mid = (i + 0.5)/nbins
            ca = bins_dict["ALL"][i]
            c1 = bins_dict["1"][i]
            c23 = bins_dict["2-3"][i]
            c46 = bins_dict["4-6"][i]
            c7p = bins_dict[">=7"][i]
            frac = (ca/total_all*100.0) if total_all > 0 else 0.0
            print(f"{i:3d} | {mid:7.3f} | {ca:6d}({frac:4.1f}%) | {c1:6d} | {c23:6d} | {c46:6d} | {c7p:6d}")
        print()

    # Build simple dict wrappers for printing
    bins_all_wrap = {
        "ALL": bins_all,
        "1": bins_cat["1"],
        "2-3": bins_cat["2-3"],
        "4-6": bins_cat["4-6"],
        ">=7": bins_cat[">=7"],
    }
    bins_hg_wrap = {
        "ALL": bins_all_hg,
        "1": bins_cat_hg["1"],
        "2-3": bins_cat_hg["2-3"],
        "4-6": bins_cat_hg["4-6"],
        ">=7": bins_cat_hg[">=7"],
    }
    bins_hl_wrap = {
        "ALL": bins_all_hl,
        "1": bins_cat_hl["1"],
        "2-3": bins_cat_hl["2-3"],
        "4-6": bins_cat_hl["4-6"],
        ">=7": bins_cat_hl[">=7"],
    }

    print("-------------------------------------------------------------------------------------")
    print("WITHIN-CDS LOCK RUN MIDPOINT HISTOGRAM — ALL CDS")
    print("-------------------------------------------------------------------------------------")
    _print_hist("ALL CDS (run midpoint distributions by length category):", bins_all_wrap)

    print("-------------------------------------------------------------------------------------")
    print("WITHIN-CDS LOCK RUN MIDPOINT HISTOGRAM — HYPER-GC3 CDS")
    print("-------------------------------------------------------------------------------------")
    _print_hist("Hyper-GC3 CDS:", bins_hg_wrap)

    print("-------------------------------------------------------------------------------------")
    print("WITHIN-CDS LOCK RUN MIDPOINT HISTOGRAM — HYPER-LOCK CDS")
    print("-------------------------------------------------------------------------------------")
    _print_hist("Hyper-lock CDS:", bins_hl_wrap)

    # ------------------------------------------------------------------
    # Top genes: 5'-biased vs 3'-biased long runs
    # ------------------------------------------------------------------
    min_long_runs_for_ranking = 3

    ranked_candidates = [
        d for d in cds_data if d["n_long_runs"] >= min_long_runs_for_ranking
    ]

    # mean midpoint of long runs per CDS
    for d in ranked_candidates:
        d["mean_mid_long"] = _mean(d["run_midpoints_long"])

    # 5'-biased: lowest mean_mid_long
    ranked_5p = sorted(
        ranked_candidates,
        key=lambda d: (d["mean_mid_long"], -d["n_long_runs"], -d["lock_frac"])
    )

    # 3'-biased: highest mean_mid_long
    ranked_3p = sorted(
        ranked_candidates,
        key=lambda d: (-d["mean_mid_long"], -d["n_long_runs"], -d["lock_frac"])
    )

    top_n = 10
    print("-------------------------------------------------------------------------------------")
    print(f"TOP {top_n} GENES WITH LONG RUNS MOST 5'-SHIFTED (LOWEST MEAN LONG-RUN MIDPOINT)")
    print("-------------------------------------------------------------------------------------")
    print("rank | gene        | codons | gc3_frac | lock_frac | n_long | 5'-long | 3'-long | mean_mid_long | hyperGC3 | hyperLock")
    print("-----+------------+--------+----------+-----------+--------+---------+---------+--------------+----------+----------")
    for i, d in enumerate(ranked_5p[:top_n], start=1):
        print(
            f"{i:4d} | {d['gene'][:10]:10s} | {d['n_codons']:6d} |"
            f" {d['gc3_frac']:8.4f} | {d['lock_frac']:9.4f} | {d['n_long_runs']:6d} |"
            f" {d['n_long_5p']:7d} | {d['n_long_3p']:7d} | {d['mean_mid_long']:12.3f} |"
            f" {('Y' if d['is_hyper_gc3'] else 'N'):8s} |"
            f" {('Y' if d['is_hyper_lock'] else 'N'):8s}"
        )

    print()
    print("-------------------------------------------------------------------------------------")
    print(f"TOP {top_n} GENES WITH LONG RUNS MOST 3'-SHIFTED (HIGHEST MEAN LONG-RUN MIDPOINT)")
    print("-------------------------------------------------------------------------------------")
    print("rank | gene        | codons | gc3_frac | lock_frac | n_long | 5'-long | 3'-long | mean_mid_long | hyperGC3 | hyperLock")
    print("-----+------------+--------+----------+-----------+--------+---------+---------+--------------+----------+----------")
    for i, d in enumerate(ranked_3p[:top_n], start=1):
        print(
            f"{i:4d} | {d['gene'][:10]:10s} | {d['n_codons']:6d} |"
            f" {d['gc3_frac']:8.4f} | {d['lock_frac']:9.4f} | {d['n_long_runs']:6d} |"
            f" {d['n_long_5p']:7d} | {d['n_long_3p']:7d} | {d['mean_mid_long']:12.3f} |"
            f" {('Y' if d['is_hyper_gc3'] else 'N'):8s} |"
            f" {('Y' if d['is_hyper_lock'] else 'N'):8s}"
        )

    # ------------------------------------------------------------------
    # Targeted loci report
    # ------------------------------------------------------------------
    target_genes = [
        "yagA", "yagE", "yagF", "yagG", "yagH",
        "rhsD", "mdtB", "mdtC", "mutS",
        "phnC", "phnD", "phnE", "phnF", "phnG", "phnH",
        "phnI", "phnJ", "phnK", "phnL", "phnM", "phnN",
        "nikB", "nikC", "ugpA", "ugpE",
    ]

    cds_by_gene = defaultdict(list)
    for d in cds_data:
        cds_by_gene[d["gene"]].append(d)

    print()
    print("=====================================================================================")
    print("LOCK RUN POSITION & TERMINAL ENRICHMENT FOR SELECTED LOCI (yag*, rhsD, mdt*, mutS, phn*, nik*, ugp*)")
    print("=====================================================================================")
    print()
    for g in target_genes:
        ds = cds_by_gene.get(g, [])
        if not ds:
            print(f"  [{g}] not found in CDS set.")
            continue
        for d in ds:
            print(f"  [{g}] long-run positional profile:")
            print(f"    coords          : {d['start']}-{d['end']} (strand={d['strand']})")
            print(f"    nt_len / codons : {d['n_codons']*3} / {d['n_codons']}")
            print(f"    gc3_frac        : {d['gc3_frac']:.4f}")
            print(f"    lock_frac       : {d['lock_frac']:.4f}")
            print(f"    CpG_per_kb      : {d['cpg_per_kb']:.2f}")
            print(f"    total lock_runs : {len(d['runs'])}")
            print(f"    long runs (len>={long_run_min_len}): {d['n_long_runs']}")
            if d["n_long_runs"] > 0:
                print(f"    long runs near 5' (pos < {terminal_frac:.2f})   : {d['n_long_5p']}")
                print(f"    long runs near 3' (pos > {1.0-terminal_frac:.2f}): {d['n_long_3p']}")
                print(f"    long runs mid-body                             : {d['n_long_mid']}")
                print(f"    mean midpoint (long runs)                      : {_mean(d['run_midpoints_long']):.3f}")
            else:
                print("    no long runs (len >= {L}) detected.".format(L=long_run_min_len))
            print(f"    hyperGC3 / hyperLock: {('Y' if d['is_hyper_gc3'] else 'N')} / {('Y' if d['is_hyper_lock'] else 'N')}")
            print()

    print("LOCK CODON RUN POSITION & TERMINAL ENRICHMENT analysis finished.")
    print("=====================================================================================")


# auto-run
run_dna_L38()

# ======================================================================
# DNA-L39 — GENOMIC LOCK/GC3/CpG ISLANDS & GENE-ORDER CLUSTERING (CDS-level)
#
#   Inputs: FASTA + GFF (same as earlier DNA-L modules)
#
#   For each CDS:
#     - gc3_frac, lock_frac, CpG_per_kb
#     - genomic midpoint position (absolute bp + normalized 0–1)
#
#   Global:
#     - mean/sd of gc3_frac, lock_frac, CpG_per_kb
#     - hyper thresholds (mean + 2*sd) for GC3, lock, CpG
#     - positional bins across the genome (NBINS_POS)
#         * number of CDS per bin
#         * mean GC3, lock, CpG per bin
#         * fraction of CDS in bin that are hyper-GC3 / hyper-lock / hyper-CpG
#
#   Island / cluster detection along gene order:
#     - hyper-GC3 islands: contiguous runs of CDS that are hyper-GC3 (len >= MIN_GENES)
#     - hyper-lock islands: contiguous runs of CDS that are hyper-lock (len >= MIN_GENES)
#     - hyper-CpG islands: contiguous runs of CDS that are hyper-CpG (len >= MIN_GENES)
#
#   For each island:
#     - rank, number of genes, span (bp & kb), mean gc3_frac, lock_frac, CpG_per_kb
#     - first/last gene names
#
#   Targeted neighborhood summary:
#     - for the yag cluster, rhsD, mdtB/C, mutS, phn cluster, nikB/C, ugpA/E
#       -> show their genomic bin and local neighborhood (±N_NEIGHBOR genes)
#
# ======================================================================

from collections import defaultdict

FASTA_PATH = "/content/ecoli_U00096_3.fna"
GFF_PATH   = "/content/ecoli_U00096_3.gff"

# ----------------------------------------------------------------------
# Reuse helpers from earlier modules if present; otherwise define them
# ----------------------------------------------------------------------

try:
    load_single_fasta  # type: ignore[name-defined]
except NameError:
    def load_single_fasta(path):
        seq = []
        with open(path, "r") as fh:
            for line in fh:
                if not line:
                    continue
                if line.startswith(">"):
                    continue
                seq.append(line.strip())
        return "".join(seq).upper()

try:
    parse_gff_cds  # type: ignore[name-defined]
except NameError:
    def parse_gff_cds(path):
        cds_list = []
        with open(path, "r") as fh:
            for line in fh:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                parts = line.split("\t")
                if len(parts) < 9:
                    continue
                seqid, source, feature, start, end, score, strand, phase, attrs = parts
                if feature != "CDS":
                    continue
                try:
                    start_i = int(start)
                    end_i   = int(end)
                except ValueError:
                    continue

                gene = None
                for field in attrs.split(";"):
                    if field.startswith("gene="):
                        gene = field.split("=", 1)[1]
                        break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("Name="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    for field in attrs.split(";"):
                        if field.startswith("locus_tag="):
                            gene = field.split("=", 1)[1]
                            break
                if gene is None:
                    gene = f"CDS_{start}_{end}"

                cds_list.append(
                    {
                        "seqid": seqid,
                        "start": start_i,
                        "end": end_i,
                        "strand": strand,
                        "gene": gene,
                    }
                )
        return cds_list

try:
    revcomp  # type: ignore[name-defined]
except NameError:
    _COMP_TABLE = str.maketrans("ACGTacgtNn", "TGCAtgcaNn")
    def revcomp(seq):
        return seq.translate(_COMP_TABLE)[::-1]

try:
    is_lock_codon  # type: ignore[name-defined]
except NameError:
    def is_lock_codon(codon: str) -> bool:
        codon = codon.upper()
        if len(codon) != 3:
            return False
        if any(b not in "ACGT" for b in codon):
            return False
        if codon[2] not in "GC":
            return False
        gc_count = sum(1 for b in codon if b in "GC")
        return gc_count >= 2


def _mean(values):
    return sum(values)/len(values) if values else 0.0


def _compute_mean_sd(values):
    if not values:
        return 0.0, 0.0
    m = sum(values)/len(values)
    var = sum((v - m)**2 for v in values)/len(values)
    return m, var**0.5


def _bin_index_pos(x, nbins):
    """
    x in [0,1]; return bin in [0, nbins-1]
    """
    if x <= 0.0:
        return 0
    if x >= 1.0:
        return nbins-1
    return int(x * nbins)


def _find_islands(sorted_cds, key_flag, min_genes=3):
    """
    Given cds_data sorted by genomic coordinate and a flag key (e.g. 'is_hyper_gc3'),
    return a list of contiguous 'islands' where key_flag is True in consecutive genes.

    Each island: dict with
      - start_idx, end_idx (indices into sorted_cds, inclusive)
      - n_genes
      - start_bp, end_bp
      - span_bp
      - mean_gc3, mean_lock, mean_cpg
      - gene_first, gene_last
    """
    islands = []
    i = 0
    n = len(sorted_cds)
    while i < n:
        if not sorted_cds[i][key_flag]:
            i += 1
            continue
        j = i
        while j < n and sorted_cds[j][key_flag]:
            j += 1
        # island from i..j-1
        n_genes = j - i
        if n_genes >= min_genes:
            block = sorted_cds[i:j]
            start_bp = min(d["start"] for d in block)
            end_bp   = max(d["end"] for d in block)
            span_bp  = end_bp - start_bp + 1
            mean_gc3  = _mean([d["gc3_frac"] for d in block])
            mean_lock = _mean([d["lock_frac"] for d in block])
            mean_cpg  = _mean([d["cpg_per_kb"] for d in block])
            gene_first = block[0]["gene"]
            gene_last  = block[-1]["gene"]
            islands.append(
                {
                    "start_idx": i,
                    "end_idx": j-1,
                    "n_genes": n_genes,
                    "start_bp": start_bp,
                    "end_bp": end_bp,
                    "span_bp": span_bp,
                    "mean_gc3": mean_gc3,
                    "mean_lock": mean_lock,
                    "mean_cpg": mean_cpg,
                    "gene_first": gene_first,
                    "gene_last": gene_last,
                }
            )
        i = j
    return islands


def run_dna_L39(fasta_path=FASTA_PATH,
                gff_path=GFF_PATH,
                NBINS_POS=20,
                MIN_GENES_ISLAND=3,
                NEIGHBOR_WINDOW=5):
    print("----------------------------------------------------------------------------------------------------------------------")
    print("RUNNING DNA-L39 — GENOMIC LOCK/GC3/CpG ISLANDS & GENE-ORDER CLUSTERING (CDS-level)")
    print("----------------------------------------------------------------------------------------------------------------------")
    print()
    print(f"[DNA-L39] FASTA path: {fasta_path}")
    print(f"[DNA-L39] GFF path  : {gff_path}")
    print()

    genome = load_single_fasta(fasta_path)
    genome_len = len(genome)
    cds_features = parse_gff_cds(gff_path)

    print(f"Genome length (nt)            : {genome_len}")
    print(f"CDS features loaded           : {len(cds_features)}")
    print()

    cds_data = []
    n_total = len(cds_features)

    gc3_vals = []
    lock_vals = []
    cpg_vals = []

    # ------------------------------------------------------------------
    # Per-CDS metrics: GC3, lock, CpG, genomic position
    # ------------------------------------------------------------------
    for feat in cds_features:
        start  = feat["start"]
        end    = feat["end"]
        strand = feat["strand"]
        gene   = feat["gene"]

        subseq = genome[start-1:end]
        if strand == "-":
            subseq = revcomp(subseq)

        if len(subseq) == 0 or len(subseq) % 3 != 0:
            continue

        n_codons = len(subseq)//3
        codons = [subseq[i*3:(i+1)*3] for i in range(n_codons)]

        gc3_count = 0
        gc3_sites = 0
        lock_count = 0
        lock_sites = 0

        # CpG per kb
        cpg_count = 0
        for i in range(len(subseq)-1):
            if subseq[i:i+2].upper() == "CG":
                cpg_count += 1
        cpg_per_kb = (cpg_count / len(subseq))*1000.0 if len(subseq) > 0 else 0.0

        for c in codons:
            cu = c.upper()
            if len(cu) != 3 or any(b not in "ACGT" for b in cu):
                continue
            gc3_sites += 1
            if cu[2] in "GC":
                gc3_count += 1
            lock_sites += 1
            if is_lock_codon(cu):
                lock_count += 1

        if gc3_sites == 0 or lock_sites == 0:
            continue

        gc3_frac  = gc3_count / gc3_sites
        lock_frac = lock_count / lock_sites

        mid_bp = (start + end)/2.0
        genome_pos = mid_bp / genome_len  # [0,1]

        gc3_vals.append(gc3_frac)
        lock_vals.append(lock_frac)
        cpg_vals.append(cpg_per_kb)

        cds_data.append(
            {
                "gene": gene,
                "start": start,
                "end": end,
                "strand": strand,
                "n_codons": n_codons,
                "gc3_frac": gc3_frac,
                "lock_frac": lock_frac,
                "cpg_per_kb": cpg_per_kb,
                "mid_bp": mid_bp,
                "genome_pos": genome_pos,
            }
        )

    n_valid = len(cds_data)

    mean_gc3, sd_gc3   = _compute_mean_sd(gc3_vals)
    mean_lock, sd_lock = _compute_mean_sd(lock_vals)
    mean_cpg, sd_cpg   = _compute_mean_sd(cpg_vals)

    thr_gc3  = mean_gc3  + 2.0*sd_gc3
    thr_lock = mean_lock + 2.0*sd_lock
    thr_cpg  = mean_cpg  + 2.0*sd_cpg

    for d in cds_data:
        d["is_hyper_gc3"]  = d["gc3_frac"]  >= thr_gc3
        d["is_hyper_lock"] = d["lock_frac"] >= thr_lock
        d["is_hyper_cpg"]  = d["cpg_per_kb"]>= thr_cpg

    n_hg  = sum(1 for d in cds_data if d["is_hyper_gc3"])
    n_hl  = sum(1 for d in cds_data if d["is_hyper_lock"])
    n_hc  = sum(1 for d in cds_data if d["is_hyper_cpg"])

    print("CDS summary:")
    print(f"  CDS features in GFF           : {n_total}")
    print(f"  CDS analyzed (valid)          : {n_valid}")
    print(f"  CDS skipped (invalid/codon)   : {n_total - n_valid}")
    print()
    print("--- Per-CDS GC3, lock & CpG thresholds ---")
    print(f"  GC3_frac per CDS              : mean={mean_gc3:.4f}, sd={sd_gc3:.4f}")
    print(f"  Hyper-GC3 threshold           : {thr_gc3:.4f} (mean+2*sd)")
    print(f"  Hyper-GC3 genes (>=thr)       : {n_hg} / {n_valid}")
    print(f"  lock_frac per CDS             : mean={mean_lock:.4f}, sd={sd_lock:.4f}")
    print(f"  Hyper-lock threshold          : {thr_lock:.4f} (mean+2*sd)")
    print(f"  Hyper-lock genes (>=thr)      : {n_hl} / {n_valid}")
    print(f"  CpG_per_kb per CDS            : mean={mean_cpg:.2f}, sd={sd_cpg:.2f}")
    print(f"  Hyper-CpG threshold           : {thr_cpg:.2f} (mean+2*sd)")
    print(f"  Hyper-CpG genes (>=thr)       : {n_hc} / {n_valid}")
    print()

    # ------------------------------------------------------------------
    # Positional bins along the genome
    # ------------------------------------------------------------------
    bins = []
    for _ in range(NBINS_POS):
        bins.append(
            {
                "n_cds": 0,
                "sum_gc3": 0.0,
                "sum_lock": 0.0,
                "sum_cpg": 0.0,
                "n_hg": 0,
                "n_hl": 0,
                "n_hc": 0,
            }
        )

    for d in cds_data:
        b = _bin_index_pos(d["genome_pos"], NBINS_POS)
        rec = bins[b]
        rec["n_cds"] += 1
        rec["sum_gc3"]  += d["gc3_frac"]
        rec["sum_lock"] += d["lock_frac"]
        rec["sum_cpg"]  += d["cpg_per_kb"]
        if d["is_hyper_gc3"]:
            rec["n_hg"] += 1
        if d["is_hyper_lock"]:
            rec["n_hl"] += 1
        if d["is_hyper_cpg"]:
            rec["n_hc"] += 1

    print("=====================================================================================")
    print("GENOME-WIDE POSITIONAL BINS FOR GC3, LOCK & CpG (CDS MIDPOINTS)")
    print("=====================================================================================")
    print()
    print(f"  NBINS_POS (genome bins)      : {NBINS_POS}")
    print()
    print("Bin | mid_genome | n_CDS | mean_GC3 | mean_lock | mean_CpG | frac_hyperGC3 | frac_hyperLock | frac_hyperCpG")
    print("----+------------+-------+----------+-----------+----------+--------------+---------------+--------------")
    for i, rec in enumerate(bins):
        mid = (i + 0.5)/NBINS_POS
        n_c = rec["n_cds"]
        if n_c > 0:
            mg = rec["sum_gc3"]/n_c
            ml = rec["sum_lock"]/n_c
            mc = rec["sum_cpg"]/n_c
            fhg = rec["n_hg"]/n_c
            fhl = rec["n_hl"]/n_c
            fhc = rec["n_hc"]/n_c
        else:
            mg = ml = mc = fhg = fhl = fhc = 0.0
        print(
            f"{i:3d} |   {mid:7.3f}  | {n_c:5d} |"
            f" {mg:8.4f} | {ml:9.4f} | {mc:8.2f} |"
            f" {fhg:12.3f} | {fhl:13.3f} | {fhc:12.3f}"
        )
    print()

    # ------------------------------------------------------------------
    # Gene-order islands of hyper-GC3 / hyper-lock / hyper-CpG
    # ------------------------------------------------------------------
    sorted_cds = sorted(cds_data, key=lambda d: d["start"])

    islands_gc3 = _find_islands(sorted_cds, "is_hyper_gc3", min_genes=MIN_GENES_ISLAND)
    islands_lock = _find_islands(sorted_cds, "is_hyper_lock", min_genes=MIN_GENES_ISLAND)
    islands_cpg = _find_islands(sorted_cds, "is_hyper_cpg", min_genes=MIN_GENES_ISLAND)

    def _print_island_table(title, islands, metric_key="mean_gc3", top_n=10):
        print("-------------------------------------------------------------------------------------")
        print(title)
        print("-------------------------------------------------------------------------------------")
        if not islands:
            print("  No islands detected with the current settings.")
            print()
            return
        # rank by span_bp (largest first), then by mean metric
        islands_sorted = sorted(
            islands,
            key=lambda d: (-d["n_genes"], -d[metric_key], -d["span_bp"])
        )
        print("rank | n_genes | span_bp | span_kb | start_bp | end_bp | mean_GC3 | mean_lock | mean_CpG | first_gene  | last_gene")
        print("-----+---------+---------+---------+----------+--------+----------+-----------+----------+------------+-----------")
        for i, isl in enumerate(islands_sorted[:top_n], start=1):
            print(
                f"{i:4d} | {isl['n_genes']:7d} | {isl['span_bp']:7d} |"
                f" {isl['span_bp']/1000.0:7.3f} | {isl['start_bp']:8d} | {isl['end_bp']:6d} |"
                f" {isl['mean_gc3']:8.4f} | {isl['mean_lock']:9.4f} | {isl['mean_cpg']:8.2f} |"
                f" {isl['gene_first'][:10]:10s} | {isl['gene_last'][:10]:9s}"
            )
        print()

    print("=====================================================================================")
    print(f"HYPER-GC3 ISLANDS (CONTIGUOUS HYPER-GC3 GENES, MIN_GENES={MIN_GENES_ISLAND})")
    print("=====================================================================================")
    _print_island_table("Top hyper-GC3 islands:", islands_gc3, metric_key="mean_gc3", top_n=10)

    print("=====================================================================================")
    print(f"HYPER-LOCK ISLANDS (CONTIGUOUS HYPER-LOCK GENES, MIN_GENES={MIN_GENES_ISLAND})")
    print("=====================================================================================")
    _print_island_table("Top hyper-lock islands:", islands_lock, metric_key="mean_lock", top_n=10)

    print("=====================================================================================")
    print(f"HYPER-CpG ISLANDS (CONTIGUOUS HYPER-CpG GENES, MIN_GENES={MIN_GENES_ISLAND})")
    print("=====================================================================================")
    _print_island_table("Top hyper-CpG islands:", islands_cpg, metric_key="mean_cpg", top_n=10)

    # ------------------------------------------------------------------
    # Targeted neighborhood summaries around specific loci
    # ------------------------------------------------------------------
    target_genes = [
        "yagA", "yagE", "yagF", "yagG", "yagH",
        "rhsD", "mdtB", "mdtC", "mutS",
        "phnC", "phnD", "phnE", "phnF", "phnG", "phnH",
        "phnI", "phnJ", "phnK", "phnL", "phnM", "phnN",
        "nikB", "nikC", "ugpA", "ugpE",
    ]

    # index sorted_cds by gene name (can be multiple entries; we keep all)
    gene_to_indices = defaultdict(list)
    for idx, d in enumerate(sorted_cds):
        gene_to_indices[d["gene"]].append(idx)

    print("=====================================================================================")
    print("GENOMIC POSITION & NEIGHBORHOODS FOR SELECTED LOCI (yag*, rhsD, mdt*, mutS, phn*, nik*, ugp*)")
    print("=====================================================================================")
    print()
    for g in target_genes:
        if g not in gene_to_indices:
            print(f"  [{g}] not found in CDS set.")
            continue
        for idx in gene_to_indices[g]:
            d = sorted_cds[idx]
            bp_start = d["start"]
            bp_end   = d["end"]
            bin_pos  = _bin_index_pos(d["genome_pos"], NBINS_POS)
            print(f"  [{g}] genomic neighborhood:")
            print(f"    coords           : {bp_start}-{bp_end} (strand={d['strand']})")
            print(f"    genome_pos (0-1) : {d['genome_pos']:.3f} (bin {bin_pos}/{NBINS_POS-1})")
            print(f"    gc3_frac         : {d['gc3_frac']:.4f}")
            print(f"    lock_frac        : {d['lock_frac']:.4f}")
            print(f"    CpG_per_kb       : {d['cpg_per_kb']:.2f}")
            print(f"    hyperGC3/lock/CpG: "
                  f"{'Y' if d['is_hyper_gc3'] else 'N'} / "
                  f"{'Y' if d['is_hyper_lock'] else 'N'} / "
                  f"{'Y' if d['is_hyper_cpg'] else 'N'}")
            print(f"    local neighborhood (±{NEIGHBOR_WINDOW} CDS in gene order):")
            left = max(0, idx-NEIGHBOR_WINDOW)
            right = min(len(sorted_cds)-1, idx+NEIGHBOR_WINDOW)
            print("      idx | gene        | start   | end     | gc3   | lock  | CpG   | hyperG | hyperL | hyperC")
            print("      ----+------------+---------+---------+-------+-------+-------+--------+--------+-------")
            for j in range(left, right+1):
                dj = sorted_cds[j]
                mark = "*" if j == idx else " "
                print(
                    f"      {j:3d}{mark}| {dj['gene'][:10]:10s} |"
                    f" {dj['start']:7d} | {dj['end']:7d} |"
                    f" {dj['gc3_frac']:5.3f} | {dj['lock_frac']:5.3f} | {dj['cpg_per_kb']:5.1f} |"
                    f"   {('Y' if dj['is_hyper_gc3'] else 'N')}    |"
                    f"   {('Y' if dj['is_hyper_lock'] else 'N')}    |"
                    f"   {('Y' if dj['is_hyper_cpg'] else 'N')}"
                )
            print()

    print("GENOMIC LOCK/GC3/CpG ISLANDS & GENE-ORDER CLUSTERING analysis finished.")
    print("=====================================================================================")


# auto-run
run_dna_L39()
