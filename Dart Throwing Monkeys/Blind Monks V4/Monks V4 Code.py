# -*- coding: utf-8 -*-
"""Blind Monks V4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14YV9p3bV5knmiMS1kX3zxXx7Elm4UN_q
"""



#!/usr/bin/env python3
# ==============================================================================
# PHASE8_YUKAWA_MINIMAL_GEOMETRY_NULLSCAN_v1
#   → Null test for the 2D small-integer Yukawa geometry that enforces (-4,4,3)
# ==============================================================================

import math
import random
import numpy as np

# ------------------------------------------------------------------------------
# Pretty-print helpers
# ------------------------------------------------------------------------------

def print_banner(title: str) -> None:
    width = 82
    pad = (width - len(title) - 2)
    left = pad // 2
    right = pad - left
    line = "=" * width
    print(line)
    print(" " * left + " " + title + " " + " " * right)
    print(line)
    print()

def print_section(title: str) -> None:
    line = "-" * 82
    print(line)
    print(title)
    print(line)

# ------------------------------------------------------------------------------
# Core geometry helpers
# ------------------------------------------------------------------------------

def build_basis_triplets(C_basis: int = 4):
    """
    Build all integer rows (r_me, r_tau, r_d) in Z^2 with |components|<=C_basis
    satisfying the exponent-level constraint:

        -4 * row(me) + 4 * row(tau) + 3 * row(d) = 0  (vector equation)

    This enforces the (-4,4,3) lock at the geometry level by construction.
    """
    triplets = []
    seen = set()

    for a1 in range(-C_basis, C_basis + 1):
        for a2 in range(-C_basis, C_basis + 1):
            if a1 == 0 and a2 == 0:
                continue
            r_me = (a1, a2)

            for b1 in range(-C_basis, C_basis + 1):
                for b2 in range(-C_basis, C_basis + 1):
                    if b1 == 0 and b2 == 0:
                        continue
                    r_tau = (b1, b2)

                    # From -4 r_me + 4 r_tau + 3 r_d = 0  →  3 r_d = 4 (r_me - r_tau)
                    rhs0 = 4 * (r_me[0] - r_tau[0])
                    rhs1 = 4 * (r_me[1] - r_tau[1])

                    if rhs0 % 3 != 0 or rhs1 % 3 != 0:
                        continue

                    c1 = rhs0 // 3
                    c2 = rhs1 // 3

                    if abs(c1) > C_basis or abs(c2) > C_basis:
                        continue
                    if c1 == 0 and c2 == 0:
                        continue

                    r_d = (c1, c2)
                    key = (r_me, r_tau, r_d)
                    if key in seen:
                        continue
                    seen.add(key)
                    triplets.append(key)

    return triplets

def build_comp_pairs(C_other: int = 6):
    """
    Build all integer coefficient pairs (c1, c2) in Z^2 with |components|<=C_other,
    excluding (0,0). These are used for the non-basis Yukawas.
    """
    pairs = []
    for i in range(-C_other, C_other + 1):
        for j in range(-C_other, C_other + 1):
            if i == 0 and j == 0:
                continue
            pairs.append((i, j))
    return pairs

def fit_geometry_for_logs(
    z_vec: np.ndarray,
    names: list,
    basis_triplets,
    comp_pairs,
):
    """
    Given:
      • z_vec: array of log10 Yukawas (ordered as 'names')
      • basis_triplets: list of (row(me), row(tau), row(d))
      • comp_pairs: allowed integer coefficient pairs for other Yukawas

    Find the best 2D integer geometry:

      z_i_geom ≈ c_i1 * q1 + c_i2 * q2

    where:
      • (c_me, c_tau, c_d) come from one basis triplet
      • other c_i are chosen from comp_pairs by brute force
      • best is chosen by minimal RMS over all 9 Yukawas, then by smaller max|coef|.
    """
    name_to_idx = {n: i for i, n in enumerate(names)}
    idx_me  = name_to_idx["me_over_v"]
    idx_tau = name_to_idx["mtau_over_v"]
    idx_d   = name_to_idx["md_over_v"]

    best = None

    for r_me, r_tau, r_d in basis_triplets:
        r_me_arr  = np.array(r_me,  dtype=float)
        r_tau_arr = np.array(r_tau, dtype=float)
        r_d_arr   = np.array(r_d,   dtype=float)

        A = np.vstack([r_me_arr, r_tau_arr, r_d_arr])
        if np.linalg.matrix_rank(A) < 2:
            continue

        basis_logs = np.array([z_vec[idx_me], z_vec[idx_tau], z_vec[idx_d]])
        q, *_ = np.linalg.lstsq(A, basis_logs, rcond=None)

        coeffs = {}
        z_pred = np.zeros_like(z_vec)

        # Basis Yukawas
        coeffs[idx_me]  = r_me
        coeffs[idx_tau] = r_tau
        coeffs[idx_d]   = r_d

        z_pred[idx_me]  = float(r_me_arr  @ q)
        z_pred[idx_tau] = float(r_tau_arr @ q)
        z_pred[idx_d]   = float(r_d_arr   @ q)

        # Other Yukawas: brute-force over comp_pairs
        for idx in range(len(z_vec)):
            if idx in (idx_me, idx_tau, idx_d):
                continue

            target = z_vec[idx]
            best_res_sq = float("inf")
            best_c = None

            for c1, c2 in comp_pairs:
                val = c1 * q[0] + c2 * q[1]
                res_sq = (val - target) ** 2
                if res_sq < best_res_sq:
                    best_res_sq = res_sq
                    best_c = (c1, c2)

            coeffs[idx] = best_c
            z_pred[idx] = best_c[0] * q[0] + best_c[1] * q[1]

        resid = z_pred - z_vec
        rms = math.sqrt(float(np.mean(resid ** 2)))
        max_abs = float(np.max(np.abs(resid)))

        # Geometric triple lock; for this construction it will be ~0 by design
        S_geom = abs(
            -4.0 * z_pred[idx_me]
            + 4.0 * z_pred[idx_tau]
            + 3.0 * z_pred[idx_d]
        )

        maxcoef = max(abs(c) for row in coeffs.values() for c in row)
        key = (rms, maxcoef)

        if best is None or key < best["key"]:
            best = {
                "key": key,
                "r_me": r_me,
                "r_tau": r_tau,
                "r_d": r_d,
                "q": q,
                "z_pred": z_pred,
                "resid": resid,
                "coeffs": coeffs,
                "rms": rms,
                "max_abs": max_abs,
                "S_geom": S_geom,
                "maxcoef": maxcoef,
            }

    return best

def sample_jitter_logs(z_central: np.ndarray, halfwidth: float) -> np.ndarray:
    """
    Simple jitter null:
      z_i_null = z_i_real + uniform(-halfwidth, +halfwidth) independently.
    """
    return np.array(
        [random.uniform(val - halfwidth, val + halfwidth) for val in z_central]
    )

# ------------------------------------------------------------------------------
# Main driver
# ------------------------------------------------------------------------------

def run_phase8_yukawa_minimal_geometry_nullscan(
    C_basis: int = 4,
    C_other: int = 6,
    jitter_halfwidth_log10: float = 0.5,
    num_null: int = 2000,
    seed: int = 12345,
):
    # --------------------------------------------------------------------------
    # 1. Fixed Yukawa input (same as in your previous phases)
    # --------------------------------------------------------------------------
    yuk_logs = {
        "me_over_v":   -5.683401,
        "mmu_over_v":  -3.367606,
        "mtau_over_v": -2.141781,
        "mb_over_v":   -1.770024,
        "mc_over_v":   -2.287532,
        "mt_over_v":   -0.154056,
        "md_over_v":   -4.722162,
        "ms_over_v":   -3.422873,
        "mu_over_v":   -5.056852,
    }

    names = [
        "me_over_v",
        "mmu_over_v",
        "mtau_over_v",
        "mb_over_v",
        "mc_over_v",
        "mt_over_v",
        "md_over_v",
        "ms_over_v",
        "mu_over_v",
    ]

    z_real = np.array([yuk_logs[n] for n in names], dtype=float)

    # Real lock value (data)
    z_me   = yuk_logs["me_over_v"]
    z_tau  = yuk_logs["mtau_over_v"]
    z_d    = yuk_logs["md_over_v"]
    S_real = abs(-4.0 * z_me + 4.0 * z_tau + 3.0 * z_d)

    print_banner("PHASE 8 – MODULE 2: MINIMAL YUKAWA GEOMETRY NULLSCAN (2D INTEGER)")

    print_section("[INPUT YUKAWA LOGS]")
    print("  name          log10(value)")
    print("  ------------ -------------")
    for n in names:
        print(f"  {n:12s} {yuk_logs[n]:+12.6f}")
    print()
    print(f"  Real triple lock S_real = |-4 z_me + 4 z_tau + 3 z_d| = {S_real: .6e}")
    print()

    # --------------------------------------------------------------------------
    # 2. Geometry setup
    # --------------------------------------------------------------------------
    print_section("[GEOMETRY SETUP]")
    print(f"  Geometry dimension D                     : 2")
    print(f"  Basis coeff bound for (me,tau,d)         : ±{C_basis:d}")
    print(f"  Coeff bound for other Yukawas            : ±{C_other:d}")
    print(f"  Constraint enforced exactly              : -4 row(me) + 4 row(tau) + 3 row(d) = 0")
    print(f"  Jitter halfwidth for null (log10 units)  : {jitter_halfwidth_log10:.3f}")
    print(f"  Number of null universes                 : {num_null:d}")
    print()

    basis_triplets = build_basis_triplets(C_basis)
    comp_pairs = build_comp_pairs(C_other)

    print(f"  Number of basis (me,tau,d) triplets      : {len(basis_triplets):d}")
    print(f"  Number of coeff pairs for others         : {len(comp_pairs):d}")
    print()

    # --------------------------------------------------------------------------
    # 3. Real-universe geometry fit
    # --------------------------------------------------------------------------
    print_section("[REAL-UNIVERSE MINIMAL GEOMETRY FIT]")

    best_real = fit_geometry_for_logs(z_real, names, basis_triplets, comp_pairs)

    print("  Best basis rows (me, tau, d):")
    print(f"    row(me)  = {best_real['r_me']}")
    print(f"    row(tau) = {best_real['r_tau']}")
    print(f"    row(d)   = {best_real['r_d']}")
    print()
    print("  Fitted geometry parameters q (log10 units):")
    print(f"    q1 = {best_real['q'][0]: .6f}")
    print(f"    q2 = {best_real['q'][1]: .6f}")
    print()
    print("  Fit quality (all 9 Yukawas):")
    print(f"    RMS_all (dex)             : {best_real['rms']: .6f}")
    print(f"    Max |residual| (dex)      : {best_real['max_abs']: .6f}")
    print(f"    Max |integer coeff|       : {best_real['maxcoef']: d}")
    print()
    print("  Lock on geometry:")
    print(f"    S_geom (from geometry)    : {best_real['S_geom']: .6e}")
    print(f"    S_geom / S_real           : {best_real['S_geom'] / S_real if S_real>0 else float('nan'): .3e}")
    print("    (For this construction S_geom is effectively zero by design.)")
    print()

    print("  Per-Yukawa residuals (geom - real):")
    print("  name         coeffs(c1,c2)   z_real      z_geom      resid")
    print("  -----------  --------------  ---------   ---------   --------")
    for i, n in enumerate(names):
        c1, c2 = best_real["coeffs"][i]
        z_r = z_real[i]
        z_g = best_real["z_pred"][i]
        resid = best_real["resid"][i]
        # FIX: remove leading space before '+' so format spec is valid
        print(f"  {n:11s}  ({c1:3d},{c2:3d})   {z_r:+9.6f}   {z_g:+9.6f}   {resid:+8.6f}")
    print()

    # --------------------------------------------------------------------------
    # 4. Null ensemble: jitter Yukawas, refit geometry each time
    # --------------------------------------------------------------------------
    print_section("[NULL ENSEMBLE: JITTERED YUKAWA UNIVERSES]")

    random.seed(seed)

    rms_null = []

    for u in range(num_null):
        z_null = sample_jitter_logs(z_real, jitter_halfwidth_log10)
        best_u = fit_geometry_for_logs(z_null, names, basis_triplets, comp_pairs)
        rms_null.append(best_u["rms"])

        if (u + 1) % max(1, (num_null // 10)) == 0:
            print(f"  ... {u+1}/{num_null} universes processed")

    print()

    # --------------------------------------------------------------------------
    # 5. Null statistics and significance
    # --------------------------------------------------------------------------
    rms_null_sorted = sorted(rms_null)
    n = len(rms_null_sorted)

    def percentile(sorted_list, p):
        if n == 0:
            return float("nan")
        k = (n - 1) * p
        f = math.floor(k)
        c = math.ceil(k)
        if f == c:
            return sorted_list[int(k)]
        return sorted_list[f] + (sorted_list[c] - sorted_list[f]) * (k - f)

    rms_min = rms_null_sorted[0]
    rms_max = rms_null_sorted[-1]
    rms_p25 = percentile(rms_null_sorted, 0.25)
    rms_p50 = percentile(rms_null_sorted, 0.50)
    rms_p75 = percentile(rms_null_sorted, 0.75)
    rms_mean = sum(rms_null_sorted) / n
    rms_var = sum((x - rms_mean) ** 2 for x in rms_null_sorted) / n
    rms_std = math.sqrt(rms_var)

    rms_real = best_real["rms"]
    count_le = sum(1 for x in rms_null_sorted if x <= rms_real)
    p_emp = count_le / n
    z_score = (rms_real - rms_mean) / rms_std if rms_std > 0 else float("nan")

    print_section("[NULL RMS STATISTICS – MINIMAL GEOMETRY FIT]")
    print(f"  null RMS min / max        : {rms_min: .6e} / {rms_max: .6e}")
    print(f"  null RMS 25% / 50% / 75%  : {rms_p25: .6e} / {rms_p50: .6e} / {rms_p75: .6e}")
    print(f"  null RMS mean / std       : {rms_mean: .6e} / {rms_std: .6e}")
    print()
    print_section("[SIGNIFICANCE OF MINIMAL 2D INTEGER GEOMETRY]")
    print(f"  real RMS                  : {rms_real: .6e}")
    print(f"  z(real vs null mean)      : {z_score:+.2f} σ")
    print(f"  P_null(RMS <= real)       : {p_emp: .6f}")
    print()
    print("INTERPRETATION GUIDE:")
    print("  • RMS measures how well a 2D small-integer geometry fits ALL 9 Yukawas.")
    print("  • If P_null is ~0.5, then geometries this good (or better) are common")
    print("    in jittered random Yukawa universes: the geometry is NOT special.")
    print("  • If P_null is very small, the full 9-point geometry would be an extra")
    print("    non-random lock beyond the (-4,4,3) triple itself.")
    print()
    print_banner("PHASE8_YUKAWA_MINIMAL_GEOMETRY_NULLSCAN_v1 COMPLETE")


# ------------------------------------------------------------------------------
# Entry point
# ------------------------------------------------------------------------------

if __name__ == "__main__":
    run_phase8_yukawa_minimal_geometry_nullscan(
        C_basis=4,
        C_other=6,
        jitter_halfwidth_log10=0.5,
        num_null=2000,
        seed=12345,
    )

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE8_YUKAWA_MINIMAL_GEOMETRY_EVIDENCE_v1
  • Takes the result of PHASE 8 – MODULE 2 (minimal 2D integer geometry + nullscan)
  • Encodes it as an evidence item in bits.
  • Prints a loud banner verdict: does this geometry count as a new lock or not?
"""

import math

def run_phase8_yukawa_minimal_geometry_evidence():
    # ----------------------------------------------------------------------
    # 1) Hard-coded summary from PHASE 8 – MODULE 2
    # ----------------------------------------------------------------------
    real_RMS   = 2.681783e-02     # dex
    null_mean  = 8.372246e-02     # dex
    null_std   = 5.308169e-02     # dex
    p_null     = 1.220000e-01     # P_null(RMS <= real)

    # Bits of surprise:
    # bits = -log2(p), but guard against p=0 just in case.
    if p_null <= 0:
        bits = float("inf")
    else:
        bits = -math.log(p_null, 2.0)

    # ----------------------------------------------------------------------
    # 2) Print headline
    # ----------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 8 – MODULE 3: YUKAWA MINIMAL GEOMETRY EVIDENCE UPDATE (2D INTEGER) ")
    print("=" * 82)
    print()

    print("Real-universe minimal 2D integer geometry (from MODULE 2):")
    print(f"  • RMS_all_real (9 Yukawas)  : {real_RMS: .6e} dex")
    print(f"  • Null mean RMS             : {null_mean: .6e} dex")
    print(f"  • Null std RMS              : {null_std: .6e} dex")
    print(f"  • P_null(RMS <= real)       : {p_null: .6e}")
    print(f"  • bits ≈ -log2(p_null)      : {bits: .2f} bits")
    print()

    # ----------------------------------------------------------------------
    # 3) Classify significance (same language as earlier phases)
    # ----------------------------------------------------------------------
    print("=" * 82)
    print(" INTERPRETATION – DOES THIS GEOMETRY COUNT AS A NEW LOCK? ")
    print("=" * 82)
    print()

    if bits < 3:
        level = "COMPLETELY ORDINARY"
        msg = (
            "P_null ≈ 0.12 → about 1 in 8 null universes achieve an equal or better\n"
            "fit. This is well within 'nothing special' territory. The 2D integer\n"
            "geometry is just a convenient parametrization, not new evidence."
        )
    elif bits < 6:
        level = "MILDLY INTERESTING BUT NOT A SURVIVOR"
        msg = (
            "Around ~3–6 bits: mildly interesting, but not strong enough to promote\n"
            "this geometry to a fundamental lock. It does *not* compete with the\n"
            "7–14 bits from the (-4,4,3) triple itself."
        )
    else:
        level = "SURPRISING (would qualify as a lock)"
        msg = (
            "If this happened, the 2D geometry would carry genuine extra evidence.\n"
            "But with the actual p ≈ 0.12, we are not in this regime."
        )

    print(f"Significance level classification: {level}")
    print()
    print(msg)
    print()

    # For our actual numbers, bits ≈ 3.0, so we fall in the 'mild/ordinary' zone:
    print("Verdict for geometry hunting:")
    print("  • The minimal 2D integer geometry for all 9 Yukawas is NOT a new lock.")
    print("  • It should NOT be added as extra bits to the global evidence budget.")
    print("  • The *only* Yukawa lock that geometry must explain remains:")
    print("        me – mtau – md with (-4, 4, 3) and S_real ≈ 6×10^-6.")
    print()

    # ----------------------------------------------------------------------
    # 4) Optional: small evidence object you can reuse later
    # ----------------------------------------------------------------------
    GEOM_EVIDENCE = {
        "yukawa_minimal_2d_integer_geometry": {
            "p_null": p_null,
            "bits": bits,
            "status": "killed" if bits < 5 else "survivor",
            "comment": (
                "2D small-integer geometry enforcing (-4,4,3) for (me, tau, d) "
                "and fitting all 9 Yukawas with RMS ~0.027 dex; null p≈0.12, "
                "so not added as a new lock."
            ),
        }
    }

    print("=" * 82)
    print(" SUMMARY FLAG FOR EVIDENCE BUDGET ")
    print("=" * 82)
    print()
    print("  GEOM_EVIDENCE['yukawa_minimal_2d_integer_geometry'] =")
    print(f"    p_null  = {GEOM_EVIDENCE['yukawa_minimal_2d_integer_geometry']['p_null']:.6e}")
    print(f"    bits    = {GEOM_EVIDENCE['yukawa_minimal_2d_integer_geometry']['bits']:.2f}")
    print(f"    status  = {GEOM_EVIDENCE['yukawa_minimal_2d_integer_geometry']['status']}")
    print()
    print("Interpretation for global geometry search:")
    print("  → We *keep* the me–tau–d (-4,4,3) triple as a primary lock.")
    print("  → We *discard* the full 9-point 2D integer geometry as a separate lock.")
    print()
    print("=" * 82)
    print(" PHASE8_YUKAWA_MINIMAL_GEOMETRY_EVIDENCE_v1 COMPLETE ")
    print("=" * 82)

if __name__ == "__main__":
    run_phase8_yukawa_minimal_geometry_evidence()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE9_YUKAWA_GEOMETRY_STRUCTURE_ANALYZER_v1

Goal:
  • Take the best 2D integer Yukawa geometry found in PHASE 8 – MODULE 1.
  • Treat the integer coefficient pairs (c1,c2) as a "geometry fingerprint".
  • Look for structure:
       - repeated rows ("lock families" in coefficient space),
       - basic stats on family sizes,
       - residuals per family.
  • This is analogous in spirit to the DNA lock-family analysis, but for the
    Yukawa 2D geometry.

IMPORTANT:
  • This module does NOT claim new statistical evidence.
  • It just extracts structure from the *chosen* geometry so we can see
    what patterns exist (e.g. mmu & ms sharing the same coefficients).
  • If something looks interesting, we can later build a dedicated
    nullscan module to test its significance.
"""

import math
from collections import defaultdict

def run_phase9_yukawa_geometry_structure_analyzer():
    # ----------------------------------------------------------------------
    # 1) Hard-coded real Yukawa logs (same as earlier phases)
    # ----------------------------------------------------------------------
    z_real = {
        "me_over_v":   -5.683401,
        "mmu_over_v":  -3.367606,
        "mtau_over_v": -2.141781,
        "mb_over_v":   -1.770024,
        "mc_over_v":   -2.287532,
        "mt_over_v":   -0.154056,
        "md_over_v":   -4.722162,
        "ms_over_v":   -3.422873,
        "mu_over_v":   -5.056852,
    }

    # ----------------------------------------------------------------------
    # 2) Best 2D integer geometry from PHASE 8 – MODULE 1
    #    Basis rows and per-Yukawa coefficients (c1,c2)
    # ----------------------------------------------------------------------
    # Geometry parameters q1, q2 (log10 λ-like scales)
    q1 = 0.830580
    q2 = 1.180540

    # Integer coefficient pairs (c1, c2) for each Yukawa
    coeffs = {
        "me_over_v":   (-4, -2),
        "mmu_over_v":  ( 3, -5),
        "mtau_over_v": (-4,  1),
        "mb_over_v":   ( 5, -5),
        "mc_over_v":   ( 3, -4),
        "mt_over_v":   (-3,  2),
        "md_over_v":   ( 0, -4),
        "ms_over_v":   ( 3, -5),
        "mu_over_v":   ( 1, -5),
    }

    # Basis rows for me, tau, d (just for info)
    row_me  = coeffs["me_over_v"]
    row_tau = coeffs["mtau_over_v"]
    row_d   = coeffs["md_over_v"]

    # Check the enforced (-4,4,3) relation on these rows:
    # -4*row(me) + 4*row(tau) + 3*row(d) should be (0,0).
    rel_vec = (
        -4 * row_me[0] + 4 * row_tau[0] + 3 * row_d[0],
        -4 * row_me[1] + 4 * row_tau[1] + 3 * row_d[1],
    )

    # ----------------------------------------------------------------------
    # 3) Compute predicted logs and residuals
    # ----------------------------------------------------------------------
    z_pred = {}
    resid  = {}

    for name, (c1, c2) in coeffs.items():
        z_g = c1 * q1 + c2 * q2
        z_pred[name] = z_g
        z_r = z_real[name]
        resid[name] = z_g - z_r

    # RMS and max residual over all 9 Yukawas
    all_resid = list(resid.values())
    rms = math.sqrt(sum(r*r for r in all_resid) / len(all_resid))
    max_abs_resid = max(abs(r) for r in all_resid)

    # ----------------------------------------------------------------------
    # 4) Build "coefficient families" (lock-like clusters in coeff space)
    # ----------------------------------------------------------------------
    families = defaultdict(list)
    for name, pair in coeffs.items():
        families[pair].append(name)

    family_list = sorted(
        [(pair, names) for pair, names in families.items()],
        key=lambda x: (-len(x[1]), x[0])
    )

    # Extract stats
    family_sizes = [len(names) for _, names in family_list]
    num_families = len(family_list)
    max_family   = max(family_sizes)
    num_multi    = sum(1 for s in family_sizes if s >= 2)

    # ----------------------------------------------------------------------
    # 5) PRINT OUTPUT
    # ----------------------------------------------------------------------
    print("=" * 82)
    print("          PHASE 9 – MODULE 1: YUKAWA 2D GEOMETRY STRUCTURE ANALYZER          ")
    print("=" * 82)
    print()
    print("Using the best 2D integer geometry from PHASE 8 – MODULE 1.")
    print("We treat each Yukawa's integer pair (c1,c2) as a 'geometry fingerprint'.")
    print("Then we look for 'lock-family' structure in this coefficient space.")
    print()

    print("Best 2D geometry recap:")
    print(f"  q1 (log10-scale) = {q1: .6f}")
    print(f"  q2 (log10-scale) = {q2: .6f}")
    print()
    print("  Basis coefficient rows for (me, tau, d):")
    print(f"    row(me)  = {row_me}")
    print(f"    row(tau) = {row_tau}")
    print(f"    row(d)   = {row_d}")
    print()
    print("  Check of (-4,4,3) relation at row level:")
    print(f"    -4*row(me) + 4*row(tau) + 3*row(d) = {rel_vec}")
    print("    (Should be (0,0) if the (-4,4,3) lock is enforced in coefficient space.)")
    print()

    print("Fit quality over all 9 Yukawas (using these integer rows):")
    print(f"  RMS_all (dex)        : {rms: .6e}")
    print(f"  Max |residual| (dex) : {max_abs_resid: .6e}")
    print()

    print("=" * 82)
    print(" PER-YUKAWA COEFFICIENTS AND RESIDUALS ")
    print("=" * 82)
    print()
    print("  name         (c1,c2)    z_real      z_geom      resid")
    print("  -----------  --------  ---------   ---------   --------")
    for name in sorted(z_real.keys()):
        c1, c2 = coeffs[name]
        z_r = z_real[name]
        z_g = z_pred[name]
        r   = resid[name]
        print(f"  {name:11s}  ({c1:2d},{c2:2d})  {z_r:9.6f}   {z_g:9.6f}   {r:+8.6f}")
    print()

    # ----------------------------------------------------------------------
    # 6) Coefficient families ("lock families" in geometry space)
    # ----------------------------------------------------------------------
    print("=" * 82)
    print(" COEFFICIENT FAMILIES (GEOMETRY LOCK CANDIDATES) ")
    print("=" * 82)
    print()
    print("We group Yukawas that share the EXACT same integer pair (c1,c2).")
    print("This is analogous to 'lock families' in the DNA residue fingerprint space.")
    print()

    print(f"  Total coefficient families     : {num_families}")
    print(f"  Family sizes                   : {family_sizes}")
    print(f"  Number of multi-member families: {num_multi}")
    print(f"  Largest family size            : {max_family}")
    print()

    for idx, (pair, names) in enumerate(family_list, start=1):
        print(f"  Family {idx}: coeffs = {pair}, size = {len(names)}")
        for name in names:
            r = resid[name]
            print(f"    - {name:11s}   resid = {r:+8.6f} dex")
        print()

    print("=" * 82)
    print(" INTERPRETATION (DESCRIPTIVE, NO NULLSCAN YET) ")
    print("=" * 82)
    print()
    print("Key observations in this 2D integer geometry:")
    print("  • me_over_v, mtau_over_v, md_over_v define the basis rows and enforce")
    print("    the (-4,4,3) lock in coefficient space by construction.")
    print("  • We see at least one multi-member coefficient family:")
    print("      e.g. mmu_over_v and ms_over_v share the same (c1,c2) pair (3,-5).")
    print("    That means, in this geometry, muon and strange Yukawas lie on the")
    print("    same 'ray' in coefficient space, with differences absorbed into the")
    print("    residuals at the ~few×10^-2 dex level.")
    print()
    print("At this stage:")
    print("  • These families are *candidates* for additional structure (geometry")
    print("    lock families), but we have NOT tested their significance under a")
    print("    proper null yet.")
    print("  • A future module could:")
    print("       - Run a nullscan over jittered Yukawa universes and re-fit the")
    print("         minimal 2D geometry each time,")
    print("       - Measure the distribution of maximum family size in coefficient")
    print("         space,")
    print("       - Compare the real family sizes (e.g. size-2 mmu/ms) to null.")
    print()
    print("For now, the correct attitude is:")
    print("  → Log these families as structural features of the chosen geometry;")
    print("  → DO NOT treat them as extra 'locks' or extra bits of evidence yet.")
    print()
    print("=" * 82)
    print(" PHASE9_YUKAWA_GEOMETRY_STRUCTURE_ANALYZER_v1 COMPLETE ")
    print("=" * 82)


if __name__ == "__main__":
    run_phase9_yukawa_geometry_structure_analyzer()

"""
PHASE 9 – MODULE 2: YUKAWA 2D GEOMETRY FAMILY NULLSCAN
------------------------------------------------------
Goal:
  Starting from the best 2D integer geometry (with rows for me, tau, d that
  enforce the (-4,4,3) lock), we ask:

    "Are the coefficient families in this geometry (e.g. mmu and ms sharing
     (3,-5)) unusual compared to jittered Yukawa universes?"

  We:
    • Fix the integer rows for (me, tau, d) to the best geometry found earlier.
    • For each universe (real + jittered):
         - Fit geometry parameters q = (q1, q2) by least squares to me, tau, d.
         - For each Yukawa, assign the best small-integer pair (c1,c2) in
           [-C_other, C_other]^2 \ {(0,0)}.
         - Build families in coefficient space and compute:
              * max family size
              * number of collision pairs (sum over families of nC2).
    • Compare the real universe to a jitter null ensemble.

You should be able to run this cell as-is.
"""

import math
import random
from collections import defaultdict
from typing import Dict, Tuple, List

import numpy as np


def run_phase9_yukawa_geometry_family_nullscan(
    C_other: int = 6,
    jitter_halfwidth_log10: float = 0.5,
    num_null: int = 2000,
    seed: int = 20251119,
) -> None:
    print("=" * 82)
    print(" PHASE 9 – MODULE 2: YUKAWA 2D GEOMETRY FAMILY NULLSCAN ".center(82))
    print("=" * 82)
    print()

    # -------------------------------------------------------------------------
    # 1. Input Yukawa logs (central values)
    # -------------------------------------------------------------------------
    z_real: Dict[str, float] = {
        "me_over_v":   -5.683401,
        "mmu_over_v":  -3.367606,
        "mtau_over_v": -2.141781,
        "mb_over_v":   -1.770024,
        "mc_over_v":   -2.287532,
        "mt_over_v":   -0.154056,
        "md_over_v":   -4.722162,
        "ms_over_v":   -3.422873,
        "mu_over_v":   -5.056852,
    }

    names: List[str] = [
        "me_over_v",
        "mmu_over_v",
        "mtau_over_v",
        "mb_over_v",
        "mc_over_v",
        "mt_over_v",
        "md_over_v",
        "ms_over_v",
        "mu_over_v",
    ]

    z_me = z_real["me_over_v"]
    z_tau = z_real["mtau_over_v"]
    z_d = z_real["md_over_v"]

    S_real = abs(-4.0 * z_me + 4.0 * z_tau + 3.0 * z_d)

    print("Real Yukawa triple logs (z = log10(y/v)):")
    print(f"  z_me   = {z_me:.6f}")
    print(f"  z_tau  = {z_tau:.6f}")
    print(f"  z_d    = {z_d:.6f}")
    print(f"  Real triple lock S_real = |-4 z_me + 4 z_tau + 3 z_d| = {S_real:.6e}")
    print()

    # -------------------------------------------------------------------------
    # 2. Fix the integer basis rows for (me, tau, d) from Phase 8 / Phase 9
    # -------------------------------------------------------------------------
    # Best geometry recap (from PHASE 9 – MODULE 1):
    #   row(me)  = (-4, -2)
    #   row(tau) = (-4,  1)
    #   row(d)   = ( 0, -4)
    #   and -4*row(me) + 4*row(tau) + 3*row(d) = (0,0)
    #
    # We treat these rows as defining the 2D geometry; they enforce the
    # (-4,4,3) lock in coefficient space by construction.
    row_me = np.array([-4.0, -2.0])
    row_tau = np.array([-4.0, 1.0])
    row_d = np.array([0.0, -4.0])

    combo = -4.0 * row_me + 4.0 * row_tau + 3.0 * row_d

    print("Fixed basis coefficient rows for (me, tau, d):")
    print(f"  row(me)   = ({row_me[0]:.0f}, {row_me[1]:.0f})")
    print(f"  row(tau)  = ({row_tau[0]:.0f}, {row_tau[1]:.0f})")
    print(f"  row(d)    = ({row_d[0]:.0f}, {row_d[1]:.0f})")
    print(f"  -4*row(me) + 4*row(tau) + 3*row(d) = ({combo[0]:.0f}, {combo[1]:.0f})")
    print("  (Should be (0,0) if the (-4,4,3) lock is enforced in coefficient space.)")
    print()

    # Build matrix A (3x2) and vector z_basis (3,)
    A = np.vstack([row_me, row_tau, row_d])  # shape (3,2)

    # Candidate coefficient pairs for all Yukawas (except we will keep me,tau,d fixed)
    coeff_candidates: List[Tuple[int, int]] = []
    for c1 in range(-C_other, C_other + 1):
        for c2 in range(-C_other, C_other + 1):
            if c1 == 0 and c2 == 0:
                continue
            coeff_candidates.append((c1, c2))

    print("Geometry setup:")
    print(f"  Geometry dimension D                  : 2")
    print(f"  Coeff bound for other Yukawas         : ±{C_other}")
    print(f"  Jitter halfwidth for null (log10)     : {jitter_halfwidth_log10:.3f}")
    print(f"  Number of candidate coeff pairs       : {len(coeff_candidates)}")
    print(f"  Number of null universes              : {num_null}")
    print()

    # -------------------------------------------------------------------------
    # Helper: given a dict of logs z[name], fit q and assign coeffs for all 9.
    # -------------------------------------------------------------------------
    def fit_geometry_and_coeffs(z: Dict[str, float]) -> Tuple[np.ndarray, Dict[str, Tuple[int, int]], Dict[str, float]]:
        """
        Fit q = (q1, q2) in least squares sense to me, tau, d using fixed rows,
        then assign best small-integer coeffs to all Yukawas.

        Returns:
            q         : np.array of shape (2,)
            coeffs    : dict name -> (c1, c2)
            residuals : dict name -> (z_geom - z_real) for each Yukawa
        """
        # Build target vector for basis Yukawas
        b = np.array([z["me_over_v"], z["mtau_over_v"], z["md_over_v"]])

        # Least squares fit for q (3 eqns, 2 unknowns)
        # q = argmin ||A q - b||^2
        q, *_ = np.linalg.lstsq(A, b, rcond=None)

        coeffs: Dict[str, Tuple[int, int]] = {}
        residuals: Dict[str, float] = {}

        # First, fix basis rows explicitly for me, tau, d
        for name, row in [
            ("me_over_v", row_me),
            ("mtau_over_v", row_tau),
            ("md_over_v", row_d),
        ]:
            z_pred = float(row.dot(q))
            resid = z_pred - z[name]
            coeffs[name] = (int(row[0]), int(row[1]))
            residuals[name] = resid

        # Now assign best coeff pair for all others
        for name in names:
            if name in ("me_over_v", "mtau_over_v", "md_over_v"):
                continue
            z_target = z[name]
            best_pair = None
            best_err = float("inf")
            for (c1, c2) in coeff_candidates:
                z_pred = c1 * q[0] + c2 * q[1]
                err = (z_pred - z_target) ** 2
                if err < best_err:
                    best_err = err
                    best_pair = (c1, c2)
            # record best
            c1_best, c2_best = best_pair  # type: ignore
            z_pred = c1_best * q[0] + c2_best * q[1]
            resid = z_pred - z_target
            coeffs[name] = (c1_best, c2_best)
            residuals[name] = resid

        return q, coeffs, residuals

    # -------------------------------------------------------------------------
    # 3. Real-universe geometry: fit q_real and coefficient families
    # -------------------------------------------------------------------------
    q_real, coeffs_real, residuals_real = fit_geometry_and_coeffs(z_real)

    # Compute geometry-based lock S_geom_real (should be ~0)
    z_me_geom = coeffs_real["me_over_v"][0] * q_real[0] + coeffs_real["me_over_v"][1] * q_real[1]
    z_tau_geom = coeffs_real["mtau_over_v"][0] * q_real[0] + coeffs_real["mtau_over_v"][1] * q_real[1]
    z_d_geom = coeffs_real["md_over_v"][0] * q_real[0] + coeffs_real["md_over_v"][1] * q_real[1]
    S_geom_real = abs(-4.0 * z_me_geom + 4.0 * z_tau_geom + 3.0 * z_d_geom)

    # RMS and max residual over all 9 Yukawas
    resid_vals_real = list(residuals_real.values())
    rms_real = math.sqrt(sum(r * r for r in resid_vals_real) / len(resid_vals_real))
    max_resid_real = max(abs(r) for r in resid_vals_real)

    # Build families in coefficient space
    fam_map_real: Dict[Tuple[int, int], List[str]] = defaultdict(list)
    for n in names:
        fam_map_real[coeffs_real[n]].append(n)

    family_sizes_real = sorted(len(v) for v in fam_map_real.values())
    maxfam_real = max(family_sizes_real)
    # total collision pairs = sum over families of nC2
    coll_real = sum(sz * (sz - 1) // 2 for sz in family_sizes_real)

    print("=" * 82)
    print(" REAL-UNIVERSE 2D GEOMETRY & COEFFICIENT FAMILIES ".center(82))
    print("=" * 82)
    print()
    print(f"Fitted geometry parameters q (log10 λ-vector):")
    print(f"  q1 = {q_real[0]: .6f}")
    print(f"  q2 = {q_real[1]: .6f}")
    print()
    print("Fit quality over all 9 Yukawas:")
    print(f"  RMS_all (dex)        : {rms_real:.6e}")
    print(f"  Max |residual| (dex) : {max_resid_real:.6e}")
    print()
    print("Lock combination on geometry:")
    print(f"  S_geom_real          : {S_geom_real:.6e}")
    print(f"  S_geom_real / S_real : {S_geom_real / S_real if S_real > 0 else float('nan'):.3e}")
    print()

    print("Per-Yukawa integer coefficients and residuals (geom - real):")
    print("  name         (c1,c2)   z_real      z_geom      resid")
    print("  -----------  --------  ---------   ---------   --------")
    for n in names:
        c1, c2 = coeffs_real[n]
        z_r = z_real[n]
        z_g = z_r + residuals_real[n]
        resid = residuals_real[n]
        print(f"  {n:11s}  ({c1:2d},{c2:2d})  {z_r:9.6f}   {z_g:9.6f}   {resid:+8.6f}")
    print()

    print("Coefficient families in real geometry:")
    print(f"  Total families              : {len(fam_map_real)}")
    print(f"  Family sizes                : {family_sizes_real}")
    print(f"  Largest family size         : {maxfam_real}")
    print(f"  Total collision pairs       : {coll_real}")
    print()
    for (c1, c2), members in fam_map_real.items():
        print(f"  Family coeffs = ({c1:2d},{c2:2d}), size = {len(members)} → {', '.join(members)}")
    print()

    # -------------------------------------------------------------------------
    # 4. Null ensemble: jitter Yukawa logs, re-fit geometry & families each time
    # -------------------------------------------------------------------------
    rng = np.random.default_rng(seed)

    maxfam_null: List[int] = []
    coll_null: List[int] = []

    print("=" * 82)
    print(" NULL ENSEMBLE: JITTERED YUKAWA UNIVERSES ".center(82))
    print("=" * 82)
    print()
    print("Progress:")
    for i in range(num_null):
        # jittered logs: uniform in [z_real - h, z_real + h]
        z_jit: Dict[str, float] = {}
        for n in names:
            z0 = z_real[n]
            dz = rng.uniform(-jitter_halfwidth_log10, jitter_halfwidth_log10)
            z_jit[n] = z0 + dz

        q_jit, coeffs_jit, residuals_jit = fit_geometry_and_coeffs(z_jit)

        # build families
        fam_map_jit: Dict[Tuple[int, int], List[str]] = defaultdict(list)
        for n in names:
            fam_map_jit[coeffs_jit[n]].append(n)
        sizes = [len(v) for v in fam_map_jit.values()]
        maxfam = max(sizes)
        coll = sum(sz * (sz - 1) // 2 for sz in sizes)

        maxfam_null.append(maxfam)
        coll_null.append(coll)

        if (i + 1) % 200 == 0 or i == num_null - 1:
            print(f"  ... {i+1}/{num_null} universes processed")

    print()

    # -------------------------------------------------------------------------
    # 5. Null statistics vs real
    # -------------------------------------------------------------------------
    def summarize_int_list(xs: List[int]) -> Tuple[int, int, float, float, float]:
        xs_sorted = sorted(xs)
        n = len(xs_sorted)
        lo = xs_sorted[0]
        hi = xs_sorted[-1]
        q25 = xs_sorted[n // 4]
        q50 = xs_sorted[n // 2]
        q75 = xs_sorted[(3 * n) // 4]
        return lo, hi, q25, q50, q75

    maxfam_lo, maxfam_hi, maxfam_q25, maxfam_q50, maxfam_q75 = summarize_int_list(maxfam_null)
    coll_lo, coll_hi, coll_q25, coll_q50, coll_q75 = summarize_int_list(coll_null)

    maxfam_mean = sum(maxfam_null) / len(maxfam_null)
    coll_mean = sum(coll_null) / len(coll_null)

    maxfam_var = sum((x - maxfam_mean) ** 2 for x in maxfam_null) / len(maxfam_null)
    coll_var = sum((x - coll_mean) ** 2 for x in coll_null) / len(coll_null)

    maxfam_std = math.sqrt(maxfam_var)
    coll_std = math.sqrt(coll_var)

    # empirical p-values
    count_maxfam_ge = sum(1 for x in maxfam_null if x >= maxfam_real)
    p_maxfam = count_maxfam_ge / len(maxfam_null)

    count_coll_ge = sum(1 for x in coll_null if x >= coll_real)
    p_coll = count_coll_ge / len(coll_null)

    print("=" * 82)
    print(" NULL STATISTICS – COEFFICIENT FAMILY STRUCTURE ".center(82))
    print("=" * 82)
    print()
    print("Max family size (maxfam):")
    print(f"  null maxfam min / max     : {maxfam_lo} / {maxfam_hi}")
    print(f"  null maxfam 25%/50%/75%   : {maxfam_q25:.1f} / {maxfam_q50:.1f} / {maxfam_q75:.1f}")
    print(f"  null maxfam mean / std    : {maxfam_mean:.3f} / {maxfam_std:.3f}")
    print(f"  real maxfam               : {maxfam_real}")
    print(f"  P_null(maxfam >= real)    : {p_maxfam:.6f}")
    print()
    print("Collision pairs (coll = sum over families of nC2):")
    print(f"  null coll min / max       : {coll_lo} / {coll_hi}")
    print(f"  null coll 25%/50%/75%     : {coll_q25:.1f} / {coll_q50:.1f} / {coll_q75:.1f}")
    print(f"  null coll mean / std      : {coll_mean:.3f} / {coll_std:.3f}")
    print(f"  real coll                 : {coll_real}")
    print(f"  P_null(coll >= real)      : {p_coll:.6f}")
    print()

    print("=" * 82)
    print(" INTERPRETATION GUIDE ".center(82))
    print("=" * 82)
    print()
    print("  • This module tests whether the COEFFICIENT-FAMILY structure of the")
    print("    best 2D integer geometry (with (-4,4,3) enforced) is itself a new")
    print("    'lock' compared to jittered Yukawa universes.")
    print("  • If P_null(maxfam >= real) ≪ 1 and P_null(coll >= real) ≪ 1, then")
    print("    large coefficient families (mmu/ms/etc.) would represent extra")
    print("    non-random structure beyond the me–tau–d triple.")
    print("  • If both p-values are O(0.1–1), the coefficient-family structure")
    print("    is statistically ordinary and should NOT be promoted to a new lock.")
    print()
    print("  You can now plug these p-values into your global evidence budget in")
    print("  the same style as the DNA lock-family tests.")
    print()
    print("=" * 82)
    print(" PHASE9_YUKAWA_GEOMETRY_FAMILY_NULLSCAN_v1 COMPLETE ".center(82))
    print("=" * 82)


if __name__ == "__main__":
    # You can tweak these hyperparameters if desired.
    run_phase9_yukawa_geometry_family_nullscan(
        C_other=6,
        jitter_halfwidth_log10=0.5,
        num_null=2000,
        seed=20251119,
    )

"""
PHASE 9 – MODULE 3: YUKAWA 2D COEFFICIENT-FAMILY EVIDENCE UPDATE
-----------------------------------------------------------------
Goal:
  Use the results from PHASE 9 – MODULE 2 (family nullscan) to decide whether
  the 2D integer-geometry COEFFICIENT FAMILIES (e.g. mmu/ms sharing (3,-5))
  count as an additional lock, or are just noise.

Input numbers (from MODULE 2 output):
  • P_null(maxfam >= real maxfam)  = 0.394000
  • P_null(coll  >= real coll)     = 0.394000

We convert these to "bits of surprise" via bits = -log2(p), classify them,
and update a global evidence object GEOM_EVIDENCE.
"""

import math

def run_phase9_yukawa_family_evidence_update() -> None:
    print("=" * 82)
    print(" PHASE 9 – MODULE 3: YUKAWA 2D COEFFICIENT-FAMILY EVIDENCE UPDATE ".center(82))
    print("=" * 82)
    print()

    # -------------------------------------------------------------------------
    # 1. Hard-code the null results from MODULE 2
    # -------------------------------------------------------------------------
    p_maxfam = 0.394000   # P_null(maxfam >= real)
    p_coll   = 0.394000   # P_null(coll  >= real)

    bits_maxfam = -math.log(p_maxfam, 2)
    bits_coll   = -math.log(p_coll, 2)

    print("Input from PHASE 9 – MODULE 2 (family nullscan):")
    print(f"  P_null(maxfam >= real)  = {p_maxfam:.6f}")
    print(f"  P_null(coll  >= real)   = {p_coll:.6f}")
    print()
    print("Converted to 'bits of surprise'  bits = -log2(p):")
    print(f"  bits_maxfam             = {bits_maxfam:.2f} bits")
    print(f"  bits_coll               = {bits_coll:.2f} bits")
    print()

    # Conservative: treat the *less* surprising of the two as the effective bits
    p_eff   = max(p_maxfam, p_coll)
    bits_eff = -math.log(p_eff, 2)

    print("Effective evidence for 2D coefficient-family structure:")
    print(f"  p_eff                    = {p_eff:.6f}")
    print(f"  bits_eff ≈ -log2(p_eff)  = {bits_eff:.2f} bits")
    print()

    # -------------------------------------------------------------------------
    # 2. Classification
    # -------------------------------------------------------------------------
    # Rough scheme:
    #   bits < 3    : ordinary (killed as a lock)
    #   3–6         : mildly interesting
    #   > 6         : serious lock candidate
    if bits_eff < 3.0:
        status = "killed"
        label  = "ORDINARY (NOT A LOCK)"
    elif bits_eff < 6.0:
        status = "interesting"
        label  = "MILDLY INTERESTING"
    else:
        status = "survivor"
        label  = "SURVIVOR LOCK"

    print("=" * 82)
    print(" INTERPRETATION ".center(82))
    print("=" * 82)
    print()
    print(f"  Effective bits from coefficient-family structure: {bits_eff:.2f} bits")
    print(f"  Classification: {label}")
    print()
    print("  • Since bits_eff ≲ 3, the mmu/ms-style coefficient families in the")
    print("    2D integer geometry are statistically ordinary under the jitter null.")
    print("  • They do NOT constitute an additional 'Yukawa lock' beyond the")
    print("    me–mtau–md (-4,4,3) triple itself.")
    print("  • Geometry hunting should *not* try to explain these families as")
    print("    fundamental; they are part of the noise.")
    print()

    # -------------------------------------------------------------------------
    # 3. Update / create global GEOM_EVIDENCE object
    # -------------------------------------------------------------------------
    global GEOM_EVIDENCE
    try:
        GEOM_EVIDENCE
    except NameError:
        GEOM_EVIDENCE = {}

    if "yukawa_2d_coeff_families" not in GEOM_EVIDENCE:
        GEOM_EVIDENCE["yukawa_2d_coeff_families"] = {}

    GEOM_EVIDENCE["yukawa_2d_coeff_families"].update(
        {
            "p_maxfam": p_maxfam,
            "p_coll": p_coll,
            "p_eff": p_eff,
            "bits_maxfam": bits_maxfam,
            "bits_coll": bits_coll,
            "bits_eff": bits_eff,
            "status": status,
            "description": (
                "2D integer geometry coefficient families (e.g. mmu/ms sharing (3,-5)); "
                "tested vs jitter null."
            ),
        }
    )

    print("=" * 82)
    print(" GLOBAL GEOMETRY EVIDENCE UPDATE ".center(82))
    print("=" * 82)
    print()
    print("  GEOM_EVIDENCE['yukawa_2d_coeff_families'] =")
    for k, v in GEOM_EVIDENCE["yukawa_2d_coeff_families"].items():
        if isinstance(v, float):
            print(f"    {k:12s} : {v:.6g}")
        else:
            print(f"    {k:12s} : {v}")
    print()
    print("Verdict for global geometry search:")
    print("  → KEEP the me–tau–d (-4,4,3) triple as the only Yukawa lock.")
    print("  → DISCARD 2D coefficient families as independent locks.")
    print()
    print("=" * 82)
    print(" PHASE9_YUKAWA_FAMILY_EVIDENCE_UPDATE_v1 COMPLETE ".center(82))
    print("=" * 82)


if __name__ == "__main__":
    run_phase9_yukawa_family_evidence_update()

"""
PHASE 10 – MODULE 1: GLOBAL GEOMETRY LOCK CONTRACT v2
-----------------------------------------------------
Goal:
  • Encode, in code, the current "lock contract" that any serious geometry must satisfy.
  • Provide a reusable scorecard function for candidate geometries.

Based on previous phases:
  • DNA sector:
      Effective DNA bits  ≈ 12.29
      (backbone + locks + four-zero rows; multi-σ, multi-10-bit effects)
  • Yukawa sector (me, mtau, md):
      Global 3-term int-rel (error-model null):
        p ≈ 5.6e-3 → bits ≈ 7.48  (conservative)
      Fixed triple (error-model null):
        p ≈ 5.0e-5 → bits ≈ 14.29 (optimistic)
  • 2D minimal geometry + coefficient families:
      p ~ 0.1–0.4 → bits ≲ 3 → KILLED as locks.

This module:
  • Constructs GLOBAL_LOCKS with DNA + Yukawa lock specs.
  • Exposes score_geometry(...) to print a loud scorecard for any geometry.
"""

import math

# ------------------------------------------------------------------------------
# 1. Construct GLOBAL_LOCKS / GEOMETRY_CONTRACT object
# ------------------------------------------------------------------------------

def build_global_locks_contract():
    """Return a dict encoding the current lock contract for geometry search."""
    dna_effective_bits = 12.29

    yukawa_global_p   = 5.600e-03  # PHASE3B global 3-term error-model null
    yukawa_global_bits = -math.log(yukawa_global_p, 2)  # ≈ 7.48

    yukawa_fixed_p    = 5.000e-05  # fixed triple, error-model null
    yukawa_fixed_bits = -math.log(yukawa_fixed_p, 2)    # ≈ 14.29

    contract = {
        "dna": {
            "effective_bits": dna_effective_bits,
            "description": (
                "DNA residue backbone + lock families + all-four-zero rows; "
                "multi-σ, multi-10-bit structure beyond histogram-preserving nulls."
            ),
            "tests": {
                "entropy_full": {
                    "p": 5.0e-04,
                    "bits": -math.log(5.0e-04, 2),
                    "status": "survivor",
                    "note": "DNA entropy MDL (full).",
                },
                "lock_maxfam_full": {
                    "p": 2.0e-04,
                    "bits": -math.log(2.0e-04, 2),
                    "status": "survivor",
                    "note": "Full DNA lock max-family.",
                },
                "lock_coll_full": {
                    "p": 2.0e-04,
                    "bits": -math.log(2.0e-04, 2),
                    "status": "survivor",
                    "note": "Full DNA lock collision pairs.",
                },
                "four_zero_rows": {
                    "p": 2.0e-04,
                    "bits": -math.log(2.0e-04, 2),
                    "status": "survivor",
                    "note": "Five p=6 rows with all rails zero.",
                },
                # Trimmed entropy/locks exist, but effective bits are dominated
                # by the strongest tests; we keep them conceptually but don't
                # increase the sector-level effective bits to avoid double counting.
            },
        },
        "yukawa": {
            "triple": {
                "names": ("me_over_v", "mtau_over_v", "md_over_v"),
                "coeffs": (-4, 4, 3),
                "S_real": 6.0e-06,
                "description": (
                    "Fixed Yukawa triple with integer coefficients (-4, 4, 3) in log10-space; "
                    "tuned at ~10^-5 with realistic error models."
                ),
                "global_error_model": {
                    "p": yukawa_global_p,
                    "bits": yukawa_global_bits,
                    "status": "survivor",
                    "note": "Global 3-term integer relation under error-model null.",
                },
                "fixed_error_model": {
                    "p": yukawa_fixed_p,
                    "bits": yukawa_fixed_bits,
                    "status": "survivor",
                    "note": "Fixed (me,mtau,md) triple under error-model null.",
                },
                "coeff_stability": {
                    "fraction_lock_best": 0.0635,
                    "status": "supporting",
                    "note": (
                        "(-4,4,3) often remains the best primitive triple under errors; "
                        "supports targeting these exact integers."
                    ),
                },
            },
            "effective_bits_conservative": yukawa_global_bits,
            "effective_bits_optimistic": yukawa_fixed_bits,
            "killed_structures": {
                "minimal_2d_integer_geometry": {
                    "p": 1.22e-01,
                    "bits": -math.log(1.22e-01, 2),
                    "status": "killed",
                    "note": "2D small-integer geometry for all 9 Yukawas; RMS modest, p ~ 0.12.",
                },
                "coeff_families_2d": {
                    "p": 3.94e-01,
                    "bits": -math.log(3.94e-01, 2),
                    "status": "killed",
                    "note": "2D coefficient-family structure (mmu/ms etc.) ordinary under jitter null.",
                },
            },
        },
    }

    # Combined bits
    contract["combined"] = {
        "dna_bits": dna_effective_bits,
        "yukawa_bits_conservative": yukawa_global_bits,
        "yukawa_bits_optimistic": yukawa_fixed_bits,
        "total_bits_conservative": dna_effective_bits + yukawa_global_bits,
        "total_bits_optimistic": dna_effective_bits + yukawa_fixed_bits,
        "note": (
            "Any serious geometry must at least be capable of reproducing "
            "≈ dna_bits + yukawa_bits_conservative ~ 20 bits of structure "
            "in DNA + Yukawa triple, without tuning them by hand."
        ),
    }

    return contract


# Initialize / refresh the global contract
GLOBAL_LOCKS = build_global_locks_contract()


# ------------------------------------------------------------------------------
# 2. Reusable geometry scorecard
# ------------------------------------------------------------------------------

def score_geometry(
    name: str,
    description: str,
    explains_dna_backbone: bool = False,
    explains_yukawa_global_triple: bool = False,
    explains_yukawa_fixed_triple: bool = False,
) -> None:
    """
    Print a loud scorecard for a candidate geometry, using GLOBAL_LOCKS.
    You pass booleans saying which locks the geometry *claims* to explain.
    This function then assigns bits accordingly.
    """

    dna_bits = GLOBAL_LOCKS["dna"]["effective_bits"]
    yukawa_bits_cons = GLOBAL_LOCKS["yukawa"]["effective_bits_conservative"]
    yukawa_bits_opt  = GLOBAL_LOCKS["yukawa"]["effective_bits_optimistic"]

    # Bits earned
    dna_earned = dna_bits if explains_dna_backbone else 0.0

    # Conservative Yukawa bits: only if geometry explains at least the global triple
    yukawa_cons_earned = yukawa_bits_cons if explains_yukawa_global_triple else 0.0

    # Optimistic Yukawa bits: only if geometry explains the *fixed* triple
    yukawa_opt_earned = yukawa_bits_opt if explains_yukawa_fixed_triple else 0.0

    total_cons = dna_earned + yukawa_cons_earned
    total_opt  = dna_earned + yukawa_opt_earned

    banner = "=" * 82
    print(banner)
    title = f"GEOMETRY SCORECARD – {name}"
    print(title.center(82))
    print(banner)
    print()
    print("Description:")
    print(f"  {description}")
    print()
    print("Lock claims:")
    print(f"  • explains_dna_backbone         : {explains_dna_backbone}")
    print(f"  • explains_yukawa_global_triple : {explains_yukawa_global_triple}")
    print(f"  • explains_yukawa_fixed_triple  : {explains_yukawa_fixed_triple}")
    print()
    print("Bits earned (relative to GLOBAL_LOCKS):")
    print(f"  DNA sector bits                 : {dna_earned:5.2f}")
    print(f"  Yukawa bits (conservative)      : {yukawa_cons_earned:5.2f}")
    print(f"  Yukawa bits (optimistic)        : {yukawa_opt_earned:5.2f}")
    print()
    print(f"  → Total (conservative)          : {total_cons:5.2f} bits")
    print(f"  → Total (optimistic)           : {total_opt:5.2f} bits")
    print()
    print(banner)
    print()


# ------------------------------------------------------------------------------
# 3. Example scorecards (you can ignore or reuse as templates)
# ------------------------------------------------------------------------------

def demo_phase10_examples():
    """Print scorecards for a few canonical geometries."""
    # Null geometry: explains nothing
    score_geometry(
        name="NullGeometry",
        description="Random / structureless geometry; predicts nothing and explains no locks.",
        explains_dna_backbone=False,
        explains_yukawa_global_triple=False,
        explains_yukawa_fixed_triple=False,
    )

    # Perfect lock geometry: hypothetical ideal
    score_geometry(
        name="PerfectLockGeometry",
        description=(
            "Hypothetical geometry that derives the DNA backbone/locks and the "
            "Yukawa triple (-4,4,3) from its structure, without tuning."
        ),
        explains_dna_backbone=True,
        explains_yukawa_global_triple=True,
        explains_yukawa_fixed_triple=True,
    )

    # Two-scale FN with physical priors: Yukawa-only, fails triple precision and DNA
    score_geometry(
        name="TwoScaleFN_Physical",
        description=(
            "Two FN spurions λ1, λ2<1 with integer charges for me,mtau,md; "
            "fits rough Yukawa hierarchies but misses the (-4,4,3) triple "
            "by ~10^4 in precision and does not touch DNA."
        ),
        explains_dna_backbone=False,
        explains_yukawa_global_triple=False,
        explains_yukawa_fixed_triple=False,
    )


if __name__ == "__main__":
    # Build / refresh contract and show example scorecards
    GLOBAL_LOCKS = build_global_locks_contract()

    print("=" * 82)
    print(" PHASE 10 – MODULE 1: GLOBAL GEOMETRY LOCK CONTRACT v2 ".center(82))
    print("=" * 82)
    print()
    print("GLOBAL_LOCKS summary:")
    print(f"  DNA effective bits                 : {GLOBAL_LOCKS['dna']['effective_bits']:.2f}")
    print(f"  Yukawa bits (conservative, global) : {GLOBAL_LOCKS['yukawa']['effective_bits_conservative']:.2f}")
    print(f"  Yukawa bits (optimistic, fixed)    : {GLOBAL_LOCKS['yukawa']['effective_bits_optimistic']:.2f}")
    print(f"  Combined bits (conservative)       : {GLOBAL_LOCKS['combined']['total_bits_conservative']:.2f}")
    print(f"  Combined bits (optimistic)         : {GLOBAL_LOCKS['combined']['total_bits_optimistic']:.2f}")
    print()
    print("You can now use score_geometry(name, description, ...) to evaluate ")
    print("future candidate geometries against this contract.")
    print()
    print("=" * 82)
    print(" DEMO SCORECARDS ".center(82))
    print("=" * 82)
    print()
    demo_phase10_examples()

"""
PHASE 10 – MODULE 2: YUKAWA GEOMETRY FRONTIER MAP
--------------------------------------------------
Goal:
  Summarize and compare the concrete Yukawa geometries we've already tested,
  using hard numbers from earlier phases.

We include:
  1) PerfectLockGeometry_Data
  2) SingleLambda_FN (single-λ FN)
  3) TwoScaleFN_Physical (two FN spurions, physical priors)
  4) Minimal2DIntegerGeometry_9pt (2D integer geometry, (-4,4,3) enforced)

Metrics:
  • RMS_me_tau_d (or RMS_all) in dex
  • S_geom = |-4 z_me_geom + 4 z_tau_geom + 3 z_d_geom|
  • S_real = 6.0e-06 (from data)
  • S_ratio = S_geom / S_real
  • Qualitative classification

This gives us a “frontier map” of what works, what fails, and how.
"""

import math

# ---------------------------------------------------------------------------
# 1. Constants from earlier phases
# ---------------------------------------------------------------------------

S_real = 6.0e-06  # real lock S_real = |-4 z_me + 4 z_tau + 3 z_d|

# From PHASE 5 – single-λ FN geometry:
single_lambda = {
    "name": "SingleLambda_FN",
    "description": (
        "Single-λ FN geometry: z_i ≈ n_i * log10(λ) with (n_me,n_tau,n_d) = (19,7,16). "
        "Enforces (-4,4,3) at exponent level, but only matches hierarchies to O(0.04 dex)."
    ),
    "RMS": 0.043453,    # dex (RMS over me, tau, d)
    "max_resid": 0.055112,
    "S_geom": 1.776357e-15,  # from earlier module (essentially 0 for the geometry)
}

# From PHASE 6 – TwoScaleFN_Physical (λ1, λ2<1, integer charges with priors):
two_scale_fn_phys = {
    "name": "TwoScaleFN_Physical",
    "description": (
        "Two-scale FN with physical priors (λ1, λ2<1; non-negative charges). "
        "Fits me, mtau, md to ~0.02 dex RMS, but misses the (-4,4,3) lock by ~1.6×10^4."
    ),
    "RMS": 0.022709,    # dex
    "max_resid": 0.035943,
    "S_geom": 9.584085e-02,  # ≈ 0.09584085
}

# From PHASE 8 – Minimal 2D integer geometry (all 9 Yukawas, (-4,4,3) enforced):
minimal_2d = {
    "name": "Minimal2DIntegerGeometry_9pt",
    "description": (
        "2D small-integer geometry q·c_i with rows for (me,tau,d) chosen so that "
        "(-4,4,3) holds in coefficient space. All 9 Yukawas fit with RMS≈0.027 dex, "
        "max residual ≈0.057 dex."
    ),
    "RMS": 0.026818,    # dex over all 9 Yukawas
    "max_resid": 0.057111,
    "S_geom": 0.0,      # by construction triple lock is exact for the geometry
}

# Perfect lock geometry = 'data is exactly the geometry'
perfect_lock = {
    "name": "PerfectLockGeometry_Data",
    "description": (
        "Reference geometry where the predictions equal the measured Yukawas. "
        "By definition RMS=0 and S_geom=S_real."
    ),
    "RMS": 0.0,
    "max_resid": 0.0,
    "S_geom": S_real,
}


# ---------------------------------------------------------------------------
# 2. Helper: classify each geometry qualitatively
# ---------------------------------------------------------------------------

def classify_geometry(RMS, S_geom, S_real=S_real):
    """
    Return a simple qualitative classification string based on:
      • RMS (dex) – how well we match the actual Yukawas
      • S_geom / S_real – how well the geometry respects the (-4,4,3) lock
    """
    if S_real <= 0:
        S_ratio = math.inf
    else:
        S_ratio = S_geom / S_real if S_geom is not None else math.inf

    # Basic buckets; these are intentionally simple and interpretable
    if RMS == 0.0 and abs(S_ratio - 1.0) < 1e-3:
        return "REFERENCE (perfect data geometry)"

    # Triple extremely tight (comparable or better than real lock scale)
    if S_geom is not None and S_geom <= 10 * S_real:
        if RMS <= 0.01:
            return "STRONG: triple-locked & very precise Yukawas"
        elif RMS <= 0.03:
            return "OK: triple-locked but only moderate Yukawa precision"
        else:
            return "WEAK: triple-locked but poor Yukawa precision"

    # Triple badly missed
    if S_geom is not None and S_geom >= 1e3 * S_real:
        if RMS <= 0.03:
            return "BAD: matches Yukawa magnitudes but DESTROYS triple lock"
        else:
            return "BAD: neither triple nor Yukawas are well reproduced"

    # Fallback
    return "MISC: ambiguous or intermediate quality"


# ---------------------------------------------------------------------------
# 3. Build the frontier list and compute derived quantities
# ---------------------------------------------------------------------------

def build_yukawa_frontier():
    geoms = [perfect_lock, single_lambda, two_scale_fn_phys, minimal_2d]
    enriched = []
    for g in geoms:
        S_geom = g["S_geom"]
        if S_real > 0:
            S_ratio = S_geom / S_real if S_geom is not None else math.inf
        else:
            S_ratio = math.inf
        enriched.append({
            **g,
            "S_ratio": S_ratio,
            "class": classify_geometry(g["RMS"], S_geom, S_real),
        })
    return enriched


# ---------------------------------------------------------------------------
# 4. Pretty-print the frontier map
# ---------------------------------------------------------------------------

def print_yukawa_frontier_map():
    geoms = build_yukawa_frontier()

    banner = "=" * 82
    print(banner)
    print(" PHASE 10 – MODULE 2: YUKAWA GEOMETRY FRONTIER MAP ".center(82))
    print(banner)
    print()
    print(f"Real triple lock scale: S_real = {S_real:.6e}")
    print()

    # Table header
    print("Name                          RMS[dex]   max|res|   S_geom       S_geom/S_real       Class")
    print("-" * 82)

    for g in geoms:
        name = g["name"]
        RMS = g["RMS"]
        maxr = g["max_resid"]
        Sg = g["S_geom"]
        Sr = g["S_ratio"]
        cls = g["class"]
        print(f"{name:28s}  {RMS:8.4f}  {maxr:8.4f}  {Sg:10.3e}  {Sr:14.3e}   {cls}")

    print()
    print(banner)
    print(" DETAILED SUMMARIES ".center(82))
    print(banner)
    print()

    for g in geoms:
        print("=" * 82)
        print(f"GEOMETRY: {g['name']}".center(82))
        print("=" * 82)
        print("Description:")
        print("  " + g["description"])
        print()
        print("Numbers:")
        print(f"  RMS (dex)               : {g['RMS']:.6f}")
        print(f"  Max |residual| (dex)    : {g['max_resid']:.6f}")
        print(f"  S_geom                  : {g['S_geom']:.6e}")
        print(f"  S_geom / S_real         : {g['S_ratio']:.3e}")
        print()
        print(f"Classification: {g['class']}")
        print()


if __name__ == "__main__":
    print_yukawa_frontier_map()

"""
==================================================================================
     PHASE 11 – MODULE 1: YUKAWA 3D INTEGER GEOMETRY (LOCAL SEARCH AROUND 2D)
==================================================================================

Goal:
  • Upgrade from 2D → 3D small-integer geometry for the 9 Yukawas.
  • Keep the (-4,4,3) triple enforced at the COEFFICIENT level.
  • See if a simple 3D geometry can significantly reduce RMS compared to:
        - 2D minimal geometry (RMS ≈ 0.0268 dex)
        - Single-λ FN (RMS ≈ 0.0435 dex)

Setup:
  • Geometry dimension D = 3.
  • Each Yukawa i has an integer coefficient vector c_i ∈ Z^3.
  • Logs are modeled as:  z_i ≈ c_i ⋅ q   with q ∈ R^3.
  • We fix the FIRST TWO components of (me, tau, d) coefficients
    to the best 2D basis:
        row_2D(me)  = (-4, -2)
        row_2D(tau) = (-4,  1)
        row_2D(d)   = ( 0, -4)
    and add a THIRD integer coordinate that we scan over.

  • We enforce the (-4,4,3) triple in coefficient space:
        -4 row(me) + 4 row(tau) + 3 row(d) = 0 (vector equation in R^3)
    This guarantees that in the geometry, the combination
        S_geom = |-4 z_me_geom + 4 z_tau_geom + 3 z_d_geom|
    is identically ~0 (up to numerical precision), even if the
    geometry only approximately matches the actual Yukawas.

  • Given a candidate basis (row(me), row(tau), row(d)):
       - We solve for q in least-squares sense using (me, tau, d).
       - For each of the remaining Yukawas, we assign small-integer
         coefficient vectors c_i ∈ [-C_other, C_other]^3 \ {(0,0,0)}
         that best approximate the real logs.

  • We then measure:
       - RMS_all over all 9 Yukawas.
       - Max |residual|.
       - Max |integer coefficient|.
       - S_geom / S_real as a sanity check (should be ~0 by design).

Interpretation:
  • If 3D geometry can push RMS_all down to ≲ 0.01 dex with small
    integers, that's a strong sign of a very tight low-dimensional
    structure in Yukawa space.
  • If RMS_all stays ~0.02–0.03 dex (like 2D), then 3D is not
    buying much with small coefficients.

You do NOT need to edit anything; just run this module.
"""

import math
import itertools
import numpy as np

# ------------------------------------------------------------------------------
# 1. Input Yukawa logs (central values)
# ------------------------------------------------------------------------------

yukawa_logs = {
    "me_over_v":   -5.683401,
    "mmu_over_v":  -3.367606,
    "mtau_over_v": -2.141781,
    "mb_over_v":   -1.770024,
    "mc_over_v":   -2.287532,
    "mt_over_v":   -0.154056,
    "md_over_v":   -4.722162,
    "ms_over_v":   -3.422873,
    "mu_over_v":   -5.056852,
}

S_real = 6.0e-06  # real lock scale from earlier phases

# Names in a fixed order
yuk_order = [
    "me_over_v",
    "mmu_over_v",
    "mtau_over_v",
    "mb_over_v",
    "mc_over_v",
    "mt_over_v",
    "md_over_v",
    "ms_over_v",
    "mu_over_v",
]

# ------------------------------------------------------------------------------
# 2. Config for this 3D search (local around best 2D geometry)
# ------------------------------------------------------------------------------

C3 = 4        # bound for the third coordinate of basis rows
C_other = 4   # bound for coefficient triples (others Yukawas)

# 2D best basis (from PHASE 8):
#   row(me)_2D  = (-4, -2)
#   row(tau)_2D = (-4,  1)
#   row(d)_2D   = ( 0, -4)
# We will extend these into 3D by adding a scanned third coordinate.


# ------------------------------------------------------------------------------
# 3. Helper: evaluate a single 3D geometry candidate
# ------------------------------------------------------------------------------

def evaluate_geometry_3d(row_me, row_tau, row_d, C_other=4):
    """
    Given integer 3D rows for (me, tau, d), build q via least squares,
    then assign small integer coefficient triples to the remaining Yukawas.

    Returns a dict with:
      - rows: dict of 3D integer rows for all Yukawas
      - q: geometry parameters (length-3 numpy array)
      - RMS_all, max_resid, max_coef_abs, S_geom, S_ratio
      - per_yukawa: list of (name, coeffs, z_real, z_geom, resid)
    """
    z_me   = yukawa_logs["me_over_v"]
    z_tau  = yukawa_logs["mtau_over_v"]
    z_d    = yukawa_logs["md_over_v"]

    # Build A and z_vec for the triple
    A = np.array([row_me, row_tau, row_d], dtype=float)   # shape (3,3)
    z_vec = np.array([z_me, z_tau, z_d], dtype=float)     # shape (3,)

    # Solve for q with least squares (handles rank-deficiency)
    q, residuals, rank, s = np.linalg.lstsq(A, z_vec, rcond=None)

    # Geometry predictions for the triple
    z_me_geom  = float(np.dot(row_me, q))
    z_tau_geom = float(np.dot(row_tau, q))
    z_d_geom   = float(np.dot(row_d, q))

    # Lock in geometry space
    S_geom = abs(-4.0*z_me_geom + 4.0*z_tau_geom + 3.0*z_d_geom)
    S_ratio = S_geom / S_real if S_real > 0 else math.inf

    # Prepare rows dict
    rows = {
        "me_over_v":   np.array(row_me, dtype=int),
        "mtau_over_v": np.array(row_tau, dtype=int),
        "md_over_v":   np.array(row_d, dtype=int),
    }

    # For the remaining 6 Yukawas, we search over small integer triples
    other_names = [n for n in yuk_order if n not in ["me_over_v", "mtau_over_v", "md_over_v"]]

    # Precompute candidate coefficient triples for others
    coeff_candidates = []
    for c1 in range(-C_other, C_other + 1):
        for c2 in range(-C_other, C_other + 1):
            for c3 in range(-C_other, C_other + 1):
                if c1 == 0 and c2 == 0 and c3 == 0:
                    continue
                coeff_candidates.append((c1, c2, c3))

    # Assign best coefficients to each non-basis Yukawa
    for name in other_names:
        z_real = yukawa_logs[name]
        best_coeff = None
        best_z = None
        best_resid = None
        best_abs = float("inf")

        for c1, c2, c3 in coeff_candidates:
            z_pred = float(c1*q[0] + c2*q[1] + c3*q[2])
            resid = z_pred - z_real
            a = abs(resid)
            if a < best_abs:
                best_abs = a
                best_resid = resid
                best_z = z_pred
                best_coeff = (c1, c2, c3)

        rows[name] = np.array(best_coeff, dtype=int)

    # Now compute residuals for all 9 Yukawas
    per_yukawa = []
    squared_sum = 0.0
    max_abs_resid = 0.0
    max_coef_abs = 0

    for name in yuk_order:
        z_real = yukawa_logs[name]
        c = rows[name]
        z_geom = float(np.dot(c, q))
        resid = z_geom - z_real
        per_yukawa.append((name, tuple(int(x) for x in c), z_real, z_geom, resid))
        squared_sum += resid * resid
        abs_resid = abs(resid)
        if abs_resid > max_abs_resid:
            max_abs_resid = abs_resid
        max_coef_abs = max(max_coef_abs, max(abs(int(x)) for x in c))

    RMS_all = math.sqrt(squared_sum / len(yuk_order))

    return {
        "rows": rows,
        "q": q,
        "RMS_all": RMS_all,
        "max_resid": max_abs_resid,
        "max_coef_abs": max_coef_abs,
        "S_geom": S_geom,
        "S_ratio": S_ratio,
        "per_yukawa": per_yukawa,
    }


# ------------------------------------------------------------------------------
# 4. Search over 3D basis patterns anchored on 2D rows
# ------------------------------------------------------------------------------

def run_phase11_yukawa_3d_geometry_local_search(C3=4, C_other=4):
    """
    Anchor the first two coordinates to the best 2D basis:
      row(me)_2D  = (-4, -2)
      row(tau)_2D = (-4,  1)
      row(d)_2D   = ( 0, -4)

    Then:
      • Scan over third coordinates m3, t3 ∈ [-C3, C3].
      • Enforce the (-4,4,3) constraint:
            -4 row(me) + 4 row(tau) + 3 row(d) = 0
        which implies
            row(d) = (4/3) * (row(me) - row(tau))
        component-wise.
      • Require all row(d) components to be integers and |row(d)_i| ≤ C3.

    For each valid basis, evaluate geometry and keep the best few by RMS_all.
    """

    print("=" * 82)
    print(" PHASE 11 – MODULE 1: YUKAWA 3D INTEGER GEOMETRY (LOCAL SEARCH) ".center(82))
    print("=" * 82)
    print()
    print("Anchoring on best 2D basis for (me, tau, d):")
    print("  row_2D(me)  = (-4, -2)")
    print("  row_2D(tau) = (-4,  1)")
    print("  row_2D(d)   = ( 0, -4)")
    print()
    print(f"3D search config:")
    print(f"  • Third-coordinate bound C3        = {C3}")
    print(f"  • Coeff bound for other Yukawas    = ±{C_other}")
    print(f"  • Enforce coefficient-level (-4,4,3) lock.")
    print()

    z_me   = yukawa_logs["me_over_v"]
    z_tau  = yukawa_logs["mtau_over_v"]
    z_d    = yukawa_logs["md_over_v"]

    # For reference, print real triple lock scale
    S_real_local = abs(-4*z_me + 4*z_tau + 3*z_d)
    print(f"Real triple lock scale S_real = {S_real_local:.6e}")
    print()

    candidates = []

    # Scan over m3, t3 for the 3rd coordinate of me and tau
    for m3 in range(-C3, C3 + 1):
        for t3 in range(-C3, C3 + 1):
            # row(me) = (-4, -2, m3)
            # row(tau)= (-4,  1, t3)
            # From -4 r_me + 4 r_tau + 3 r_d = 0 ⇒ 3 r_d = 4 (r_me - r_tau)
            # r_me - r_tau = (0, -3, m3 - t3)
            diff = m3 - t3

            # We need 4*(diff) divisible by 3 for the third component of r_d.
            # The first two components:
            #   r_me - r_tau = (0, -3, diff)
            #   4*(0, -3, diff) = (0, -12, 4*diff)
            #   r_d = (0/3, -12/3, 4*diff/3) = (0, -4, 4*diff/3)
            if (4 * diff) % 3 != 0:
                continue

            d3 = (4 * diff) // 3

            # Now define rows and enforce bounds
            row_me = np.array([-4, -2, m3], dtype=int)
            row_tau = np.array([-4,  1, t3], dtype=int)
            row_d = np.array([0, -4, d3], dtype=int)

            # Bound check
            if any(abs(x) > C3 for x in row_me):
                continue
            if any(abs(x) > C3 for x in row_tau):
                continue
            if any(abs(x) > C3 for x in row_d):
                continue

            # Avoid trivial all-zero rows (they can't happen here, but be safe)
            if np.all(row_me == 0) or np.all(row_tau == 0) or np.all(row_d == 0):
                continue

            # Evaluate this geometry candidate
            geom = evaluate_geometry_3d(row_me, row_tau, row_d, C_other=C_other)
            candidates.append({
                "row_me": row_me,
                "row_tau": row_tau,
                "row_d": row_d,
                **geom,
            })

    print(f"Total valid 3D basis patterns scanned: {len(candidates)}")
    print()

    if not candidates:
        print("No valid 3D geometries found under these bounds.")
        return

    # Sort by RMS_all (ascending)
    candidates.sort(key=lambda g: g["RMS_all"])
    best = candidates[:10]

    # ----------------------------------------------------------------------
    # Summary table of top candidates
    # ----------------------------------------------------------------------
    print("=" * 82)
    print(" TOP 3D GEOMETRY CANDIDATES (LOCAL AROUND 2D) ".center(82))
    print("=" * 82)
    print()
    print("Rank  RMS_all  max|res|  max|coef|   S_geom      S_geom/S_real")
    print("----  -------  -------  ---------  ----------   -------------")

    for i, g in enumerate(best, start=1):
        print(f"{i:4d}  {g['RMS_all']:7.4f}  {g['max_resid']:7.4f}  "
              f"{g['max_coef_abs']:9d}  {g['S_geom']:10.3e}   {g['S_ratio']:13.3e}")

    # ----------------------------------------------------------------------
    # Detailed breakdown for the best geometry
    # ----------------------------------------------------------------------
    best_geom = best[0]
    print()
    print("=" * 82)
    print(" DETAILED BEST 3D GEOMETRY (RANK 1) ".center(82))
    print("=" * 82)
    print()
    print("Basis coefficient rows for (me, tau, d):")
    print(f"  row(me)   = {tuple(int(x) for x in best_geom['row_me'])}")
    print(f"  row(tau)  = {tuple(int(x) for x in best_geom['row_tau'])}")
    print(f"  row(d)    = {tuple(int(x) for x in best_geom['row_d'])}")
    print()
    print("Fitted geometry parameters q (log10 λ-vector):")
    q = best_geom["q"]
    print(f"  q1 = {q[0]: .6f}")
    print(f"  q2 = {q[1]: .6f}")
    print(f"  q3 = {q[2]: .6f}")
    print()
    print("Fit quality over all 9 Yukawas:")
    print(f"  RMS_all (dex)         : {best_geom['RMS_all']:.6f}")
    print(f"  Max |residual| (dex)  : {best_geom['max_resid']:.6f}")
    print(f"  Max |integer coeff|   : {best_geom['max_coef_abs']}")
    print()
    print("Lock on geometry:")
    print(f"  S_geom                : {best_geom['S_geom']:.6e}")
    print(f"  S_geom / S_real       : {best_geom['S_ratio']:.3e}")
    print("  (Should be ~0 because (-4,4,3) is enforced in coefficient space.)")
    print()
    print("Per-Yukawa coefficients and residuals (geom - real):")
    print("  name         (c1,c2,c3)      z_real       z_geom      resid")
    print("  -----------  ----------    ----------   ----------   ---------")
    for name, coeffs, z_real, z_geom, resid in best_geom["per_yukawa"]:
        c1, c2, c3 = coeffs
        print(f"  {name:11s}  ({c1:2d},{c2:2d},{c3:2d})    {z_real:10.6f}   {z_geom:10.6f}   {resid:9.6f}")
    print()
    print("=" * 82)
    print(" INTERPRETATION GUIDE ".center(82))
    print("=" * 82)
    print()
    print("Compare this best 3D RMS_all to:")
    print("  • 2D minimal integer geometry:   RMS ≈ 0.0268 dex")
    print("  • Single-λ FN:                  RMS ≈ 0.0435 dex (me,tau,d only)")
    print()
    print("If the best 3D RMS_all is only ~0.02–0.03 dex, then going to 3D")
    print("with small integers did NOT unlock a dramatically tighter structure.")
    print("If (unexpectedly) RMS_all drops to ≲ 0.01 dex, that would be")
    print("a serious signal of a very rigid low-dimensional geometry.")
    print()
    print("This module is LOCAL around the known best 2D geometry.")
    print("If desired, future modules can:")
    print("  • Drop the anchoring and search more globally in 3D, or")
    print("  • Add MDL/complexity penalties to trade off fit vs simplicity.")
    print()
    print("PHASE11_YUKAWA_3D_GEOMETRY_LOCAL_SEARCH_v1 COMPLETE")
    print("=" * 82)


# ------------------------------------------------------------------------------
# Run module if executed as main
# ------------------------------------------------------------------------------

if __name__ == "__main__":
    run_phase11_yukawa_3d_geometry_local_search(C3=4, C_other=4)

"""
==================================================================================
 PHASE 11 – MODULE 2: YUKAWA 3D INTEGER GEOMETRY NULLSCAN (LOCAL AROUND 2D)
==================================================================================

Goal:
  • Take the 3D small-integer geometry from PHASE 11 – MODULE 1 and ask:
        Is this much compression (RMS ≈ 0.0062 dex) SPECIAL?
  • Do a jitter nullscan:
        - Jitter the 9 Yukawa logs in log10-space with halfwidth h=0.5 dex.
        - For EACH jittered universe, re-run the SAME 3D local integer scan:
              * Basis rows for (me, tau, d) anchored on the best 2D pattern,
                with scanned 3rd coordinates.
              * Enforce the (-4,4,3) lock in coefficient space.
              * Assign small-integer triples to the other Yukawas.
        - Record the best RMS_all in that universe.

  • Compare real RMS_all ≈ 0.0062 dex to the null distribution:
        → p_null = fraction of jitter universes with RMS_all <= real.

If p_null is tiny, the 3D geometry is a new non-random lock.
If p_null is O(0.1–1), the 3D geometry is ordinary and should be killed.

You do NOT need to edit anything; just run this module as-is.
"""

import math
import numpy as np

# ------------------------------------------------------------------------------
# 1. Input Yukawa logs (central values)
# ------------------------------------------------------------------------------

yukawa_logs_central = {
    "me_over_v":   -5.683401,
    "mmu_over_v":  -3.367606,
    "mtau_over_v": -2.141781,
    "mb_over_v":   -1.770024,
    "mc_over_v":   -2.287532,
    "mt_over_v":   -0.154056,
    "md_over_v":   -4.722162,
    "ms_over_v":   -3.422873,
    "mu_over_v":   -5.056852,
}

S_real = 6.0e-06  # triple lock scale

yuk_order = [
    "me_over_v",
    "mmu_over_v",
    "mtau_over_v",
    "mb_over_v",
    "mc_over_v",
    "mt_over_v",
    "md_over_v",
    "ms_over_v",
    "mu_over_v",
]

# ------------------------------------------------------------------------------
# 2. Config for 3D local search and null
# ------------------------------------------------------------------------------

C3 = 4            # bound for basis 3rd coordinate
C_other = 4       # bound for other Yukawa coeff triples
jitter_halfwidth = 0.5  # dex
num_null = 2000
rng = np.random.default_rng(123456)  # fixed seed for reproducibility

# ------------------------------------------------------------------------------
# 3. Core helper: evaluate 3D geometry for a given log-dict
# ------------------------------------------------------------------------------

def evaluate_geometry_3d_for_logs(logs_dict, row_me, row_tau, row_d, C_other=4):
    """
    Given:
      - logs_dict: dict name -> z = log10(y/v)
      - integer 3D rows for (me, tau, d)
      - coeff bound for other Yukawas
    Build q via least squares on (me, tau, d), then assign small-integer triples
    to the remaining Yukawas.

    Returns:
      {
        "rows": dict name -> np.array([c1,c2,c3]),
        "q": np.array([q1,q2,q3]),
        "RMS_all": float,
        "max_resid": float,
        "max_coef_abs": int,
        "S_geom": float,
        "S_ratio": float,
      }
    """
    z_me   = logs_dict["me_over_v"]
    z_tau  = logs_dict["mtau_over_v"]
    z_d    = logs_dict["md_over_v"]

    A = np.array([row_me, row_tau, row_d], dtype=float)   # (3,3)
    z_vec = np.array([z_me, z_tau, z_d], dtype=float)     # (3,)

    q, residuals, rank, s = np.linalg.lstsq(A, z_vec, rcond=None)

    z_me_geom  = float(np.dot(row_me, q))
    z_tau_geom = float(np.dot(row_tau, q))
    z_d_geom   = float(np.dot(row_d, q))

    S_geom = abs(-4.0*z_me_geom + 4.0*z_tau_geom + 3.0*z_d_geom)
    S_ratio = S_geom / S_real if S_real > 0 else math.inf

    rows = {
        "me_over_v":   np.array(row_me, dtype=int),
        "mtau_over_v": np.array(row_tau, dtype=int),
        "md_over_v":   np.array(row_d, dtype=int),
    }

    other_names = [n for n in yuk_order if n not in ["me_over_v", "mtau_over_v", "md_over_v"]]

    # Precompute all coefficient triples for others
    coeff_candidates = []
    for c1 in range(-C_other, C_other + 1):
        for c2 in range(-C_other, C_other + 1):
            for c3 in range(-C_other, C_other + 1):
                if c1 == 0 and c2 == 0 and c3 == 0:
                    continue
                coeff_candidates.append((c1, c2, c3))

    # Assign best triples to others
    for name in other_names:
        z_real = logs_dict[name]
        best_coeff = None
        best_resid_abs = float("inf")

        for (c1, c2, c3) in coeff_candidates:
            z_pred = float(c1*q[0] + c2*q[1] + c3*q[2])
            resid_abs = abs(z_pred - z_real)
            if resid_abs < best_resid_abs:
                best_resid_abs = resid_abs
                best_coeff = (c1, c2, c3)

        rows[name] = np.array(best_coeff, dtype=int)

    # Residuals over all 9
    squared_sum = 0.0
    max_abs_resid = 0.0
    max_coef_abs = 0

    for name in yuk_order:
        z_real = logs_dict[name]
        c = rows[name]
        z_geom = float(np.dot(c, q))
        resid = z_geom - z_real
        squared_sum += resid * resid
        ar = abs(resid)
        if ar > max_abs_resid:
            max_abs_resid = ar
        max_coef_abs = max(max_coef_abs, max(abs(int(x)) for x in c))

    RMS_all = math.sqrt(squared_sum / len(yuk_order))

    return {
        "rows": rows,
        "q": q,
        "RMS_all": float(RMS_all),
        "max_resid": float(max_abs_resid),
        "max_coef_abs": int(max_coef_abs),
        "S_geom": float(S_geom),
        "S_ratio": float(S_ratio),
    }

# ------------------------------------------------------------------------------
# 4. Helper: best 3D geometry for a given log-dict (local scan around 2D basis)
# ------------------------------------------------------------------------------

def best_3d_geometry_for_logs(logs_dict, C3=4, C_other=4):
    """
    Anchor on the 2D basis:
      row_2D(me)  = (-4, -2)
      row_2D(tau) = (-4,  1)
      row_2D(d)   = ( 0, -4)

    Extend to 3D by scanning third coords m3, t3 in [-C3, C3], and enforcing
    coefficient-level (-4,4,3) lock:
        -4 r_me + 4 r_tau + 3 r_d = 0
      ⇒ 3 r_d = 4 (r_me - r_tau)

    For each valid triple (row_me, row_tau, row_d), fit q and assign rows for
    the other Yukawas, then keep the pattern with minimal RMS_all.
    """
    candidates = []

    for m3 in range(-C3, C3 + 1):
        for t3 in range(-C3, C3 + 1):
            # row(me) = (-4, -2, m3)
            # row(tau)= (-4,  1, t3)
            # r_me - r_tau = (0, -3, m3 - t3)
            diff = m3 - t3
            # Need 4*diff divisible by 3 for d3
            if (4 * diff) % 3 != 0:
                continue
            d3 = (4 * diff) // 3

            row_me = np.array([-4, -2, m3], dtype=int)
            row_tau = np.array([-4,  1, t3], dtype=int)
            row_d = np.array([0, -4, d3], dtype=int)

            # Bound checks on each component (|component| <= C3)
            if any(abs(x) > C3 for x in row_me):
                continue
            if any(abs(x) > C3 for x in row_tau):
                continue
            if any(abs(x) > C3 for x in row_d):
                continue

            geom = evaluate_geometry_3d_for_logs(logs_dict, row_me, row_tau, row_d, C_other=C_other)
            candidates.append(geom)

    if not candidates:
        return None

    # Best by RMS_all
    best = min(candidates, key=lambda g: g["RMS_all"])
    return best, len(candidates)

# ------------------------------------------------------------------------------
# 5. Main routine: real geometry + jitter nullscan
# ------------------------------------------------------------------------------

def run_phase11_yukawa_3d_geometry_nullscan(
    C3=4,
    C_other=4,
    jitter_halfwidth=0.5,
    num_null=2000,
    rng=None,
):
    if rng is None:
        rng_local = np.random.default_rng()
    else:
        rng_local = rng

    print("=" * 82)
    print(" PHASE 11 – MODULE 2: YUKAWA 3D INTEGER GEOMETRY NULLSCAN ".center(82))
    print("=" * 82)
    print()
    print("Config:")
    print(f"  • 3D basis third-coordinate bound C3      = {C3}")
    print(f"  • Coeff bound for other Yukawas (±C_other)= ±{C_other}")
    print(f"  • Jitter halfwidth (log10 units)          = {jitter_halfwidth:.3f}")
    print(f"  • Number of null universes                = {num_null}")
    print()
    print("Anchored 2D basis for (me, tau, d):")
    print("  row_2D(me)  = (-4, -2)")
    print("  row_2D(tau) = (-4,  1)")
    print("  row_2D(d)   = ( 0, -4)")
    print("  Extended to 3D by scanning m3, t3 and enforcing (-4,4,3) lock.")
    print()

    # --- Real-universe best 3D geometry ---
    best_real, n_basis = best_3d_geometry_for_logs(yukawa_logs_central, C3=C3, C_other=C_other)
    if best_real is None:
        print("No valid 3D basis patterns found for real logs. Aborting.")
        return

    print("Number of valid 3D basis patterns scanned (per universe):", n_basis)
    print()

    RMS_real = float(best_real["RMS_all"])
    max_resid_real = float(best_real["max_resid"])

    print("Real-universe best 3D geometry:")
    print(f"  RMS_all_real (dex)        : {RMS_real:.6f}")
    print(f"  Max |residual| (dex)      : {max_resid_real:.6f}")
    print(f"  Max |integer coeff|       : {best_real['max_coef_abs']}")
    print(f"  S_geom_real               : {best_real['S_geom']:.6e}")
    print(f"  S_geom_real / S_real      : {best_real['S_ratio']:.3e}")
    print()
    print("Basis rows for (me, tau, d) in best 3D geometry:")
    print("  row(me)  =", tuple(int(x) for x in best_real["rows"]["me_over_v"]))
    print("  row(tau) =", tuple(int(x) for x in best_real["rows"]["mtau_over_v"]))
    print("  row(d)   =", tuple(int(x) for x in best_real["rows"]["md_over_v"]))
    print()

    # --- Null ensemble ---
    RMS_null = []

    print("=" * 82)
    print(" NULL ENSEMBLE: JITTERED YUKAWA UNIVERSES ".center(82))
    print("=" * 82)
    print()

    names = yuk_order
    z_central_arr = np.array([yukawa_logs_central[n] for n in names], dtype=float)

    for k in range(1, num_null + 1):
        # Jitter logs: uniform in [-h, +h]
        jitter = rng_local.uniform(-jitter_halfwidth, jitter_halfwidth, size=z_central_arr.shape)
        z_jit = z_central_arr + jitter
        logs_jit = {name: float(z_jit[i]) for i, name in enumerate(names)}

        best_null, _ = best_3d_geometry_for_logs(logs_jit, C3=C3, C_other=C_other)
        RMS_null.append(float(best_null["RMS_all"]))

        if k % 200 == 0 or k == num_null:
            print(f"  ... {k}/{num_null} universes processed")

    RMS_null = np.array(RMS_null, dtype=float)

    # --- Null stats ---
    print()
    print("=" * 82)
    print(" NULL RMS STATISTICS – 3D GEOMETRY FIT ".center(82))
    print("=" * 82)
    print()

    def quantile(arr, q):
        return float(np.quantile(arr, q))

    rmin, rmax = float(RMS_null.min()), float(RMS_null.max())
    q25 = quantile(RMS_null, 0.25)
    q50 = quantile(RMS_null, 0.50)
    q75 = quantile(RMS_null, 0.75)
    mean = float(RMS_null.mean())
    std = float(RMS_null.std(ddof=0))

    print(f"  null RMS min / max        : {rmin: .6e} / {rmax: .6e}")
    print(f"  null RMS 25% / 50% / 75%  : {q25: .6e} / {q50: .6e} / {q75: .6e}")
    print(f"  null RMS mean / std       : {mean: .6e} / {std: .6e}")
    print()

    # --- Significance ---
    count_le = int(np.sum(RMS_null <= RMS_real))
    p_emp = count_le / float(num_null)
    z_score = (RMS_real - mean) / std if std > 0 else float("nan")
    z_score = float(z_score)

    print("=" * 82)
    print(" SIGNIFICANCE OF 3D INTEGER GEOMETRY COMPRESSION ".center(82))
    print("=" * 82)
    print()
    print(f"  real RMS_all              : {RMS_real: .6e}")
    print(f"  z(real vs null mean)      : {z_score:.2f} σ")
    print(f"  P_null(RMS <= real)       : {p_emp:.6f}")
    print()
    print("Interpretation guide:")
    print("  • RMS_all measures how well a 3D small-integer geometry fits ALL 9 Yukawas.")
    print("  • If P_null is ~0.1–1, geometries this good are common under jitter ⇒")
    print("      3D geometry is NOT an extra lock; it’s just another way to write noise.")
    print("  • If P_null is tiny (e.g. ≲ 0.01), the full 9-point 3D structure is")
    print("      a serious new lock, beyond the (-4,4,3) triple itself.")
    print()
    print("PHASE11_YUKAWA_3D_GEOMETRY_NULLSCAN_v1 COMPLETE")
    print("=" * 82)


# ------------------------------------------------------------------------------
# Run module if executed as main
# ------------------------------------------------------------------------------

if __name__ == "__main__":
    run_phase11_yukawa_3d_geometry_nullscan(
        C3=C3,
        C_other=C_other,
        jitter_halfwidth=jitter_halfwidth,
        num_null=num_null,
        rng=rng,
    )

"""
==================================================================================
      PHASE 11 – MODULE 3: YUKAWA 3D INTEGER GEOMETRY EVIDENCE UPDATE v2
==================================================================================

Adds:
  • Timestamp (ISO 8601) for when this module was run.
  • SHA256 hash over a payload containing:
        - module name
        - timestamp
        - key inputs (p_null, z_score)
        - key outputs (bits_3d)
    so you can later verify that the printed numbers match a specific run.

Input (from PHASE 11 – MODULE 2: 3D geometry nullscan):

  Real 3D integer geometry (anchored on the (-4,4,3) triple):
    • RMS_all_real (dex)   ≈ 0.006193
    • Max |residual|       ≈ 0.012743
    • Max |integer coeff|  = 4
    • S_geom_real / S_real ≈ 3×10^-10 (lock enforced in coefficient space)

  Null ensemble (jitter halfwidth h = 0.5 dex, 2000 universes):
    • null RMS mean        ≈ 0.08159564 dex
    • null RMS std         ≈ 0.05629137 dex
    • P_null(RMS <= real)  = 0.016000

Goal of this module:
  • Convert the 3D geometry null result into "bits of surprise".
  • Decide if the 3D 9-point geometry is an independent LOCK,
    or just mild extra evidence attached to the already-counted
    (-4,4,3) Yukawa triple.
  • Update GEOM_EVIDENCE accordingly, without touching GLOBAL_LOCKS.
"""

import math
import datetime
import hashlib
import json

# ---------------------------------------------------------------------------
# 1. Hard-coded inputs from PHASE 11 – MODULE 2
# ---------------------------------------------------------------------------

p_null_3d = 0.016000  # P_null(RMS <= real) from your run
z_score_3d = -1.34    # reported z(real vs null mean) in σ (for reference only)

# Convert to bits: bits = -log2(p)
bits_3d = -math.log2(p_null_3d) if p_null_3d > 0 else float("inf")

# Timestamp
timestamp = datetime.datetime.now().isoformat()

# Build hash payload
hash_payload = {
    "module": "PHASE11_YUKAWA_3D_GEOMETRY_EVIDENCE_v2",
    "timestamp": timestamp,
    "inputs": {
        "p_null_3d": p_null_3d,
        "z_score_3d": z_score_3d,
    },
    "outputs": {
        "bits_3d": bits_3d,
    },
}

hash_str = json.dumps(hash_payload, sort_keys=True)
sha256_hex = hashlib.sha256(hash_str.encode("utf-8")).hexdigest()

# ---------------------------------------------------------------------------
# 2. Print header with timestamp + hash
# ---------------------------------------------------------------------------

print("=" * 82)
print(" PHASE 11 – MODULE 3: YUKAWA 3D INTEGER GEOMETRY EVIDENCE UPDATE v2 ".center(82))
print("=" * 82)
print()
print(f"Run timestamp (local) : {timestamp}")
print(f"Run SHA256 payload    : {sha256_hex}")
print()
print("Hash payload fields:")
print(json.dumps(hash_payload, indent=2, sort_keys=True))
print()

# ---------------------------------------------------------------------------
# 3. Print evidence summary
# ---------------------------------------------------------------------------

print("=" * 82)
print(" INPUT FROM PHASE 11 – MODULE 2 (3D GEOMETRY NULLSCAN) ".center(82))
print("=" * 82)
print()
print(f"  P_null(RMS <= real)       = {p_null_3d:.6f}")
print(f"  z(real vs null mean)      = {z_score_3d:.2f} σ")
print()
print("=" * 82)
print(" CONVERSION TO BITS OF SURPRISE ".center(82))
print("=" * 82)
print()
print("  bits = -log2(p_null)")
print(f"  bits_3d                    = {bits_3d:.2f} bits")
print()

print("=" * 82)
print(" INTERPRETATION – DOES 3D GEOMETRY COUNT AS A NEW LOCK? ".center(82))
print("=" * 82)
print()
if bits_3d < 3:
    level = "ORDINARY / NO LOCK"
elif bits_3d < 7:
    level = "MILD–MODERATE (INTERESTING, BUT NOT A PRIMARY LOCK)"
else:
    level = "STRONG (CANDIDATE PRIMARY LOCK)"

print(f"  Effective bits from 3D geometry: {bits_3d:.2f} bits")
print(f"  Classification: {level}")
print()
print("Context comparison:")
print("  • Yukawa (-4,4,3) triple, global error-model search:")
print("        bits ≈ 7.5 (p ≈ 0.0056).")
print("  • Yukawa (-4,4,3) triple, fixed under error-model null:")
print("        bits ≈ 14.3 (p ≈ 5×10^-5).")
print("  • DNA backbone/locks:")
print("        bits ≈ 12.3 in the DNA sector.")
print()
print("Structural dependency:")
print("  • The 3D integer geometry is explicitly built on the (-4,4,3) lock;")
print("    it does not introduce new, independent data points.")
print("  • Its ~6 bits (from p ≈ 0.016) are therefore NOT fully independent")
print("    of the already-counted Yukawa triple evidence.")
print()
print("Verdict for geometry hunting:")
print("  → The 3D 9-point integer geometry is **interesting**, but")
print("    it should NOT be promoted to a separate primary lock.")
print("  → Treat it as supportive structure around the existing")
print("    Yukawa triple lock, not as extra bits in GLOBAL_LOCKS.")
print()

# ---------------------------------------------------------------------------
# 4. Update / create GEOM_EVIDENCE entry
# ---------------------------------------------------------------------------

try:
    GEOM_EVIDENCE
except NameError:
    GEOM_EVIDENCE = {}

GEOM_EVIDENCE['yukawa_3d_integer_geometry'] = {
    "p_null": p_null_3d,
    "bits": bits_3d,
    "z_score": z_score_3d,
    "timestamp": timestamp,
    "sha256": sha256_hex,
    "status": "interesting_but_not_primary_lock",
    "description": (
        "3D small-integer geometry for all 9 Yukawas, anchored on the "
        "(-4,4,3) lock; RMS_all ≈ 0.0062 dex, p_null ≈ 0.016. "
        "Moderately surprising, but not treated as an independent lock "
        "beyond the me–mtau–md triple."
    ),
}

print("=" * 82)
print(" GLOBAL GEOMETRY EVIDENCE UPDATE ".center(82))
print("=" * 82)
print()
print("  GEOM_EVIDENCE['yukawa_3d_integer_geometry'] =")
for k, v in GEOM_EVIDENCE['yukawa_3d_integer_geometry'].items():
    print(f"    {k:12s}: {v}")
print()
print("Interpretation for the global geometry search:")
print("  → KEEP:")
print("       - DNA backbone/lock structure as a primary lock (~12 bits).")
print("       - me–mtau–md (-4,4,3) Yukawa triple as the Yukawa lock")
print("         (7–14 bits, depending on how you count).")
print("  → DO NOT ADD:")
print("       - The 3D 9-point integer geometry as a separate lock.")
print()
print("PHASE11_YUKAWA_3D_GEOMETRY_EVIDENCE_v2 COMPLETE")
print("=" * 82)

"""
==================================================================================
   PHASE 12 – MODULE 1: YUKAWA 3D INTEGER GEOMETRY MDL EVALUATOR (TOY MODEL)
==================================================================================

Purpose:
  We have a best 3D small-integer geometry for all 9 Yukawas that:

    • Enforces the (-4,4,3) lock in coefficient space exactly.
    • Fits all 9 Yukawa logs with RMS ≈ 0.0062 dex.
    • Has max |integer coefficient| = 4.

  This module asks a MDL-style question:

    "If you had to describe the 9 Yukawa logs to someone in bits,
     is it shorter to:
       (A) just send the 9 numbers directly, or
       (B) send the 3D geometry (integer matrix + q-vector) plus
           small corrections (residuals)?"

  This is a *toy* MDL model, not a full rigorous one:
    • We parameterize:
        - B_float: bits per real number (for z or q).
        - B_resid: bits per residual correction.
    • We approximate:
        - each integer coefficient uses ceil(log2(2*C_max+1)) bits
        - we ignore entropy of the residual distribution itself.

  The key output:
    • Δbits = baseline_bits - geometry_bits
      > 0  ⇒ geometry compresses the Yukawa sector.
      ≤ 0 ⇒ geometry doesn’t actually buy you anything in code length.

  This does NOT change the global LOCK budget (DNA + Yukawa triple).
  It just tells us whether the 3D geometry is an efficient *encoding*.
"""

import math
import datetime
import hashlib
import json
import numpy as np

# ------------------------------------------------------------------------------
# 1. Hard-code Yukawa logs and the best 3D integer geometry from Phase 11
# ------------------------------------------------------------------------------

# Central Yukawa logs z = log10(y/v)
YUKAWA_LOGS = {
    "me_over_v":   -5.683401,
    "mmu_over_v":  -3.367606,
    "mtau_over_v": -2.141781,
    "mb_over_v":   -1.770024,
    "mc_over_v":   -2.287532,
    "mt_over_v":   -0.154056,
    "md_over_v":   -4.722162,
    "ms_over_v":   -3.422873,
    "mu_over_v":   -5.056852,
}

# Measurement error model (1σ fractional) from earlier phases
FRAC_ERR = {
    "me_over_v":   1.0e-8,
    "mmu_over_v":  1.0e-8,
    "mtau_over_v": 1.0e-5,
    "mb_over_v":   1.0e-1,
    "mc_over_v":   1.0e-1,
    "mt_over_v":   2.0e-2,
    "md_over_v":   2.0e-1,
    "ms_over_v":   2.0e-1,
    "mu_over_v":   2.0e-1,
}

# Convert fractional error to σ in log10-space: σ_log10 ≈ frac_err / ln(10)
LN10 = math.log(10.0)
SIGMA_LOG10 = {
    name: frac / LN10 for name, frac in FRAC_ERR.items()
}

# Best 3D integer coefficient matrix C (9 Yukawas × 3 dims) from Phase 11
# Order of rows must match 'names' list below.
names = [
    "me_over_v",
    "mmu_over_v",
    "mtau_over_v",
    "mb_over_v",
    "mc_over_v",
    "mt_over_v",
    "md_over_v",
    "ms_over_v",
    "mu_over_v",
]

C_matrix = np.array([
    [-4, -2, -1],  # me
    [-1, -2,  2],  # mmu
    [-4,  1, -4],  # mtau
    [-2,  0, -1],  # mb
    [-2, -1, -3],  # mc
    [-2,  1, -4],  # mt
    [ 0, -4,  4],  # md
    [-3,  0,  2],  # ms
    [-1, -4,  1],  # mu
], dtype=int)

# Geometry parameters q (log10 λ-vector)
q_vector = np.array([
    0.993782,   # q1
    0.962938,   # q2
    -0.217602,  # q3
])

C_max = int(np.max(np.abs(C_matrix)))

# Compute predicted logs and residuals
z_real = np.array([YUKAWA_LOGS[n] for n in names])
z_geom = C_matrix @ q_vector
resid = z_geom - z_real

RMS_all = math.sqrt(np.mean(resid**2))
max_abs_resid = float(np.max(np.abs(resid)))

# ------------------------------------------------------------------------------
# 2. MDL model: bits for baseline vs bits for geometry
# ------------------------------------------------------------------------------

def mdl_bits_baseline(B_float: int) -> float:
    """
    Baseline MDL: send each of the 9 logs directly as a floating-point number
    with B_float bits. (Ignoring model-structure overhead.)
    """
    return 9 * B_float

def mdl_bits_geometry(B_float: int, B_resid: int) -> float:
    """
    Geometry MDL:
      • Send 3 geometry parameters q_j, each B_float bits.
      • Send 27 integer coefficients C_ij, each with ceil(log2(2*C_max+1)) bits.
      • Send 9 residual corrections (one per Yukawa), each B_resid bits.
    """
    bits_q = 3 * B_float
    bits_int_per_coeff = math.ceil(math.log2(2 * C_max + 1))  # for integers in [-C_max, +C_max]
    bits_C = C_matrix.size * bits_int_per_coeff
    bits_resid = 9 * B_resid
    return bits_q + bits_C + bits_resid

def infer_residual_bits_from_error(name: str, target_precision_sigma_fraction: float = 0.5) -> float:
    """
    Given a Yukawa name and a target precision as a fraction of its 1σ log10 error,
    estimate how many bits are needed to encode a residual for that Yukawa.

    Idea:
      • Range of interest for residual ~ a few σ_log10.
      • Quantization step δ ~ target_precision_sigma_fraction * σ_log10.
      • bits ≈ log2(range / δ) with range ~ 8 σ_log10 (say ±4σ).

    This is heuristic and used only for orientation.
    """
    sigma = SIGMA_LOG10[name]
    if sigma <= 0.0:
        return 0.0
    rng = 8.0 * sigma            # ±4σ range
    delta = target_precision_sigma_fraction * sigma
    return math.log2(rng / delta)

# ------------------------------------------------------------------------------
# 3. Timestamp + SHA256 payload
# ------------------------------------------------------------------------------

timestamp = datetime.datetime.now().isoformat()

hash_payload = {
    "module": "PHASE12_YUKAWA_3D_GEOMETRY_MDL_v1",
    "timestamp": timestamp,
    "geometry": {
        "q_vector": q_vector.tolist(),
        "C_matrix": C_matrix.tolist(),
        "C_max": C_max,
    },
    "fit_quality": {
        "RMS_all": RMS_all,
        "max_abs_resid": max_abs_resid,
    },
}

hash_str = json.dumps(hash_payload, sort_keys=True)
sha256_hex = hashlib.sha256(hash_str.encode("utf-8")).hexdigest()

# ------------------------------------------------------------------------------
# 4. Print header + hash info
# ------------------------------------------------------------------------------

print("=" * 82)
print(" PHASE 12 – MODULE 1: YUKAWA 3D INTEGER GEOMETRY MDL EVALUATOR (TOY) ".center(82))
print("=" * 82)
print()
print(f"Run timestamp (local) : {timestamp}")
print(f"Run SHA256 payload    : {sha256_hex}")
print()
print("Hash payload (key fields):")
print(json.dumps(hash_payload, indent=2, sort_keys=True))
print()

# ------------------------------------------------------------------------------
# 5. Print geometry + residuals
# ------------------------------------------------------------------------------

print("=" * 82)
print(" BEST 3D INTEGER GEOMETRY RECAP ".center(82))
print("=" * 82)
print()
print("Basis coefficient rows for (me, tau, d):")
print(f"  row(me)   = {C_matrix[names.index('me_over_v')]}")
print(f"  row(tau)  = {C_matrix[names.index('mtau_over_v')]}")
print(f"  row(d)    = {C_matrix[names.index('md_over_v')]}")
print()
print("Geometry parameters q (log10 λ-vector):")
for j, qj in enumerate(q_vector, start=1):
    print(f"  q{j} = {qj:+.6f}")
print()
print("Fit quality over all 9 Yukawas:")
print(f"  RMS_all (dex)         : {RMS_all:.6f}")
print(f"  Max |residual| (dex)  : {max_abs_resid:.6f}")
print(f"  Max |integer coeff|   : {C_max:d}")
print()
print("Per-Yukawa coefficients and residuals (geom - real):")
print("  name         (c1,c2,c3)      z_real       z_geom      resid")
print("  -----------  ----------    ----------   ----------   ----------")
for i, n in enumerate(names):
    c1, c2, c3 = C_matrix[i]
    zr = z_real[i]
    zg = z_geom[i]
    r  = resid[i]
    print(f"  {n:11s}  ({c1:2d},{c2:2d},{c3:2d})  {zr:10.6f}  {zg:10.6f}  {r:10.6f}")
print()

# ------------------------------------------------------------------------------
# 6. MDL calculations for several (B_float, B_resid) scenarios
# ------------------------------------------------------------------------------

print("=" * 82)
print(" TOY MDL MODEL: DIRECT VS GEOMETRY ENCODING ".center(82))
print("=" * 82)
print()
print("We compare:")
print("  • Baseline: send 9 logs directly, each B_float bits.")
print("  • Geometry: send 3 q_j (B_float bits each), 27 ints C_ij,")
print("              and 9 residual corrections (B_resid bits each).")
print()

# A few representative choices
scenarios = [
    (32, 16),
    (64, 16),
    (64, 20),
    (64, 24),
]

print("  B_float  B_resid   bits_baseline   bits_geometry     Δbits (base - geom)")
print("  -------  -------   -------------   -------------     -------------------")
for B_float, B_resid in scenarios:
    base_bits = mdl_bits_baseline(B_float)
    geom_bits = mdl_bits_geometry(B_float, B_resid)
    delta_bits = base_bits - geom_bits
    print(f"  {B_float:7d}  {B_resid:7d}   {base_bits:13.2f}   {geom_bits:13.2f}     {delta_bits:19.2f}")
print()

# Estimate bits needed per residual using the error model (heuristic)
print("=" * 82)
print(" HEURISTIC RESIDUAL BIT ESTIMATE FROM ERROR MODEL ".center(82))
print("=" * 82)
print()
print("Assume we want to encode each residual to ~0.5 σ_log10 precision.")
print("Estimated bits per residual (for each Yukawa):")
print("  name         σ_log10       bits_resid(≈)")
print("  -----------  ----------    ---------------")
bits_resid_list = []
for n in names:
    bits_i = infer_residual_bits_from_error(n, target_precision_sigma_fraction=0.5)
    bits_resid_list.append(bits_i)
    print(f"  {n:11s}  {SIGMA_LOG10[n]:10.3e}    {bits_i:13.2f}")
avg_bits_resid = sum(bits_resid_list) / len(bits_resid_list)
print()
print(f"  Average bits_resid from error model ≈ {avg_bits_resid:.2f} bits")
print()

# Use avg_bits_resid with two different B_float assumptions
print("=" * 82)
print(" MDL SUMMARY WITH ERROR-MODEL RESIDUAL BITS ".center(82))
print("=" * 82)
print()
for B_float in (32, 64):
    base_bits = mdl_bits_baseline(B_float)
    geom_bits = mdl_bits_geometry(B_float, avg_bits_resid)
    delta_bits = base_bits - geom_bits
    print(f"  For B_float = {B_float} bits, B_resid ≈ {avg_bits_resid:.2f} bits:")
    print(f"    bits_baseline  ≈ {base_bits:.2f}")
    print(f"    bits_geometry  ≈ {geom_bits:.2f}")
    print(f"    Δbits          ≈ {delta_bits:.2f}  (positive ⇒ geometry compresses)")
    print()
print()

# ------------------------------------------------------------------------------
# 7. Interpretation and (optional) GEOM_EVIDENCE update
# ------------------------------------------------------------------------------

print("=" * 82)
print(" INTERPRETATION (TOY MDL, NOT A NEW LOCK) ".center(82))
print("=" * 82)
print()
print("Key points:")
print("  • The 3D small-integer geometry gives RMS_all ≈ 0.0062 dex, which is")
print("    comfortably below the log10 σ for the messy Yukawas (b, c, d, s, u).")
print("  • Under plausible encoding assumptions (e.g. 64-bit floats for the logs")
print("    and ~18–22 bits to encode each residual), the geometry can compress")
print("    the Yukawa sector by O(10^1–10^2) bits relative to sending raw logs.")
print("  • For more aggressive assumptions (32-bit logs and high-precision residuals),")
print("    geometry may NOT compress; then it's just a fancy reparameterization.")
print()
print("Crucial conceptual point:")
print("  • This MDL gain is *not* an independent source of evidence; it is another")
print("    way of quantifying the same structure already captured by the")
print("    (-4,4,3) triple lock and the small residuals around it.")
print("  • Therefore, we do NOT add these MDL bits to the global LOCK budget.")
print("    The primary Yukawa lock remains the me–mtau–md triple itself.")
print()

# Optional: update GEOM_EVIDENCE with a note about MDL
try:
    GEOM_EVIDENCE
except NameError:
    GEOM_EVIDENCE = {}

GEOM_EVIDENCE.setdefault("yukawa_3d_integer_geometry", {})
GEOM_EVIDENCE["yukawa_3d_integer_geometry"].update({
    "mdl_note": (
        "Toy MDL comparison suggests the 3D small-integer geometry can compress "
        "the 9 Yukawa logs by O(10–100) bits under plausible encoding assumptions, "
        "but this is not counted as an independent lock; it re-expresses the "
        "same structure as the (-4,4,3) triple and small residuals."
    ),
    "mdl_timestamp": timestamp,
    "mdl_sha256": sha256_hex,
})

print("=" * 82)
print(" GEOM_EVIDENCE UPDATE (MDL NOTE ONLY) ".center(82))
print("=" * 82)
print()
print("  GEOM_EVIDENCE['yukawa_3d_integer_geometry']['mdl_note']      set")
print("  GEOM_EVIDENCE['yukawa_3d_integer_geometry']['mdl_timestamp'] =", timestamp)
print("  GEOM_EVIDENCE['yukawa_3d_integer_geometry']['mdl_sha256']   =", sha256_hex)
print()
print("Interpretation for global geometry search:")
print("  → The 3D integer geometry looks like a reasonably efficient encoding of")
print("    the Yukawa sector, but it is *derivative* of the primary lock.")
print("  → We keep focusing on:")
print("       - DNA backbone/locks, and")
print("       - The me–mtau–md (-4,4,3) triple")
print("    as the true hard constraints any future geometry must satisfy.")
print()
print("PHASE12_YUKAWA_3D_GEOMETRY_MDL_v1 COMPLETE")
print("=" * 82)

"""
==================================================================================
 PHASE 12 – MODULE 2 (v2): YUKAWA 3D INTEGER GEOMETRY STABILITY (FIXED q)
==================================================================================

Goal (updated to avoid singular-matrix issues):

  We already have a best 3D small-integer geometry for all 9 Yukawas:

      z_i ≈ c_i · q   with c_i ∈ ℤ^3, |c_i| ≤ 4,

  where C_REAL (9×3) and q = Q_REAL were found by a global search that
  enforces the (-4,4,3) lock and minimizes RMS over all 9 Yukawas.

  This module assumes q = Q_REAL is the underlying geometry and asks:

      "If we jitter the Yukawa logs within their measurement errors and
       re-assign the best integer coefficients for each Yukawa (with q
       held fixed), how often do we recover EXACTLY the same coefficient
       matrix C_REAL as in the real universe?"

  Algorithm:
    • Fix q = Q_REAL.
    • Fix basis rows (me, tau, d) to their real integer triples in C_REAL
      (since the (-4,4,3) lock is already tested separately).
    • For the other 6 Yukawas, search over all integer triples
      (a,b,c) in [-C_other, C_other]^3 \ {(0,0,0)} and choose the one
      minimizing (a q1 + b q2 + c q3 - z_jit)^2.
    • Count how often the resulting 9×3 coefficient matrix equals C_REAL.
    • Also track per-Yukawa row stability and RMS statistics.

  Output:
    • p_exact_match = fraction of jitter universes where C_fit == C_REAL.
    • bits_exact ≈ -log2(p_exact_match) (or lower bound if p≈0).
    • Per-row stability fractions for each Yukawa.
    • Timestamp + SHA256 of the run payload.
"""

import math
import datetime
import hashlib
import json
import numpy as np

# ==============================================================================
# 1. Hard-code Yukawa logs, error model, and best 3D geometry
# ==============================================================================

# Central Yukawa logs z = log10(y/v)
YUKAWA_LOGS = {
    "me_over_v":   -5.683401,
    "mmu_over_v":  -3.367606,
    "mtau_over_v": -2.141781,
    "mb_over_v":   -1.770024,
    "mc_over_v":   -2.287532,
    "mt_over_v":   -0.154056,
    "md_over_v":   -4.722162,
    "ms_over_v":   -3.422873,
    "mu_over_v":   -5.056852,
}

# Measurement error model (1σ fractional)
FRAC_ERR = {
    "me_over_v":   1.0e-8,
    "mmu_over_v":  1.0e-8,
    "mtau_over_v": 1.0e-5,
    "mb_over_v":   1.0e-1,
    "mc_over_v":   1.0e-1,
    "mt_over_v":   2.0e-2,
    "md_over_v":   2.0e-1,
    "ms_over_v":   2.0e-1,
    "mu_over_v":   2.0e-1,
}

LN10 = math.log(10.0)
SIGMA_LOG10 = {name: frac / LN10 for name, frac in FRAC_ERR.items()}

# Order of Yukawas
NAMES = [
    "me_over_v",
    "mmu_over_v",
    "mtau_over_v",
    "mb_over_v",
    "mc_over_v",
    "mt_over_v",
    "md_over_v",
    "ms_over_v",
    "mu_over_v",
]

# Best 3D integer coefficient matrix C (rows aligned with NAMES)
C_REAL = np.array([
    [-4, -2, -1],  # me
    [-1, -2,  2],  # mmu
    [-4,  1, -4],  # mtau
    [-2,  0, -1],  # mb
    [-2, -1, -3],  # mc
    [-2,  1, -4],  # mt
    [ 0, -4,  4],  # md
    [-3,  0,  2],  # ms
    [-1, -4,  1],  # mu
], dtype=int)

Q_REAL = np.array([
    0.993782,
    0.962938,
    -0.217602,
])

C_MAX = int(np.max(np.abs(C_REAL)))

# Basis indices for (me, tau, d) – these rows are held fixed
IDX_ME   = NAMES.index("me_over_v")
IDX_TAU  = NAMES.index("mtau_over_v")
IDX_D    = NAMES.index("md_over_v")
BASIS_IDXS = [IDX_ME, IDX_TAU, IDX_D]

# Non-basis (other Yukawas)
OTHER_IDXS = [i for i in range(len(NAMES)) if i not in BASIS_IDXS]

# ==============================================================================
# 2. Helpers
# ==============================================================================

def jitter_logs_once(z_real: np.ndarray, rng: np.random.Generator) -> np.ndarray:
    """Draw one jittered set of log10 Yukawas using the error model."""
    z_jit = np.empty_like(z_real)
    for i, name in enumerate(NAMES):
        sigma = SIGMA_LOG10[name]
        z_jit[i] = z_real[i] + rng.normal(loc=0.0, scale=sigma)
    return z_jit

def assign_coeffs_fixed_q(z_jit: np.ndarray,
                          q: np.ndarray,
                          C_candidates: np.ndarray) -> np.ndarray:
    """
    With q fixed, assign integer coefficients for each Yukawa.

    • For basis Yukawas (me, tau, d), we keep the rows fixed to C_REAL.
    • For the others, choose (a,b,c) ∈ C_candidates that minimizes
      (a q1 + b q2 + c q3 - z_jit)^2.

    Returns:
      C_fit: full 9×3 coefficient matrix.
    """
    C_fit = np.array(C_REAL, copy=True)

    # Precompute candidate predictions once: shape (Ncands,)
    cand_pred = C_candidates @ q

    for idx in OTHER_IDXS:
        z_target = z_jit[idx]
        diffs = cand_pred - z_target
        sq = diffs * diffs
        best_idx = int(np.argmin(sq))
        C_fit[idx] = C_candidates[best_idx]

    return C_fit

def compute_rms_for_geometry(C: np.ndarray, q: np.ndarray, z: np.ndarray) -> float:
    """Compute RMS of residuals for given geometry C·q vs z."""
    z_pred = C @ q
    resid = z_pred - z
    return math.sqrt(float(np.mean(resid * resid)))

# ==============================================================================
# 3. Main driver
# ==============================================================================

def run_phase12_yukawa_3d_geometry_stability_v2(
    num_null: int = 2000,
    seed: int = 20251120,
    C_other: int = 4,
) -> None:
    """
    Jitter Yukawa logs under the error model, with q = Q_REAL fixed,
    re-assign integer coefficients for the 6 non-basis Yukawas, and
    track how often the full coefficient matrix matches C_REAL exactly.
    """

    # Timestamp + SHA256 payload
    timestamp = datetime.datetime.now().isoformat()

    hash_payload = {
        "module": "PHASE12_YUKAWA_3D_GEOMETRY_STABILITY_v2",
        "timestamp": timestamp,
        "num_null": num_null,
        "seed": seed,
        "C_other": C_other,
        "C_real": C_REAL.tolist(),
        "Q_real": Q_REAL.tolist(),
    }
    hash_str = json.dumps(hash_payload, sort_keys=True)
    sha256_hex = hashlib.sha256(hash_str.encode("utf-8")).hexdigest()

    # Header
    print("=" * 82)
    print(" PHASE 12 – MODULE 2 (v2): YUKAWA 3D INTEGER GEOMETRY STABILITY ".center(82))
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256_hex}")
    print()
    print("Hash payload (key fields):")
    print(json.dumps(hash_payload, indent=2, sort_keys=True))
    print()

    # Real universe recap
    z_real_vec = np.array([YUKAWA_LOGS[n] for n in NAMES])
    z_geom_real = C_REAL @ Q_REAL
    resid_real = z_geom_real - z_real_vec
    RMS_real = math.sqrt(float(np.mean(resid_real * resid_real)))
    max_abs_resid_real = float(np.max(np.abs(resid_real)))

    print("=" * 82)
    print(" REAL-UNIVERSE 3D GEOMETRY RECAP ".center(82))
    print("=" * 82)
    print()
    print("Basis coefficient rows for (me, tau, d):")
    print(f"  row(me)   = {C_REAL[IDX_ME]}")
    print(f"  row(tau)  = {C_REAL[IDX_TAU]}")
    print(f"  row(d)    = {C_REAL[IDX_D]}")
    print()
    print("Geometry parameters q (log10 λ-vector):")
    for j, qj in enumerate(Q_REAL, start=1):
        print(f"  q{j} = {qj:.6f}")
    print()
    print("Fit quality over all 9 Yukawas (real data):")
    print(f"  RMS_all (dex)         : {RMS_real:.6f}")
    print(f"  Max |residual| (dex)  : {max_abs_resid_real:.6f}")
    print(f"  Max |integer coeff|   : {C_MAX:d}")
    print()
    print("Per-Yukawa residuals (geom - real):")
    print("  name         (c1,c2,c3)      z_real       z_geom       resid")
    print("  -----------  ----------    ----------   ----------   ----------")
    for i, name in enumerate(NAMES):
        c = C_REAL[i]
        zr = z_real_vec[i]
        zg = z_geom_real[i]
        r  = resid_real[i]
        print(f"  {name:11s}  ({c[0]:2d},{c[1]:2d},{c[2]:2d})   {zr:10.6f}   {zg:10.6f}   {r:10.6f}")
    print()

    # Candidate integer coefficient triples for OTHER Yukawas
    cand_list = []
    for a in range(-C_other, C_other + 1):
        for b in range(-C_other, C_other + 1):
            for c in range(-C_other, C_other + 1):
                if a == 0 and b == 0 and c == 0:
                    continue
                cand_list.append((a, b, c))
    C_candidates = np.array(cand_list, dtype=int)
    num_cands = C_candidates.shape[0]

    print("=" * 82)
    print(" GEOMETRY SETUP FOR STABILITY SCAN ".center(82))
    print("=" * 82)
    print()
    print(f"  Coeff bound for other Yukawas      : ±{C_other}")
    print(f"  Number of candidate coeff triples  : {num_cands}")
    print(f"  Number of null universes           : {num_null}")
    print("  Basis rows (me,tau,d) are held fixed to C_REAL.")
    print("  q is held fixed to Q_REAL (no re-fit of q under jitter).")
    print()

    # Prepare jitter loop
    rng = np.random.default_rng(seed)

    rms_list = []
    exact_match_count = 0
    row_match_counts = np.zeros(len(NAMES), dtype=int)

    print("=" * 82)
    print(" NULL ENSEMBLE: JITTERED YUKAWA UNIVERSES ".center(82))
    print("=" * 82)
    print()

    for u in range(num_null):
        # Jitter logs
        z_jit = jitter_logs_once(z_real_vec, rng)

        # Assign integer coefficients for all Yukawas (basis fixed, others via search)
        C_fit = assign_coeffs_fixed_q(z_jit, Q_REAL, C_candidates)

        # RMS for this jittered universe under (C_fit, Q_REAL)
        rms_u = compute_rms_for_geometry(C_fit, Q_REAL, z_jit)
        rms_list.append(rms_u)

        # Per-row equality
        equal_rows = (C_fit == C_REAL).all(axis=1)
        row_match_counts += equal_rows.astype(int)

        # Exact full-matrix equality
        if np.array_equal(C_fit, C_REAL):
            exact_match_count += 1

        # Progress
        if (u + 1) % 200 == 0 or (u + 1) == num_null:
            print(f"  ... {u+1}/{num_null} universes processed")

    rms_array = np.array(rms_list, dtype=float)

    # ==============================================================================
    # 4. Summary statistics
    # ==============================================================================

    print()
    print("=" * 82)
    print(" NULL STATISTICS – RMS UNDER FIXED (C_fit, Q_REAL) ".center(82))
    print("=" * 82)
    print()
    print(f"  null RMS min / max        : {rms_array.min(): .6e} / {rms_array.max(): .6e}")
    q25, q50, q75 = np.percentile(rms_array, [25, 50, 75])
    mean_rms = float(rms_array.mean())
    std_rms = float(rms_array.std(ddof=0))
    print(f"  null RMS 25% / 50% / 75%  : {q25: .6e} / {q50: .6e} / {q75: .6e}")
    print(f"  null RMS mean / std       : {mean_rms: .6e} / {std_rms: .6e}")
    print()

    # Exact coefficient-matrix match statistics
    print("=" * 82)
    print(" COEFFICIENT-MATRIX STABILITY UNDER JITTER (FIXED q) ".center(82))
    print("=" * 82)
    print()
    print(f"  exact matches (C_fit == C_REAL)  : {exact_match_count} / {num_null}")

    if exact_match_count > 0:
        p_exact = exact_match_count / num_null
        bits_exact = -math.log2(p_exact)
        print(f"  p_exact_match                    : {p_exact:.6f}")
        print(f"  bits_exact_match                 : {bits_exact:.2f} bits")
    else:
        p_exact = 0.0
        bits_exact = math.log2(num_null)  # lower bound
        print("  p_exact_match                    : < 1/num_null")
        print(f"  bits_exact_match (lower bound)   : ≥ {bits_exact:.2f} bits")

    print()
    print("Per-Yukawa row stability (fraction of universes where row_i == row_i_real):")
    print("  name         match_count   frac_match")
    print("  -----------  -----------   ----------")
    for i, name in enumerate(NAMES):
        count_i = int(row_match_counts[i])
        frac_i = count_i / num_null
        print(f"  {name:11s}  {count_i:11d}   {frac_i:10.4f}")
    print()

    print("INTERPRETATION GUIDE:")
    print("  • If p_exact_match ≈ O(1), the entire 3D integer pattern C_REAL is")
    print("    extremely stable under realistic measurement errors; geometry must")
    print("    aim for THIS specific C, not just 'some' nearby integer pattern.")
    print("  • If p_exact_match is tiny, the full 9×3 pattern is brittle: small")
    print("    jitters move you to different integer triples for at least one Yukawa.")
    print("  • Per-row fractions show which Yukawa coefficients are most stable.")
    print()

    # ==============================================================================
    # 5. GEOM_EVIDENCE update (if dict exists in the environment)
    # ==============================================================================

    try:
        GEOM_EVIDENCE
    except NameError:
        GEOM_EVIDENCE = {}

    GEOM_EVIDENCE.setdefault("yukawa_3d_integer_geometry", {})
    GEOM_EVIDENCE["yukawa_3d_integer_geometry"].update({
        "stability_p_exact_fixed_q": p_exact,
        "stability_bits_exact_fixed_q": bits_exact,
        "stability_row_match_counts": row_match_counts.tolist(),
        "stability_num_null_fixed_q": num_null,
        "stability_timestamp_fixed_q": timestamp,
        "stability_sha256_fixed_q": sha256_hex,
        "stability_note_fixed_q": (
            "Exact-coefficient stability of the 3D small-integer Yukawa geometry "
            "under error-model jitter, with q fixed to Q_REAL and basis rows "
            "(me, tau, d) held fixed. p_exact ≈ fraction of jitter universes "
            "whose best-fit coefficient matrix equals C_REAL."
        ),
    })

    print("=" * 82)
    print(" GEOM_EVIDENCE UPDATE (3D STABILITY, FIXED q) ".center(82))
    print("=" * 82)
    print()
    print("  GEOM_EVIDENCE['yukawa_3d_integer_geometry']['stability_p_exact_fixed_q']   =", p_exact)
    print("  GEOM_EVIDENCE['yukawa_3d_integer_geometry']['stability_bits_exact_fixed_q'] =", bits_exact)
    print("  GEOM_EVIDENCE['yukawa_3d_integer_geometry']['stability_timestamp_fixed_q']  =", timestamp)
    print("  GEOM_EVIDENCE['yukawa_3d_integer_geometry']['stability_sha256_fixed_q']    =", sha256_hex)
    print()
    print("PHASE12_YUKAWA_3D_GEOMETRY_STABILITY_v2 COMPLETE")
    print("=" * 82)


# Run module if executed as a script
if __name__ == "__main__":
    run_phase12_yukawa_3d_geometry_stability_v2(
        num_null=2000,
        seed=20251120,
        C_other=4,
    )

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 12 – MODULE 3: YUKAWA 3D INTEGER GEOMETRY STABILITY EVIDENCE (FIXED q)

This module takes the already-computed results from:
  PHASE12_YUKAWA_3D_GEOMETRY_STABILITY_v2

and converts them into a clean "evidence update" for the global geometry search.
It does NOT rerun any Monte Carlo; it only interprets the numbers you already saw.
"""

import math
import json
import hashlib
from datetime import datetime


def run_phase12_yukawa_3d_geometry_stability_evidence_v1():
    # -------------------------------------------------------------------------
    # 1. Hard-coded inputs from PHASE12_YUKAWA_3D_GEOMETRY_STABILITY_v2
    # -------------------------------------------------------------------------
    num_null = 2000

    # RMS stats for fixed-q 3D geometry on jittered universes (from v2 output)
    RMS_real = 6.193358e-03          # real RMS_all (dex)
    null_RMS_mean = 2.574111e-02     # mean null RMS (dex)
    null_RMS_std = 1.618058e-02      # std of null RMS (dex)

    # Per-row match fractions (how often each Yukawa's row == real row)
    row_match_fracs = {
        "me_over_v":   1.0000,
        "mmu_over_v":  1.0000,
        "mtau_over_v": 1.0000,
        "mb_over_v":   0.1400,
        "mc_over_v":   0.1405,
        "mt_over_v":   0.4775,
        "md_over_v":   1.0000,
        "ms_over_v":   0.0660,
        "mu_over_v":   0.1395,
    }

    # -------------------------------------------------------------------------
    # 2. Derived quantities: z-score, p-bounds, bits
    # -------------------------------------------------------------------------
    # z-score for RMS under fixed-q stability null
    if null_RMS_std > 0:
        z_score = (RMS_real - null_RMS_mean) / null_RMS_std
    else:
        z_score = float("nan")

    # Exact full 9×3 integer matrix never reappeared among 2000 jitter universes
    # ⇒ p_exact_match < 1/num_null ⇒ bits_exact >= log2(num_null).
    p_exact_upper = 1.0 / num_null
    bits_exact_lower = math.log2(num_null)

    # For RMS we *already* did a proper nullscan in PHASE11; here we just
    # record the fixed-q z-score as an extra diagnostic, not a new lock.
    # No fresh p-value is introduced here; the "lock" decision still comes
    # from PHASE11 + global evidence modules.

    # -------------------------------------------------------------------------
    # 3. Build hash payload and compute SHA256
    # -------------------------------------------------------------------------
    timestamp = datetime.now().isoformat()

    payload = {
        "module": "PHASE12_YUKAWA_3D_GEOMETRY_STABILITY_EVIDENCE_v1",
        "num_null": num_null,
        "RMS_real": RMS_real,
        "null_RMS_mean": null_RMS_mean,
        "null_RMS_std": null_RMS_std,
        "z_score_fixed_q": z_score,
        "p_exact_upper_bound": p_exact_upper,
        "bits_exact_lower_bound": bits_exact_lower,
        "row_match_fracs": row_match_fracs,
        "timestamp": timestamp,
    }

    payload_str = json.dumps(payload, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()

    # -------------------------------------------------------------------------
    # 4. Pretty print: banner + interpretation + GEOM_EVIDENCE update
    # -------------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 12 – MODULE 3: YUKAWA 3D INTEGER GEOMETRY STABILITY EVIDENCE (FIXED q) ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields):")
    print(payload_str)
    print()
    print("=" * 82)
    print("                    INPUT RECAP FROM STABILITY MODULE (v2)                  ")
    print("=" * 82)
    print()
    print("Fixed 3D geometry (from earlier modules):")
    print("  Basis coefficient rows for (me, tau, d):")
    print("    row(me)   = [-4 -2 -1]")
    print("    row(tau)  = [-4  1 -4]")
    print("    row(d)    = [ 0 -4  4]")
    print()
    print("  Geometry parameters q (log10 λ-vector):")
    print("    q1 = 0.993782")
    print("    q2 = 0.962938")
    print("    q3 = -0.217602")
    print()
    print("Fit quality over all 9 Yukawas (real data, fixed 3D geometry):")
    print(f"  RMS_all_real (dex)       : {RMS_real: .6e}")
    print(f"  null RMS mean (dex)      : {null_RMS_mean: .6e}")
    print(f"  null RMS std  (dex)      : {null_RMS_std: .6e}")
    print(f"  z(real vs null mean)     : {z_score: .2f} σ")
    print()
    print("=" * 82)
    print("          EXACT FULL-MATRIX STABILITY UNDER JITTER (FIXED q)                ")
    print("=" * 82)
    print()
    print(f"  num_null universes       : {num_null}")
    print("  exact matches (C_fit == C_REAL)  : 0 / {0}".format(num_null))
    print(f"  p_exact_match upper bound        : < {p_exact_upper: .6e}")
    print(f"  bits_exact_match lower bound     : ≥ {bits_exact_lower: .2f} bits")
    print()
    print("Per-Yukawa row stability (fraction of universes where the row exactly")
    print("matches the real-universe integer triple, with q held fixed):")
    print("  name         frac_match")
    print("  -----------  ----------")
    for name, frac in row_match_fracs.items():
        print(f"  {name:11s}  {frac:8.4f}")
    print()
    print("=" * 82)
    print("                          INTERPRETATION (FIXED q)                           ")
    print("=" * 82)
    print()
    print("  • Under fixed q and small-integer rows:")
    print("      – The *exact* 9×3 integer pattern never reappears in 2000 jittered")
    print("        Yukawa universes, so as a *combinatorial object* it looks very")
    print("        specific (≥ ~11 bits of 'uniqueness').")
    print("      – However, this is heavily conditioned on choosing q = Q_REAL and")
    print("        on the fact that the (-4,4,3) triple is already baked into the")
    print("        basis rows. It is not an independent new data point.")
    print()
    print("  • Row-level stability:")
    print("      – me, mmu, mtau, md rows are extremely stable (frac_match ≈ 1).")
    print("      – mb, mc, ms, mu, mt rows are only moderately stable; their best")
    print("        integer triples change under jitter in a non-negligible fraction")
    print("        of universes.")
    print()
    print("  • Combined with the PHASE 11 nullscan (where q and rows were both")
    print("    re-fit), the picture is:")
    print("      – The 3D integer geometry is a *pretty decent* encoding once we")
    print("        already know the me–mtau–md (-4,4,3) lock.")
    print("      – But as far as *independent evidence* goes, it is derivative of")
    print("        that primary lock, not a separate new constraint.")
    print()
    print("Verdict for evidence budget:")
    print("  → We DO NOT treat the exact 9×3 integer pattern as a new lock.")
    print("  → We keep the me–mtau–md (-4,4,3) triple as the only Yukawa lock.")
    print("  → The 3D geometry and its stability remain useful *shape information*")
    print("    for building candidate geometries, but they do not add bits.")
    print()
    print("=" * 82)
    print("                   GEOM_EVIDENCE UPDATE (STABILITY NOTE)                     ")
    print("=" * 82)
    print()
    print("  GEOM_EVIDENCE['yukawa_3d_integer_geometry']['stability_fixed_q'] = {")
    print(f"      'num_null'        : {num_null},")
    print(f"      'p_exact_upper'   : {p_exact_upper: .6e},")
    print(f"      'bits_exact_lower': {bits_exact_lower: .6f},")
    print(f"      'z_RMS_fixed_q'   : {z_score: .4f},")
    print(f"      'timestamp'       : '{timestamp}',")
    print(f"      'sha256'          : '{sha256}',")
    print("      'note'            : (")
    print("          'Full 9×3 integer pattern never reappears under jitter with '")
    print("          'fixed q; interesting combinatorially, but derivative of the '")
    print("          '(-4,4,3) lock and not treated as a new primary lock.'")
    print("      ),")
    print("  }")
    print()
    print("PHASE12_YUKAWA_3D_GEOMETRY_STABILITY_EVIDENCE_v1 COMPLETE")
    print("=" * 82)


if __name__ == "__main__":
    run_phase12_yukawa_3d_geometry_stability_evidence_v1()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 13 – MODULE 1:
GLOBAL GEOMETRY EVIDENCE V3 – UPDATED LOCK CONTRACT WITH 3D GEOMETRY & STABILITY

This module:
  • Assembles all the surviving evidence from previous phases,
  • Adds the 3D integer geometry + stability results as SUPPORTING, not new locks,
  • Prints an updated GLOBAL_LOCKS_v3 contract for geometry hunting,
  • Stamps a timestamp + SHA256 over the config payload.

You JUST run this file; it prints banners and a clean summary.
"""

import math
import json
import hashlib
from datetime import datetime


def run_phase13_global_geometry_evidence_v3():
    # -------------------------------------------------------------------------
    # 1. Hard-coded evidence inputs from earlier phases
    # -------------------------------------------------------------------------

    # --- DNA sector (from PHASE3B + earlier DNA modules) ---
    dna_effective_bits = 12.29  # lower bound, dominated by lock families & zeros

    # --- Yukawa primary lock: me–mtau–md (-4,4,3) triple ---
    yukawa_triple_bits_global = 7.48   # global 3-term search, error-model null (p≈0.0056)
    yukawa_triple_bits_fixed  = 14.29  # fixed triple, error-model null (p≈5e-5)

    # We keep both conservative and optimistic views:
    yukawa_bits_conservative = yukawa_triple_bits_global
    yukawa_bits_optimistic   = yukawa_triple_bits_fixed

    # --- 2D geometry (minimal integer geometry for 9 Yukawas) ---
    yukawa_2d_min_geom_p    = 0.122   # P_null(RMS_2D <= real)
    yukawa_2d_min_geom_bits = -math.log2(yukawa_2d_min_geom_p)  # ≈ 3.04

    # 2D coefficient families (mmu/ms sharing (3,-5))
    yukawa_2d_fam_p    = 0.394   # P_null(maxfam >= real) ≈ P_null(coll >= real)
    yukawa_2d_fam_bits = -math.log2(yukawa_2d_fam_p)     # ≈ 1.34

    # --- 3D integer geometry (PHASE11 nullscan, re-fitting) ---
    yukawa_3d_geom_p    = 0.016            # P_null(RMS_3D <= real) ≈ 0.016
    yukawa_3d_geom_bits = -math.log2(yukawa_3d_geom_p)  # ≈ 5.97

    # --- 3D stability, fixed q and fixed basis rows (PHASE12 v2 & v3) ---
    num_null_stab = 2000
    p_exact_upper = 1.0 / num_null_stab
    bits_exact_lower = math.log2(num_null_stab)  # ≥ ~10.97 bits

    # NOTE: these ~11 bits are *combinatorial specificity* of the exact 9×3
    # integer pattern, conditional on q and the triple lock; we treat them as
    # SUPPORTING, not independent evidence.

    # -------------------------------------------------------------------------
    # 2. Construct GLOBAL_LOCKS_v3: only primary locks get counted
    # -------------------------------------------------------------------------
    combined_bits_conservative = dna_effective_bits + yukawa_bits_conservative
    combined_bits_optimistic   = dna_effective_bits + yukawa_bits_optimistic

    GLOBAL_LOCKS_v3 = {
        "dna": {
            "effective_bits": dna_effective_bits,
            "status": "primary_lock",
            "description": (
                "DNA backbone + lock-family structure + all-four-zero rows; "
                "multi-10-bit anomaly under harsh nulls."
            ),
        },
        "yukawa": {
            "triple_me_tau_d": {
                "bits_global_error_model": yukawa_triple_bits_global,
                "bits_fixed_error_model": yukawa_triple_bits_fixed,
                "status": "primary_lock",
                "description": (
                    "me–mtau–md (-4,4,3) triple in log10(y/v); "
                    "≈7.5 bits under global search, ≈14.3 bits when treated "
                    "as a fixed triple under a realistic error model."
                ),
            },
            "supporting": {
                "minimal_2d_integer_geometry": {
                    "p_null": yukawa_2d_min_geom_p,
                    "bits": yukawa_2d_min_geom_bits,
                    "status": "supporting_structure",
                    "description": (
                        "2D small-integer geometry for 9 Yukawas; "
                        "RMS≈0.027 dex, p≈0.122 (~3 bits). Interesting but "
                        "NOT promoted to a separate lock."
                    ),
                },
                "coeff_families_2d": {
                    "p_null": yukawa_2d_fam_p,
                    "bits": yukawa_2d_fam_bits,
                    "status": "killed",
                    "description": (
                        "Coefficient families (e.g. mmu/ms sharing (3,-5)); "
                        "statistically ordinary (≈1.34 bits) under jitter null."
                    ),
                },
                "integer_3d_geometry": {
                    "p_null": yukawa_3d_geom_p,
                    "bits": yukawa_3d_geom_bits,
                    "status": "supporting_structure",
                    "description": (
                        "3D small-integer geometry for all 9 Yukawas anchored "
                        "on the (-4,4,3) triple; RMS≈0.0062 dex, p≈0.016 "
                        "(≈6 bits). Moderately surprising but treated as "
                        "derivative, not a new lock."
                    ),
                },
                "integer_3d_stability_fixed_q": {
                    "p_exact_upper": p_exact_upper,
                    "bits_exact_lower": bits_exact_lower,
                    "status": "supporting_structure",
                    "description": (
                        "Fixed-q 3D geometry integer pattern never reappears "
                        "in 2000 jittered universes; ≥~11 bits of combinatorial "
                        "specificity, but heavily conditioned on the known "
                        "triple and on fixing q, so not counted as an "
                        "independent lock."
                    ),
                },
            },
        },
        "combined": {
            "bits_conservative": combined_bits_conservative,
            "bits_optimistic": combined_bits_optimistic,
            "status": "global_contract",
            "description": (
                "Total bits any future geometry must explain without cheating: "
                "DNA + Yukawa triple; supporting structures (2D/3D geometries) "
                "guide model-building but do not increase this total."
            ),
        },
    }

    # -------------------------------------------------------------------------
    # 3. Timestamp + SHA256 over payload
    # -------------------------------------------------------------------------
    timestamp = datetime.now().isoformat()

    payload = {
        "module": "PHASE13_GLOBAL_GEOMETRY_EVIDENCE_v3",
        "GLOBAL_LOCKS_v3": GLOBAL_LOCKS_v3,
        "timestamp": timestamp,
    }

    payload_str = json.dumps(payload, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()

    # -------------------------------------------------------------------------
    # 4. Pretty-print everything
    # -------------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 13 – MODULE 1: GLOBAL GEOMETRY EVIDENCE V3 – UPDATED LOCK CONTRACT ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields):")
    print(payload_str)
    print()
    print("=" * 82)
    print("                          PRIMARY LOCKS (COUNTED BITS)                      ")
    print("=" * 82)
    print()
    print("DNA sector:")
    print(f"  • Effective DNA bits   : {dna_effective_bits:5.2f}")
    print("  • Status               : PRIMARY_LOCK")
    print("  • Content              : backbone rows, lock families, all-four-zero rails.")
    print()
    print("Yukawa sector (me–mtau–md triple):")
    print(f"  • Global 3-term search bits     : {yukawa_triple_bits_global:5.2f}")
    print(f"  • Fixed triple error-model bits : {yukawa_triple_bits_fixed:5.2f}")
    print("  • Status                        : PRIMARY_LOCK")
    print("  • Content                       : (-4,4,3) relation in log10-space.")
    print()
    print("=" * 82)
    print("                 SUPPORTING / KILLED STRUCTURES (NOT LOCKS)                 ")
    print("=" * 82)
    print()
    print("Yukawa 2D minimal integer geometry (9-point):")
    print(f"  • p_null(RMS_2D <= real)   : {yukawa_2d_min_geom_p: .3e}")
    print(f"  • bits                     : {yukawa_2d_min_geom_bits:5.2f}")
    print("  • Status                   : SUPPORTING_STRUCTURE (NOT a lock)")
    print()
    print("Yukawa 2D coefficient families (mmu/ms sharing (3,-5)): ")
    print(f"  • p_null(families >= real) : {yukawa_2d_fam_p: .3e}")
    print(f"  • bits                     : {yukawa_2d_fam_bits:5.2f}")
    print("  • Status                   : KILLED (ordinary)")
    print()
    print("Yukawa 3D integer geometry (re-fit under jitter):")
    print(f"  • p_null(RMS_3D <= real)   : {yukawa_3d_geom_p: .3e}")
    print(f"  • bits                     : {yukawa_3d_geom_bits:5.2f}")
    print("  • Status                   : SUPPORTING_STRUCTURE")
    print("  • Note                     : Moderately surprising, but built on the")
    print("                                existing (-4,4,3) lock; not independent.")
    print()
    print("Yukawa 3D integer pattern stability (fixed q):")
    print(f"  • p_exact_match  < {p_exact_upper: .3e}")
    print(f"  • bits_exact ≥     {bits_exact_lower:5.2f}")
    print("  • Status          : SUPPORTING_STRUCTURE (combinatorial specificity)")
    print("  • Note            : Full 9×3 pattern never reappears under jitter, but")
    print("                      this is conditional on q and the known triple.")
    print()
    print("=" * 82)
    print("                          UPDATED GLOBAL LOCK CONTRACT                       ")
    print("=" * 82)
    print()
    print("Effective bits that ANY serious geometry must explain (without tuning):")
    print(f"  • DNA effective bits                 : {dna_effective_bits:5.2f}")
    print(f"  • Yukawa bits (conservative, global): {yukawa_bits_conservative:5.2f}")
    print(f"      → Combined (conservative)       : {combined_bits_conservative:5.2f} bits")
    print()
    print(f"  • Yukawa bits (optimistic, fixed)   : {yukawa_bits_optimistic:5.2f}")
    print(f"      → Combined (optimistic)         : {combined_bits_optimistic:5.2f} bits")
    print()
    print("Interpretation:")
    print("  → PRIMARY LOCKS:")
    print("       1) DNA backbone / lock structure (~12 bits).")
    print("       2) me–mtau–md (-4,4,3) Yukawa triple (7–14 bits, depending on")
    print("          whether you use the global search or fixed-triple view).")
    print()
    print("  → SUPPORTING STRUCTURE (NO EXTRA BITS):")
    print("       • 2D and 3D small-integer geometries for the Yukawas.")
    print("       • Coefficient-family patterns, 3D stability patterns, MDL gains.")
    print("     These guide the SHAPE of candidate geometries but do NOT raise the")
    print("     required bit budget above ~20–27 bits total.")
    print()
    print("=" * 82)
    print("                       GEOM_EVIDENCE['GLOBAL_LOCKS_v3']                      ")
    print("=" * 82)
    print()
    print("GLOBAL_LOCKS_v3 = ")
    print(json.dumps(GLOBAL_LOCKS_v3, indent=2))
    print()
    print("PHASE13_GLOBAL_GEOMETRY_EVIDENCE_v3 COMPLETE")
    print("=" * 82)


if __name__ == "__main__":
    run_phase13_global_geometry_evidence_v3()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 13 – MODULE 2:
YUKAWA 3D q-VECTOR INTEGER-RELATION NULLSCAN

Goal:
  • Treat the 3D geometry parameters q = (q1,q2,q3) as data.
  • Search for small-integer relations a q1 + b q2 + c q3 ≈ 0
    with (a,b,c) in [-C_coeff, ..., +C_coeff]^3, primitive.
  • Then build a null ensemble by jittering the Yukawa logs under a
    realistic error model, re-fitting q for each null universe, and
    re-running the integer-relation search on q_null.
  • Finally, report how special the real best relation is compared to null.

This is a *supporting* test: if it lights up, it suggests extra internal
structure in the 3D geometry; if not, we treat q as just another way
of encoding the same triple lock.
"""

import numpy as np
import math
import json
import hashlib
from datetime import datetime


# ---------------------------------------------------------------------------
# INPUT: Real Yukawa logs and error model (same as earlier phases)
# ---------------------------------------------------------------------------

YUKAWA_LOGS = {
    "me_over_v":   -5.683401,
    "mmu_over_v":  -3.367606,
    "mtau_over_v": -2.141781,
    "mb_over_v":   -1.770024,
    "mc_over_v":   -2.287532,
    "mt_over_v":   -0.154056,
    "md_over_v":   -4.722162,
    "ms_over_v":   -3.422873,
    "mu_over_v":   -5.056852,
}

# Error-model sigmas in log10-space (from earlier error-model modules)
YUKAWA_SIGMA_LOG10 = {
    "me_over_v":   4.342945e-09,  # frac_err 1e-8
    "mmu_over_v":  4.342945e-09,  # frac_err 1e-8
    "mtau_over_v": 4.342945e-06,  # frac_err 1e-5
    "mb_over_v":   4.342945e-02,  # frac_err 0.1
    "mc_over_v":   4.342945e-02,  # frac_err 0.1
    "mt_over_v":   8.685890e-03,  # frac_err 0.02
    "md_over_v":   8.685890e-02,  # frac_err 0.2
    "ms_over_v":   8.685890e-02,  # frac_err 0.2
    "mu_over_v":   8.685890e-02,  # frac_err 0.2
}

# 3D integer coefficient matrix from best 3D geometry (rows in Yukawa order)
C_REAL = np.array([
    [-4, -2, -1],  # me
    [-1, -2,  2],  # mmu
    [-4,  1, -4],  # mtau
    [-2,  0, -1],  # mb
    [-2, -1, -3],  # mc
    [-2,  1, -4],  # mt
    [ 0, -4,  4],  # md
    [-3,  0,  2],  # ms
    [-1, -4,  1],  # mu
], dtype=float)

# Real q-vector (log10 λs) from best 3D geometry
Q_REAL = np.array([0.993782, 0.962938, -0.217602], dtype=float)


# ---------------------------------------------------------------------------
# Small-integer relation search a q1 + b q2 + c q3 ≈ 0
# ---------------------------------------------------------------------------

def primitive(a: int, b: int, c: int) -> bool:
    """Check if (a,b,c) is primitive: gcd(|a|,|b|,|c|) = 1 and not all zero."""
    if a == 0 and b == 0 and c == 0:
        return False
    g = math.gcd(abs(a), math.gcd(abs(b), abs(c)))
    return g == 1


def best_int_relation_for_q(q_vec, C_coeff=6, require_two_nonzero=True):
    """
    Given q_vec = (q1,q2,q3), search for best small-integer relation
    a q1 + b q2 + c q3 ≈ 0 with |a|,|b|,|c| <= C_coeff.

    Returns:
      dict with keys:
        'best_resid', 'a', 'b', 'c', 'sum_val'
    """
    q1, q2, q3 = q_vec
    best = {
        "best_resid": float("inf"),
        "a": None,
        "b": None,
        "c": None,
        "sum_val": None,
    }

    for a in range(-C_coeff, C_coeff + 1):
        for b in range(-C_coeff, C_coeff + 1):
            for c in range(-C_coeff, C_coeff + 1):
                if a == 0 and b == 0 and c == 0:
                    continue
                if require_two_nonzero:
                    if (a == 0) + (b == 0) + (c == 0) >= 2:
                        # skip if fewer than two non-zero entries
                        continue
                if not primitive(a, b, c):
                    continue

                s = a * q1 + b * q2 + c * q3
                resid = abs(s)
                if resid < best["best_resid"]:
                    best["best_resid"] = resid
                    best["a"] = a
                    best["b"] = b
                    best["c"] = c
                    best["sum_val"] = s

    return best


# ---------------------------------------------------------------------------
# Helper: jitter Yukawa logs and refit q via least squares with fixed C_REAL
# ---------------------------------------------------------------------------

YUKAWA_ORDER = [
    "me_over_v",
    "mmu_over_v",
    "mtau_over_v",
    "mb_over_v",
    "mc_over_v",
    "mt_over_v",
    "md_over_v",
    "ms_over_v",
    "mu_over_v",
]


def sample_jittered_logs(rng: np.random.Generator):
    """Draw one jittered Yukawa-log vector z from the error model."""
    z = []
    for name in YUKAWA_ORDER:
        mu = YUKAWA_LOGS[name]
        sigma = YUKAWA_SIGMA_LOG10[name]
        z.append(rng.normal(loc=mu, scale=sigma))
    return np.array(z, dtype=float)


def refit_q_from_logs(z_vec):
    """
    Given jittered logs z_vec (9-dim), refit q via least squares:

      minimize || C_REAL q - z ||^2

    using np.linalg.lstsq to avoid singular issues.
    """
    q_fit, *_ = np.linalg.lstsq(C_REAL, z_vec, rcond=None)
    return q_fit


# ---------------------------------------------------------------------------
# Main runner
# ---------------------------------------------------------------------------

def run_phase13_yukawa_q_intrel_nullscan(
    C_coeff=6,
    num_null=2000,
    seed=20251120,
):
    # Timestamp + RNG
    timestamp = datetime.now().isoformat()
    rng = np.random.default_rng(seed)

    # ----------------------------------------------------------------------
    # 1) Real-universe best relation on Q_REAL
    # ----------------------------------------------------------------------
    real_best = best_int_relation_for_q(Q_REAL, C_coeff=C_coeff)

    # ----------------------------------------------------------------------
    # 2) Null ensemble: jitter Yukawas, refit q, redo search
    # ----------------------------------------------------------------------
    null_best_resids = np.zeros(num_null, dtype=float)
    null_coeffs = []

    for i in range(num_null):
        z_null = sample_jittered_logs(rng)
        q_null = refit_q_from_logs(z_null)
        best_null = best_int_relation_for_q(q_null, C_coeff=C_coeff)
        null_best_resids[i] = best_null["best_resid"]
        null_coeffs.append((best_null["a"], best_null["b"], best_null["c"]))

        if (i + 1) % 200 == 0:
            print(f"  ... {i+1}/{num_null} null universes processed")

    # Null stats
    null_min = float(np.min(null_best_resids))
    null_max = float(np.max(null_best_resids))
    q25, q50, q75 = np.percentile(null_best_resids, [25, 50, 75])
    null_mean = float(np.mean(null_best_resids))
    null_std = float(np.std(null_best_resids))

    R_real = real_best["best_resid"]
    if null_std > 0:
        z_score = (R_real - null_mean) / null_std
    else:
        z_score = float("nan")

    p_emp = float(np.mean(null_best_resids <= R_real))
    bits = -math.log2(p_emp) if p_emp > 0 else float("inf")

    # ----------------------------------------------------------------------
    # 3) Build payload and SHA256
    # ----------------------------------------------------------------------
    payload = {
        "module": "PHASE13_YUKAWA_Q_INTREL_NULLSCAN_v1",
        "timestamp": timestamp,
        "C_coeff": C_coeff,
        "num_null": num_null,
        "seed": seed,
        "Q_real": Q_REAL.tolist(),
        "real_best": {
            "a": real_best["a"],
            "b": real_best["b"],
            "c": real_best["c"],
            "best_resid": R_real,
            "sum_val": real_best["sum_val"],
        },
        "null_stats": {
            "min": null_min,
            "max": null_max,
            "q25": float(q25),
            "q50": float(q50),
            "q75": float(q75),
            "mean": null_mean,
            "std": null_std,
        },
        "significance": {
            "p_emp": p_emp,
            "bits": bits,
            "z_score": z_score,
        },
    }

    payload_str = json.dumps(payload, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()

    # ----------------------------------------------------------------------
    # 4) Pretty-print results
    # ----------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 13 – MODULE 2: YUKAWA 3D q-VECTOR INTEGER-RELATION NULLSCAN ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields):")
    print(payload_str)
    print()
    print("=" * 82)
    print("                         REAL-UNIVERSE q-VECTOR INPUT                     ")
    print("=" * 82)
    print()
    print(f"Q_REAL (log10 λ) = ({Q_REAL[0]:+0.6f}, {Q_REAL[1]:+0.6f}, {Q_REAL[2]:+0.6f})")
    print()
    print(f"Coefficient bound C_coeff : ±{C_coeff}")
    print("Search space (a,b,c): primitive triples with at least two non-zero entries.")
    print()
    print("=" * 82)
    print("                     BEST INTEGER RELATION FOR REAL q                     ")
    print("=" * 82)
    print()
    print(f"  best_resid |a q1 + b q2 + c q3| : {R_real: .6e}")
    print(f"  best (a,b,c)                    : ({real_best['a']}, {real_best['b']}, {real_best['c']})")
    print(f"  sum_val (signed)                : {real_best['sum_val']: .6e}")
    print()
    print("  Interpretation:")
    print("    • If best_resid is extremely tiny compared to typical null values,")
    print("      then q sits unusually close to a small-integer plane.")
    print("    • If best_resid is typical under the null, q has no extra")
    print("      small-integer structure beyond what we already know.")
    print()
    print("=" * 82)
    print("                   NULL ENSEMBLE – BEST RELATIONS FOR q_null             ")
    print("=" * 82)
    print()
    print("Null stats for best_resid(q_null):")
    print(f"  null best_resid min / max       : {null_min: .6e} / {null_max: .6e}")
    print(f"  null best_resid 25% / 50% / 75% : {q25: .6e} / {q50: .6e} / {q75: .6e}")
    print(f"  null best_resid mean / std      : {null_mean: .6e} / {null_std: .6e}")
    print()
    print("=" * 82)
    print("                  SIGNIFICANCE OF INTEGER-RELATION COMPRESSION           ")
    print("=" * 82)
    print()
    print(f"  real best_resid                 : {R_real: .6e}")
    print(f"  z(real vs null mean)            : {z_score:+.2f} σ")
    print(f"  P_null(best_resid <= real)      : {p_emp:.6f}")
    if p_emp > 0:
        print(f"  bits ≈ -log2(p_null)            : {bits:5.2f} bits")
    else:
        print("  bits ≈ -log2(p_null)            : > log2(num_null) (no null hits)")
    print()
    print("Interpretation guide:")
    print("  • If p_null is O(0.1–1), the q-vector small-integer relation is")
    print("    statistically ordinary; we DO NOT promote it to a new lock.")
    print("  • If p_null is tiny (e.g. ≲ 0.01), then the geometry parameters")
    print("    themselves sit on an unusually clean small-integer relation.")
    print("    Even then, this is likely SUPPORTING structure, not an extra")
    print("    primary lock, because q is derived from the Yukawa triple.")
    print()
    print("=" * 82)
    print("                 GEOM_EVIDENCE UPDATE SUGGESTION (PSEUDOCODE)            ")
    print("=" * 82)
    print()
    print("Suggested bookkeeping (human-level, not executed here):")
    print("  GEOM_EVIDENCE['yukawa_q_intrel'] = {")
    print("      'p_null'   : p_emp,")
    print("      'bits'     : bits,")
    print("      'z_score'  : z_score,")
    print("      'timestamp': timestamp,")
    print("      'sha256'   : sha256,")
    print("      'status'   : 'supporting_structure' if p_emp not tiny else")
    print("                   'maybe_supporting_lock',")
    print("      'note'     : 'Integer relations among q-vector (3D geometry")
    print("                   parameters); derivative of Yukawa triple.'")
    print("  }")
    print()
    print("PHASE13_YUKAWA_Q_INTREL_NULLSCAN_v1 COMPLETE")
    print("=" * 82)


if __name__ == "__main__":
    run_phase13_yukawa_q_intrel_nullscan()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 13 – MODULE 3:
YUKAWA 3D q-VECTOR INTEGER-RELATION EVIDENCE (LOCK BUDGET UPDATE)

Input (from PHASE13_YUKAWA_Q_INTREL_NULLSCAN_v1):
  • Q_REAL = (0.993782, 0.962938, -0.217602)
  • Best integer relation on q:
        a q1 + b q2 + c q3 ≈ 0
        (a,b,c) = (-3, 4, 4)
        best_resid ≈ 2.0×10^-6
  • Null ensemble (2000 universes, C_coeff = 6):
        p_emp(best_resid_null ≤ best_resid_real) = 0.0005
        bits ≈ -log2(0.0005) ≈ 10.97 bits
        z_score ≈ -1.36 σ

Goal:
  • Turn that into a clean evidence object.
  • Decide whether it counts as a NEW lock or as SUPPORTING structure.
"""

import json
import math
import hashlib
from datetime import datetime


def run_phase13_yukawa_q_intrel_evidence():
    # ------------------------------------------------------------------
    # Hard-code the key results from the previous nullscan run
    # ------------------------------------------------------------------
    Q_real = (0.993782, 0.962938, -0.217602)
    a_best, b_best, c_best = -3, 4, 4
    best_resid_real = 2.0000000003905782e-06
    sum_val_real = -2.0000000003905782e-06

    p_emp = 0.0005
    bits = -math.log2(p_emp)  # ≈ 10.9657842847
    z_score = -1.3576789771850117

    null_stats = {
        "min": 1.0605918654427171e-06,
        "q25": 0.00190436957143289,
        "q50": 0.004154900214465851,
        "q75": 0.0072601176666656775,
        "max": 0.01656416400256422,
        "mean": 0.004833444101858364,
        "std": 0.003558605666764765,
    }

    # ------------------------------------------------------------------
    # Build payload and SHA256
    # ------------------------------------------------------------------
    timestamp = datetime.now().isoformat()

    payload = {
        "module": "PHASE13_YUKAWA_Q_INTREL_EVIDENCE_v1",
        "timestamp": timestamp,
        "q_intrel": {
            "Q_real": Q_real,
            "best_relation": {
                "a": a_best,
                "b": b_best,
                "c": c_best,
                "best_resid": best_resid_real,
                "sum_val": sum_val_real,
            },
            "null_stats": null_stats,
            "significance": {
                "p_emp": p_emp,
                "bits": bits,
                "z_score": z_score,
            },
            "C_coeff": 6,
            "num_null": 2000,
        },
        "classification": {
            "status": "supporting_structure",
            "reason": (
                "q-vector integer relation (-3,4,4) gives ~11 bits (p≈0.0005), "
                "but q is derived from the same Yukawa dataset and the "
                "(-4,4,3) triple lock; it is treated as supporting, not an "
                "independent primary lock."
            ),
        },
    }

    payload_str = json.dumps(payload, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()

    # ------------------------------------------------------------------
    # Pretty-print report
    # ------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 13 – MODULE 3: YUKAWA 3D q-VECTOR INTEGER-RELATION EVIDENCE ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields):")
    print(payload_str)
    print()
    print("=" * 82)
    print("                          INPUT RECAP FROM NULLSCAN                      ")
    print("=" * 82)
    print()
    print(f"Q_REAL (log10 λ) = ({Q_real[0]:+0.6f}, {Q_real[1]:+0.6f}, {Q_real[2]:+0.6f})")
    print()
    print("Best small-integer relation (from PHASE13_M2):")
    print(f"  (a,b,c)                  = ({a_best}, {b_best}, {c_best})")
    print(f"  a q1 + b q2 + c q3       = {sum_val_real: .6e}")
    print(f"  best_resid |sum|         = {best_resid_real: .6e}")
    print()
    print("Null stats for best_resid(q_null):")
    print(f"  min / max                : {null_stats['min']: .6e} / {null_stats['max']: .6e}")
    print(
        "  25% / 50% / 75%          : "
        f"{null_stats['q25']: .6e} / {null_stats['q50']: .6e} / {null_stats['q75']: .6e}"
    )
    print(
        "  mean / std               : "
        f"{null_stats['mean']: .6e} / {null_stats['std']: .6e}"
    )
    print()
    print("=" * 82)
    print("                     CONVERSION TO BITS OF SURPRISE                       ")
    print("=" * 82)
    print()
    print(f"  P_null(best_resid <= real) : {p_emp:.6f}")
    print(f"  z(real vs null mean)       : {z_score:+.2f} σ")
    print(f"  bits ≈ -log2(p_null)       : {bits:5.2f} bits")
    print()
    print("=" * 82)
    print("                  INTERPRETATION – DOES THIS COUNT AS A LOCK?             ")
    print("=" * 82)
    print()
    print("Qualitative comparison:")
    print("  • q-intrel bits             ≈ 10.97 bits (p ≈ 5×10^-4).")
    print("  • Yukawa triple (global)    ≈ 7.5 bits.")
    print("  • Yukawa triple (fixed)     ≈ 14.3 bits.")
    print("  • DNA backbone/locks        ≈ 12.3 bits.")
    print()
    print("Key conceptual point:")
    print("  • The q-vector is NOT independent data; it is computed from the")
    print("    Yukawa logs and the chosen C_REAL matrix, which already encodes")
    print("    the (-4,4,3) triple and other small-integer structure.")
    print("  • A very clean relation (-3,4,4)·q ≈ 0 therefore reflects additional")
    print("    *shape* inside the same sector, not a new independent anomaly.")
    print()
    print("Classification for evidence budget:")
    print("  → Status: SUPPORTING_STRUCTURE (NOT a primary lock).")
    print("  → We do NOT add these ~11 bits on top of the existing Yukawa triple")
    print("    bits; that would double-count the same underlying information.")
    print()
    print("=" * 82)
    print("                     GEOM_EVIDENCE UPDATE (SUGGESTED)                     ")
    print("=" * 82)
    print()
    print("Suggested entry (conceptual, not executed here):")
    print("  GEOM_EVIDENCE['yukawa_q_intrel'] = {")
    print(f"      'p_null'   : {p_emp},")
    print(f"      'bits'     : {bits},")
    print(f"      'z_score'  : {z_score},")
    print(f"      'timestamp': '{timestamp}',")
    print(f"      'sha256'   : '{sha256}',")
    print("      'status'   : 'supporting_structure',")
    print("      'description': (")
    print("          'Integer relation among q-vector (3D geometry parameters); '")
    print("          'moderately strong (~11 bits) but derived from the same '")
    print("          'Yukawa triple lock, so not counted as an independent lock.'")
    print("      ),")
    print("  }")
    print()
    print("PHASE13_YUKAWA_Q_INTREL_EVIDENCE_v1 COMPLETE")
    print("=" * 82)


if __name__ == "__main__":
    run_phase13_yukawa_q_intrel_evidence()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 14 – MODULE 1:
YUKAWA SECONDARY 3-TERM INTEGER-RELATION SEARCH (ERROR-MODEL NULL)

Goal:
  • We already know the primary Yukawa lock:
        (me_over_v, mtau_over_v, md_over_v) with (a,b,c)=(-4,4,3).
  • This module asks: is there a *second* independent triple lock
    among the other Yukawas, once we EXCLUDE that triple from the scan?

  • We:
      1) Scan all 3-term integer relations over all 9 Yukawas,
         with coefficient bound C=4, BUT excluding the {me,mtau,md} triple.
      2) Use the same error-model jitter as earlier (fractional errors).
      3) Compute p-value and bits for the best "secondary triple" and
         check if it is a genuine new lock or just a side-effect.

Conventions:
  • z_i = log10(y_i / v) as in earlier phases.
  • Residual S = |a z_i + b z_j + c z_k|.
  • We use primitive (a,b,c) with gcd=1 and at least two non-zero entries.
"""

import itertools
import math
import random
import json
import hashlib
from datetime import datetime


# ----------------------------------------------------------------------
# 1. CENTRAL YUKAWA LOGS AND ERROR MODEL (same as earlier phases)
# ----------------------------------------------------------------------

YUK_LOGS = {
    "me_over_v":   -5.683401,
    "mmu_over_v":  -3.367606,
    "mtau_over_v": -2.141781,
    "mb_over_v":   -1.770024,
    "mc_over_v":   -2.287532,
    "mt_over_v":   -0.154056,
    "md_over_v":   -4.722162,
    "ms_over_v":   -3.422873,
    "mu_over_v":   -5.056852,
}

# Error model: fractional errors → σ in log10-space (same mapping as before)
FRAC_ERRS = {
    "me_over_v":   1.0e-08,
    "mmu_over_v":  1.0e-08,
    "mtau_over_v": 1.0e-05,
    "mb_over_v":   1.0e-01,
    "mc_over_v":   1.0e-01,
    "mt_over_v":   2.0e-02,
    "md_over_v":   2.0e-01,
    "ms_over_v":   2.0e-01,
    "mu_over_v":   2.0e-01,
}


def frac_to_sigma_log10(frac):
    """Convert fractional error f (1σ) to σ_log10 ≈ f / ln(10)."""
    # For small f, σ_log10 ≈ f / (ln 10); that’s what earlier modules used numerically.
    ln10 = math.log(10.0)
    return frac / ln10


SIGMA_LOG10 = {name: frac_to_sigma_log10(frac) for name, frac in FRAC_ERRS.items()}

YUK_NAMES = list(YUK_LOGS.keys())
N_YUK = len(YUK_NAMES)


# ----------------------------------------------------------------------
# 2. INTEGER COEFFICIENT SPACE
# ----------------------------------------------------------------------

def gcd3(a, b, c):
    """gcd of three integers."""
    return math.gcd(math.gcd(abs(a), abs(b)), abs(c))


def generate_coeff_triples(C):
    """
    Generate primitive (a,b,c) in [-C, C]^3 \ {(0,0,0)},
    with at least two non-zero entries and gcd(|a|,|b|,|c|) = 1.
    """
    coeffs = []
    for a in range(-C, C + 1):
        for b in range(-C, C + 1):
            for c in range(-C, C + 1):
                if a == 0 and b == 0 and c == 0:
                    continue
                if (a != 0) + (b != 0) + (c != 0) < 2:
                    continue
                if gcd3(a, b, c) != 1:
                    continue
                coeffs.append((a, b, c))
    return coeffs


def best_relation_for_triple(z_vec, triple_idx, coeff_list):
    """
    For a fixed triple of indices (i,j,k) and logs z_vec,
    search over coeff_list to find minimal |a z_i + b z_j + c z_k|.
    """
    i, j, k = triple_idx
    zi, zj, zk = z_vec[i], z_vec[j], z_vec[k]
    best_resid = float("inf")
    best = None
    for a, b, c in coeff_list:
        s = a * zi + b * zj + c * zk
        r = abs(s)
        if r < best_resid:
            best_resid = r
            best = (a, b, c, s)
    return best_resid, best


# ----------------------------------------------------------------------
# 3. MAIN MODULE
# ----------------------------------------------------------------------

def run_phase14_yukawa_secondary_triple_nullscan(
    C=4,
    num_null=2000,
    seed=20251120,
):
    random.seed(seed)

    # Real logs as vector in a fixed order
    z_real = [YUK_LOGS[name] for name in YUK_NAMES]

    # Build list of all index triples, but EXCLUDE (me, mtau, md)
    idx_me   = YUK_NAMES.index("me_over_v")
    idx_tau  = YUK_NAMES.index("mtau_over_v")
    idx_d    = YUK_NAMES.index("md_over_v")
    primary_set = {idx_me, idx_tau, idx_d}

    all_triples = list(itertools.combinations(range(N_YUK), 3))
    triples_secondary = [t for t in all_triples if set(t) != primary_set]

    # Generate coefficient triples
    coeff_list = generate_coeff_triples(C)
    num_coeff = len(coeff_list)

    # Timestamp and SHA payload later
    timestamp = datetime.now().isoformat()

    # ------------------------------------------------------------------
    # REAL UNIVERSE: BEST SECONDARY TRIPLE
    # ------------------------------------------------------------------
    best_real_resid = float("inf")
    best_real_info = None
    top_records = []

    for triple in triples_secondary:
        resid, (a, b, c, s) = best_relation_for_triple(z_real, triple, coeff_list)
        i, j, k = triple
        record = {
            "indices": triple,
            "names": (YUK_NAMES[i], YUK_NAMES[j], YUK_NAMES[k]),
            "a": a,
            "b": b,
            "c": c,
            "sum_val": s,
            "resid": resid,
        }
        top_records.append(record)
        if resid < best_real_resid:
            best_real_resid = resid
            best_real_info = record

    # Sort top_records by residual (ascending) and keep top 10
    top_records.sort(key=lambda r: r["resid"])
    top10 = top_records[:10]

    # ------------------------------------------------------------------
    # NULL ENSEMBLE: ERROR-MODEL JITTER
    # ------------------------------------------------------------------
    sigma_vec = [SIGMA_LOG10[name] for name in YUK_NAMES]

    null_best_resids = []

    for u in range(num_null):
        # jittered logs
        z_null = [
            z_real[i] + random.gauss(0.0, sigma_vec[i])
            for i in range(N_YUK)
        ]
        # best over all secondary triples
        best_resid_u = float("inf")
        for triple in triples_secondary:
            resid, _ = best_relation_for_triple(z_null, triple, coeff_list)
            if resid < best_resid_u:
                best_resid_u = resid
        null_best_resids.append(best_resid_u)

        if (u + 1) % 200 == 0:
            print(f"  ... {(u + 1)}/{num_null} null universes processed")

    # ------------------------------------------------------------------
    # NULL STATISTICS
    # ------------------------------------------------------------------
    null_sorted = sorted(null_best_resids)
    n = len(null_sorted)

    def quantile(q):
        idx = int(q * (n - 1))
        return null_sorted[idx]

    null_min = null_sorted[0]
    null_max = null_sorted[-1]
    null_q25 = quantile(0.25)
    null_q50 = quantile(0.50)
    null_q75 = quantile(0.75)
    null_mean = sum(null_best_resids) / n
    null_var = sum((x - null_mean) ** 2 for x in null_best_resids) / n
    null_std = math.sqrt(null_var)

    # p-value and bits
    count_le = sum(1 for x in null_best_resids if x <= best_real_resid)
    p_emp = count_le / n
    if p_emp == 0.0:
        p_emp = 1.0 / n  # upper bound
    bits = -math.log2(p_emp)
    z_score = (best_real_resid - null_mean) / null_std if null_std > 0 else float("nan")

    # ------------------------------------------------------------------
    # SHA256 PAYLOAD
    # ------------------------------------------------------------------
    payload = {
        "module": "PHASE14_YUKAWA_SECONDARY_TRIPLE_NULLSCAN_v1",
        "timestamp": timestamp,
        "C_coeff": C,
        "num_null": num_null,
        "seed": seed,
        "primary_triple_excluded": {
            "indices": sorted(list(primary_set)),
            "names": [YUK_NAMES[i] for i in sorted(list(primary_set))],
        },
        "real_best_secondary": best_real_info,
        "null_stats": {
            "min": null_min,
            "q25": null_q25,
            "q50": null_q50,
            "q75": null_q75,
            "max": null_max,
            "mean": null_mean,
            "std": null_std,
        },
        "significance": {
            "p_emp": p_emp,
            "bits": bits,
            "z_score": z_score,
        },
        "top10_secondary": top10,
    }

    payload_str = json.dumps(payload, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()

    # ------------------------------------------------------------------
    # PRETTY PRINT
    # ------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 14 – MODULE 1: YUKAWA SECONDARY 3-TERM INTEGER-RELATION NULLSCAN ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields):")
    print(payload_str)
    print()
    print("=" * 82)
    print("                       SETUP AND EXCLUDED PRIMARY TRIPLE                  ")
    print("=" * 82)
    print()
    print("Coefficient bound C           :", C)
    print("Number of Yukawas             :", N_YUK)
    print("Number of index triples total :", len(all_triples))
    print("Number of secondary triples   :", len(triples_secondary))
    print("Number of coeff triples       :", num_coeff)
    print("Number of null universes      :", num_null)
    print()
    print("Primary (EXCLUDED) triple:")
    print("  indices :", sorted(list(primary_set)))
    print("  names   :", [YUK_NAMES[i] for i in sorted(list(primary_set))])
    print()
    print("=" * 82)
    print("                REAL-UNIVERSE BEST *SECONDARY* 3-TERM RELATION           ")
    print("=" * 82)
    print()
    br = best_real_info
    i, j, k = br["indices"]
    print(f"Best secondary triple indices : {br['indices']}")
    print(f"Best secondary triple names   : {br['names']}")
    print(f"Best coefficients (a,b,c)     : ({br['a']}, {br['b']}, {br['c']})")
    print(f"Best residual |sum|           : {br['resid']: .6e}")
    print(f"Signed sum a z_i + b z_j + c z_k: {br['sum_val']: .6e}")
    print()
    print("Top 10 secondary triples by residual:")
    print("  rank  resid        (i,j,k)      (names)                      (a,b,c)")
    print("  ----  -----------  -----------  ---------------------------  -----------")
    for rank, rec in enumerate(top10, start=1):
        print(
            f"  {rank:4d}  {rec['resid']: .6e}  "
            f"{rec['indices']}  "
            f"{rec['names']}  "
            f"({rec['a']:+d},{rec['b']:+d},{rec['c']:+d})"
        )
    print()
    print("=" * 82)
    print("                 NULL ENSEMBLE – BEST SECONDARY RESIDUALS                ")
    print("=" * 82)
    print()
    print(
        f"  null best_resid min / max       : {null_min: .6e} / {null_max: .6e}"
    )
    print(
        "  null best_resid 25% / 50% / 75% : "
        f"{null_q25: .6e} / {null_q50: .6e} / {null_q75: .6e}"
    )
    print(
        f"  null best_resid mean / std      : {null_mean: .6e} / {null_std: .6e}"
    )
    print()
    print("=" * 82)
    print("                 SIGNIFICANCE OF SECONDARY-TRIPLE COMPRESSION             ")
    print("=" * 82)
    print()
    print(f"  real best_resid (secondary)     : {best_real_resid: .6e}")
    print(f"  z(real vs null mean)            : {z_score: .2f} σ")
    print(f"  P_null(best_resid <= real)      : {p_emp:.6f}")
    print(f"  bits ≈ -log2(p_null)            : {bits:.2f} bits")
    print()
    print("=" * 82)
    print("                           INTERPRETATION GUIDE                           ")
    print("=" * 82)
    print()
    print("If bits ≲ 3    : secondary structure is ordinary noise.")
    print("If bits ~ 3–7  : mildly interesting, but not a primary lock.")
    print("If bits ≳ 10   : strong secondary lock (would be a big deal).")
    print()
    print("Remember:")
    print("  • This search EXCLUDES the known me–mtau–md triple.")
    print("  • Any strong secondary triple would represent a *new* constraint")
    print("    on the Yukawa sector that a geometry would have to explain.")
    print("  • If p_null is not tiny, we keep the me–mtau–md triple as the ONLY")
    print("    Yukawa primary lock and treat other patterns as noise.")
    print()
    print("PHASE14_YUKAWA_SECONDARY_TRIPLE_NULLSCAN_v1 COMPLETE")
    print("=" * 82)


if __name__ == "__main__":
    run_phase14_yukawa_secondary_triple_nullscan(
        C=4,
        num_null=2000,
        seed=20251120,
    )

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 14 – MODULE 2:
YUKAWA SECONDARY 3-TERM INTEGER-RELATION EVIDENCE UPDATE

This module ingests the *result* of PHASE 14 – MODULE 1
(YUKAWA_SECONDARY_TRIPLE_NULLSCAN_v1) and turns it into a
clean, timestamped, hashed evidence record.

From your last run (pasted in chat):

  • Primary triple (EXCLUDED from search):
        indices: [0, 2, 6]
        names  : ['me_over_v', 'mtau_over_v', 'md_over_v']

  • Best *secondary* triple:
        indices      : (5, 7, 8)
        names        : ('mt_over_v', 'ms_over_v', 'mu_over_v')
        coeffs (a,b,c): (-1, 3, -2)
        best_resid   : 8.59e-04
        p_emp        : 0.5625
        bits         : ≈0.8301

Conclusion:
  → No second Yukawa lock; the best secondary triple is ordinary noise.
"""

import json
import hashlib
from datetime import datetime
import math


def run_phase14_yukawa_secondary_triple_evidence_update():
    # ------------------------------------------------------------------
    # Hard-code the key numerical results from MODULE 1
    # ------------------------------------------------------------------
    C_coeff = 4
    num_null = 2000

    primary_triple = {
        "indices": [0, 2, 6],
        "names": ["me_over_v", "mtau_over_v", "md_over_v"],
    }

    best_secondary = {
        "indices": [5, 7, 8],
        "names": ["mt_over_v", "ms_over_v", "mu_over_v"],
        "a": -1,
        "b": 3,
        "c": -2,
        "resid": 0.0008590000000001652,
        "sum_val": -0.0008590000000001652,
    }

    null_stats = {
        "min": 1.6641100941683362e-07,
        "q25": 0.00031751459607182175,
        "q50": 0.0007370107582023167,
        "q75": 0.001367496208757757,
        "max": 0.0063675957378350745,
        "mean": 0.0009882643293344549,
        "std": 0.0009098886734551946,
    }

    p_emp = 0.5625
    bits = -math.log2(p_emp)  # should match ~0.8300749985576876
    z_score = -0.1420660934742969

    # ------------------------------------------------------------------
    # Build payload and hash
    # ------------------------------------------------------------------
    timestamp = datetime.now().isoformat()

    payload = {
        "module": "PHASE14_YUKAWA_SECONDARY_TRIPLE_EVIDENCE_v1",
        "timestamp": timestamp,
        "C_coeff": C_coeff,
        "num_null": num_null,
        "primary_triple_excluded": primary_triple,
        "best_secondary": best_secondary,
        "null_stats": null_stats,
        "significance": {
            "p_emp": p_emp,
            "bits": bits,
            "z_score": z_score,
        },
        "classification": {
            "status": "killed",
            "reason": (
                "Best secondary triple (mt, ms, mu) with (a,b,c)=(-1,3,-2) has "
                f"p≈{p_emp:.4f} (≈{bits:.2f} bits); completely ordinary under "
                "the error-model null. No second Yukawa lock."
            ),
        },
    }

    payload_str = json.dumps(payload, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()

    # ------------------------------------------------------------------
    # Pretty print
    # ------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 14 – MODULE 2: YUKAWA SECONDARY 3-TERM INTEGER-RELATION EVIDENCE ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields):")
    print(payload_str)
    print()
    print("=" * 82)
    print("                       INPUT RECAP FROM NULLSCAN (M1)                      ")
    print("=" * 82)
    print()
    print("Excluded PRIMARY triple (already-known Yukawa lock):")
    print(f"  indices : {primary_triple['indices']}")
    print(f"  names   : {primary_triple['names']}")
    print()
    print("Best *secondary* triple relation (real universe):")
    print(f"  indices      : {best_secondary['indices']}")
    print(f"  names        : {best_secondary['names']}")
    print(
        f"  coeffs (a,b,c): ({best_secondary['a']}, "
        f"{best_secondary['b']}, {best_secondary['c']})"
    )
    print(f"  best_resid    : {best_secondary['resid']: .6e}")
    print(f"  signed sum    : {best_secondary['sum_val']: .6e}")
    print()
    print("=" * 82)
    print("                    NULL STATISTICS – SECONDARY TRIPLES                    ")
    print("=" * 82)
    print()
    print(
        "  null best_resid min / max       : "
        f"{null_stats['min']: .6e} / {null_stats['max']: .6e}"
    )
    print(
        "  null best_resid 25% / 50% / 75% : "
        f"{null_stats['q25']: .6e} / {null_stats['q50']: .6e} / {null_stats['q75']: .6e}"
    )
    print(
        "  null best_resid mean / std      : "
        f"{null_stats['mean']: .6e} / {null_stats['std']: .6e}"
    )
    print()
    print("=" * 82)
    print("             SIGNIFICANCE OF SECONDARY-TRIPLE COMPRESSION                  ")
    print("=" * 82)
    print()
    print(f"  real best_resid (secondary)     : {best_secondary['resid']: .6e}")
    print(f"  z(real vs null mean)            : {z_score: .2f} σ")
    print(f"  P_null(best_resid <= real)      : {p_emp:.6f}")
    print(f"  bits ≈ -log2(p_null)            : {bits:.2f} bits")
    print()
    print("=" * 82)
    print("                         INTERPRETATION & VERDICT                          ")
    print("=" * 82)
    print()
    print("Classification for secondary triples:")
    print("  • bits ≲ 3    → ordinary noise (KILLED).")
    print("  • bits ~ 3–7  → mildly interesting, but not a primary lock.")
    print("  • bits ≳ 10   → strong secondary lock (would be a big deal).")
    print()
    print("Here we found:")
    print(f"  → bits_secondary ≈ {bits:.2f} (p ≈ {p_emp:.3f}) ⇒ ORDINARY noise.")
    print()
    print("Implication for geometry hunting:")
    print("  • There is NO statistically significant second Yukawa triple lock.")
    print("  • The ONLY Yukawa primary lock remains:")
    print("        me_over_v – mtau_over_v – md_over_v with (a,b,c)=(-4,4,3).")
    print("  • Triples like (mt, ms, mu) behave exactly like random noise under ")
    print("    the same error-model null.")
    print()
    print("=" * 82)
    print("                     GEOM_EVIDENCE UPDATE (IN-MEMORY)                      ")
    print("=" * 82)
    print()
    # ------------------------------------------------------------------
    # Update / create GEOM_EVIDENCE
    # ------------------------------------------------------------------
    try:
        GEOM_EVIDENCE  # type: ignore[name-defined]
    except NameError:
        print("GEOM_EVIDENCE not found; creating new GEOM_EVIDENCE dict.")
        globals()["GEOM_EVIDENCE"] = {}

    GEOM_EVIDENCE = globals()["GEOM_EVIDENCE"]  # now it exists

    GEOM_EVIDENCE["yukawa_secondary_triple"] = {
        "p_null": p_emp,
        "bits": bits,
        "z_score": z_score,
        "C_coeff": C_coeff,
        "num_null": num_null,
        "primary_excluded": primary_triple,
        "best_secondary": best_secondary,
        "null_stats": null_stats,
        "timestamp": timestamp,
        "sha256": sha256,
        "status": "killed",
        "description": (
            "Secondary 3-term integer relations among Yukawas with C=4, "
            "explicitly excluding (me, mtau, md). "
            "Best triple is (mt, ms, mu) with (a,b,c)=(-1,3,-2), "
            f"p≈{p_emp:.3f} (≈{bits:.2f} bits) ⇒ no second Yukawa lock."
        ),
    }

    print("GEOM_EVIDENCE['yukawa_secondary_triple'] =")
    print(json.dumps(GEOM_EVIDENCE["yukawa_secondary_triple"], indent=2))
    print()
    print("PHASE14_YUKAWA_SECONDARY_TRIPLE_EVIDENCE_v1 COMPLETE")
    print("=" * 82)


if __name__ == "__main__":
    run_phase14_yukawa_secondary_triple_evidence_update()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 15 – MODULE 1:
GLOBAL GEOMETRY SEARCH BLUEPRINT v1

Purpose:
  • Freeze the current state of knowledge into a single object:
        GLOBAL_LOCKS_BLUEPRINT
    with a timestamp and SHA256 hash.
  • Make explicit:
        - What counts as a PRIMARY LOCK (must be explained).
        - What is SUPPORTING STRUCTURE (guides shape but adds no bits).
        - What is KILLED (must be ignored as geometry bait).
  • Provide a brief, human-readable search blueprint for next phases.

You do NOT edit this; you just run it and use the printed blueprint
as the "rules of the game" going forward.
"""

import json
import hashlib
from datetime import datetime

def run_phase15_global_geometry_search_blueprint():
    # ------------------------------------------------------------------
    # 1. Re-encode the primary locks (from GLOBAL_LOCKS_v3)
    # ------------------------------------------------------------------
    dna_lock = {
        "sector": "DNA",
        "status": "primary_lock",
        "effective_bits": 12.29,
        "description": (
            "DNA backbone + lock-family structure + all-four-zero rows; "
            "multi-10-bit anomaly under harsh nulls. This is one full "
            "sector-level lock."
        ),
    }

    yukawa_triple_lock = {
        "sector": "Yukawa",
        "subsector": "me_mtau_md_triple",
        "status": "primary_lock",
        "bits_global_error_model": 7.48,
        "bits_fixed_error_model": 14.29,
        "description": (
            "me–mtau–md (-4,4,3) triple in log10(y/v); ≈7.5 bits when treated "
            "as best global 3-term relation under an error-model null, and "
            "≈14.3 bits when treated as a fixed triple under realistic errors."
        ),
    }

    # ------------------------------------------------------------------
    # 2. Supporting structures in the Yukawa sector
    # ------------------------------------------------------------------
    yukawa_supporting = {
        "minimal_2d_integer_geometry": {
            "status": "supporting_structure",
            "p_null": 0.122,
            "bits": 3.0350469470992008,
            "description": (
                "2D small-integer geometry for all 9 Yukawas; RMS≈0.0268 dex, "
                "p≈0.122 (~3 bits). Interesting but not a separate lock."
            ),
        },
        "coeff_families_2d": {
            "status": "killed",
            "p_null": 0.394,
            "bits": 1.3437324652057108,
            "description": (
                "Coefficient families in 2D geometry (e.g. mmu/ms sharing (3,-5)); "
                "statistically ordinary (~1.34 bits) under jitter null."
            ),
        },
        "integer_3d_geometry": {
            "status": "supporting_structure",
            "p_null": 0.016,
            "bits": 5.965784284662087,
            "description": (
                "3D small-integer geometry for all 9 Yukawas anchored on the "
                "(-4,4,3) triple; RMS_all≈0.0062 dex, p≈0.016 (~6 bits). "
                "Moderately surprising, but built on the primary triple."
            ),
        },
        "integer_3d_stability_fixed_q": {
            "status": "supporting_structure",
            "p_exact_upper": 0.0005,
            "bits_exact_lower": 10.965784284662087,
            "description": (
                "With q fixed, the full 9×3 integer pattern never reappears "
                "in 2000 jittered universes (≥~11 bits of combinatorial "
                "specificity), but this is heavily conditioned on the "
                "primary triple and fixed q, so not an independent lock."
            ),
        },
        "yukawa_q_intrel": {
            "status": "supporting_structure",
            "p_null": 0.0005,
            "bits": 10.965784284662087,
            "description": (
                "Integer relation among the 3D geometry q-vector: "
                "(-3,4,4)·q ≈ 0 with ~11 bits (p≈5×10^-4). "
                "Derived from the same Yukawa dataset and triple; "
                "treated as supporting shape, not a new lock."
            ),
        },
        "yukawa_secondary_triple": {
            "status": "killed",
            "p_null": 0.5625,
            "bits": 0.8300749985576876,
            "description": (
                "Global search over all 3-term integer relations with C=4, "
                "explicitly excluding (me,mtau,md). Best secondary triple is "
                "(mt,ms,mu) with (a,b,c)=(-1,3,-2), p≈0.562 (~0.83 bits). "
                "No second Yukawa lock."
            ),
        },
    }

    # ------------------------------------------------------------------
    # 3. Combined global contract (what any geometry MUST explain)
    # ------------------------------------------------------------------
    combined_contract = {
        "bits_conservative": 19.77,  # 12.29 DNA + 7.48 Yukawa(global)
        "bits_optimistic": 26.58,    # 12.29 DNA + 14.29 Yukawa(fixed)
        "status": "global_contract",
        "description": (
            "Total bits any future geometry must explain without cheating: "
            "DNA backbone/locks (~12 bits) plus the me–mtau–md (-4,4,3) "
            "Yukawa triple (7–14 bits depending on how we count). "
            "All 2D/3D Yukawa geometries, q-relations, and secondary triples "
            "are treated as supporting shape, not extra bits."
        ),
    }

    # ------------------------------------------------------------------
    # 4. Assemble BLUEPRINT object
    # ------------------------------------------------------------------
    BLUEPRINT = {
        "module": "PHASE15_GLOBAL_GEOMETRY_SEARCH_BLUEPRINT_v1",
        "timestamp": datetime.now().isoformat(),
        "primary_locks": {
            "dna": dna_lock,
            "yukawa_triple": yukawa_triple_lock,
        },
        "yukawa_supporting": yukawa_supporting,
        "combined_contract": combined_contract,
        "search_guidelines": {
            "must_explain": [
                "DNA backbone and lock-family architecture (12.29 bits).",
                "me–mtau–md (-4,4,3) triple in log10(y/v) "
                "(7–14 bits of structure).",
            ],
            "must_not_do": [
                "Do NOT hardcode the (-4,4,3) triple or DNA locks as input "
                "parameters; they must arise from the geometry.",
                "Do NOT count 2D/3D Yukawa geometries, q-relations, or "
                "secondary triples as independent evidence; they are "
                "derivative of the primary locks.",
            ],
            "can_use_as_hints": [
                "3D small-integer geometry for Yukawas (charges / exponents).",
                "q-vector integer relation (-3,4,4)·q≈0 as a hint about "
                "internal geometry.",
                "Stability patterns of the 3D integer charges under jitter.",
            ],
            "future_directions": [
                "Design explicit toy geometries (e.g. charge lattices, "
                "multi-scale FN-like models, discrete symmetry structures) "
                "that reproduce BOTH primary locks.",
                "Test any proposed geometry with the lock-checkers: does it "
                "hit DNA + Yukawa triple at the measured precision without "
                "extra free tuning parameters?",
                "If a future geometry also predicts some of the supporting "
                "structures (2D/3D integer patterns, q-relations) naturally, "
                "that is a bonus, but it does not raise the required bit "
                "budget beyond ~20–27 bits.",
            ],
        },
    }

    # ------------------------------------------------------------------
    # 5. Hash the blueprint
    # ------------------------------------------------------------------
    payload_str = json.dumps(BLUEPRINT, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()
    BLUEPRINT["sha256"] = sha256

    # ------------------------------------------------------------------
    # 6. Pretty-print
    # ------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 15 – MODULE 1: GLOBAL GEOMETRY SEARCH BLUEPRINT v1 ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {BLUEPRINT['timestamp']}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields):")
    print(payload_str)
    print()
    print("=" * 82)
    print("                             PRIMARY LOCKS                                 ")
    print("=" * 82)
    print()
    print(f"DNA sector:")
    print(f"  • Status         : {dna_lock['status']}")
    print(f"  • Effective bits : {dna_lock['effective_bits']:.2f}")
    print(f"  • Description    : {dna_lock['description']}")
    print()
    print("Yukawa sector (me–mtau–md triple):")
    print(f"  • Status           : {yukawa_triple_lock['status']}")
    print(
        "  • Bits (global)    : "
        f"{yukawa_triple_lock['bits_global_error_model']:.2f}"
    )
    print(
        "  • Bits (fixed)     : "
        f"{yukawa_triple_lock['bits_fixed_error_model']:.2f}"
    )
    print(f"  • Description      : {yukawa_triple_lock['description']}")
    print()
    print("=" * 82)
    print("                 SUPPORTING STRUCTURES (NOT NEW LOCKS)                     ")
    print("=" * 82)
    print()
    for key, info in yukawa_supporting.items():
        print(f"- {key}:")
        print(f"    status : {info['status']}")
        if "p_null" in info:
            print(f"    p_null : {info['p_null']}")
        if "bits" in info:
            print(f"    bits   : {info['bits']:.2f}")
        if "p_exact_upper" in info:
            print(f"    p_exact_upper : {info['p_exact_upper']}")
            print(f"    bits_exact_lower : {info['bits_exact_lower']:.2f}")
        print(f"    note   : {info['description']}")
        print()
    print("=" * 82)
    print("                        GLOBAL LOCK CONTRACT SUMMARY                        ")
    print("=" * 82)
    print()
    print(
        "  • DNA effective bits                 : "
        f"{dna_lock['effective_bits']:.2f}"
    )
    print(
        "  • Yukawa bits (conservative, global) : "
        f"{yukawa_triple_lock['bits_global_error_model']:.2f}"
    )
    print(
        "      → Combined (conservative)        : "
        f"{combined_contract['bits_conservative']:.2f} bits"
    )
    print()
    print(
        "  • Yukawa bits (optimistic, fixed)    : "
        f"{yukawa_triple_lock['bits_fixed_error_model']:.2f}"
    )
    print(
        "      → Combined (optimistic)          : "
        f"{combined_contract['bits_optimistic']:.2f} bits"
    )
    print()
    print("Interpretation:")
    print("  → Any serious geometry must explain ~20–27 bits of structure, coming")
    print("    from TWO independent sectors: DNA and the me–mtau–md triple.")
    print("  → All other Yukawa geometries (2D/3D, q-relations, secondary triples)")
    print("    are *supporting shape* and must NOT be double-counted as extra bits.")
    print()
    print("=" * 82)
    print("                             SEARCH GUIDELINES                              ")
    print("=" * 82)
    print()
    for line in BLUEPRINT["search_guidelines"]["must_explain"]:
        print("  MUST EXPLAIN : ", line)
    print()
    for line in BLUEPRINT["search_guidelines"]["must_not_do"]:
        print("  MUST NOT DO  : ", line)
    print()
    for line in BLUEPRINT["search_guidelines"]["can_use_as_hints"]:
        print("  HINT SOURCE  : ", line)
    print()
    print("Future directions suggested:")
    for line in BLUEPRINT["search_guidelines"]["future_directions"]:
        print("  → ", line)
    print()
    print("=" * 82)
    print(" GLOBAL_LOCKS_BLUEPRINT object is now available as a Python dict named ")
    print(" GLOBAL_LOCKS_BLUEPRINT in this interpreter (if you keep this session). ")
    print(" You can also copy the JSON payload above into a file for future runs. ")
    print("=" * 82)
    print()

    # Expose blueprint in the global namespace so later modules can import it
    globals()["GLOBAL_LOCKS_BLUEPRINT"] = BLUEPRINT


if __name__ == "__main__":
    run_phase15_global_geometry_search_blueprint()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 16 – MODULE 1:
GEOMETRY CANDIDATE SCORECARD ENGINE v1

Purpose:
  • Use the GLOBAL_LOCKS_BLUEPRINT (from PHASE 15) to score candidate
    geometries in a consistent way.
  • For each candidate, compute:
        - DNA bits earned
        - Yukawa bits (conservative / optimistic)
        - Total bits (conservative / optimistic)
        - Optional tuning penalty
  • Print a loud, timestamped scorecard with a SHA256 hash of the
    candidate + score + blueprint reference.

You do NOT edit internals; you just run the module. By default it will
print scorecards for three demo geometries:
  - NullGeometry
  - PerfectLockGeometry
  - Toy3DIntegerGeometry
"""

import json
import hashlib
from datetime import datetime


# ----------------------------------------------------------------------
# 1. Blueprint access helper
# ----------------------------------------------------------------------
def get_global_locks_blueprint():
    """
    Return the GLOBAL_LOCKS_BLUEPRINT object if present.
    If not found, reconstruct the minimal data needed for scoring.
    """
    if "GLOBAL_LOCKS_BLUEPRINT" in globals():
        bp = globals()["GLOBAL_LOCKS_BLUEPRINT"]
        if isinstance(bp, dict):
            return bp

    # Minimal reconstruction (consistent with PHASE 15)
    dna_lock = {
        "description": (
            "DNA backbone + lock-family structure + all-four-zero rows; "
            "multi-10-bit anomaly under harsh nulls. This is one full "
            "sector-level lock."
        ),
        "effective_bits": 12.29,
        "sector": "DNA",
        "status": "primary_lock",
    }

    yukawa_triple = {
        "description": (
            "me–mtau–md (-4,4,3) triple in log10(y/v); ≈7.5 bits when treated "
            "as best global 3-term relation under an error-model null, and "
            "≈14.3 bits when treated as a fixed triple under realistic errors."
        ),
        "bits_global_error_model": 7.48,
        "bits_fixed_error_model": 14.29,
        "sector": "Yukawa",
        "subsector": "me_mtau_md_triple",
        "status": "primary_lock",
    }

    combined_contract = {
        "bits_conservative": 19.77,
        "bits_optimistic": 26.58,
        "status": "global_contract",
        "description": (
            "Total bits any future geometry must explain without cheating: "
            "DNA backbone/locks (~12 bits) plus the me–mtau–md (-4,4,3) "
            "Yukawa triple (7–14 bits depending on how we count). "
            "2D/3D Yukawa geometries, q-relations, and secondary triples are "
            "supporting shape, not extra bits."
        ),
    }

    blueprint = {
        "module": "PHASE15_GLOBAL_GEOMETRY_SEARCH_BLUEPRINT_v1",
        "timestamp": None,
        "primary_locks": {
            "dna": dna_lock,
            "yukawa_triple": yukawa_triple,
        },
        "combined_contract": combined_contract,
    }

    # Add a synthetic sha so downstream always has a field
    payload_str = json.dumps(blueprint, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()
    blueprint["sha256"] = sha256

    return blueprint


# ----------------------------------------------------------------------
# 2. Geometry scoring logic
# ----------------------------------------------------------------------
def score_geometry_candidate(candidate, mode="both"):
    """
    Input:
      candidate: dict with fields:
        - name: str
        - description: str
        - explains_dna_backbone: bool
        - explains_yukawa_triple: bool
        - tuning_penalty_bits: float (optional, default 0.0)

      mode:
        - "conservative" → use 7.48 bits for Yukawa
        - "optimistic"   → use 14.29 bits for Yukawa
        - "both"         → compute both totals

    Output:
      score: dict with DNA bits, Yukawa bits (con/opt), totals, penalty.
    """
    bp = get_global_locks_blueprint()

    dna_bits = bp["primary_locks"]["dna"]["effective_bits"]
    yuk_global = bp["primary_locks"]["yukawa_triple"]["bits_global_error_model"]
    yuk_fixed = bp["primary_locks"]["yukawa_triple"]["bits_fixed_error_model"]

    explains_dna = bool(candidate.get("explains_dna_backbone", False))
    explains_yuk = bool(candidate.get("explains_yukawa_triple", False))
    tuning_penalty = float(candidate.get("tuning_penalty_bits", 0.0))

    dna_contrib = dna_bits if explains_dna else 0.0
    yuk_contrib_con = yuk_global if explains_yuk else 0.0
    yuk_contrib_opt = yuk_fixed if explains_yuk else 0.0

    total_con = max(dna_contrib + yuk_contrib_con - tuning_penalty, 0.0)
    total_opt = max(dna_contrib + yuk_contrib_opt - tuning_penalty, 0.0)

    score = {
        "dna_bits": dna_contrib,
        "yukawa_bits_conservative": yuk_contrib_con,
        "yukawa_bits_optimistic": yuk_contrib_opt,
        "tuning_penalty_bits": tuning_penalty,
        "total_bits_conservative": total_con,
        "total_bits_optimistic": total_opt,
        "mode": mode,
    }
    return score


# ----------------------------------------------------------------------
# 3. Pretty printer for scorecards
# ----------------------------------------------------------------------
def print_geometry_scorecard(candidate, mode="both"):
    """
    Compute score, hash the payload, and print a loud scorecard
    with timestamp and SHA256.
    """
    blueprint = get_global_locks_blueprint()
    score = score_geometry_candidate(candidate, mode=mode)

    timestamp = datetime.now().isoformat()
    payload = {
        "module": "PHASE16_GEOMETRY_CANDIDATE_SCORECARD_v1",
        "timestamp": timestamp,
        "candidate": candidate,
        "score": score,
        "blueprint_sha256": blueprint.get("sha256", None),
    }
    payload_str = json.dumps(payload, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()

    name = candidate.get("name", "UnnamedGeometry")
    desc = candidate.get("description", "").strip()

    print("=" * 82)
    print(f" PHASE 16 – GEOMETRY SCORECARD: {name} ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Blueprint SHA256      : ", blueprint.get("sha256", "<none>"))
    print()

    print("Description:")
    print("  " + desc)
    print()

    print("Lock claims:")
    print(f"  • explains_dna_backbone         : {bool(candidate.get('explains_dna_backbone', False))}")
    print(f"  • explains_yukawa_triple        : {bool(candidate.get('explains_yukawa_triple', False))}")
    print(f"  • tuning_penalty_bits           : {float(candidate.get('tuning_penalty_bits', 0.0)):.2f}")
    print()

    print("Bits earned (relative to GLOBAL_LOCKS_BLUEPRINT):")
    print(f"  DNA sector bits                 : {score['dna_bits']:.2f}")
    print(f"  Yukawa bits (conservative)      : {score['yukawa_bits_conservative']:.2f}")
    print(f"  Yukawa bits (optimistic)        : {score['yukawa_bits_optimistic']:.2f}")
    print(f"  Tuning penalty                  : {score['tuning_penalty_bits']:.2f}")
    print()
    print(f"  → Total (conservative)          : {score['total_bits_conservative']:.2f} bits")
    print(f"  → Total (optimistic)            : {score['total_bits_optimistic']:.2f} bits")
    print()
    print("=" * 82)
    print()


# ----------------------------------------------------------------------
# 4. Demo candidates (you can ignore or reuse)
# ----------------------------------------------------------------------
def run_phase16_geometry_scorecard_engine():
    """
    Run demo scorecards for three geometries:
      - NullGeometry
      - PerfectLockGeometry
      - Toy3DIntegerGeometry
    """
    # 1) NullGeometry: predicts nothing, explains nothing.
    null_geom = {
        "name": "NullGeometry",
        "description": (
            "Random / structureless geometry; predicts nothing and explains "
            "no locks. Baseline for comparison."
        ),
        "explains_dna_backbone": False,
        "explains_yukawa_triple": False,
        "tuning_penalty_bits": 0.0,
    }

    # 2) PerfectLockGeometry: hypothetical god-tier geometry.
    perfect_geom = {
        "name": "PerfectLockGeometry",
        "description": (
            "Hypothetical geometry that derives BOTH primary locks from its "
            "internal structure without tuning: DNA backbone/locks AND "
            "the me–mtau–md (-4,4,3) triple at the observed precision."
        ),
        "explains_dna_backbone": True,
        "explains_yukawa_triple": True,
        "tuning_penalty_bits": 0.0,
    }

    # 3) Toy3DIntegerGeometry: only Yukawa triple, no DNA.
    toy3d_geom = {
        "name": "Toy3DIntegerGeometry",
        "description": (
            "Toy geometry inspired by the 3D small-integer Yukawa structure. "
            "Assumed (for scoring purposes) to explain the me–mtau–md triple "
            "but NOT the DNA backbone. In reality this is just a demo; you "
            "should NOT claim this until a real model is built and tested."
        ),
        "explains_dna_backbone": False,
        "explains_yukawa_triple": True,
        "tuning_penalty_bits": 0.0,
    }

    # Print scorecards
    print_geometry_scorecard(null_geom, mode="both")
    print_geometry_scorecard(perfect_geom, mode="both")
    print_geometry_scorecard(toy3d_geom, mode="both")


# ----------------------------------------------------------------------
# 5. Main
# ----------------------------------------------------------------------
if __name__ == "__main__":
    run_phase16_geometry_scorecard_engine()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 17 – MODULE 1:
TOY 3D YUKAWA GEOMETRY OBJECT + AUTOSCORE (v1)

Purpose:
  • Wrap the best 3D small-integer Yukawa geometry into a concrete
    "Toy3DIntegerGeometry_v1" object.
  • Recompute predictions for all 9 Yukawas from:
        z_i^geom = C_i · q
    with C the integer coefficient matrix and q the 3D log10 λ-vector.
  • Verify:
        - RMS over all 9 Yukawas (~0.0062 dex).
        - Triple lock (-4,4,3) is satisfied at geometry level.
  • Optionally, if the Phase 16 scorecard engine is available,
    auto-score this geometry against GLOBAL_LOCKS_BLUEPRINT.

You do NOT edit this file; just run it.
"""

import math
import json
import hashlib
from datetime import datetime


# ----------------------------------------------------------------------
# 1. Hardcoded Yukawa logs (real data)
# ----------------------------------------------------------------------
def get_real_yukawa_logs():
    """
    Returns a dict name -> log10(y/v) for the 9 Yukawas.
    """
    return {
        "me_over_v":   -5.683401,
        "mmu_over_v":  -3.367606,
        "mtau_over_v": -2.141781,
        "mb_over_v":   -1.770024,
        "mc_over_v":   -2.287532,
        "mt_over_v":   -0.154056,
        "md_over_v":   -4.722162,
        "ms_over_v":   -3.422873,
        "mu_over_v":   -5.056852,
    }


# ----------------------------------------------------------------------
# 2. Best 3D integer geometry (C matrix, q vector)
# ----------------------------------------------------------------------
def get_toy3d_integer_geometry():
    """
    Returns the coefficient matrix C (9x3), the q-vector (3,),
    and the corresponding Yukawa name ordering.
    """
    names = [
        "me_over_v",
        "mmu_over_v",
        "mtau_over_v",
        "mb_over_v",
        "mc_over_v",
        "mt_over_v",
        "md_over_v",
        "ms_over_v",
        "mu_over_v",
    ]

    # Integer coefficient matrix C (rows correspond to names above)
    C = [
        [-4, -2, -1],  # me
        [-1, -2,  2],  # mmu
        [-4,  1, -4],  # tau
        [-2,  0, -1],  # b
        [-2, -1, -3],  # c
        [-2,  1, -4],  # t
        [ 0, -4,  4],  # d
        [-3,  0,  2],  # s
        [-1, -4,  1],  # u
    ]

    # q-vector (log10 λ1, log10 λ2, log10 λ3)
    q = [0.993782, 0.962938, -0.217602]

    return names, C, q


# ----------------------------------------------------------------------
# 3. Basic geometry computation helpers
# ----------------------------------------------------------------------
def dot3(a, b):
    """Simple 3D dot product."""
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]


def predict_yukawa_logs(names, C, q):
    """
    Given Yukawa names, integer rows C, and q-vector, compute:
      z_pred[name] = C_i · q
    """
    z_pred = {}
    for name, row in zip(names, C):
        z_pred[name] = dot3(row, q)
    return z_pred


def compute_residuals(z_real, z_pred):
    """
    Compute residuals (geom - real) and RMS / max|resid|.
    Returns:
      residuals[name] = z_geom - z_real
      RMS_all, max_abs_resid
    """
    residuals = {}
    sq_sum = 0.0
    max_abs = 0.0
    n = 0

    for name, z_r in z_real.items():
        z_g = z_pred[name]
        resid = z_g - z_r
        residuals[name] = resid
        sq_sum += resid * resid
        max_abs = max(max_abs, abs(resid))
        n += 1

    RMS = math.sqrt(sq_sum / n) if n > 0 else 0.0
    return residuals, RMS, max_abs


def compute_triple_lock(z_real, z_pred):
    """
    Compute the (-4,4,3) triple both on real logs and on geometry logs.
    Returns:
      S_real, S_geom, ratio
    """
    z_me_real   = z_real["me_over_v"]
    z_tau_real  = z_real["mtau_over_v"]
    z_d_real    = z_real["md_over_v"]

    z_me_geom   = z_pred["me_over_v"]
    z_tau_geom  = z_pred["mtau_over_v"]
    z_d_geom    = z_pred["md_over_v"]

    sum_real = -4 * z_me_real + 4 * z_tau_real + 3 * z_d_real
    sum_geom = -4 * z_me_geom + 4 * z_tau_geom + 3 * z_d_geom

    S_real = abs(sum_real)
    S_geom = abs(sum_geom)
    ratio = S_geom / S_real if S_real != 0.0 else float("inf")

    return S_real, S_geom, ratio


# ----------------------------------------------------------------------
# 4. Minimal fallback scorecard engine (if Phase 16 not loaded)
# ----------------------------------------------------------------------
def get_global_locks_blueprint_minimal():
    """
    Minimal reconstruction of the global locks blueprint,
    in case Phase 15 is not loaded.
    """
    dna_bits = 12.29
    yukawa_global = 7.48
    yukawa_fixed = 14.29

    blueprint = {
        "dna": {
            "effective_bits": dna_bits,
            "status": "primary_lock",
            "description": (
                "DNA backbone + lock-family structure + all-four-zero rows; "
                "multi-10-bit anomaly under harsh nulls."
            ),
        },
        "yukawa": {
            "triple_me_tau_d": {
                "bits_global_error_model": yukawa_global,
                "bits_fixed_error_model": yukawa_fixed,
                "status": "primary_lock",
                "description": (
                    "me–mtau–md (-4,4,3) triple in log10(y/v); "
                    "≈7.5 bits global, ≈14.3 bits fixed-triple."
                ),
            }
        },
        "combined": {
            "bits_conservative": dna_bits + yukawa_global,
            "bits_optimistic": dna_bits + yukawa_fixed,
            "status": "global_contract",
        },
    }

    payload_str = json.dumps(blueprint, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()
    blueprint["sha256"] = sha256
    return blueprint


def score_candidate_minimal(candidate):
    """
    Minimal scorer if Phase 16's scorecard engine is not loaded.
    Uses the same bits as GLOBAL_LOCKS_BLUEPRINT.
    """
    bp = get_global_locks_blueprint_minimal()

    dna_bits = bp["dna"]["effective_bits"]
    yuk_global = bp["yukawa"]["triple_me_tau_d"]["bits_global_error_model"]
    yuk_fixed = bp["yukawa"]["triple_me_tau_d"]["bits_fixed_error_model"]

    explains_dna = bool(candidate.get("explains_dna_backbone", False))
    explains_yuk = bool(candidate.get("explains_yukawa_triple", False))
    tuning_penalty = float(candidate.get("tuning_penalty_bits", 0.0))

    dna_contrib = dna_bits if explains_dna else 0.0
    yuk_contrib_con = yuk_global if explains_yuk else 0.0
    yuk_contrib_opt = yuk_fixed if explains_yuk else 0.0

    total_con = max(dna_contrib + yuk_contrib_con - tuning_penalty, 0.0)
    total_opt = max(dna_contrib + yuk_contrib_opt - tuning_penalty, 0.0)

    return {
        "dna_bits": dna_contrib,
        "yukawa_bits_conservative": yuk_contrib_con,
        "yukawa_bits_optimistic": yuk_contrib_opt,
        "tuning_penalty_bits": tuning_penalty,
        "total_bits_conservative": total_con,
        "total_bits_optimistic": total_opt,
    }


def print_scorecard_minimal(candidate):
    """
    Fallback scorecard printer if Phase 16's print_geometry_scorecard
    is not in the global namespace.
    """
    blueprint = get_global_locks_blueprint_minimal()
    score = score_candidate_minimal(candidate)

    timestamp = datetime.now().isoformat()
    payload = {
        "module": "PHASE17_Toy3DIntegerGeometry_Scorecard_Minimal",
        "timestamp": timestamp,
        "candidate": candidate,
        "score": score,
        "blueprint_sha256": blueprint["sha256"],
    }
    payload_str = json.dumps(payload, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()

    name = candidate.get("name", "Toy3DIntegerGeometry_v1")
    desc = candidate.get("description", "").strip()

    print("=" * 82)
    print(f" PHASE 17 – GEOMETRY SCORECARD (MINIMAL): {name} ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Blueprint SHA256      : ", blueprint["sha256"])
    print()
    print("Description:")
    print("  " + desc)
    print()
    print("Lock claims:")
    print(f"  • explains_dna_backbone         : {bool(candidate.get('explains_dna_backbone', False))}")
    print(f"  • explains_yukawa_triple        : {bool(candidate.get('explains_yukawa_triple', False))}")
    print(f"  • tuning_penalty_bits           : {float(candidate.get('tuning_penalty_bits', 0.0)):.2f}")
    print()
    print("Bits earned (relative to GLOBAL_LOCKS_BLUEPRINT):")
    print(f"  DNA sector bits                 : {score['dna_bits']:.2f}")
    print(f"  Yukawa bits (conservative)      : {score['yukawa_bits_conservative']:.2f}")
    print(f"  Yukawa bits (optimistic)        : {score['yukawa_bits_optimistic']:.2f}")
    print(f"  Tuning penalty                  : {score['tuning_penalty_bits']:.2f}")
    print()
    print(f"  → Total (conservative)          : {score['total_bits_conservative']:.2f} bits")
    print(f"  → Total (optimistic)            : {score['total_bits_optimistic']:.2f} bits")
    print()
    print("=" * 82)
    print()


# ----------------------------------------------------------------------
# 5. Main driver for this module
# ----------------------------------------------------------------------
def run_phase17_toy3d_integer_geometry():
    """
    1) Reconstruct Toy3DIntegerGeometry_v1 from C and q.
    2) Compute predictions, residuals, and triple lock.
    3) Print detailed geometry recap (with timestamp + SHA).
    4) Score the geometry via Phase 16 scorecard engine if available,
       otherwise use the minimal fallback scorer.
    """
    timestamp = datetime.now().isoformat()

    # Data and geometry
    z_real = get_real_yukawa_logs()
    names, C, q = get_toy3d_integer_geometry()
    z_pred = predict_yukawa_logs(names, C, q)
    residuals, RMS_all, max_abs_resid = compute_residuals(z_real, z_pred)
    S_real, S_geom, ratio = compute_triple_lock(z_real, z_pred)

    # Build hash payload
    payload = {
        "module": "PHASE17_Toy3DIntegerGeometry_v1",
        "timestamp": timestamp,
        "names": names,
        "C": C,
        "q": q,
        "RMS_all": RMS_all,
        "max_abs_resid": max_abs_resid,
        "S_real": S_real,
        "S_geom": S_geom,
        "ratio_S_geom_over_S_real": ratio,
    }
    payload_str = json.dumps(payload, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()

    # Pretty print geometry recap
    print("=" * 82)
    print(" PHASE 17 – MODULE 1: TOY 3D YUKAWA GEOMETRY OBJECT (v1) ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()

    print("Best 3D integer geometry recap:")
    print()
    print("Basis coefficient rows for (me, tau, d):")
    print("  row(me)   =", C[0])
    print("  row(tau)  =", C[2])
    print("  row(d)    =", C[6])
    print()
    print("Geometry parameters q (log10 λ-vector):")
    print(f"  q1 = {q[0]: .6f}")
    print(f"  q2 = {q[1]: .6f}")
    print(f"  q3 = {q[2]: .6f}")
    print()
    print("Fit quality over all 9 Yukawas:")
    print(f"  RMS_all (dex)        : {RMS_all: .6f}")
    print(f"  Max |residual| (dex) : {max_abs_resid: .6f}")
    print()

    print("Triple lock (-4,4,3) comparison:")
    print(f"  S_real                = {S_real: .6e}")
    print(f"  S_geom                = {S_geom: .6e}")
    print(f"  S_geom / S_real       = {ratio: .3e}")
    print()

    print("Per-Yukawa coefficients and residuals (geom - real):")
    print("  name         (c1,c2,c3)      z_real       z_geom       resid")
    print("  -----------  ----------    ----------   ----------   ----------")
    for name, row in zip(names, C):
        z_r = z_real[name]
        z_g = z_pred[name]
        resid = residuals[name]
        print(
            f"  {name:11s}  ({row[0]:2d},{row[1]:2d},{row[2]:2d})  "
            f"{z_r: 10.6f}   {z_g: 10.6f}   {resid: 10.6f}"
        )
    print()

    # Build candidate dict for scoring
    candidate = {
        "name": "Toy3DIntegerGeometry_v1",
        "description": (
            "Concrete toy geometry based on the best 3D small-integer Yukawa "
            "fit: C (9×3 integer charges) and q (3D log10 λ-vector). "
            "By construction it nails the (-4,4,3) triple at the geometry "
            "level and fits all 9 Yukawas with RMS≈0.0062 dex. "
            "It does NOT attempt to explain the DNA backbone."
        ),
        "explains_dna_backbone": False,
        "explains_yukawa_triple": True,   # CLAIM for scoring purposes
        "tuning_penalty_bits": 0.0,       # you can adjust later if needed
    }

    # Try to use Phase 16 scorecard engine if present
    print("=" * 82)
    print(" PHASE 17 – TOY3DIntegerGeometry_v1 SCORECARD ")
    print("=" * 82)
    print()

    if "print_geometry_scorecard" in globals():
        # Use the Phase 16 engine
        print_geometry_scorecard(candidate, mode="both")
    else:
        # Fallback minimal scoring
        print_scorecard_minimal(candidate)


# ----------------------------------------------------------------------
# 6. Main
# ----------------------------------------------------------------------
if __name__ == "__main__":
    run_phase17_toy3d_integer_geometry()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 18 – MODULE 1:
YUKAWA 3D q-VECTOR ERROR-MODEL STABILITY (FIXED C, LS-FIT q)

Goal:
  • Take the fixed 3D integer coefficient matrix C from Toy3DIntegerGeometry_v1.
  • Fit q_real by least squares from the real Yukawa logs.
  • Verify the small-integer relation on q:
        (-3, 4, 4) · q ≈ 0
  • Jitter the Yukawa logs using the *measurement error model* (Gaussian in
    log10-space) and, for each jittered universe:
        - Re-fit q_null via least squares with C fixed.
        - Compute |(-3,4,4)·q_null|.
  • Compare real |(-3,4,4)·q_real| to the null distribution:
        p_emp = P_null(best_resid <= real)
        bits  = -log2(p_emp)

Interpretation:
  • This is an error-model-based stability test for the q-vector integer
    relation, conditional on:
      - using the fixed 3D integer charges C (from Toy3D geometry), and
      - the known Yukawa triple lock (-4,4,3) that went into C.
  • Any significance we find here is SUPPORTING STRUCTURE, not a new
    primary lock.
"""

import math
import json
import hashlib
from datetime import datetime

import numpy as np


# ----------------------------------------------------------------------
# 1. Yukawa logs + error model (same as earlier phases)
# ----------------------------------------------------------------------
def get_yukawa_logs_and_sigmas():
    """
    Returns:
      names        : ordered list of Yukawa names
      z_real       : dict name -> log10(y/v)
      sigma_log10  : dict name -> 1σ in log10-space from fractional errors
    """
    # Central log10(y/v) values
    z_real = {
        "me_over_v":   -5.683401,
        "mmu_over_v":  -3.367606,
        "mtau_over_v": -2.141781,
        "mb_over_v":   -1.770024,
        "mc_over_v":   -2.287532,
        "mt_over_v":   -0.154056,
        "md_over_v":   -4.722162,
        "ms_over_v":   -3.422873,
        "mu_over_v":   -5.056852,
    }

    names = [
        "me_over_v",
        "mmu_over_v",
        "mtau_over_v",
        "mb_over_v",
        "mc_over_v",
        "mt_over_v",
        "md_over_v",
        "ms_over_v",
        "mu_over_v",
    ]

    # Fractional 1σ errors (same as earlier error-model modules)
    frac_err = {
        "me_over_v":   1.0e-08,
        "mmu_over_v":  1.0e-08,
        "mtau_over_v": 1.0e-05,
        "mb_over_v":   1.0e-01,
        "mc_over_v":   1.0e-01,
        "mt_over_v":   2.0e-02,
        "md_over_v":   2.0e-01,
        "ms_over_v":   2.0e-01,
        "mu_over_v":   2.0e-01,
    }

    # Convert fractional errors to σ in log10-space:
    #   σ_log10 ≈ frac_err / ln(10)
    ln10 = math.log(10.0)
    sigma_log10 = {
        name: frac_err[name] / ln10 for name in names
    }

    return names, z_real, sigma_log10


# ----------------------------------------------------------------------
# 2. Fixed 3D integer coefficient matrix C (Toy3D geometry)
# ----------------------------------------------------------------------
def get_C_matrix_toy3d(names):
    """
    Returns C as a numpy array (9x3) matching the given name order.
    """
    # Hardcoded in the same order as names list
    rows = {
        "me_over_v":   [-4, -2, -1],
        "mmu_over_v":  [-1, -2,  2],
        "mtau_over_v": [-4,  1, -4],
        "mb_over_v":   [-2,  0, -1],
        "mc_over_v":   [-2, -1, -3],
        "mt_over_v":   [-2,  1, -4],
        "md_over_v":   [ 0, -4,  4],
        "ms_over_v":   [-3,  0,  2],
        "mu_over_v":   [-1, -4,  1],
    }
    C = np.array([rows[n] for n in names], dtype=float)
    return C


# ----------------------------------------------------------------------
# 3. LS fit for q and residuals
# ----------------------------------------------------------------------
def fit_q_least_squares(C, z_vec):
    """
    Solve q in least-squares sense:
        minimize ||C q - z||^2
      via numpy.linalg.lstsq.

    Inputs:
      C     : (9x3) matrix
      z_vec : (9,) vector of log10(y/v)

    Returns:
      q     : (3,) fitted q-vector
      RMS   : RMS of residuals
      max_abs_resid : max |residual|
      residuals     : (9,) residuals Cq - z
    """
    q, *_ = np.linalg.lstsq(C, z_vec, rcond=None)
    z_fit = C @ q
    residuals = z_fit - z_vec
    RMS = float(np.sqrt(np.mean(residuals**2)))
    max_abs = float(np.max(np.abs(residuals)))
    return q, RMS, max_abs, residuals


def q_int_relation_residual(q):
    """
    Compute |(-3,4,4) · q| for a given q-vector.
    """
    a, b, c = -3.0, 4.0, 4.0
    val = a * q[0] + b * q[1] + c * q[2]
    return abs(float(val))


# ----------------------------------------------------------------------
# 4. Main driver
# ----------------------------------------------------------------------
def run_phase18_yukawa_q_error_model_stability(
    num_null=2000,
    seed=20251120,
):
    """
    Error-model-based null for the q-vector integer relation, with C fixed.

    Steps:
      1) Fit q_real from central Yukawa logs using fixed C.
      2) Compute real_resid_q = |(-3,4,4)·q_real|.
      3) Generate num_null jittered Yukawa universes:
           z_i^null ~ N(z_i_real, σ_log10_i),
         fit q_null via LS each time, and compute
           resid_q_null = |(-3,4,4)·q_null|.
      4) Compare real_resid_q to the null distribution.
    """
    timestamp = datetime.now().isoformat()

    # Data
    names, z_real_dict, sigma_log10 = get_yukawa_logs_and_sigmas()
    z_real_vec = np.array([z_real_dict[n] for n in names], dtype=float)
    sig_vec = np.array([sigma_log10[n] for n in names], dtype=float)

    # Fixed coefficient matrix C
    C = get_C_matrix_toy3d(names)

    # Fit q_real via least squares
    q_real, RMS_real, max_abs_real, resids_real = fit_q_least_squares(C, z_real_vec)
    real_resid_q = q_int_relation_residual(q_real)

    # Null ensemble
    rng = np.random.default_rng(seed)
    null_resids_q = []
    null_RMS = []

    print("=" * 82)
    print(" PHASE 18 – MODULE 1: YUKAWA 3D q-VECTOR ERROR-MODEL STABILITY ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    # Build hash payload now; we'll fill in null stats later, then re-hash for final log
    hash_payload = {
        "module": "PHASE18_YUKAWA_Q_ERRORMODEL_STABILITY_v1",
        "num_null": num_null,
        "seed": seed,
        "timestamp": timestamp,
        "z_real": z_real_dict,
        "sigma_log10": sigma_log10,
        "names": names,
        "C": C.tolist(),
    }

    print("Real Yukawa logs and error model:")
    print("  name         z_real       sigma_log10")
    print("  -----------  ----------   ----------")
    for n in names:
        print(f"  {n:11s}  {z_real_dict[n]: 10.6f}   {sigma_log10[n]: 10.6e}")
    print()

    print("Fixed 3D integer coefficient matrix C (Toy3D geometry):")
    for n, row in zip(names, C):
        print(f"  {n:11s}  ({int(row[0]):2d},{int(row[1]):2d},{int(row[2]):2d})")
    print()

    print("Least-squares q_real fit with C fixed:")
    print(f"  q_real = ({q_real[0]: .6f}, {q_real[1]: .6f}, {q_real[2]: .6f})")
    print(f"  RMS_real (dex)        : {RMS_real: .6f}")
    print(f"  Max |resid| (dex)     : {max_abs_real: .6f}")
    print()

    print("q-vector integer relation (-3,4,4)·q ≈ 0 (REAL):")
    print(f"  |(-3,4,4)·q_real|     : {real_resid_q: .6e}")
    print()

    print("Generating jittered Yukawa universes under error model...")
    for i in range(num_null):
        # Jitter each Yukawa log
        z_null = z_real_vec + sig_vec * rng.standard_normal(size=z_real_vec.shape)
        q_null, RMS_null, _, _ = fit_q_least_squares(C, z_null)
        resid_q_null = q_int_relation_residual(q_null)

        null_resids_q.append(resid_q_null)
        null_RMS.append(RMS_null)

        if (i + 1) % 200 == 0 or (i + 1) == num_null:
            print(f"  ... {i+1}/{num_null} universes processed")

    null_resids_q = np.array(null_resids_q, dtype=float)
    null_RMS = np.array(null_RMS, dtype=float)

    # Null statistics
    min_q = float(np.min(null_resids_q))
    max_q = float(np.max(null_resids_q))
    q25 = float(np.quantile(null_resids_q, 0.25))
    q50 = float(np.quantile(null_resids_q, 0.50))
    q75 = float(np.quantile(null_resids_q, 0.75))
    mean_q = float(np.mean(null_resids_q))
    std_q = float(np.std(null_resids_q))

    # Empirical p-value
    count_le = int(np.sum(null_resids_q <= real_resid_q))
    p_emp = (count_le + 0.0) / num_null
    bits = -math.log(p_emp, 2.0) if p_emp > 0.0 else float("inf")

    # z-score vs null mean
    if std_q > 0.0:
        z_score = (real_resid_q - mean_q) / std_q
    else:
        z_score = float("nan")

    # Finalize hash payload with stats
    hash_payload["q_real"] = q_real.tolist()
    hash_payload["RMS_real"] = RMS_real
    hash_payload["max_abs_real"] = max_abs_real
    hash_payload["real_resid_q"] = real_resid_q
    hash_payload["null_resids_q_stats"] = {
        "min": min_q,
        "q25": q25,
        "q50": q50,
        "q75": q75,
        "max": max_q,
        "mean": mean_q,
        "std": std_q,
    }
    hash_payload["significance"] = {
        "p_emp": p_emp,
        "bits": bits,
        "z_score": z_score,
        "count_le": count_le,
    }

    payload_str = json.dumps(hash_payload, sort_keys=True)
    sha256 = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()

    print()
    print("=" * 82)
    print(" NULL STATISTICS – q-VECTOR INTEGER RELATION UNDER ERROR MODEL ")
    print("=" * 82)
    print()
    print("Null distribution of |(-3,4,4)·q_null|:")
    print(f"  null resid_q min / max       : {min_q: .6e} / {max_q: .6e}")
    print(f"  null resid_q 25% / 50% / 75% : {q25: .6e} / {q50: .6e} / {q75: .6e}")
    print(f"  null resid_q mean / std      : {mean_q: .6e} / {std_q: .6e}")
    print()
    print("Significance of real q-vector relation (error-model null):")
    print(f"  real resid_q                 : {real_resid_q: .6e}")
    print(f"  count_null <= real           : {count_le} / {num_null}")
    print(f"  P_null(resid_q <= real)      : {p_emp: .6f}")
    print(f"  bits ≈ -log2(p_null)         : {bits: .2f} bits")
    print(f"  z(real vs null mean)         : {z_score: .2f} σ")
    print()
    print("=" * 82)
    print(" HASH & BOOKKEEPING ")
    print("=" * 82)
    print()
    print(f"Run SHA256 payload    : {sha256}")
    print()

    # Optional: update GEOM_EVIDENCE if present
    if "GEOM_EVIDENCE" in globals() and isinstance(globals()["GEOM_EVIDENCE"], dict):
        GEOM_EVIDENCE = globals()["GEOM_EVIDENCE"]
    else:
        GEOM_EVIDENCE = None

    if GEOM_EVIDENCE is not None:
        entry = {
            "p_null": p_emp,
            "bits": bits,
            "z_score": z_score,
            "num_null": num_null,
            "count_le": count_le,
            "null_stats": {
                "min": min_q,
                "q25": q25,
                "q50": q50,
                "q75": q75,
                "max": max_q,
                "mean": mean_q,
                "std": std_q,
            },
            "q_real": q_real.tolist(),
            "RMS_real": RMS_real,
            "timestamp": timestamp,
            "sha256": sha256,
            "status": "supporting_structure",
            "description": (
                "Error-model-based null for the q-vector integer relation "
                "with fixed 3D integer charges C (Toy3D geometry). "
                "Significance is treated as supporting structure, not an "
                "independent primary lock."
            ),
        }
        GEOM_EVIDENCE["yukawa_q_intrel_error_model"] = entry
        globals()["GEOM_EVIDENCE"] = GEOM_EVIDENCE

        print("GEOM_EVIDENCE['yukawa_q_intrel_error_model'] updated.")
        print()


# ----------------------------------------------------------------------
# 5. Main
# ----------------------------------------------------------------------
if __name__ == "__main__":
    run_phase18_yukawa_q_error_model_stability(
        num_null=2000,
        seed=20251120,
    )

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 18 – MODULE 2: YUKAWA 3D q-VECTOR ERROR-MODEL EVIDENCE (v1)

This module takes the numerical results from:
  PHASE 18 – MODULE 1: YUKAWA 3D q-VECTOR ERROR-MODEL STABILITY

and turns them into a clean evidence/evaluation block for the
global geometry evidence budget.

It does NOT re-run the jitter simulation; it just encodes the
numbers you already saw:

  • q_real       = (0.995464, 0.960785, -0.220050)
  • relation     = (-3, 4, 4) · q_real ≈ 0.023454
  • p_emp        = 0.138
  • bits         ≈ 2.86
  • z_score      ≈ -1.05 σ

Conclusion (spoiler):
  → The q-vector integer relation is at most a ~3-bit effect under
    a realistic error-model null. That is weak. We treat it purely
    as *supporting shape*, not a lock, and do NOT change the global
    lock contract.
"""

import json
import math
import hashlib
import datetime


def run_phase18_yukawa_q_error_model_evidence_v1():
    # ------------------------------------------------------------------
    # 0. Timestamp + fixed numerical inputs from MODULE 1
    # ------------------------------------------------------------------
    timestamp = datetime.datetime.now().isoformat()

    # These are the numbers printed by PHASE 18 – MODULE 1
    q_real = (0.995464, 0.960785, -0.220050)

    # Integer relation we care about: (-3, 4, 4) · q
    resid_q_real = 2.345412e-02  # |(-3,4,4)·q_real|

    # Null stats for |(-3,4,4)·q_null| under error model
    null_mean = 1.187936e-01
    null_std = 9.087840e-02
    null_min = 8.087715e-05
    null_q25 = 4.566269e-02
    null_q50 = 1.019907e-01
    null_q75 = 1.730533e-01
    null_max = 5.948385e-01

    # Empirical p-value from MODULE 1
    p_emp = 0.138000
    bits = -math.log2(p_emp)
    z_score = (resid_q_real - null_mean) / null_std

    # ------------------------------------------------------------------
    # 1. Build hash payload for reproducibility
    # ------------------------------------------------------------------
    payload = {
        "module": "PHASE18_YUKAWA_Q_ERRORMODEL_EVIDENCE_v1",
        "timestamp": timestamp,
        "q_real": q_real,
        "relation": {
            "a": -3,
            "b": 4,
            "c": 4,
            "resid_real": resid_q_real,
        },
        "null_stats": {
            "min": null_min,
            "q25": null_q25,
            "q50": null_q50,
            "q75": null_q75,
            "max": null_max,
            "mean": null_mean,
            "std": null_std,
        },
        "significance": {
            "p_emp": p_emp,
            "bits": bits,
            "z_score": z_score,
        },
        "interpretation": {
            "summary": (
                "Under a realistic error-model null, the q-vector integer "
                "relation (-3,4,4)·q has p≈0.138 (≈2.9 bits). That is weak; "
                "we treat it as supporting shape only, not an independent lock."
            ),
            "classification": "supporting_structure_weak",
        },
    }

    sha256 = hashlib.sha256(
        json.dumps(payload, sort_keys=True).encode("utf-8")
    ).hexdigest()

    # ------------------------------------------------------------------
    # 2. Pretty print report
    # ------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 18 – MODULE 2: YUKAWA 3D q-VECTOR ERROR-MODEL EVIDENCE (v1) ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields):")
    print(json.dumps(payload, indent=2, sort_keys=True))
    print()

    print("=" * 82)
    print("                      INPUT RECAP FROM ERROR-MODEL SCAN                 ")
    print("=" * 82)
    print()
    print(f"q_real (log10 λ) = ({q_real[0]:+0.6f}, {q_real[1]:+0.6f}, {q_real[2]:+0.6f})")
    print()
    print("Integer relation tested: (-3,4,4) · q ≈ 0")
    print(f"  |(-3,4,4)·q_real|      : {resid_q_real: .6e}")
    print()
    print("Null stats for |(-3,4,4)·q_null| under error model:")
    print(f"  min / max              : {null_min: .6e} / {null_max: .6e}")
    print(f"  25% / 50% / 75%        : {null_q25: .6e} / {null_q50: .6e} / {null_q75: .6e}")
    print(f"  mean / std             : {null_mean: .6e} / {null_std: .6e}")
    print()

    print("=" * 82)
    print("                  SIGNIFICANCE UNDER ERROR-MODEL NULL                    ")
    print("=" * 82)
    print()
    print(f"  real resid_q           : {resid_q_real: .6e}")
    print(f"  P_null(resid_q <= real): {p_emp: .6f}")
    print(f"  bits ≈ -log2(p_null)   : {bits: .2f} bits")
    print(f"  z(real vs null mean)   : {z_score: .2f} σ")
    print()

    print("=" * 82)
    print("                        INTERPRETATION & VERDICT                         ")
    print("=" * 82)
    print()
    print("  • Rough scale: bits ≲ 3 ⇒ weak / ordinary-ish; 3–7 ⇒ mildly interesting;")
    print("    >10 ⇒ strong. Here we get ≈2.9 bits, i.e. borderline weak.")
    print()
    print("  • Under the realistic error model, the q-vector relation (-3,4,4)·q")
    print("    is *not* sharply tuned: p≈0.138 means many jittered universes")
    print("    generate equally good or better small-integer relations.")
    print()
    print("  • Combined with earlier modules:")
    print("      – The ~11-bit effect found when we jittered q directly was")
    print("        clearly over-optimistic and heavily conditioned on prior choices.")
    print("      – Once we respect the Yukawa error model, this drops to ≈3 bits.")
    print()
    print("Verdict for evidence budget:")
    print("  → q-vector integer relation is SUPPORTING SHAPE ONLY.")
    print("  → It does NOT modify the global lock contract (~20–27 bits).")
    print("  → Primary Yukawa lock remains ONLY the me–mtau–md (-4,4,3) triple.")
    print()

    # ------------------------------------------------------------------
    # 3. Update in-memory GEOM_EVIDENCE, if present
    # ------------------------------------------------------------------
    try:
        GEOM_EVIDENCE  # type: ignore[name-defined]
    except NameError:
        print("GEOM_EVIDENCE not found; creating new GEOM_EVIDENCE dict.")
        globals()["GEOM_EVIDENCE"] = {}
    ge = globals()["GEOM_EVIDENCE"]

    ge["yukawa_q_intrel_error_model"] = {
        "p_null": p_emp,
        "bits": bits,
        "z_score": z_score,
        "q_real": q_real,
        "relation": {"a": -3, "b": 4, "c": 4},
        "null_stats": {
            "min": null_min,
            "q25": null_q25,
            "q50": null_q50,
            "q75": null_q75,
            "max": null_max,
            "mean": null_mean,
            "std": null_std,
        },
        "timestamp": timestamp,
        "sha256": sha256,
        "status": "supporting_structure_weak",
        "description": (
            "Integer relation (-3,4,4)·q for the 3D Yukawa geometry q-vector, "
            "evaluated under a realistic error-model null. p≈0.138 (~2.9 bits): "
            "treated as weak supporting structure only, not an independent lock."
        ),
    }

    print("=" * 82)
    print("      GEOM_EVIDENCE['yukawa_q_intrel_error_model'] UPDATED IN-MEMORY     ")
    print("=" * 82)
    print()


# Run if executed as a script
if __name__ == "__main__":
    run_phase18_yukawa_q_error_model_evidence_v1()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 19 – MODULE 1: GLOBAL GEOMETRY EVIDENCE V4 – UPDATED LOCK CONTRACT

This module folds in the latest result:

  PHASE 18 – MODULE 2: YUKAWA 3D q-VECTOR ERROR-MODEL EVIDENCE (v1)

and produces an updated global geometry evidence object:

  GLOBAL_LOCKS_v4
  YUKAWA_SUPPORTING_v4

Key new point:
  • Under the realistic error model, the q-vector integer relation
      (-3,4,4)·q ≈ 0
    only gives p ≈ 0.138 (≈ 2.86 bits). That’s weak – *supporting shape*,
    not an independent lock.

Bottom line:
  • The global lock contract is unchanged: any serious geometry must
    still explain ~20–27 bits from:
       – DNA backbone/locks (~12.29 bits)
       – me–mtau–md (-4,4,3) triple (7–14 bits)
"""

import json
import math
import hashlib
import datetime


def run_phase19_global_geometry_evidence_v4():
    # ------------------------------------------------------------------
    # 0. Timestamp
    # ------------------------------------------------------------------
    timestamp = datetime.datetime.now().isoformat()

    # ------------------------------------------------------------------
    # 1. Primary locks (same as v3)
    # ------------------------------------------------------------------
    dna_lock = {
        "effective_bits": 12.29,
        "status": "primary_lock",
        "sector": "DNA",
        "description": (
            "DNA backbone + lock-family structure + all-four-zero rows; "
            "multi-10-bit anomaly under harsh nulls. This is one full "
            "sector-level lock."
        ),
    }

    yukawa_triple_lock = {
        "sector": "Yukawa",
        "subsector": "me_mtau_md_triple",
        "status": "primary_lock",
        "bits_global_error_model": 7.48,
        "bits_fixed_error_model": 14.29,
        "description": (
            "me–mtau–md (-4,4,3) triple in log10(y/v); ≈7.5 bits when treated "
            "as best global 3-term relation under an error-model null, and "
            "≈14.3 bits when treated as a fixed triple under realistic errors."
        ),
    }

    # Conservative vs optimistic contract (unchanged)
    bits_dna = dna_lock["effective_bits"]
    bits_yukawa_conservative = yukawa_triple_lock["bits_global_error_model"]
    bits_yukawa_optimistic = yukawa_triple_lock["bits_fixed_error_model"]

    combined_conservative = bits_dna + bits_yukawa_conservative
    combined_optimistic = bits_dna + bits_yukawa_optimistic

    combined_contract = {
        "bits_conservative": combined_conservative,
        "bits_optimistic": combined_optimistic,
        "status": "global_contract",
        "description": (
            "Total bits any future geometry must explain without cheating: "
            "DNA backbone/locks (~12 bits) plus the me–mtau–md (-4,4,3) Yukawa "
            "triple (7–14 bits depending on how we count). All 2D/3D Yukawa "
            "geometries, q-relations, and secondary triples are treated as "
            "supporting shape, not extra bits."
        ),
    }

    # ------------------------------------------------------------------
    # 2. Supporting Yukawa structures (v3 + new q-error-model result)
    # ------------------------------------------------------------------

    yukawa_supporting = {
        # 2D minimal integer geometry (9 Yukawas)
        "minimal_2d_integer_geometry": {
            "p_null": 0.122,
            "bits": 3.0350469470992008,
            "status": "supporting_structure",
            "description": (
                "2D small-integer geometry for all 9 Yukawas; RMS≈0.0268 dex, "
                "p≈0.122 (~3 bits). Interesting but not a separate lock."
            ),
        },

        # 2D coefficient families (mmu/ms sharing (3,-5)) – killed
        "coeff_families_2d": {
            "p_null": 0.394,
            "bits": 1.3437324652057108,
            "status": "killed",
            "description": (
                "Coefficient families in 2D geometry (e.g. mmu/ms sharing (3,-5)); "
                "statistically ordinary (~1.34 bits) under jitter null."
            ),
        },

        # 3D integer geometry (re-fit under jitter)
        "integer_3d_geometry": {
            "p_null": 0.016,
            "bits": 5.965784284662087,
            "status": "supporting_structure",
            "description": (
                "3D small-integer geometry for all 9 Yukawas anchored on the "
                "(-4,4,3) triple; RMS_all≈0.0062 dex, p≈0.016 (~6 bits). "
                "Moderately surprising, but built on the primary triple."
            ),
        },

        # 3D integer pattern stability with q fixed – combinatorial specificity
        "integer_3d_stability_fixed_q": {
            "p_exact_upper": 0.0005,
            "bits_exact_lower": 10.965784284662087,
            "status": "supporting_structure",
            "description": (
                "With q fixed, the full 9×3 integer pattern never reappears in "
                "2000 jittered universes (≥~11 bits of combinatorial specificity), "
                "but this is heavily conditioned on the primary triple and fixed q, "
                "so not an independent lock."
            ),
        },

        # Earlier q-intrel (jittered q, no error model) – supporting
        "yukawa_q_intrel": {
            "p_null": 0.0005,
            "bits": 10.965784284662087,
            "status": "supporting_structure",
            "description": (
                "Integer relation among the 3D geometry q-vector: (-3,4,4)·q ≈ 0 "
                "with ~11 bits (p≈5×10^-4) when q is jittered directly. "
                "Derived from the same Yukawa dataset and triple; treated as "
                "supporting shape, not a new lock."
            ),
        },

        # NEW: q-intrel under realistic error-model null – weak supporting structure
        "yukawa_q_intrel_error_model": {
            "p_null": 0.138,
            "bits": -math.log2(0.138),
            "status": "supporting_structure_weak",
            "description": (
                "Integer relation (-3,4,4)·q evaluated under a realistic Yukawa "
                "error-model null. p≈0.138 (~2.9 bits): many jittered universes "
                "have equally good or better relations. Weak supporting shape only."
            ),
        },

        # Secondary 3-term relations (excluding me–mtau–md) – killed
        "yukawa_secondary_triple": {
            "p_null": 0.5625,
            "bits": 0.8300749985576876,
            "status": "killed",
            "description": (
                "Global search over all 3-term integer relations with C=4, "
                "explicitly excluding (me,mtau,md). Best secondary triple is "
                "(mt,ms,mu) with (a,b,c)=(-1,3,-2), p≈0.562 (~0.83 bits). "
                "No second Yukawa lock."
            ),
        },
    }

    # ------------------------------------------------------------------
    # 3. Bundle into GLOBAL_LOCKS_v4-style object
    # ------------------------------------------------------------------
    GLOBAL_LOCKS_v4 = {
        "dna": dna_lock,
        "yukawa": {
            "triple_me_tau_d": yukawa_triple_lock,
            "supporting": yukawa_supporting,
        },
        "combined": combined_contract,
    }

    # ------------------------------------------------------------------
    # 4. Hash payload for reproducibility
    # ------------------------------------------------------------------
    payload = {
        "module": "PHASE19_GLOBAL_GEOMETRY_EVIDENCE_v4",
        "timestamp": timestamp,
        "GLOBAL_LOCKS_v4": GLOBAL_LOCKS_v4,
    }

    sha256 = hashlib.sha256(
        json.dumps(payload, sort_keys=True).encode("utf-8")
    ).hexdigest()

    # ------------------------------------------------------------------
    # 5. Pretty print report
    # ------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 19 – MODULE 1: GLOBAL GEOMETRY EVIDENCE V4 – UPDATED CONTRACT ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields):")
    print(json.dumps(payload, indent=2, sort_keys=True))
    print()

    print("=" * 82)
    print("                              PRIMARY LOCKS                               ")
    print("=" * 82)
    print()
    print("DNA sector:")
    print(f"  • Status         : {dna_lock['status']}")
    print(f"  • Effective bits : {dna_lock['effective_bits']:.2f}")
    print(f"  • Description    : {dna_lock['description']}")
    print()
    print("Yukawa sector (me–mtau–md triple):")
    print(f"  • Status         : {yukawa_triple_lock['status']}")
    print(f"  • Bits (global)  : {yukawa_triple_lock['bits_global_error_model']:.2f}")
    print(f"  • Bits (fixed)   : {yukawa_triple_lock['bits_fixed_error_model']:.2f}")
    print(f"  • Description    : {yukawa_triple_lock['description']}")
    print()

    print("=" * 82)
    print("                     SUPPORTING STRUCTURES (NOT LOCKS)                     ")
    print("=" * 82)
    print()
    for key, entry in yukawa_supporting.items():
        print(f"- {key}:")
        print(f"    status : {entry['status']}")
        if "p_null" in entry:
            print(f"    p_null : {entry['p_null']}")
            print(f"    bits   : {entry['bits']:.2f}")
        elif "p_exact_upper" in entry:
            print(f"    p_exact_upper    : {entry['p_exact_upper']}")
            print(f"    bits_exact_lower : {entry['bits_exact_lower']:.2f}")
        print(f"    note   : {entry['description']}")
        print()

    print("=" * 82)
    print("                        GLOBAL LOCK CONTRACT SUMMARY                        ")
    print("=" * 82)
    print()
    print(f"  • DNA effective bits                 : {bits_dna:.2f}")
    print(f"  • Yukawa bits (conservative, global) : {bits_yukawa_conservative:.2f}")
    print(f"      → Combined (conservative)        : {combined_conservative:.2f} bits")
    print()
    print(f"  • Yukawa bits (optimistic, fixed)    : {bits_yukawa_optimistic:.2f}")
    print(f"      → Combined (optimistic)          : {combined_optimistic:.2f} bits")
    print()
    print("Interpretation:")
    print("  → Any serious geometry must explain ~20–27 bits of structure, coming")
    print("    from TWO independent sectors: DNA and the me–mtau–md triple.")
    print("  → All other Yukawa geometries (2D/3D, q-relations, secondary triples)")
    print("    are *supporting shape* and MUST NOT be double-counted as extra bits.")
    print()
    print("=" * 82)
    print(" GLOBAL_LOCKS_BLUEPRINT (v4-style) IS NOW AVAILABLE IN THIS INTERPRETER   ")
    print("=" * 82)
    print()

    # ------------------------------------------------------------------
    # 6. Update in-memory globals if present
    # ------------------------------------------------------------------
    globals()["GLOBAL_LOCKS_BLUEPRINT"] = GLOBAL_LOCKS_v4

    try:
        GEOM_EVIDENCE  # type: ignore[name-defined]
    except NameError:
        globals()["GEOM_EVIDENCE"] = {}
    ge = globals()["GEOM_EVIDENCE"]
    ge["GLOBAL_LOCKS_v4"] = {
        "timestamp": timestamp,
        "sha256": sha256,
        "object": GLOBAL_LOCKS_v4,
    }


# Run if executed as a script
if __name__ == "__main__":
    run_phase19_global_geometry_evidence_v4()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 20 – MODULE 1: YUKAWA 3D INTEGER GEOMETRY BASIS SIMPLIFIER (v1)

Goal:
  • Take the existing 3D small-integer Yukawa geometry (C, q).
  • Search over small unimodular integer matrices U (det = ±1).
  • Transform:
        C' = C @ U
        q' = (U^{-1}).T @ q
    so that C' q' = C q (same predictions in a new basis).
  • Look for bases with "simpler" integer charges C':
        – smaller max |coeff|,
        – fewer distinct patterns,
        – maybe hints of effective lower dimension (e.g. a nearly zero q'_3).

This does NOT change the evidence budget; it’s purely about understanding
the internal structure of the Toy3DIntegerGeometry we already found.
"""

import numpy as np
import itertools
import datetime
import json
import hashlib


def generate_unimodular_matrices(max_entry=2):
    """
    Generate all 3x3 integer matrices U with entries in [-max_entry, max_entry]
    and det(U) in {+1, -1}. This is a brute-force scan for small U.

    For max_entry = 2:
      – total candidates = (2*max_entry + 1)^9 = 5^9 = 1,953,125
      – many will be filtered out by the det check.

    This is heavy but still feasible in a normal Python environment.
    """
    vals = range(-max_entry, max_entry + 1)
    for entries in itertools.product(vals, repeat=9):
        U = np.array(entries, dtype=int).reshape(3, 3)
        det = round(np.linalg.det(U))
        if det in (1, -1):
            # Ensure it's exactly ±1 (and not just numerically close)
            if np.linalg.det(U) * det > 0.999 and np.linalg.det(U) * det < 1.001:
                yield U


def complexity_metrics(C_prime):
    """
    Compute simple complexity measures for a 9×3 integer charge matrix C'.
    """
    max_abs = int(np.max(np.abs(C_prime)))
    l1_sum = int(np.sum(np.abs(C_prime)))
    num_nonzero = int(np.count_nonzero(C_prime))
    # Number of distinct rows (as tuples) – a crude 'family structure' count
    rows = [tuple(row.tolist()) for row in C_prime]
    num_distinct_rows = len(set(rows))
    return {
        "max_abs": max_abs,
        "l1_sum": l1_sum,
        "num_nonzero": num_nonzero,
        "num_distinct_rows": num_distinct_rows,
    }


def run_phase20_yukawa_3d_basis_simplifier(max_entry=2, top_k=10):
    # ----------------------------------------------------------------------
    # 0. Timestamp + setup
    # ----------------------------------------------------------------------
    timestamp = datetime.datetime.now().isoformat()

    # Toy3DIntegerGeometry: hard-coded from earlier phases
    # C_real: 9×3 integer coefficients for Yukawa logs
    # Order: [me, mmu, mtau, mb, mc, mt, md, ms, mu]
    C_real = np.array([
        [-4, -2, -1],   # me_over_v
        [-1, -2,  2],   # mmu_over_v
        [-4,  1, -4],   # mtau_over_v
        [-2,  0, -1],   # mb_over_v
        [-2, -1, -3],   # mc_over_v
        [-2,  1, -4],   # mt_over_v
        [ 0, -4,  4],   # md_over_v
        [-3,  0,  2],   # ms_over_v
        [-1, -4,  1],   # mu_over_v
    ], dtype=int)

    # q_real: 3D log10 λ-vector from Toy3D geometry
    q_real = np.array([0.993782, 0.962938, -0.217602], dtype=float)

    yukawa_names = [
        "me_over_v",
        "mmu_over_v",
        "mtau_over_v",
        "mb_over_v",
        "mc_over_v",
        "mt_over_v",
        "md_over_v",
        "ms_over_v",
        "mu_over_v",
    ]

    # Complexity metrics for the original basis
    base_metrics = complexity_metrics(C_real)

    # ----------------------------------------------------------------------
    # 1. Scan unimodular basis changes U with entries in [-max_entry, max_entry]
    # ----------------------------------------------------------------------
    candidates = []

    for U in generate_unimodular_matrices(max_entry=max_entry):
        # New charge matrix
        C_prime = C_real @ U

        # Try to compute q' = (U^{-1})^T @ q_real
        try:
            U_inv = np.linalg.inv(U)
        except np.linalg.LinAlgError:
            continue  # Shouldn't happen for unimodular, but just in case

        q_prime = U_inv.T @ q_real

        # Complexity metrics
        metrics = complexity_metrics(C_prime)

        # Define a lexicographic score:
        #   1) smaller max_abs is better
        #   2) smaller l1_sum is better
        #   3) fewer distinct rows is better
        score = (
            metrics["max_abs"],
            metrics["l1_sum"],
            metrics["num_distinct_rows"],
        )

        candidates.append({
            "U": U,
            "U_det": int(round(np.linalg.det(U))),
            "C_prime": C_prime,
            "q_prime": q_prime,
            "metrics": metrics,
            "score": score,
        })

    # Sort candidates by the lexicographic score
    candidates_sorted = sorted(candidates, key=lambda d: d["score"])

    # Keep only the top_k
    top = candidates_sorted[:top_k]

    # ----------------------------------------------------------------------
    # 2. Build hash payload for reproducibility
    # ----------------------------------------------------------------------
    # To keep the payload small, only include summary of top candidates
    top_summary = []
    for entry in top:
        U = entry["U"].tolist()
        m = entry["metrics"]
        q_prime = entry["q_prime"].tolist()
        top_summary.append({
            "U": U,
            "det": entry["U_det"],
            "metrics": m,
            "q_prime": [float(x) for x in q_prime],
        })

    payload = {
        "module": "PHASE20_YUKAWA_3D_BASIS_SIMPLIFIER_v1",
        "timestamp": timestamp,
        "max_entry": max_entry,
        "base_C": C_real.tolist(),
        "base_q": q_real.tolist(),
        "base_metrics": base_metrics,
        "top_candidates": top_summary,
    }

    sha256 = hashlib.sha256(
        json.dumps(payload, sort_keys=True).encode("utf-8")
    ).hexdigest()

    # ----------------------------------------------------------------------
    # 3. Pretty-print report
    # ----------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 20 – MODULE 1: YUKAWA 3D INTEGER GEOMETRY BASIS SIMPLIFIER (v1) ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields, truncated top_candidates):")
    print(json.dumps({k: payload[k] for k in payload if k != "top_candidates"},
                     indent=2, sort_keys=True))
    print("  'top_candidates': [ ... ]  # see in-memory payload if needed")
    print()

    print("=" * 82)
    print("                    ORIGINAL 3D INTEGER GEOMETRY (BASIS 0)               ")
    print("=" * 82)
    print()
    print("C_real (9×3 integer charges):")
    for name, row in zip(yukawa_names, C_real):
        print(f"  {name:11s}  {row}")
    print()
    print(f"q_real (log10 λ): {q_real}")
    print()
    print("Charge complexity metrics (original basis):")
    print(f"  max |C_ij|           : {base_metrics['max_abs']}")
    print(f"  L1 sum of |C_ij|     : {base_metrics['l1_sum']}")
    print(f"  num non-zero entries : {base_metrics['num_nonzero']}")
    print(f"  num distinct rows    : {base_metrics['num_distinct_rows']}")
    print()

    print("=" * 82)
    print("                      TOP CANDIDATE BASES BY SIMPLICITY                   ")
    print("=" * 82)
    print()
    print("Ranking criterion:")
    print("  1) smaller max |C'_ij|,")
    print("  2) then smaller L1 sum of |C'_ij|,")
    print("  3) then fewer distinct rows.")
    print()

    header = (
        "rank  det  max|C'|  L1_sum  distinct_rows   "
        "q'_1        q'_2        q'_3"
    )
    print(header)
    print("-" * len(header))

    for idx, entry in enumerate(top, start=1):
        m = entry["metrics"]
        q_p = entry["q_prime"]
        print(
            f"{idx:4d}  {entry['U_det']:3d}  "
            f"{m['max_abs']:7d}  {m['l1_sum']:7d}  {m['num_distinct_rows']:13d}   "
            f"{q_p[0]:+10.6f}  {q_p[1]:+10.6f}  {q_p[2]:+10.6f}"
        )

    print()
    print("=" * 82)
    print("                DETAIL FOR BEST CANDIDATE BASIS (RANK 1)                  ")
    print("=" * 82)
    print()

    best = top[0]
    U_best = best["U"]
    C_prime_best = best["C_prime"]
    q_prime_best = best["q_prime"]
    m_best = best["metrics"]

    print("Best unimodular U (3×3):")
    print(U_best)
    print()
    print("Transformed charges C' = C_real @ U_best:")
    for name, row in zip(yukawa_names, C_prime_best):
        print(f"  {name:11s}  {row}")
    print()
    print(f"Transformed q' = (U_best^-1)^T @ q_real:")
    print(f"  q'_1 = {q_prime_best[0]:+0.6f}")
    print(f"  q'_2 = {q_prime_best[1]:+0.6f}")
    print(f"  q'_3 = {q_prime_best[2]:+0.6f}")
    print()
    print("Complexity metrics for best basis:")
    print(f"  max |C'_ij|           : {m_best['max_abs']}")
    print(f"  L1 sum of |C'_ij|     : {m_best['l1_sum']}")
    print(f"  num non-zero entries  : {m_best['num_nonzero']}")
    print(f"  num distinct rows     : {m_best['num_distinct_rows']}")
    print()

    print("=" * 82)
    print("                          INTERPRETATION GUIDE                             ")
    print("=" * 82)
    print()
    print("  • If the best basis has the SAME max |C'_ij| and similar L1_sum as the")
    print("    original, then the Toy3DIntegerGeometry is already in a fairly simple")
    print("    small-integer basis; there is no dramatically simpler description.")
    print()
    print("  • If you find a basis with strictly smaller max |C'_ij| or many fewer")
    print("    distinct rows, that suggests a more natural 'charge lattice' basis.")
    print()
    print("  • Look especially at q'_3:")
    print("       – If q'_3 ≈ 0 and some column of C' is small/zero, the system may")
    print("         be effectively 2D in a better-chosen basis.")
    print("       – If all three q'_i remain O(1) and C' stays complex, the 3D")
    print("         structure is genuinely 3D, not a trivial re-labeling.")
    print()
    print("This module does NOT change the global lock contract. It is a tool for")
    print("understanding the internal structure of the 3D Yukawa geometry and for")
    print("guiding future candidate model-building.")
    print()
    print("=" * 82)
    print(" PHASE20_YUKAWA_3D_BASIS_SIMPLIFIER_v1 COMPLETE ")
    print("=" * 82)
    print()

    # Export to globals for later modules if desired
    globals()["PHASE20_YUKAWA_3D_BASIS_SIMPLIFIER_RESULT"] = {
        "timestamp": timestamp,
        "sha256": sha256,
        "base_C": C_real,
        "base_q": q_real,
        "base_metrics": base_metrics,
        "top_candidates": top,
    }


# Run if executed as a script
if __name__ == "__main__":
    run_phase20_yukawa_3d_basis_simplifier(max_entry=2, top_k=10)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 20 – MODULE 2: YUKAWA 3D INTEGER GEOMETRY LOCAL NEIGHBORHOOD SCAN (v1)

Goal:
  • Start from the Toy3DIntegerGeometry (C_real, q_real).
  • Treat the basis rows (me, mtau, md) as fixed (they encode the (-4,4,3) lock).
  • For each of the OTHER 6 Yukawas, explore small integer perturbations:
        row_i' = row_i + Δ,  with Δ ∈ {-1,0,1}^3 \ {(0,0,0)},
        and |row_i'| <= C_max (here C_max = 4).
  • For each candidate C', refit q' by least squares to the real Yukawa logs.
  • Measure RMS_all(C', q') and compare to the baseline RMS_all(C_real, q_LS_real).

Interpretation:
  • If many nearby integer patterns (ΔC ≠ 0) give RMS_all almost as small as
    the baseline, then the detailed 3D integer charges for (mmu, mb, mc, mt, ms, mu)
    are NOT uniquely determined by data – there is a big degeneracy.
  • If almost no neighbors have comparable RMS, the Toy3D integer pattern
    is relatively rigid for the non-basis rows.
"""

import numpy as np
import itertools
import datetime
import json
import hashlib


def ls_fit_q(C, z):
    """
    Least-squares fit for q in z ≈ C q.
    Returns q (3,), residuals (9,), RMS_all (scalar), max_abs_resid (scalar).
    """
    C = np.asarray(C, dtype=float)
    z = np.asarray(z, dtype=float)
    # q = (C^T C)^(-1) C^T z
    CT_C = C.T @ C
    CT_z = C.T @ z
    q = np.linalg.solve(CT_C, CT_z)
    z_pred = C @ q
    resid = z_pred - z
    RMS_all = np.sqrt(np.mean(resid**2))
    max_abs_resid = np.max(np.abs(resid))
    return q, resid, float(RMS_all), float(max_abs_resid)


def run_phase20_yukawa_3d_local_neighborhood_scan(C_max=4, max_delta=1):
    # ----------------------------------------------------------------------
    # 0. Timestamp & constants
    # ----------------------------------------------------------------------
    timestamp = datetime.datetime.now().isoformat()

    # Real Yukawa logs (z = log10(y/v)), hard-coded
    # Order: [me, mmu, mtau, mb, mc, mt, md, ms, mu]
    z_real = np.array([
        -5.683401,  # me_over_v
        -3.367606,  # mmu_over_v
        -2.141781,  # mtau_over_v
        -1.770024,  # mb_over_v
        -2.287532,  # mc_over_v
        -0.154056,  # mt_over_v
        -4.722162,  # md_over_v
        -3.422873,  # ms_over_v
        -5.056852,  # mu_over_v
    ], dtype=float)

    yukawa_names = [
        "me_over_v",
        "mmu_over_v",
        "mtau_over_v",
        "mb_over_v",
        "mc_over_v",
        "mt_over_v",
        "md_over_v",
        "ms_over_v",
        "mu_over_v",
    ]

    # Toy3DIntegerGeometry C_real (from earlier phases)
    C_real = np.array([
        [-4, -2, -1],   # me_over_v
        [-1, -2,  2],   # mmu_over_v
        [-4,  1, -4],   # mtau_over_v
        [-2,  0, -1],   # mb_over_v
        [-2, -1, -3],   # mc_over_v
        [-2,  1, -4],   # mt_over_v
        [ 0, -4,  4],   # md_over_v
        [-3,  0,  2],   # ms_over_v
        [-1, -4,  1],   # mu_over_v
    ], dtype=int)

    # Rows 0,2,6 are the basis rows (me, mtau, md) encoding the (-4,4,3) lock.
    basis_indices = {0, 2, 6}
    # We will only perturb the non-basis rows:
    # indices: 1 (mmu), 3 (mb), 4 (mc), 5 (mt), 7 (ms), 8 (mu)
    perturbable_indices = [i for i in range(9) if i not in basis_indices]

    # ----------------------------------------------------------------------
    # 1. Baseline LS fit with C_real
    # ----------------------------------------------------------------------
    q_base, resid_base, RMS_base, max_resid_base = ls_fit_q(C_real, z_real)

    # ----------------------------------------------------------------------
    # 2. Generate local integer perturbations Δ ∈ {-max_delta,...,+max_delta}^3
    #    excluding (0,0,0).
    # ----------------------------------------------------------------------
    deltas = []
    for dx in range(-max_delta, max_delta + 1):
        for dy in range(-max_delta, max_delta + 1):
            for dz in range(-max_delta, max_delta + 1):
                if dx == 0 and dy == 0 and dz == 0:
                    continue
                deltas.append(np.array([dx, dy, dz], dtype=int))

    # ----------------------------------------------------------------------
    # 3. Scan single-row perturbations
    # ----------------------------------------------------------------------
    candidates = []

    for row_idx in perturbable_indices:
        base_row = C_real[row_idx].copy()
        for d in deltas:
            new_row = base_row + d
            # Enforce coefficient bound |c| <= C_max
            if np.any(np.abs(new_row) > C_max):
                continue

            # Build candidate C'
            C_candidate = C_real.copy()
            C_candidate[row_idx] = new_row

            # Fit q' by least squares
            try:
                q_cand, resid_cand, RMS_cand, max_resid_cand = ls_fit_q(
                    C_candidate, z_real
                )
            except np.linalg.LinAlgError:
                # Singular (C^T C) — skip
                continue

            candidates.append({
                "row_idx": int(row_idx),
                "row_name": yukawa_names[row_idx],
                "delta": d.copy(),
                "new_row": new_row.copy(),
                "RMS": RMS_cand,
                "max_resid": max_resid_cand,
                "q": q_cand.copy(),
            })

    # Sort candidates by RMS
    candidates_sorted = sorted(candidates, key=lambda x: x["RMS"])

    # Also include baseline as "candidate 0" for comparison
    baseline_entry = {
        "row_idx": None,
        "row_name": "baseline",
        "delta": np.array([0, 0, 0], dtype=int),
        "new_row": None,
        "RMS": RMS_base,
        "max_resid": max_resid_base,
        "q": q_base.copy(),
    }

    # ----------------------------------------------------------------------
    # 4. Basic statistics on neighborhood
    # ----------------------------------------------------------------------
    RMS_values = np.array([c["RMS"] for c in candidates_sorted], dtype=float)
    delta_RMS = RMS_values - RMS_base

    # How many neighbors are "near-degenerate"?
    # Define thresholds relative to baseline
    thr_factor_1 = 1.1   # RMS <= 1.1 * RMS_base
    thr_factor_2 = 2.0   # RMS <= 2.0 * RMS_base
    thr_abs = RMS_base + 0.002  # RMS within +0.002 dex

    near1_count = int(np.sum(RMS_values <= thr_factor_1 * RMS_base))
    near2_count = int(np.sum(RMS_values <= thr_factor_2 * RMS_base))
    near_abs_count = int(np.sum(RMS_values <= thr_abs))

    # ----------------------------------------------------------------------
    # 5. Build hash payload for reproducibility
    # ----------------------------------------------------------------------
    # Keep a compact summary of the top N candidates
    TOP_N_SUMMARY = 15
    top_summary = []
    for c in candidates_sorted[:TOP_N_SUMMARY]:
        top_summary.append({
            "row_idx": c["row_idx"],
            "row_name": c["row_name"],
            "delta": c["delta"].tolist(),
            "new_row": c["new_row"].tolist(),
            "RMS": c["RMS"],
            "max_resid": c["max_resid"],
            "q": c["q"].tolist(),
        })

    payload = {
        "module": "PHASE20_YUKAWA_3D_LOCAL_NEIGHBORHOOD_SCAN_v1",
        "timestamp": timestamp,
        "C_real": C_real.tolist(),
        "z_real": z_real.tolist(),
        "RMS_base": RMS_base,
        "max_resid_base": max_resid_base,
        "C_max": C_max,
        "max_delta": max_delta,
        "perturbable_indices": perturbable_indices,
        "num_candidates": len(candidates_sorted),
        "near_degenerate_counts": {
            "factor_1p1": near1_count,
            "factor_2p0": near2_count,
            "abs_plus_0p002": near_abs_count,
        },
        "top_candidates": top_summary,
    }

    sha256 = hashlib.sha256(
        json.dumps(payload, sort_keys=True).encode("utf-8")
    ).hexdigest()

    # ----------------------------------------------------------------------
    # 6. Print report
    # ----------------------------------------------------------------------
    print("=" * 82)
    print(" PHASE 20 – MODULE 2: YUKAWA 3D INTEGER GEOMETRY LOCAL NEIGHBORHOOD SCAN ")
    print("                                   (v1)                                    ")
    print("=" * 82)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields, top_candidates truncated):")
    compact = {k: payload[k] for k in payload if k not in ("top_candidates",)}
    print(json.dumps(compact, indent=2, sort_keys=True))
    print("  'top_candidates': [ ... ]")
    print()

    print("=" * 82)
    print("                      BASELINE 3D INTEGER GEOMETRY                          ")
    print("=" * 82)
    print()
    print("C_real (9×3 integer charges):")
    for name, row in zip(yukawa_names, C_real):
        print(f"  {name:11s}  {row}")
    print()
    print(f"Least-squares q_base (log10 λ): {q_base}")
    print(f"Baseline RMS_all (dex)        : {RMS_base: .6f}")
    print(f"Baseline max |resid| (dex)    : {max_resid_base: .6f}")
    print()
    print("Basis rows held fixed (encode (-4,4,3) lock):")
    for idx in sorted(basis_indices):
        print(f"  idx {idx} : {yukawa_names[idx]}  row = {C_real[idx]}")
    print()
    print("Perturbable rows (single-row Δ ∈ {-1,0,1}^3, |c|≤C_max):")
    for idx in perturbable_indices:
        print(f"  idx {idx} : {yukawa_names[idx]}  row = {C_real[idx]}")
    print()

    print("=" * 82)
    print("                     NEIGHBORHOOD SCAN SUMMARY (SINGLE-ROW)                 ")
    print("=" * 82)
    print()
    print(f"Coefficient bound C_max           : {C_max}")
    print(f"Max Δ per component (±max_delta) : {max_delta}")
    print(f"Total candidate C' tested         : {len(candidates_sorted)}")
    print()
    print("Near-degenerate neighbors (based on RMS_all):")
    print(f"  RMS <= 1.10 × RMS_base  : {near1_count:5d} candidates")
    print(f"  RMS <= 2.00 × RMS_base  : {near2_count:5d} candidates")
    print(f"  RMS <= RMS_base + 0.002 : {near_abs_count:5d} candidates")
    print()

    print("=" * 82)
    print("                       TOP LOCAL NEIGHBORS BY RMS_all                       ")
    print("=" * 82)
    print()
    header = (
        "rank  row  name         Δ(c1,c2,c3)   new_row       RMS_all   ΔRMS    max|resid|"
    )
    print(header)
    print("-" * len(header))

    # Show baseline as rank 0
    print(
        f"{0:4d}  {'-':>3s}  {'baseline':11s}  "
        f"{'(0,0,0)':>11s}   {'-':>9s}   {RMS_base: .6f}   "
        f"{0.0: .6f}   {max_resid_base: .6f}"
    )

    for rank, c in enumerate(candidates_sorted[:15], start=1):
        d = c["delta"]
        new_row = c["new_row"]
        dRMS = c["RMS"] - RMS_base
        print(
            f"{rank:4d}  {c['row_idx']:3d}  {c['row_name']:11s}  "
            f"({d[0]:+2d},{d[1]:+2d},{d[2]:+2d})   "
            f"[{new_row[0]:+2d},{new_row[1]:+2d},{new_row[2]:+2d}]   "
            f"{c['RMS']: .6f}  {dRMS: .6f}   {c['max_resid']: .6f}"
        )

    print()
    print("=" * 82)
    print("                          INTERPRETATION GUIDE                              ")
    print("=" * 82)
    print()
    print("  • This module keeps the me/mtau/md basis rows fixed (to preserve the")
    print("    (-4,4,3) triple) and explores small ±1 perturbations to the other")
    print("    six Yukawa charge rows within |c| <= C_max.")
    print()
    print("  • If MANY candidates have RMS_all only slightly above the baseline")
    print("    (e.g. within 10% or within +0.002 dex), then the detailed 3D")
    print("    integer pattern for (mmu, mb, mc, mt, ms, mu) is highly degenerate:")
    print("    lots of nearby integer choices fit almost as well.")
    print()
    print("  • If only a handful of neighbors are that good (or none), the Toy3D")
    print("    integer pattern is relatively rigid given the data and the chosen")
    print("    3D framework with the (-4,4,3) basis fixed.")
    print()
    print("  • This is a STRUCTURAL diagnostic, not new evidence: it does NOT")
    print("    change the global lock contract. It tells you how sharply the 3D")
    print("    integer geometry is selected by the Yukawa data once the primary")
    print("    triple is enforced.")
    print()
    print("=" * 82)
    print(" PHASE20_YUKAWA_3D_LOCAL_NEIGHBORHOOD_SCAN_v1 COMPLETE ")
    print("=" * 82)
    print()

    # Export to globals for later use if desired
    globals()["PHASE20_YUKAWA_3D_LOCAL_NEIGHBORHOOD_RESULT"] = {
        "timestamp": timestamp,
        "sha256": sha256,
        "baseline": baseline_entry,
        "candidates_sorted": candidates_sorted,
        "payload": payload,
    }


# Run if executed as a script
if __name__ == "__main__":
    run_phase20_yukawa_3d_local_neighborhood_scan(C_max=4, max_delta=1)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 20 – MODULE 3: YUKAWA 3D LOCAL NEIGHBORHOOD EVIDENCE (v1)

Goal:
  • Consume the results from PHASE20_YUKAWA_3D_LOCAL_NEIGHBORHOOD_SCAN_v1.
  • Quantify how isolated the Toy3D integer pattern is under small ±1
    single-row perturbations (with basis rows fixed).
  • Classify this as SHAPE-ONLY information: it does NOT change the
    global lock contract; it only tells us how rigid the 3D integer
    pattern is, given the (-4,4,3) triple and 3D ansatz.
"""

import datetime
import json
import hashlib
import math


def run_phase20_yukawa_3d_neighborhood_evidence_v1():
    # ------------------------------------------------------------------
    # 0. Pull neighborhood scan result from globals
    # ------------------------------------------------------------------
    if "PHASE20_YUKAWA_3D_LOCAL_NEIGHBORHOOD_RESULT" not in globals():
        print("=" * 80)
        print(" PHASE 20 – MODULE 3: YUKAWA 3D LOCAL NEIGHBORHOOD EVIDENCE (v1) ")
        print("=" * 80)
        print()
        print("ERROR: PHASE20_YUKAWA_3D_LOCAL_NEIGHBORHOOD_RESULT not found.")
        print("       Please run PHASE20_YUKAWA_3D_LOCAL_NEIGHBORHOOD_SCAN_v1 first.")
        print()
        return

    res = globals()["PHASE20_YUKAWA_3D_LOCAL_NEIGHBORHOOD_RESULT"]
    payload_scan = res["payload"]
    baseline = res["baseline"]

    timestamp = datetime.datetime.now().isoformat()

    RMS_base = payload_scan["RMS_base"]
    num_candidates = payload_scan["num_candidates"]
    near_counts = payload_scan["near_degenerate_counts"]

    near_1p1 = near_counts["factor_1p1"]
    near_2p0 = near_counts["factor_2p0"]
    near_abs = near_counts["abs_plus_0p002"]

    frac_1p1 = near_1p1 / num_candidates if num_candidates > 0 else 0.0
    frac_2p0 = near_2p0 / num_candidates if num_candidates > 0 else 0.0
    frac_abs = near_abs / num_candidates if num_candidates > 0 else 0.0

    # Heuristic classification of local rigidity (no p-values here)
    # We just tag it qualitatively.
    if near_1p1 == 0 and near_abs == 0 and near_2p0 <= 5:
        rigidity_label = "highly_rigid_local_pattern"
        rigidity_note = (
            "Very few single-row ±1 perturbations keep RMS_all within even 2× "
            "the baseline; the Toy3D integer pattern is locally isolated."
        )
    elif near_1p1 <= 0.1 * num_candidates and near_abs <= 0.1 * num_candidates:
        rigidity_label = "moderately_rigid_local_pattern"
        rigidity_note = (
            "Some nearby integer patterns fit almost as well, but the baseline "
            "pattern is still relatively special in its local neighborhood."
        )
    else:
        rigidity_label = "highly_degenerate_local_pattern"
        rigidity_note = (
            "Many nearby integer patterns fit almost as well; the detailed rows "
            "for non-basis Yukawas are strongly degenerate."
        )

    # This is NOT a statistical lock, so bits=0 by construction.
    bits = 0.0

    # ------------------------------------------------------------------
    # 1. Build hash payload
    # ------------------------------------------------------------------
    hash_payload = {
        "module": "PHASE20_YUKAWA_3D_LOCAL_NEIGHBORHOOD_EVIDENCE_v1",
        "timestamp": timestamp,
        "RMS_base": RMS_base,
        "num_candidates": num_candidates,
        "near_degenerate_counts": near_counts,
        "fractions": {
            "factor_1p1": frac_1p1,
            "factor_2p0": frac_2p0,
            "abs_plus_0p002": frac_abs,
        },
        "rigidity_label": rigidity_label,
        "rigidity_note": rigidity_note,
        "bits": bits,
    }

    sha256 = hashlib.sha256(
        json.dumps(hash_payload, sort_keys=True).encode("utf-8")
    ).hexdigest()

    # ------------------------------------------------------------------
    # 2. Pretty print report
    # ------------------------------------------------------------------
    print("=" * 80)
    print(" PHASE 20 – MODULE 3: YUKAWA 3D LOCAL NEIGHBORHOOD EVIDENCE (v1) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print()
    print("Hash payload (key fields):")
    print(json.dumps(hash_payload, indent=2, sort_keys=True))
    print()

    print("=" * 80)
    print("                    INPUT RECAP FROM NEIGHBORHOOD SCAN                 ")
    print("=" * 80)
    print()
    print(f"Baseline RMS_all (dex)         : {RMS_base: .6e}")
    print(f"Total candidate C' tested      : {num_candidates}")
    print()
    print("Near-degenerate counts (single-row ±1, |c|≤C_max):")
    print(f"  RMS <= 1.10 × RMS_base       : {near_1p1:5d}  "
          f"({frac_1p1: .3f} of candidates)")
    print(f"  RMS <= 2.00 × RMS_base       : {near_2p0:5d}  "
          f"({frac_2p0: .3f} of candidates)")
    print(f"  RMS <= RMS_base + 0.002 dex  : {near_abs:5d}  "
          f"({frac_abs: .3f} of candidates)")
    print()

    print("=" * 80)
    print("                         QUALITATIVE CLASSIFICATION                     ")
    print("=" * 80)
    print()
    print(f"  Local rigidity label : {rigidity_label}")
    print(f"  Bits assigned        : {bits:.2f} (by design: structural only, no lock)")
    print()
    print("  Interpretation:")
    print(f"    {rigidity_note}")
    print()
    print("  Conceptual status:")
    print("    • This module does NOT introduce any new p-value or bits.")
    print("    • It only describes how isolated the Toy3D integer pattern is under")
    print("      small ±1 perturbations of the non-basis Yukawa rows, given the")
    print("      3D integer-geometry ansatz and the fixed (-4,4,3) basis.")
    print("    • The global lock contract (DNA + me–mtau–md triple, ~20–27 bits)")
    print("      remains unchanged.")
    print()

    print("=" * 80)
    print("                    GEOM_EVIDENCE UPDATE (IN-MEMORY)                    ")
    print("=" * 80)
    print()

    # ------------------------------------------------------------------
    # 3. Update GEOM_EVIDENCE in-memory
    # ------------------------------------------------------------------
    if "GEOM_EVIDENCE" not in globals():
        globals()["GEOM_EVIDENCE"] = {}
        print("GEOM_EVIDENCE not found; creating new GEOM_EVIDENCE dict.")

    GEOM_EVIDENCE = globals()["GEOM_EVIDENCE"]

    GEOM_EVIDENCE["yukawa_3d_local_neighborhood"] = {
        "RMS_base": RMS_base,
        "num_candidates": num_candidates,
        "near_degenerate_counts": near_counts,
        "fractions": {
            "factor_1p1": frac_1p1,
            "factor_2p0": frac_2p0,
            "abs_plus_0p002": frac_abs,
        },
        "rigidity_label": rigidity_label,
        "rigidity_note": rigidity_note,
        "bits": bits,
        "timestamp": timestamp,
        "sha256": sha256,
        "status": "supporting_structure_shape",
        "description": (
            "Local neighborhood scan of Toy3D integer geometry (single-row ±1 "
            "perturbations with basis rows fixed). Very few neighbors are as "
            "good as the baseline; indicates a relatively isolated 3D integer "
            "pattern conditional on the (-4,4,3) lock, but no new statistical "
            "lock (bits=0)."
        ),
    }

    print("GEOM_EVIDENCE['yukawa_3d_local_neighborhood'] =")
    print(json.dumps(GEOM_EVIDENCE["yukawa_3d_local_neighborhood"],
                     indent=2, sort_keys=True))
    print()
    print("=" * 80)
    print(" PHASE20_YUKAWA_3D_LOCAL_NEIGHBORHOOD_EVIDENCE_v1 COMPLETE ")
    print("=" * 80)
    print()


# Run if executed as a script
if __name__ == "__main__":
    run_phase20_yukawa_3d_neighborhood_evidence_v1()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PHASE 21 – MODULE 1: GLOBAL GEOMETRY HYPOTHESIS SCOREBOARD (v1)

Goal:
  • Take GLOBAL_LOCKS_BLUEPRINT (v4) as the contract.
  • Provide a standard way to register geometry hypotheses
    and score them against the DNA + Yukawa triple locks.
  • Print loud scorecards and store results in a global dict
    GEOMETRY_SCORECARDS for later comparison.

Notes:
  • This module does NOT change the lock contract.
  • All 2D/3D Yukawa geometries, q-relations, etc. are treated
    as supporting shape only (bits=0 unless they actually claim
    to explain a primary lock).
"""

import datetime
import json
import hashlib


def _get_global_locks_blueprint():
    # Try to find the v4-style blueprint
    if "GLOBAL_LOCKS_BLUEPRINT" in globals():
        return globals()["GLOBAL_LOCKS_BLUEPRINT"]
    if "GLOBAL_LOCKS_v4" in globals():
        return globals()["GLOBAL_LOCKS_v4"]

    print("=" * 80)
    print(" PHASE 21 – MODULE 1: GLOBAL GEOMETRY HYPOTHESIS SCOREBOARD (v1) ")
    print("=" * 80)
    print()
    print("ERROR: Could not find GLOBAL_LOCKS_BLUEPRINT or GLOBAL_LOCKS_v4.")
    print("       Please run your latest GLOBAL GEOMETRY EVIDENCE module (v4)")
    print("       before this one.")
    print()
    return None


def score_geometry_hypothesis(name,
                              description,
                              explains_dna_backbone=False,
                              explains_yukawa_triple=False,
                              tuning_penalty_bits=0.0,
                              blueprint=None):
    """
    Compute conservative and optimistic bits for a geometry hypothesis.

    Inputs:
      name  : string label for the geometry.
      description : short human-readable description.
      explains_dna_backbone : bool, claims DNA lock.
      explains_yukawa_triple: bool, claims me–mtau–md (-4,4,3) triple.
      tuning_penalty_bits   : float >= 0; bits to subtract for tuning.

    blueprint:
      GLOBAL_LOCKS_BLUEPRINT or GLOBAL_LOCKS_v4 dict.
    """
    dna_bits = 0.0
    yukawa_bits_cons = 0.0
    yukawa_bits_opt = 0.0

    # Extract lock bits from blueprint
    dna_lock = blueprint["dna"]
    y_lock  = blueprint["yukawa"]["triple_me_tau_d"]

    dna_effective_bits = dna_lock["effective_bits"]
    yukawa_bits_global = y_lock["bits_global_error_model"]
    yukawa_bits_fixed  = y_lock["bits_fixed_error_model"]

    if explains_dna_backbone:
        dna_bits = dna_effective_bits

    if explains_yukawa_triple:
        yukawa_bits_cons = yukawa_bits_global
        yukawa_bits_opt  = yukawa_bits_fixed

    # Apply tuning penalty to both totals
    total_cons = dna_bits + yukawa_bits_cons - tuning_penalty_bits
    total_opt  = dna_bits + yukawa_bits_opt  - tuning_penalty_bits

    # Clip to zero if someone overshoots with penalty
    total_cons = max(0.0, total_cons)
    total_opt  = max(0.0, total_opt)

    return {
        "name": name,
        "description": description,
        "explains_dna_backbone": bool(explains_dna_backbone),
        "explains_yukawa_triple": bool(explains_yukawa_triple),
        "tuning_penalty_bits": float(tuning_penalty_bits),
        "dna_bits": float(dna_bits),
        "yukawa_bits_conservative": float(yukawa_bits_cons),
        "yukawa_bits_optimistic": float(yukawa_bits_opt),
        "total_bits_conservative": float(total_cons),
        "total_bits_optimistic": float(total_opt),
    }


def run_phase21_global_geometry_scoreboard_v1():
    blueprint = _get_global_locks_blueprint()
    if blueprint is None:
        return

    timestamp = datetime.datetime.now().isoformat()

    # Compute a SHA over the blueprint (for bookkeeping)
    blueprint_sha = hashlib.sha256(
        json.dumps(blueprint, sort_keys=True).encode("utf-8")
    ).hexdigest()

    # ------------------------------------------------------------------
    # 1. Define a small default registry of geometries
    #    (You can extend this by editing GEOMETRY_REGISTRY if you like.)
    # ------------------------------------------------------------------
    GEOMETRY_REGISTRY = [
        {
            "name": "NullGeometry",
            "description": (
                "Random / structureless geometry; predicts nothing and "
                "explains no locks."
            ),
            "explains_dna_backbone": False,
            "explains_yukawa_triple": False,
            "tuning_penalty_bits": 0.0,
        },
        {
            "name": "PerfectLockGeometry",
            "description": (
                "Hypothetical geometry that derives BOTH primary locks from "
                "its structure without tuning: DNA backbone/locks AND the "
                "me–mtau–md (-4,4,3) triple."
            ),
            "explains_dna_backbone": True,
            "explains_yukawa_triple": True,
            "tuning_penalty_bits": 0.0,
        },
        {
            "name": "Toy3DIntegerGeometry_v1",
            "description": (
                "Concrete toy geometry based on the best 3D small-integer "
                "Yukawa fit. By construction it nails the (-4,4,3) triple "
                "and fits all 9 Yukawas with RMS≈0.0062 dex. It does NOT "
                "attempt to explain the DNA backbone."
            ),
            "explains_dna_backbone": False,
            "explains_yukawa_triple": True,
            "tuning_penalty_bits": 0.0,
        },
    ]

    # Score each geometry
    scorecards = []
    for g in GEOMETRY_REGISTRY:
        sc = score_geometry_hypothesis(
            name=g["name"],
            description=g["description"],
            explains_dna_backbone=g["explains_dna_backbone"],
            explains_yukawa_triple=g["explains_yukawa_triple"],
            tuning_penalty_bits=g["tuning_penalty_bits"],
            blueprint=blueprint,
        )
        scorecards.append(sc)

    # For hashing: store just essential info
    hash_payload = {
        "module": "PHASE21_GLOBAL_GEOMETRY_SCOREBOARD_v1",
        "timestamp": timestamp,
        "blueprint_sha256": blueprint_sha,
        "scorecards": scorecards,
    }
    sha256 = hashlib.sha256(
        json.dumps(hash_payload, sort_keys=True).encode("utf-8")
    ).hexdigest()

    # ------------------------------------------------------------------
    # 2. Pretty print global header
    # ------------------------------------------------------------------
    print("=" * 80)
    print(" PHASE 21 – MODULE 1: GLOBAL GEOMETRY HYPOTHESIS SCOREBOARD (v1) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha256}")
    print(f"Blueprint SHA256      : {blueprint_sha}")
    print()
    print("Hash payload (key fields):")
    print(json.dumps(hash_payload, indent=2, sort_keys=True))
    print()

    # ------------------------------------------------------------------
    # 3. Print contract recap
    # ------------------------------------------------------------------
    print("=" * 80)
    print("                         GLOBAL LOCK CONTRACT (v4)                   ")
    print("=" * 80)
    print()
    dna_bits = blueprint["dna"]["effective_bits"]
    y_bits_cons = blueprint["yukawa"]["triple_me_tau_d"]["bits_global_error_model"]
    y_bits_opt  = blueprint["yukawa"]["triple_me_tau_d"]["bits_fixed_error_model"]
    comb_cons   = blueprint["combined"]["bits_conservative"]
    comb_opt    = blueprint["combined"]["bits_optimistic"]

    print(f"DNA effective bits                 : {dna_bits:5.2f}")
    print(f"Yukawa triple bits (conservative)  : {y_bits_cons:5.2f}")
    print(f"Yukawa triple bits (optimistic)    : {y_bits_opt:5.2f}")
    print(f"→ Combined (conservative)          : {comb_cons:5.2f} bits")
    print(f"→ Combined (optimistic)            : {comb_opt:5.2f} bits")
    print()
    print("Any serious geometry must explain ~these bits WITHOUT tuning.")
    print()

    # ------------------------------------------------------------------
    # 4. Print per-geometry scorecards
    # ------------------------------------------------------------------
    for sc in scorecards:
        print("=" * 80)
        print(f" GEOMETRY SCORECARD – {sc['name']} ")
        print("=" * 80)
        print()
        print("Description:")
        print(f"  {sc['description']}")
        print()
        print("Lock claims:")
        print(f"  • explains_dna_backbone   : {sc['explains_dna_backbone']}")
        print(f"  • explains_yukawa_triple  : {sc['explains_yukawa_triple']}")
        print(f"  • tuning_penalty_bits     : {sc['tuning_penalty_bits']:.2f}")
        print()
        print("Bits earned (relative to GLOBAL_LOCKS_BLUEPRINT v4):")
        print(f"  DNA sector bits           : {sc['dna_bits']:5.2f}")
        print(
            f"  Yukawa bits (conservative): "
            f"{sc['yukawa_bits_conservative']:5.2f}"
        )
        print(
            f"  Yukawa bits (optimistic)  : "
            f"{sc['yukawa_bits_optimistic']:5.2f}"
        )
        print(f"  Tuning penalty            : {sc['tuning_penalty_bits']:5.2f}")
        print()
        print(
            f"  → Total (conservative)    : "
            f"{sc['total_bits_conservative']:5.2f} bits"
        )
        print(
            f"  → Total (optimistic)      : "
            f"{sc['total_bits_optimistic']:5.2f} bits"
        )
        print()

    # ------------------------------------------------------------------
    # 5. Store in global dict for later use
    # ------------------------------------------------------------------
    if "GEOMETRY_SCORECARDS" not in globals():
        globals()["GEOMETRY_SCORECARDS"] = {}

    GEOMETRY_SCORECARDS = globals()["GEOMETRY_SCORECARDS"]
    for sc in scorecards:
        GEOMETRY_SCORECARDS[sc["name"]] = {
            "scorecard": sc,
            "timestamp": timestamp,
            "blueprint_sha256": blueprint_sha,
            "run_sha256": sha256,
        }

    print("=" * 80)
    print(" GEOMETRY_SCORECARDS updated with:")
    print("   " + ", ".join([sc["name"] for sc in scorecards]))
    print("=" * 80)
    print()
    print("PHASE21_GLOBAL_GEOMETRY_SCOREBOARD_v1 COMPLETE")
    print("=" * 80)
    print()


# Run if executed as a script
if __name__ == "__main__":
    run_phase21_global_geometry_scoreboard_v1()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PHASE 22 – MODULE 1 (v2): EXTERNAL GEOMETRY ADAPTER & SCORECARD

Fix vs v1:
  • GEOMETRY_SCORECARDS in this notebook turned out to be a *dict*, not a list.
  • v2 no longer assumes a list; it will:
       - if dict  → store as GEOMETRY_SCORECARDS[name] = scorecard
       - if list  → GEOMETRY_SCORECARDS.append(scorecard)
  • This keeps compatibility with previous phases and avoids AttributeError.
"""

import json
import hashlib
from datetime import datetime

# =============================================================================
# Utility: canonical SHA256 over a JSON-serializable payload
# =============================================================================

def _canonical_sha256(payload) -> str:
    s = json.dumps(payload, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


# =============================================================================
# Ensure GLOBAL_LOCKS_v4 exists (fallback to minimal default if needed)
# =============================================================================

try:
    GLOBAL_LOCKS_v4  # type: ignore[name-defined]
except NameError:
    GLOBAL_LOCKS_v4 = {
        "dna": {
            "effective_bits": 12.29,
            "sector": "DNA",
            "status": "primary_lock",
            "description": (
                "DNA backbone + lock-family structure + all-four-zero rows; "
                "multi-10-bit anomaly under harsh nulls. This is one full sector-level lock."
            ),
        },
        "yukawa": {
            "triple_me_tau_d": {
                "bits_global_error_model": 7.48,
                "bits_fixed_error_model": 14.29,
                "sector": "Yukawa",
                "subsector": "me_mtau_md_triple",
                "status": "primary_lock",
                "description": (
                    "me–mtau–md (-4,4,3) triple in log10(y/v); ≈7.5 bits when treated as "
                    "best global 3-term relation under an error-model null, and ≈14.3 bits "
                    "when treated as a fixed triple under realistic errors."
                ),
            },
            "supporting": {},
        },
        "combined": {
            "bits_conservative": 19.77,
            "bits_optimistic": 26.58,
            "status": "global_contract",
            "description": (
                "Total bits any future geometry must explain without cheating: DNA backbone/locks "
                "(~12 bits) plus the me–mtau–md (-4,4,3) Yukawa triple (7–14 bits depending on how "
                "we count). All 2D/3D Yukawa geometries, q-relations, and secondary triples are "
                "treated as supporting shape, not extra bits."
            ),
        },
    }


# =============================================================================
# Ensure GEOMETRY_SCORECARDS exists; allow dict OR list
# =============================================================================

try:
    GEOMETRY_SCORECARDS  # type: ignore[name-defined]
except NameError:
    # Start with a dict keyed by geometry name
    GEOMETRY_SCORECARDS = {}


# =============================================================================
# Core scoring function
# =============================================================================

def score_geometry_hypothesis(
    name: str,
    description: str,
    explains_dna_backbone: bool,
    explains_yukawa_triple: bool,
    tuning_penalty_bits: float = 0.0,
    locks_blueprint=None,
):
    """
    Compute a scorecard for a geometry hypothesis relative to GLOBAL_LOCKS_v4.
    """
    if locks_blueprint is None:
        locks_blueprint = GLOBAL_LOCKS_v4

    dna_bits_full = locks_blueprint["dna"]["effective_bits"]
    yukawa_bits_conservative_full = locks_blueprint["yukawa"]["triple_me_tau_d"]["bits_global_error_model"]
    yukawa_bits_optimistic_full = locks_blueprint["yukawa"]["triple_me_tau_d"]["bits_fixed_error_model"]

    dna_bits = dna_bits_full if explains_dna_backbone else 0.0
    yukawa_bits_conservative = yukawa_bits_conservative_full if explains_yukawa_triple else 0.0
    yukawa_bits_optimistic = yukawa_bits_optimistic_full if explains_yukawa_triple else 0.0

    total_conservative = dna_bits + yukawa_bits_conservative - tuning_penalty_bits
    total_optimistic = dna_bits + yukawa_bits_optimistic - tuning_penalty_bits

    total_conservative = max(0.0, total_conservative)
    total_optimistic = max(0.0, total_optimistic)

    scorecard = {
        "name": name,
        "description": description,
        "explains_dna_backbone": bool(explains_dna_backbone),
        "explains_yukawa_triple": bool(explains_yukawa_triple),
        "dna_bits": dna_bits,
        "yukawa_bits_conservative": yukawa_bits_conservative,
        "yukawa_bits_optimistic": yukawa_bits_optimistic,
        "tuning_penalty_bits": tuning_penalty_bits,
        "total_bits_conservative": total_conservative,
        "total_bits_optimistic": total_optimistic,
    }

    return scorecard


# =============================================================================
# Pretty-printing of scorecards
# =============================================================================

def print_geometry_scorecard(scorecard: dict, blueprint_sha256: str | None = None):
    """
    Pretty-print a single geometry scorecard with banners, timestamp, SHA.
    """
    timestamp = datetime.now().isoformat()
    payload = {
        "scorecard": scorecard,
        "timestamp": timestamp,
        "blueprint_sha256": blueprint_sha256,
        "module": "PHASE22_GEOMETRY_ADAPTER_v2",
    }
    sha = _canonical_sha256(payload)

    name = scorecard["name"]
    desc = scorecard["description"]
    dna_bits = scorecard["dna_bits"]
    y_bits_c = scorecard["yukawa_bits_conservative"]
    y_bits_o = scorecard["yukawa_bits_optimistic"]
    tuning = scorecard["tuning_penalty_bits"]
    t_c = scorecard["total_bits_conservative"]
    t_o = scorecard["total_bits_optimistic"]

    explains_dna = scorecard["explains_dna_backbone"]
    explains_yuk = scorecard["explains_yukawa_triple"]

    print("=" * 80)
    print(f" PHASE 22 – GEOMETRY SCORECARD: {name} ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha}")
    if blueprint_sha256 is not None:
        print(f"Blueprint SHA256      : {blueprint_sha256}")
    print()
    print("Description:")
    print(f"  {desc}")
    print()
    print("Lock claims:")
    print(f"  • explains_dna_backbone   : {explains_dna}")
    print(f"  • explains_yukawa_triple  : {explains_yuk}")
    print(f"  • tuning_penalty_bits     : {tuning:0.2f}")
    print()
    print("Bits earned (relative to GLOBAL_LOCKS_BLUEPRINT v4):")
    print(f"  DNA sector bits           : {dna_bits:6.2f}")
    print(f"  Yukawa bits (conservative): {y_bits_c:6.2f}")
    print(f"  Yukawa bits (optimistic)  : {y_bits_o:6.2f}")
    print(f"  Tuning penalty            : {tuning:6.2f}")
    print()
    print(f"  → Total (conservative)    : {t_c:6.2f} bits")
    print(f"  → Total (optimistic)      : {t_o:6.2f} bits")
    print()
    print("=" * 80)
    print()


# =============================================================================
# Public helper: register geometry + store into GEOMETRY_SCORECARDS (dict or list)
# =============================================================================

def register_geometry_hypothesis(
    name: str,
    description: str,
    explains_dna_backbone: bool,
    explains_yukawa_triple: bool,
    tuning_penalty_bits: float = 0.0,
    metadata: dict | None = None,
):
    """
    Register a geometry hypothesis, score it, store in GEOMETRY_SCORECARDS
    (dict or list), and print a scorecard banner.
    """
    global GEOMETRY_SCORECARDS

    scorecard = score_geometry_hypothesis(
        name=name,
        description=description,
        explains_dna_backbone=explains_dna_backbone,
        explains_yukawa_triple=explains_yukawa_triple,
        tuning_penalty_bits=tuning_penalty_bits,
        locks_blueprint=GLOBAL_LOCKS_v4,
    )

    if metadata is not None:
        scorecard["metadata"] = metadata

    # Store depending on existing type
    if isinstance(GEOMETRY_SCORECARDS, dict):
        GEOMETRY_SCORECARDS[name] = scorecard
    elif isinstance(GEOMETRY_SCORECARDS, list):
        GEOMETRY_SCORECARDS.append(scorecard)
    else:
        # Fallback: convert to dict
        GEOMETRY_SCORECARDS = {name: scorecard}

    blueprint_sha = _canonical_sha256({"GLOBAL_LOCKS_v4": GLOBAL_LOCKS_v4})
    print_geometry_scorecard(scorecard, blueprint_sha256=blueprint_sha)

    return scorecard


# =============================================================================
# Demo runner for this module
# =============================================================================

def run_phase22_geometry_adapter_demo():
    """
    Demo:
      • Prints global lock contract (from GLOBAL_LOCKS_v4).
      • Registers a sample 'DNAOnlyGeometry' and prints its scorecard.
      • Leaves everything in GEOMETRY_SCORECARDS for later use.
    """
    timestamp = datetime.now().isoformat()
    blueprint_sha = _canonical_sha256({"GLOBAL_LOCKS_v4": GLOBAL_LOCKS_v4})

    print("=" * 80)
    print(" PHASE 22 – MODULE 1 (v2): EXTERNAL GEOMETRY ADAPTER & SCORECARD ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Blueprint SHA256      : {blueprint_sha}")
    print()
    print("GLOBAL LOCK CONTRACT (from GLOBAL_LOCKS_v4):")
    dna_bits = GLOBAL_LOCKS_v4["dna"]["effective_bits"]
    y_bits_c = GLOBAL_LOCKS_v4["yukawa"]["triple_me_tau_d"]["bits_global_error_model"]
    y_bits_o = GLOBAL_LOCKS_v4["yukawa"]["triple_me_tau_d"]["bits_fixed_error_model"]
    print(f"  DNA effective bits                 : {dna_bits:5.2f}")
    print(f"  Yukawa triple bits (conservative)  : {y_bits_c:5.2f}")
    print(f"  Yukawa triple bits (optimistic)    : {y_bits_o:5.2f}")
    print(f"    → Combined (conservative)        : {dna_bits + y_bits_c:5.2f} bits")
    print(f"    → Combined (optimistic)          : {dna_bits + y_bits_o:5.2f} bits")
    print()
    print("Now registering a demo geometry: 'DNAOnlyGeometry'")
    print("  (claims: explains DNA backbone, does NOT explain Yukawa triple)")
    print()

    demo_description = (
        "Hypothetical geometry that fully explains the DNA backbone/lock structure "
        "but leaves Yukawa masses untouched. This is ONLY a demo for the adapter."
    )

    register_geometry_hypothesis(
        name="DNAOnlyGeometry",
        description=demo_description,
        explains_dna_backbone=True,
        explains_yukawa_triple=False,
        tuning_penalty_bits=0.0,
        metadata={"kind": "demo", "phase": 22},
    )

    try:
        n_entries = len(GEOMETRY_SCORECARDS)
    except TypeError:
        n_entries = "unknown"

    print(f"GEOMETRY_SCORECARDS currently has {n_entries} entries.")
    print()
    print("=" * 80)
    print(" PHASE22_GEOMETRY_ADAPTER_v2 COMPLETE ")
    print("=" * 80)
    print()


# Run the demo automatically if executed as a script
if __name__ == "__main__":
    run_phase22_geometry_adapter_demo()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

r"""
PHASE 23 – MODULE 1: FN-COMPATIBLE BASIS SEARCH FOR TOY 3D YUKAWA GEOMETRY (v1)

Goal:
  Starting from the Toy3DIntegerGeometry (9×3 integer charges C_real and q_real),
  search for a unimodular integer basis change U (det(U)=±1, entries in {-1,0,1})
  such that in the transformed basis:

     C' = C_real @ U        (new integer charges)
     q' = (U^{-1})^T @ q    (new log10 λ-vector)

  the following FN-style "physical" conditions hold:

    (FN1) All spurions are sub-unity:     q'_j < 0  for all j   (λ_j < 1)
    (FN2) All charges are non-negative:   C'_{ij} ≥ 0 for all i,j
    (FN3) Each spurion is actually used:  max_i C'_{ij} > 0 for each column j

  If such a basis exists with a small unimodular U (entries ∈ {-1,0,1}),
  then the Toy3D geometry can be interpreted as a clean 3-spurion FN model.
  If NONE exist in this search, that's evidence that Toy3D is not a simple
  FN geometry with 3 spurions and non-negative charges.

This module:
  • Reconstructs C_real and q_real (from earlier Toy3DIntegerGeometry).
  • Enumerates all integer 3×3 matrices U with entries in {-1,0,1} and det(U)=±1.
  • For each U, computes C', q' and tests FN conditions.
  • Prints the top few FN-compatible bases (if any), ranked by charge simplicity.
  • If none are found, reports that explicitly.

No new p-values or bits are introduced here; this is structural guidance ONLY.
"""

import numpy as np
import json
import hashlib
from datetime import datetime
from itertools import product

# =============================================================================
# Utility: canonical SHA256 over a JSON-serializable payload
# =============================================================================

def _canonical_sha256(payload) -> str:
    s = json.dumps(payload, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


# =============================================================================
# Reconstruct the Toy3D integer geometry (C_real, q_real)
# =============================================================================

def get_toy3d_geometry():
    """
    Return C_real (9×3) and q_real (3,) for the Toy3DIntegerGeometry.

    We use the fixed-q least-squares fit from PHASE 20 neighborhood scan:
      q_real ≈ (0.99546434, 0.96078513, -0.22005041)
    and the 9×3 charge matrix C_real used throughout phases 17–20.
    """
    # 9×3 integer charge matrix
    C_real = np.array(
        [
            [-4, -2, -1],  # me_over_v
            [-1, -2,  2],  # mmu_over_v
            [-4,  1, -4],  # mtau_over_v
            [-2,  0, -1],  # mb_over_v
            [-2, -1, -3],  # mc_over_v
            [-2,  1, -4],  # mt_over_v
            [ 0, -4,  4],  # md_over_v
            [-3,  0,  2],  # ms_over_v
            [-1, -4,  1],  # mu_over_v
        ],
        dtype=int,
    )

    # log10 λ vector from fixed-q refit (PHASE 20)
    q_real = np.array([0.99546434, 0.96078513, -0.22005041], dtype=float)

    names = [
        "me_over_v",
        "mmu_over_v",
        "mtau_over_v",
        "mb_over_v",
        "mc_over_v",
        "mt_over_v",
        "md_over_v",
        "ms_over_v",
        "mu_over_v",
    ]

    return C_real, q_real, names


# =============================================================================
# Enumerate unimodular 3×3 integer matrices with entries in {-1,0,1}
# =============================================================================

def generate_unimodular_matrices_3x3():
    """
    Generate all 3×3 integer matrices U with entries in {-1,0,1}
    such that det(U) = ±1 (unimodular).

    There are at most 3^9 = 19,683 candidates; we filter by determinant.
    """
    values = (-1, 0, 1)
    for entries in product(values, repeat=9):
        U = np.array(entries, dtype=int).reshape(3, 3)
        det = round(np.linalg.det(U))
        if det == 1 or det == -1:
            yield U, det


# =============================================================================
# FN-compatibility test
# =============================================================================

def is_fn_compatible(C_real, q_real, U, det, tol_q=1e-6):
    """
    Given C_real (9×3), q_real (3,), and unimodular U (det=±1), test:

      C' = C_real @ U
      q' = (U^{-1})^T @ q_real

    FN-compatible if:
      • q'_j < 0 (within tol_q).
      • All entries of C' are ≥ 0.
      • Each column j has at least one strictly positive entry.

    Returns (compatible: bool, C_prime, q_prime) if OK, else (False, None, None).
    """
    # Compute inverse of U and q'
    U_inv = np.linalg.inv(U)  # exact inverse over reals; integer due to unimodularity
    q_prime = U_inv.T @ q_real

    # FN1: all q'_j < 0
    if not np.all(q_prime < -tol_q):
        return False, None, None

    # Transform charges
    C_prime = C_real @ U

    # FN2: all charges non-negative
    if np.any(C_prime < 0):
        return False, None, None

    # FN3: each spurion actually used (at least one positive in each column)
    if not np.all(np.max(C_prime, axis=0) > 0):
        return False, None, None

    return True, C_prime, q_prime


# =============================================================================
# Main FN-compatible basis search
# =============================================================================

def run_phase23_fn_basis_search():
    """
    Search for a FN-compatible basis for the Toy3D integer Yukawa geometry.
    """
    timestamp = datetime.now().isoformat()

    C_real, q_real, names = get_toy3d_geometry()

    # Basic metrics of original geometry
    max_abs_C = int(np.max(np.abs(C_real)))
    L1_sum_C = int(np.sum(np.abs(C_real)))

    # Run search
    fn_candidates = []

    for U, det in generate_unimodular_matrices_3x3():
        ok, C_prime, q_prime = is_fn_compatible(C_real, q_real, U, det)
        if not ok:
            continue

        max_abs = int(np.max(np.abs(C_prime)))
        L1_sum = int(np.sum(np.abs(C_prime)))
        fn_candidates.append(
            {
                "U": U.tolist(),
                "det": int(det),
                "C_prime": C_prime.tolist(),
                "q_prime": q_prime.tolist(),
                "max_abs": max_abs,
                "L1_sum": L1_sum,
            }
        )

    # Sort candidates by simplicity
    fn_candidates_sorted = sorted(
        fn_candidates,
        key=lambda d: (d["max_abs"], d["L1_sum"])
    )

    # Build hash payload
    payload = {
        "module": "PHASE23_YUKAWA_3D_FN_BASIS_SEARCH_v1",
        "timestamp": timestamp,
        "C_real": C_real.tolist(),
        "q_real": q_real.tolist(),
        "max_abs_C_real": max_abs_C,
        "L1_sum_C_real": L1_sum_C,
        "num_unimodular_U": "<= 19683",  # upper bound
        "num_fn_candidates": len(fn_candidates_sorted),
        "top_candidates": fn_candidates_sorted[:5],
    }
    sha = _canonical_sha256(payload)

    # Pretty print
    print("=" * 80)
    print(" PHASE 23 – MODULE 1: FN-COMPATIBLE BASIS SEARCH FOR TOY 3D GEOMETRY (v1) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha}")
    print()
    print("Original Toy3D integer geometry (C_real, q_real):")
    print(f"  C_real (9×3 charges), max |C_ij| = {max_abs_C}, L1 sum = {L1_sum_C}")
    print("  q_real (log10 λ) =", np.array2string(q_real, precision=6))
    print()

    print("Search setup:")
    print("  • U entries in {-1,0,1}")
    print("  • det(U) = ±1 (unimodular)")
    print("  • FN conditions:")
    print("       (FN1) q'_j < 0  (all spurions < 1)")
    print("       (FN2) C'_{ij} ≥ 0 (non-negative charges)")
    print("       (FN3) each column of C' used (max_i C'_{ij} > 0)")
    print()

    print(f"Search results:")
    print(f"  FN-compatible bases found : {len(fn_candidates_sorted)}")
    print()

    if len(fn_candidates_sorted) == 0:
        print("  No FN-compatible basis found within this search region.")
        print("  → Within U ∈ {-1,0,1}^{3×3} unimodular, Toy3D geometry")
        print("    cannot be turned into a 3-spurion FN model with:")
        print("      • λ_j < 1 for all j and")
        print("      • all Yukawa charges non-negative.")
        print()
        print("  Interpretation:")
        print("    • This suggests the Toy3D integer geometry is NOT equivalent")
        print("      to a simple 3-spurion FN setup with non-negative exponents.")
        print("    • Any realistic multi-spurion FN model would need more DOF,")
        print("      more complicated basis transforms, or additional structure.")
    else:
        print("  Top FN-compatible bases by simplicity (max|C'|, then L1 sum):")
        print("  rank  det  max|C'|  L1_sum   q'_1        q'_2        q'_3")
        print("  ----  ---  -------  ------  --------   --------   --------")
        for rank, cand in enumerate(fn_candidates_sorted[:10]):
            det = cand["det"]
            mabs = cand["max_abs"]
            L1 = cand["L1_sum"]
            q1, q2, q3 = cand["q_prime"]
            print(
                f"   {rank:2d}  {det:3d}     {mabs:3d}     {L1:4d} "
                f" {q1: +9.6f}  {q2: +9.6f}  {q3: +9.6f}"
            )
        print()
        print("  Example transformed charges C' for best candidate (rank 0):")
        best = fn_candidates_sorted[0]
        Cp = np.array(best["C_prime"], dtype=int)
        qp = np.array(best["q_prime"], dtype=float)
        print("    U_best (3×3):")
        print(np.array(best["U"], dtype=int))
        print()
        print("    C' rows (name, charges):")
        for name, row in zip(names, Cp):
            print(f"      {name:11s}  {row.tolist()}")
        print()
        print("    q' (log10 λ') =", np.array2string(qp, precision=6))
        print()
        print("  Interpretation:")
        print("    • At least one FN-compatible basis exists in this small search.")
        print("    • In that case, Toy3D geometry *can* be seen as a clean 3-spurion")
        print("      FN model with λ_j < 1 and non-negative charges in that basis.")
        print("    • You could then reinterpret C' as FN charges and q' as log10 λ's.")

    print()
    print("NOTE: This is a structural check only; it does NOT change the global")
    print("      lock contract (DNA + me–mtau–md triple, ~20–27 bits). It tells")
    print("      you how compatible Toy3D is with a simple FN picture.")
    print()
    print("=" * 80)
    print(" PHASE23_YUKAWA_3D_FN_BASIS_SEARCH_v1 COMPLETE ")
    print("=" * 80)
    print()


# Run module if executed as a script
if __name__ == "__main__":
    run_phase23_fn_basis_search()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

r"""
PHASE 23 – MODULE 2: YUKAWA 3D FN-COMPATIBILITY EVIDENCE (v1)

Purpose
-------
Take the *structural* result from PHASE 23 – MODULE 1:

  • Starting from the Toy3DIntegerGeometry (C_real, q_real),
  • We scanned all unimodular 3×3 integer matrices U with entries in {-1,0,1},
  • For each U we built:
        C' = C_real @ U
        q' = (U^{-1})^T @ q_real
    and demanded FN-like conditions:
        (FN1)  q'_j < 0    (all λ_j < 1)
        (FN2)  C'_{ij} ≥ 0 (non-negative charges)
        (FN3)  each spurion used: max_i C'_{ij} > 0 for each column j.

Result of PHASE 23 – MODULE 1:
  → FN-compatible bases found : 0
    within U ∈ {-1,0,1}^{3×3} with det(U)=±1.

This module:
  • Records that conclusion into GEOM_EVIDENCE as a *structural* fact,
    with bits = 0 (no new p-value / no extra lock).
  • Prints a human-readable summary of what this means for model-building.

Key conceptual takeaway:
  → Within a very natural "small unimodular" search, the Toy3D integer
    Yukawa geometry C_real, q_real is *not* equivalent to a simple
    3-spurion Froggatt–Nielsen model with non-negative exponents and λ_j<1.
  → Any realistic FN-like model that reproduces this geometry must be
    more complicated (more spurions, non-unimodular basis, negative charges,
    extra structure, etc.).
"""

import json
import hashlib
from datetime import datetime

# =============================================================================
# Attempt to access global GEOM_EVIDENCE; create if absent
# =============================================================================

try:
    GEOM_EVIDENCE  # type: ignore[name-defined]
except NameError:
    GEOM_EVIDENCE = {}  # type: ignore[assignment]


# =============================================================================
# Canonical SHA256 helper
# =============================================================================

def _canonical_sha256(payload) -> str:
    s = json.dumps(payload, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


# =============================================================================
# Main evidence module
# =============================================================================

def run_phase23_fn_compatibility_evidence():
    timestamp = datetime.now().isoformat()

    # These numbers summarize the PHASE 23 – MODULE 1 search region & outcome.
    fn_summary = {
        "module": "PHASE23_YUKAWA_3D_FN_COMPATIBILITY_EVIDENCE_v1",
        "timestamp": timestamp,
        "search_region": {
            "U_entries": [-1, 0, 1],
            "det_condition": "det(U) = ±1 (unimodular)",
            "fn_conditions": {
                "FN1": "q'_j < 0  (all spurions λ_j < 1)",
                "FN2": "C'_{ij} ≥ 0 (non-negative integer charges)",
                "FN3": "each column j has max_i C'_{ij} > 0 (spurion used)",
            },
        },
        "toy3d_geometry": {
            "C_real_max_abs": 4,
            "C_real_L1_sum": 56,
            "q_real": [0.99546434, 0.96078513, -0.22005041],
            "description": (
                "Toy3DIntegerGeometry charges and q-vector used in PHASE 20/23; "
                "fits 9 Yukawas with RMS_all ≈ 0.00424 dex."
            ),
        },
        "fn_search_result": {
            "num_fn_compatible_bases": 0,
            "interpretation": (
                "No unimodular U with entries in {-1,0,1} makes all q'_j<0 and "
                "all C'_{ij} ≥ 0 with each spurion used. Within this natural "
                "search, the Toy3D integer geometry cannot be cast as a simple "
                "3-spurion FN model with non-negative exponents and λ_j<1."
            ),
        },
        "evidence": {
            "bits": 0.0,
            "status": "supporting_structure_shape",
            "reason": (
                "This is a *structural non-existence* statement in a finite "
                "search region, not a probabilistic null-test. It constrains "
                "how Toy3D can be interpreted, but does not provide an "
                "independent p-value or extra 'lock bits'."
            ),
        },
    }

    sha = _canonical_sha256(fn_summary)
    fn_summary["sha256"] = sha

    # Store into global evidence dict
    GEOM_EVIDENCE["toy3d_fn_compatibility"] = fn_summary

    # Pretty print
    print("=" * 80)
    print(" PHASE 23 – MODULE 2: YUKAWA 3D FN-COMPATIBILITY EVIDENCE (v1) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha}")
    print()
    print("Input from PHASE 23 – MODULE 1 (structural FN search):")
    print("  • U ∈ {-1,0,1}^{3×3}, det(U)=±1 (unimodular).")
    print("  • Toy3D geometry charges C_real with max|C_ij| = 4, L1 sum = 56.")
    print("  • q_real (log10 λ) ≈ [0.99546434, 0.96078513, -0.22005041].")
    print("  • FN-conditions required in transformed basis (C', q'):")
    print("       (FN1) q'_j < 0          (all spurions λ_j < 1)")
    print("       (FN2) C'_{ij} ≥ 0       (non-negative integer charges)")
    print("       (FN3) max_i C'_{ij} > 0 for each column j (each spurion used)")
    print()
    print("Outcome of the search region:")
    print("  → FN-compatible bases found : 0")
    print()
    print("Interpretation for model-building:")
    print("  • Within this natural unimodular search, the Toy3D integer Yukawa")
    print("    geometry C_real, q_real is NOT equivalent to a textbook")
    print("    3-spurion Froggatt–Nielsen model with:")
    print("       – three sub-unity spurions λ_j < 1, and")
    print("       – purely non-negative integer exponents for all Yukawas.")
    print()
    print("  • Any realistic FN-like geometry that reproduces the Toy3D pattern")
    print("    must be more involved, e.g.:")
    print("       – additional spurions (dimension > 3), or")
    print("       – non-unimodular / larger-integer basis changes, or")
    print("       – negative charges / mixed-sign exponents, or")
    print("       – extra discrete symmetries / structure beyond plain FN.")
    print()
    print("Evidence-budget status:")
    print("  • bits assigned          : 0.00  (by design)")
    print("  • classification         : supporting_structure_shape")
    print("  • reason                 : finite structural non-existence, not a")
    print("                             probabilistic anomaly; no new lock.")
    print()
    print("Global lock contract remains:")
    print("  • PRIMARY LOCKS:")
    print("       – DNA backbone / lock structure (~12.29 bits).")
    print("       – me–mtau–md (-4,4,3) Yukawa triple (7–14 bits).")
    print("  • Toy3D FN-compatibility result only constrains how a future")
    print("    geometry can look; it does NOT alter the required bits.")
    print()
    print("GEOM_EVIDENCE['toy3d_fn_compatibility'] has been updated in memory.")
    print()
    print("=" * 80)
    print(" PHASE23_YUKAWA_3D_FN_COMPATIBILITY_EVIDENCE_v1 COMPLETE ")
    print("=" * 80)
    print()


# Run module if executed as a script
if __name__ == "__main__":
    run_phase23_fn_compatibility_evidence()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

r"""
PHASE 24 – MODULE 1 (v2): EXTERNAL FN-LIKE YUKAWA MODEL TESTER

Purpose
-------
This module gives us a *real test harness* for candidate Yukawa geometries /
FN-like models.

You provide:
  • A name and description for the model.
  • A 9×D integer charge matrix C (rows = Yukawas, columns = spurions).
  • A D-dimensional log10 λ vector q.
  • Optionally, a tuning_penalty_bits if the model is obviously tuned.

The module then:
  • Computes z_pred = C @ q for the 9 Yukawas.
  • Compares to real log10(y_i / v) data.
  • Computes:
      – RMS_all (dex),
      – max|residual| (dex),
      – S_geom = |-4 z_me + 4 z_tau + 3 z_d| and S_geom / S_real.
  • Classifies whether the model "explains" the me–mtau–md (-4,4,3) triple
    at the same level as the Toy3D geometry.
  • Builds a geometry scorecard using the GLOBAL_LOCKS blueprint (v4-style),
    if present, or falls back to hard-coded contract numbers:
        DNA bits   ≈ 12.29
        Yukawa bits: 7.48 (conservative), 14.29 (optimistic)

This is the first *general* interface to test real or toy FN-like structures
against the Yukawa triple lock and the global evidence contract.
"""

import json
import hashlib
from datetime import datetime

import numpy as np

# =============================================================================
# Global Yukawa data (log10(y / v)) and error model summary
# =============================================================================

YUKAWA_NAMES = [
    "me_over_v",
    "mmu_over_v",
    "mtau_over_v",
    "mb_over_v",
    "mc_over_v",
    "mt_over_v",
    "md_over_v",
    "ms_over_v",
    "mu_over_v",
]

# Real log10(y / v) values (same as earlier phases)
Z_REAL = np.array([
    -5.683401,  # me_over_v
    -3.367606,  # mmu_over_v
    -2.141781,  # mtau_over_v
    -1.770024,  # mb_over_v
    -2.287532,  # mc_over_v
    -0.154056,  # mt_over_v
    -4.722162,  # md_over_v
    -3.422873,  # ms_over_v
    -5.056852,  # mu_over_v
], dtype=float)

# Indices for the me–mtau–md triple
IDX_ME   = YUKAWA_NAMES.index("me_over_v")
IDX_TAU  = YUKAWA_NAMES.index("mtau_over_v")
IDX_DOWN = YUKAWA_NAMES.index("md_over_v")

# Real triple lock S_real = |-4 z_me + 4 z_tau + 3 z_d|
S_REAL = abs(-4.0 * Z_REAL[IDX_ME] + 4.0 * Z_REAL[IDX_TAU] + 3.0 * Z_REAL[IDX_DOWN])


# =============================================================================
# Global evidence / contract (try to pick up GLOBAL_LOCKS_v4 if present)
# =============================================================================

try:
    GLOBAL_LOCKS_v4  # type: ignore[name-defined]
    _GLOBAL_LOCKS = GLOBAL_LOCKS_v4["GLOBAL_LOCKS_v4"]  # type: ignore[index]
    DNA_BITS = _GLOBAL_LOCKS["dna"]["effective_bits"]
    YUKAWA_BITS_CONS = _GLOBAL_LOCKS["yukawa"]["triple_me_tau_d"]["bits_global_error_model"]
    YUKAWA_BITS_OPT  = _GLOBAL_LOCKS["yukawa"]["triple_me_tau_d"]["bits_fixed_error_model"]
except Exception:
    # Fallback: hard-coded from earlier summary
    DNA_BITS = 12.29
    YUKAWA_BITS_CONS = 7.48
    YUKAWA_BITS_OPT  = 14.29


# =============================================================================
# Geometry scorecard registry (robust handling: list OR dict)
# =============================================================================

try:
    GEOMETRY_SCORECARDS  # type: ignore[name-defined]
except NameError:
    # Initialize as a dict with a 'scorecards' list; compatible with Phase 21+
    GEOMETRY_SCORECARDS = {"scorecards": []}  # type: ignore[assignment]
else:
    # If it already exists, normalize to either:
    #   • list of scorecards, or
    #   • dict with 'scorecards' list.
    if isinstance(GEOMETRY_SCORECARDS, dict):
        if "scorecards" not in GEOMETRY_SCORECARDS or not isinstance(
            GEOMETRY_SCORECARDS.get("scorecards"), list
        ):
            GEOMETRY_SCORECARDS["scorecards"] = []
    elif isinstance(GEOMETRY_SCORECARDS, list):
        # older style; keep as-is
        pass
    else:
        # weird type: reset to safe default
        GEOMETRY_SCORECARDS = {"scorecards": []}  # type: ignore[assignment]


def _append_scorecard(sc: dict):
    """
    Append a scorecard to GEOMETRY_SCORECARDS, whether it's a list or
    a dict with 'scorecards' list.
    """
    global GEOMETRY_SCORECARDS
    if isinstance(GEOMETRY_SCORECARDS, list):
        GEOMETRY_SCORECARDS.append(sc)  # type: ignore[arg-type]
    elif isinstance(GEOMETRY_SCORECARDS, dict):
        lst = GEOMETRY_SCORECARDS.setdefault("scorecards", [])
        if not isinstance(lst, list):
            lst = []
            GEOMETRY_SCORECARDS["scorecards"] = lst
        lst.append(sc)
    else:
        # fallback: reset to dict+list
        GEOMETRY_SCORECARDS = {"scorecards": [sc]}  # type: ignore[assignment]


def _canonical_sha256(payload) -> str:
    s = json.dumps(payload, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


# =============================================================================
# Core evaluation function
# =============================================================================

def evaluate_yukawa_geometry(
    name: str,
    description: str,
    C: np.ndarray,
    q: np.ndarray,
    tuning_penalty_bits: float = 0.0,
    rms_threshold_triple: float = 0.03,
    sgeom_factor_tolerance: float = 10.0,
    register_scorecard: bool = True,
):
    """
    Evaluate an external Yukawa geometry / FN-like model.

    Parameters
    ----------
    name : str
        Name of the geometry hypothesis.
    description : str
        Short human-readable description.
    C : np.ndarray
        9×D integer charge matrix, rows ordered as YUKAWA_NAMES.
    q : np.ndarray
        D-dimensional log10 λ vector.
    tuning_penalty_bits : float, optional
        Bits to subtract if the model is obviously tuned.
    rms_threshold_triple : float, optional
        RMS_all threshold (dex) used to decide if the geometry reasonably
        fits all 9 Yukawas (default ~0.03 dex).
    sgeom_factor_tolerance : float, optional
        How many times worse than S_REAL we accept for S_geom before we say
        it fails to explain the triple (default factor 10).
    register_scorecard : bool, optional
        If True, append a scorecard to GEOMETRY_SCORECARDS.

    Returns
    -------
    result : dict
        Dictionary with fit metrics, triple metrics, and scorecard info.
    """

    timestamp = datetime.now().isoformat()

    C = np.asarray(C, dtype=float)
    q = np.asarray(q, dtype=float)

    if C.shape[0] != len(YUKAWA_NAMES):
        raise ValueError(f"C must have {len(YUKAWA_NAMES)} rows; got {C.shape[0]}")
    if C.shape[1] != q.shape[0]:
        raise ValueError(f"C is {C.shape}, q is shape {q.shape}; second dim of C must match length of q.")

    # Predictions
    z_pred = C @ q
    residuals = z_pred - Z_REAL
    rms_all = float(np.sqrt(np.mean(residuals**2)))
    max_abs_resid = float(np.max(np.abs(residuals)))

    # Triple combination on geometry
    z_me_geom   = z_pred[IDX_ME]
    z_tau_geom  = z_pred[IDX_TAU]
    z_d_geom    = z_pred[IDX_DOWN]
    s_geom = -4.0 * z_me_geom + 4.0 * z_tau_geom + 3.0 * z_d_geom
    s_geom_abs = abs(s_geom)
    s_geom_ratio = float(s_geom_abs / S_REAL) if S_REAL > 0 else float("inf")

    # Decide whether we count this as "explaining" the Yukawa triple
    explains_yukawa_triple = (rms_all <= rms_threshold_triple) and (s_geom_ratio <= sgeom_factor_tolerance)

    # For this module, we do NOT test DNA; that is handled elsewhere.
    explains_dna_backbone = False

    # Bits from contract
    if explains_yukawa_triple:
        yukawa_bits_cons = YUKAWA_BITS_CONS
        yukawa_bits_opt  = YUKAWA_BITS_OPT
    else:
        yukawa_bits_cons = 0.0
        yukawa_bits_opt  = 0.0

    dna_bits = 0.0  # DNA not checked here

    total_bits_cons = max(0.0, dna_bits + yukawa_bits_cons - tuning_penalty_bits)
    total_bits_opt  = max(0.0, dna_bits + yukawa_bits_opt  - tuning_penalty_bits)

    result = {
        "module": "PHASE24_YUKAWA_FN_MODEL_TESTER_v2",
        "timestamp": timestamp,
        "geometry": {
            "name": name,
            "description": description,
        },
        "fit": {
            "RMS_all": rms_all,
            "max_abs_resid": max_abs_resid,
        },
        "triple": {
            "z_me_geom": z_me_geom,
            "z_tau_geom": z_tau_geom,
            "z_d_geom": z_d_geom,
            "S_real": S_REAL,
            "S_geom": s_geom,
            "S_geom_abs": s_geom_abs,
            "S_geom_over_S_real": s_geom_ratio,
            "explains_yukawa_triple": explains_yukawa_triple,
            "rms_threshold_triple": rms_threshold_triple,
            "sgeom_factor_tolerance": sgeom_factor_tolerance,
        },
        "locks": {
            "explains_dna_backbone": explains_dna_backbone,
            "explains_yukawa_triple": explains_yukawa_triple,
            "tuning_penalty_bits": tuning_penalty_bits,
        },
        "bits": {
            "dna_bits": dna_bits,
            "yukawa_bits_conservative": yukawa_bits_cons,
            "yukawa_bits_optimistic": yukawa_bits_opt,
            "tuning_penalty_bits": tuning_penalty_bits,
            "total_bits_conservative": total_bits_cons,
            "total_bits_optimistic": total_bits_opt,
        },
    }

    sha = _canonical_sha256(result)
    result["sha256"] = sha

    # Pretty print scorecard
    print("=" * 80)
    print(f" PHASE 24 – GEOMETRY SCORECARD: {name} ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha}")
    print()
    print("Description:")
    print(f"  {description}")
    print()
    print("Fit quality (all 9 Yukawas):")
    print(f"  RMS_all (dex)             : {rms_all: .6f}")
    print(f"  Max |residual| (dex)      : {max_abs_resid: .6f}")
    print()
    print("Triple lock (-4,4,3) on geometry:")
    print(f"  S_real                    : {S_REAL: .6e}")
    print(f"  S_geom                    : {s_geom: .6e}")
    print(f"  |S_geom| / S_real         : {s_geom_ratio: .3e}")
    print(f"  explains_yukawa_triple?   : {explains_yukawa_triple}")
    print()
    print("Lock claims (for global contract):")
    print(f"  • explains_dna_backbone   : {explains_dna_backbone}")
    print(f"  • explains_yukawa_triple  : {explains_yukawa_triple}")
    print(f"  • tuning_penalty_bits     : {tuning_penalty_bits: .2f}")
    print()
    print("Bits earned (relative to global lock contract):")
    print(f"  DNA sector bits           : {dna_bits: 5.2f}")
    print(f"  Yukawa bits (conservative): {yukawa_bits_cons: 5.2f}")
    print(f"  Yukawa bits (optimistic)  : {yukawa_bits_opt: 5.2f}")
    print(f"  Tuning penalty            : {tuning_penalty_bits: 5.2f}")
    print()
    print(f"  → Total (conservative)    : {total_bits_cons: 5.2f} bits")
    print(f"  → Total (optimistic)      : {total_bits_opt: 5.2f} bits")
    print()
    print("=" * 80)
    print()

    # Optionally register a condensed scorecard for later comparison
    if register_scorecard:
        scorecard = {
            "name": name,
            "description": description,
            "explains_dna_backbone": explains_dna_backbone,
            "explains_yukawa_triple": explains_yukawa_triple,
            "tuning_penalty_bits": tuning_penalty_bits,
            "dna_bits": dna_bits,
            "yukawa_bits_conservative": yukawa_bits_cons,
            "yukawa_bits_optimistic": yukawa_bits_opt,
            "total_bits_conservative": total_bits_cons,
            "total_bits_optimistic": total_bits_opt,
            "sha256": sha,
            "timestamp": timestamp,
        }
        _append_scorecard(scorecard)
        print("GEOMETRY_SCORECARDS updated with:")
        print(f"  {name}")
        print()

    return result


# =============================================================================
# Demo: Evaluate the Toy3DIntegerGeometry_v1 via this tester
# =============================================================================

def _toy3d_demo():
    """
    Use the Toy3D integer geometry (from earlier phases) as a demo external model.
    """

    # Toy3D charges (C_real) and q_real as used in Phase 20/23
    C_real = np.array([
        [-4, -2, -1],  # me_over_v
        [-1, -2,  2],  # mmu_over_v
        [-4,  1, -4],  # mtau_over_v
        [-2,  0, -1],  # mb_over_v
        [-2, -1, -3],  # mc_over_v
        [-2,  1, -4],  # mt_over_v
        [ 0, -4,  4],  # md_over_v
        [-3,  0,  2],  # ms_over_v
        [-1, -4,  1],  # mu_over_v
    ], dtype=int)

    q_real = np.array([
        0.99546434,
        0.96078513,
        -0.22005041,
    ], dtype=float)

    description = (
        "External evaluation of Toy3DIntegerGeometry_v1: 9×3 integer charges "
        "and 3D log10 λ-vector. By construction, this fits all 9 Yukawas with "
        "RMS_all ≈ 0.0042 dex and enforces the (-4,4,3) triple at the geometry level."
    )

    evaluate_yukawa_geometry(
        name="Toy3DIntegerGeometry_v1_external",
        description=description,
        C=C_real,
        q=q_real,
        tuning_penalty_bits=0.0,
        rms_threshold_triple=0.03,
        sgeom_factor_tolerance=10.0,
        register_scorecard=True,
    )


# =============================================================================
# Main entry point
# =============================================================================

if __name__ == "__main__":
    print("=" * 80)
    print(" PHASE 24 – MODULE 1 (v2): EXTERNAL FN-LIKE YUKAWA MODEL TESTER ")
    print("=" * 80)
    print()
    print("This module defines evaluate_yukawa_geometry(name, description, C, q, ...)")
    print("and runs a demo on Toy3DIntegerGeometry_v1 as an external model.")
    print()

    _toy3d_demo()

    print("PHASE24_YUKAWA_FN_MODEL_TESTER_v2 COMPLETE")
    print("=" * 80)
    print()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

r"""
PHASE 25 – MODULE 1: GLOBAL GEOMETRY SCOREBOARD PRINTER (v2)

Purpose
-------
Unify ALL registered geometry hypotheses (NullGeometry, PerfectLockGeometry,
Toy3DIntegerGeometry_v1, DNAOnlyGeometry, Toy3DIntegerGeometry_v1_external,
and any future ones) into a single, dynamic scoreboard, using the
GLOBAL_LOCKS_v4 contract if available.

Behavior
--------
• Reads GLOBAL_LOCKS_v4 (if defined) to get:
      DNA bits          ≈ 12.29
      Yukawa triple     ≈ 7.48 (conservative), 14.29 (optimistic)
  otherwise falls back to those numbers directly.

• Reads GEOMETRY_SCORECARDS, which might be:
      - a plain list of scorecard dicts (older style), or
      - a dict with key "scorecards": [ ... ] (newer style).

• Normalizes each entry to a canonical minimal record:
      name, description,
      explains_dna_backbone, explains_yukawa_triple,
      tuning_penalty_bits,
      dna_bits, yukawa_bits_conservative, yukawa_bits_optimistic,
      total_bits_conservative, total_bits_optimistic.

• Sorts geometries by total_bits_conservative (descending).

• Builds GLOBAL_GEOMETRY_SCOREBOARD_v2 as a Python dict in memory and
  prints a bannered summary plus a SHA256 hash of the payload.

This module does NOT change the evidence contract; it just displays
the current landscape of candidate geometries vs the lock contract.
"""

import json
import hashlib
from datetime import datetime

# =============================================================================
# Global contract: try to load from GLOBAL_LOCKS_v4, else fallback
# =============================================================================

try:
    GLOBAL_LOCKS_v4  # type: ignore[name-defined]
    _GL = GLOBAL_LOCKS_v4["GLOBAL_LOCKS_v4"]  # type: ignore[index]
    DNA_BITS = _GL["dna"]["effective_bits"]
    YUKAWA_BITS_CONS = _GL["yukawa"]["triple_me_tau_d"]["bits_global_error_model"]
    YUKAWA_BITS_OPT = _GL["yukawa"]["triple_me_tau_d"]["bits_fixed_error_model"]
except Exception:
    # Fallback hard-coded from earlier phases
    DNA_BITS = 12.29
    YUKAWA_BITS_CONS = 7.48
    YUKAWA_BITS_OPT = 14.29


# =============================================================================
# GEOMETRY_SCORECARDS normalization
# =============================================================================

try:
    GEOMETRY_SCORECARDS  # type: ignore[name-defined]
except NameError:
    # No geometries registered yet.
    GEOMETRY_SCORECARDS = {"scorecards": []}  # type: ignore[assignment]


def _get_scorecard_list():
    """
    Normalize GEOMETRY_SCORECARDS into a list of dicts. Supports:
      • list of scorecards
      • dict with 'scorecards' list
    """
    global GEOMETRY_SCORECARDS

    if isinstance(GEOMETRY_SCORECARDS, list):
        return GEOMETRY_SCORECARDS  # type: ignore[return-value]

    if isinstance(GEOMETRY_SCORECARDS, dict):
        lst = GEOMETRY_SCORECARDS.get("scorecards", [])
        if not isinstance(lst, list):
            lst = []
        return lst

    # Weird type: just treat as empty
    return []


def _canonical_sha256(payload) -> str:
    s = json.dumps(payload, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


# =============================================================================
# Main scoreboard builder
# =============================================================================

def build_global_geometry_scoreboard_v2():
    """
    Build a canonical scoreboard object from GEOMETRY_SCORECARDS and
    the global lock contract.
    """
    timestamp = datetime.now().isoformat()

    sc_list = _get_scorecard_list()

    canonical_entries = []
    for sc in sc_list:
        if not isinstance(sc, dict):
            continue

        name = sc.get("name", "<unnamed>")
        description = sc.get("description", "")

        explains_dna_backbone = bool(sc.get("explains_dna_backbone", False))
        explains_yukawa_triple = bool(sc.get("explains_yukawa_triple", False))

        tuning_penalty_bits = float(sc.get("tuning_penalty_bits", 0.0))

        dna_bits = float(sc.get("dna_bits", 0.0))
        yuk_cons = float(sc.get("yukawa_bits_conservative", 0.0))
        yuk_opt = float(sc.get("yukawa_bits_optimistic", 0.0))

        total_cons = float(
            sc.get(
                "total_bits_conservative",
                dna_bits + yuk_cons - tuning_penalty_bits,
            )
        )
        total_opt = float(
            sc.get(
                "total_bits_optimistic",
                dna_bits + yuk_opt - tuning_penalty_bits,
            )
        )

        canonical_entries.append(
            {
                "name": name,
                "description": description,
                "explains_dna_backbone": explains_dna_backbone,
                "explains_yukawa_triple": explains_yukawa_triple,
                "tuning_penalty_bits": tuning_penalty_bits,
                "dna_bits": dna_bits,
                "yukawa_bits_conservative": yuk_cons,
                "yukawa_bits_optimistic": yuk_opt,
                "total_bits_conservative": total_cons,
                "total_bits_optimistic": total_opt,
            }
        )

    # Sort by conservative total bits (descending), then by name
    canonical_entries.sort(
        key=lambda e: (-e["total_bits_conservative"], e["name"])
    )

    scoreboard = {
        "module": "PHASE25_GLOBAL_GEOMETRY_SCOREBOARD_v2",
        "timestamp": timestamp,
        "contract": {
            "dna_effective_bits": DNA_BITS,
            "yukawa_bits_conservative": YUKAWA_BITS_CONS,
            "yukawa_bits_optimistic": YUKAWA_BITS_OPT,
            "combined_bits_conservative": DNA_BITS + YUKAWA_BITS_CONS,
            "combined_bits_optimistic": DNA_BITS + YUKAWA_BITS_OPT,
        },
        "geometries": canonical_entries,
    }

    sha = _canonical_sha256(scoreboard)
    scoreboard["sha256"] = sha

    return scoreboard


def print_global_geometry_scoreboard_v2():
    """
    Build and print the global geometry scoreboard with banners.
    """
    scoreboard = build_global_geometry_scoreboard_v2()
    ts = scoreboard["timestamp"]
    sha = scoreboard["sha256"]
    contract = scoreboard["contract"]
    entries = scoreboard["geometries"]

    print("=" * 80)
    print(" PHASE 25 – MODULE 1: GLOBAL GEOMETRY SCOREBOARD PRINTER (v2) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {ts}")
    print(f"Run SHA256 payload    : {sha}")
    print()
    print("GLOBAL LOCK CONTRACT (from GLOBAL_LOCKS_v4 or fallback):")
    print(f"  DNA effective bits                 : {contract['dna_effective_bits']:5.2f}")
    print(f"  Yukawa triple bits (conservative)  : {contract['yukawa_bits_conservative']:5.2f}")
    print(f"  Yukawa triple bits (optimistic)    : {contract['yukawa_bits_optimistic']:5.2f}")
    print(f"    → Combined (conservative)        : {contract['combined_bits_conservative']:5.2f} bits")
    print(f"    → Combined (optimistic)          : {contract['combined_bits_optimistic']:5.2f} bits")
    print()

    print("=" * 80)
    print(" GLOBAL GEOMETRY SCOREBOARD (sorted by conservative bits) ")
    print("=" * 80)
    print()

    if not entries:
        print("No geometries registered in GEOMETRY_SCORECARDS.")
        print()
        return

    # Table header
    header = (
        f"{'Name':<28} {'DNA?':<5} {'Yukawa?':<7} "
        f"{'Tuning':>8} {'DNA bits':>9} "
        f"{'Yuk(cons)':>10} {'Yuk(opt)':>9} "
        f"{'Tot(cons)':>10} {'Tot(opt)':>9}"
    )
    print(header)
    print("-" * len(header))

    for e in entries:
        name = e["name"]
        dna_flag = "Y" if e["explains_dna_backbone"] else "N"
        yuk_flag = "Y" if e["explains_yukawa_triple"] else "N"
        tune = e["tuning_penalty_bits"]
        dna_bits = e["dna_bits"]
        y_cons = e["yukawa_bits_conservative"]
        y_opt = e["yukawa_bits_optimistic"]
        t_cons = e["total_bits_conservative"]
        t_opt = e["total_bits_optimistic"]

        print(
            f"{name:<28} {dna_flag:<5} {yuk_flag:<7} "
            f"{tune:8.2f} {dna_bits:9.2f} "
            f"{y_cons:10.2f} {y_opt:9.2f} "
            f"{t_cons:10.2f} {t_opt:9.2f}"
        )

    print()
    print("=" * 80)
    print(" DETAILED GEOMETRY DESCRIPTIONS ")
    print("=" * 80)
    print()

    for e in entries:
        print("=" * 80)
        print(f" GEOMETRY: {e['name']} ")
        print("=" * 80)
        print()
        print(f"  explains_dna_backbone : {e['explains_dna_backbone']}")
        print(f"  explains_yukawa_triple: {e['explains_yukawa_triple']}")
        print(f"  tuning_penalty_bits   : {e['tuning_penalty_bits']:.2f}")
        print()
        print(f"  DNA bits              : {e['dna_bits']:.2f}")
        print(f"  Yukawa bits (cons)    : {e['yukawa_bits_conservative']:.2f}")
        print(f"  Yukawa bits (opt)     : {e['yukawa_bits_optimistic']:.2f}")
        print(f"  Total bits (cons)     : {e['total_bits_conservative']:.2f}")
        print(f"  Total bits (opt)      : {e['total_bits_optimistic']:.2f}")
        print()
        desc = e.get("description", "").strip()
        if desc:
            print("  Description:")
            print("    " + desc.replace("\n", "\n    "))
            print()
        else:
            print("  Description: (none)")
            print()

    print("PHASE25_GLOBAL_GEOMETRY_SCOREBOARD_v2 COMPLETE")
    print("=" * 80)


# If run as a script, immediately print the scoreboard
if __name__ == "__main__":
    print_global_geometry_scoreboard_v2()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PHASE 26 – MODULE 1: GLOBAL GEOMETRY SNAPSHOT EXPORTER (v1)

Purpose
-------
Freeze the current state of the geometry project into a single JSON snapshot,
including:

  • GLOBAL_LOCKS_v4  (the DNA + Yukawa lock contract), if defined.
  • GEOM_EVIDENCE    (all the supporting/killed structures), if defined.
  • GEOMETRY_SCORECARDS  (all registered geometry hypotheses), if defined.
  • The latest global geometry scoreboard (via build_global_geometry_scoreboard_v2),
    if that function is available (from PHASE 25).
  • The Toy3D integer Yukawa geometry object, if present.
  • The Yukawa input logs and error model used throughout.

The snapshot is written to:
    global_geometry_snapshot_phase26.json

and we print a SHA256 hash of the payload so you can verify integrity.

This module does NOT change the evidence contract; it just records where we are.
"""

import json
import hashlib
from datetime import datetime

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _safe_get(name, default=None):
    """
    Safely fetch a global variable by name; return default if not present.
    """
    try:
        return globals()[name]
    except KeyError:
        return default


def _canonical_sha256(payload) -> str:
    s = json.dumps(payload, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


# ---------------------------------------------------------------------------
# Core snapshot builder
# ---------------------------------------------------------------------------

def build_global_geometry_snapshot_phase26():
    """
    Build a JSON-serializable snapshot of the current global geometry state.
    """
    timestamp = datetime.now().isoformat()

    # Try to pull out the global locks v4 if it exists
    global_locks_v4 = _safe_get("GLOBAL_LOCKS_v4", None)

    # Evidence dict (all supporting/killed structures, if defined)
    geom_evidence = _safe_get("GEOM_EVIDENCE", None)

    # Scorecards may be list or dict with "scorecards"
    geometry_scorecards_raw = _safe_get("GEOMETRY_SCORECARDS", None)
    if isinstance(geometry_scorecards_raw, dict):
        geometry_scorecards = geometry_scorecards_raw.get("scorecards", geometry_scorecards_raw)
    else:
        geometry_scorecards = geometry_scorecards_raw

    # Try to build the latest scoreboard, if the builder function exists
    try:
        scoreboard = build_global_geometry_scoreboard_v2()  # from PHASE 25
    except Exception:
        scoreboard = None

    # Try to grab Toy3D geometry object, if any module created one
    toy3d_geometry = _safe_get("Toy3DIntegerGeometry_v1", None)

    # Yukawa inputs (logs and error model) as used in earlier phases
    yukawa_data = {
        "names": [
            "me_over_v",
            "mmu_over_v",
            "mtau_over_v",
            "mb_over_v",
            "mc_over_v",
            "mt_over_v",
            "md_over_v",
            "ms_over_v",
            "mu_over_v",
        ],
        "z_real": [
            -5.683401,
            -3.367606,
            -2.141781,
            -1.770024,
            -2.287532,
            -0.154056,
            -4.722162,
            -3.422873,
            -5.056852,
        ],
        "sigma_log10": [
            4.342945e-09,
            4.342945e-09,
            4.342945e-06,
            4.342945e-02,
            4.342945e-02,
            8.685890e-03,
            8.685890e-02,
            8.685890e-02,
            8.685890e-02,
        ],
    }

    snapshot = {
        "module": "PHASE26_GLOBAL_GEOMETRY_SNAPSHOT_v1",
        "timestamp": timestamp,
        "global_locks_v4": global_locks_v4,
        "geom_evidence": geom_evidence,
        "geometry_scorecards": geometry_scorecards,
        "global_geometry_scoreboard_v2": scoreboard,
        "toy3d_integer_geometry_v1": toy3d_geometry,
        "yukawa_data": yukawa_data,
    }

    sha = _canonical_sha256(snapshot)
    snapshot["sha256"] = sha

    return snapshot


def run_phase26_global_geometry_snapshot_exporter(path: str = "global_geometry_snapshot_phase26.json"):
    """
    Build the snapshot, print a banner summary, and write it to `path`.
    """
    snapshot = build_global_geometry_snapshot_phase26()
    ts = snapshot["timestamp"]
    sha = snapshot["sha256"]

    print("=" * 80)
    print(" PHASE 26 – MODULE 1: GLOBAL GEOMETRY SNAPSHOT EXPORTER (v1) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {ts}")
    print(f"Run SHA256 payload    : {sha}")
    print()
    print("Contents:")
    print("  • global_locks_v4             :", "present" if snapshot["global_locks_v4"] is not None else "None")
    print("  • geom_evidence               :", "present" if snapshot["geom_evidence"] is not None else "None")
    print("  • geometry_scorecards         :", "present" if snapshot["geometry_scorecards"] is not None else "None")
    print("  • global_geometry_scoreboard_v2:", "present" if snapshot["global_geometry_scoreboard_v2"] is not None else "None")
    print("  • toy3d_integer_geometry_v1   :", "present" if snapshot["toy3d_integer_geometry_v1"] is not None else "None")
    print("  • yukawa_data                 : present")
    print()
    print(f"Writing JSON snapshot to: {path}")
    with open(path, "w", encoding="utf-8") as f:
        json.dump(snapshot, f, sort_keys=True, indent=2)
    print("Done.")
    print()
    print("You can archive or share this file as a complete state snapshot.")
    print()
    print("PHASE26_GLOBAL_GEOMETRY_SNAPSHOT_v1 COMPLETE")
    print("=" * 80)


# If run as a script/cell, execute immediately
if __name__ == "__main__":
    run_phase26_global_geometry_snapshot_exporter()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PHASE 27 – MODULE 1: GLOBAL GEOMETRY CONSISTENCY & ROADMAP (v1)

Purpose
-------
1) Check basic consistency of the current global geometry state:
     - GLOBAL_LOCKS_v4 (DNA + Yukawa lock contract)
     - GEOM_EVIDENCE (supporting / killed structures)

2) Print a human-readable "research roadmap" for where to push next:
     - What is already locked in (primary locks)
     - What is supporting shape only
     - Concrete next-step directions for geometry hunting

This module does NOT change the evidence contract; it only inspects and
summarizes the state you've already built.
"""

import json
import hashlib
from datetime import datetime

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _safe_get(name, default=None):
    """
    Safely fetch a global variable by name; return default if not present.
    """
    try:
        return globals()[name]
    except KeyError:
        return default


def _canonical_sha256(payload) -> str:
    """
    Canonical JSON SHA256 for a small summary payload.
    """
    s = json.dumps(payload, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


# ---------------------------------------------------------------------------
# Core logic
# ---------------------------------------------------------------------------

def run_phase27_global_geometry_consistency_and_roadmap():
    """
    Inspect GLOBAL_LOCKS_v4 and GEOM_EVIDENCE (if present), print a
    consistency summary plus a research roadmap.
    """
    timestamp = datetime.now().isoformat()

    global_locks_v4 = _safe_get("GLOBAL_LOCKS_v4", None)
    geom_evidence = _safe_get("GEOM_EVIDENCE", None)

    summary_core = {
        "module": "PHASE27_GLOBAL_GEOMETRY_CONSISTENCY_AND_ROADMAP_v1",
        "timestamp": timestamp,
        "has_global_locks_v4": global_locks_v4 is not None,
        "has_geom_evidence": geom_evidence is not None,
    }
    sha = _canonical_sha256(summary_core)

    print("=" * 80)
    print(" PHASE 27 – MODULE 1: GLOBAL GEOMETRY CONSISTENCY & ROADMAP (v1) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Run SHA256 payload    : {sha}")
    print()

    # ----------------------------------------------------------------------
    # 1. GLOBAL LOCK CONTRACT SUMMARY
    # ----------------------------------------------------------------------
    print("GLOBAL LOCK CONTRACT (expected DNA + Yukawa triple)")
    print("-" * 80)

    if global_locks_v4 is None:
        print("GLOBAL_LOCKS_v4 not found in this session.")
        print("→ You may need to re-run PHASE 19 (GLOBAL_GEOMETRY_EVIDENCE_v4).")
    else:
        dna = global_locks_v4.get("dna", {})
        yuk = global_locks_v4.get("yukawa", {})
        combined = global_locks_v4.get("combined", {})

        dna_bits = dna.get("effective_bits", None)
        dna_status = dna.get("status", "unknown")

        triple = yuk.get("triple_me_tau_d", {})
        y_bits_global = triple.get("bits_global_error_model", None)
        y_bits_fixed = triple.get("bits_fixed_error_model", None)
        y_status = triple.get("status", "unknown")

        comb_cons = combined.get("bits_conservative", None)
        comb_opt = combined.get("bits_optimistic", None)

        print(f"DNA sector:")
        print(f"  • Status         : {dna_status}")
        print(f"  • Effective bits : {dna_bits}")
        print()
        print(f"Yukawa sector (me–mtau–md triple):")
        print(f"  • Status         : {y_status}")
        print(f"  • Bits (global)  : {y_bits_global}")
        print(f"  • Bits (fixed)   : {y_bits_fixed}")
        print()
        print(f"Combined:")
        print(f"  • Bits (conservative) : {comb_cons}")
        print(f"  • Bits (optimistic)   : {comb_opt}")
        print()
        print("Interpretation:")
        print("  → Any serious geometry must explain roughly 20–27 bits total,")
        print("    coming from TWO independent sectors: DNA and the Yukawa triple.")
    print()

    # ----------------------------------------------------------------------
    # 2. GEOM_EVIDENCE STATUS COUNTS
    # ----------------------------------------------------------------------
    print("=" * 80)
    print(" GEOM_EVIDENCE STATUS SUMMARY ")
    print("=" * 80)
    print()

    if geom_evidence is None:
        print("GEOM_EVIDENCE not found in this session.")
        print("→ You may need to re-run the earlier evidence modules (PHASE 8–20).")
    else:
        status_counts = {}
        for key, val in geom_evidence.items():
            status = val.get("status", "unknown")
            status_counts[status] = status_counts.get(status, 0) + 1

        total_entries = sum(status_counts.values())
        print(f"Total GEOM_EVIDENCE entries : {total_entries}")
        print("By status:")
        for status, count in sorted(status_counts.items(), key=lambda x: x[0]):
            frac = count / total_entries if total_entries > 0 else 0.0
            print(f"  • {status:30s}: {count:3d}  ({frac:5.3f} of entries)")
        print()
        print("Notes:")
        print("  • 'primary_lock' entries are the ones that actually contribute")
        print("    bits to the global contract.")
        print("  • 'supporting_structure' / 'supporting_structure_weak' are shape")
        print("    information only, not added as extra bits.")
        print("  • 'killed' entries are patterns that turned out to be ordinary.")
    print()

    # ----------------------------------------------------------------------
    # 3. RESEARCH ROADMAP
    # ----------------------------------------------------------------------
    print("=" * 80)
    print(" GLOBAL GEOMETRY RESEARCH ROADMAP (v1) ")
    print("=" * 80)
    print()
    print("PRIMARY TARGETS (must eventually be explained by a real model):")
    print("  1) DNA backbone + lock-family architecture (~12.29 bits).")
    print("  2) me–mtau–md (-4,4,3) Yukawa triple (7–14 bits).")
    print()
    print("WHAT WE HAVE ALREADY MAPPED OUT:")
    print("  • A robust statistical case that BOTH sectors are genuine locks,")
    print("    not flukes of the null models.")
    print("  • A detailed 3D integer Yukawa geometry (Toy3D) that:")
    print("      - Enforces the (-4,4,3) relation at the coefficient level.")
    print("      - Fits all 9 Yukawas to ≲ 0.01 dex RMS.")
    print("      - Is moderately surprising under nulls, but derivative of")
    print("        the primary triple, so not a separate lock.")
    print("  • Multiple nullscans showing NO second Yukawa triple lock and")
    print("    NO extra independent bits from 2D/3D structures or q-relations.")
    print()
    print("WHAT COUNTS AS *SUPPORTING SHAPE* (no extra bits):")
    print("  • 2D & 3D small-integer Yukawa geometries and their stability.")
    print("  • Integer relations among the 3D q-vector.")
    print("  • Secondary 3-term relations among Yukawas (e.g. (mt,ms,mu)).")
    print("  • FN-compatibility checks that constrain how Toy3D could come")
    print("    from multi-spurion models.")
    print()
    print("NEXT STEPS FOR MODEL-BUILDING (high level):")
    print("  A) DNA sector:")
    print("     - Propose explicit geometries / combinatorial structures")
    print("       that generate the DNA backbone + lock-family patterns.")
    print("     - Each candidate must be testable: it should output the")
    print("       backbone/locks in a way the existing DNA lock-checkers")
    print("       (from earlier phases) can verify.")
    print()
    print("  B) Yukawa sector:")
    print("     - Use Toy3D and its integer charges as a *hint* about an")
    print("       underlying charge lattice / symmetry structure.")
    print("     - Explore multi-spurion FN-like models or discrete symmetries")
    print("       that naturally reproduce the triple and the 9-point pattern,")
    print("       without over-tuning.")
    print()
    print("  C) JOINT DNA–YUKAWA GEOMETRY:")
    print("     - Long-term goal: a single geometry / code / lattice / graph")
    print("       that explains BOTH sectors at once.")
    print("     - The global contract (~20–27 bits) is your target to hit.")
    print("     - Any candidate that claims success must be run through the")
    print("       existing lock-checkers and scored with the scorecard tools.")
    print()
    print("USAGE REMINDER:")
    print("  • Use:")
    print("      - score_geometry(...) / register_geometry_hypothesis(...)")
    print("        for abstract claims (\"this model explains DNA and/or Yukawa\").")
    print("      - evaluate_yukawa_geometry(...)")
    print("        for explicit (C, q) Yukawa charge/spurion models.")
    print("  • Then re-run the scoreboard printer (PHASE 25) to see where the")
    print("    new geometry sits relative to NullGeometry and PerfectLockGeometry.")
    print()
    print("This module itself adds NO new bits of evidence; it just keeps the")
    print("project coherent and points the way forward.")
    print()
    print("PHASE27_GLOBAL_GEOMETRY_CONSISTENCY_AND_ROADMAP_v1 COMPLETE")
    print("=" * 80)


# Auto-run if executed as a script / cell
if __name__ == "__main__":
    run_phase27_global_geometry_consistency_and_roadmap()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PHASE 28 – MODULE 1: GLOBAL GEOMETRY SNAPSHOT INSPECTOR (v1)

Purpose
-------
Given a JSON snapshot (e.g. global_geometry_snapshot_phase26.json)
created by PHASE 26, this module:

  1) Loads the snapshot from disk.
  2) Computes a SHA256 of the raw file contents.
  3) Prints high-level consistency info:
       - presence of GLOBAL_LOCKS_v4
       - presence and size of GEOM_EVIDENCE
       - presence and size of geometry scorecards / scoreboard
       - presence of Yukawa data
  4) Compares the snapshot's GLOBAL_LOCKS_v4 against any in-memory
     GLOBAL_LOCKS_v4 (if present), to check that your current session
     still matches the saved contract.

This is a diagnostic / bookkeeping tool. It does NOT change any
evidence or contracts; it just reads and reports.
"""

import json
import hashlib
from datetime import datetime
from typing import Any, Dict, Optional

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _safe_get(name: str, default: Any = None) -> Any:
    """
    Safely fetch a global variable by name; return default if not present.
    """
    try:
        return globals()[name]
    except KeyError:
        return default


def _file_sha256(path: str) -> str:
    """
    Compute SHA256 hash of a file given by `path`.
    """
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(65536), b""):
            h.update(chunk)
    return h.hexdigest()


def _canonical_sha256(obj: Any) -> str:
    """
    Canonical JSON SHA256 of a small in-memory object.
    """
    s = json.dumps(obj, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


# ---------------------------------------------------------------------------
# Core logic
# ---------------------------------------------------------------------------

def run_phase28_global_geometry_snapshot_inspector(
    snapshot_path: str = "global_geometry_snapshot_phase26.json",
) -> None:
    """
    Load a saved global geometry snapshot JSON and print consistency info.
    """
    timestamp = datetime.now().isoformat()

    print("=" * 80)
    print(" PHASE 28 – MODULE 1: GLOBAL GEOMETRY SNAPSHOT INSPECTOR (v1) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Snapshot path         : {snapshot_path}")
    print()

    # ----------------------------------------------------------------------
    # 1. Try to load the snapshot file
    # ----------------------------------------------------------------------
    try:
        file_sha = _file_sha256(snapshot_path)
    except FileNotFoundError:
        print("ERROR: Snapshot file not found.")
        print("       Make sure you ran PHASE 26 in the same directory, or")
        print(f"       adjust snapshot_path to the correct JSON file.")
        print()
        print("PHASE28_GLOBAL_GEOMETRY_SNAPSHOT_INSPECTOR_v1 ABORTED (NO FILE)")
        print("=" * 80)
        return

    print(f"Snapshot file SHA256  : {file_sha}")
    print()

    with open(snapshot_path, "r", encoding="utf-8") as f:
        snapshot = json.load(f)

    # For reproducible reference, also hash the in-memory JSON object
    obj_sha = _canonical_sha256(snapshot)
    print(f"Snapshot JSON SHA256  : {obj_sha}")
    print()

    # The Phase 26 writer used something like:
    # {
    #   "global_locks_v4": ...,
    #   "geom_evidence": ...,
    #   "geometry_scorecards": ...,
    #   "global_geometry_scoreboard_v2": ...,
    #   "toy3d_integer_geometry_v1": ...,
    #   "yukawa_data": ...
    # }
    global_locks_snap: Optional[Dict[str, Any]] = snapshot.get("global_locks_v4")
    geom_evidence_snap: Optional[Dict[str, Any]] = snapshot.get("geom_evidence")
    scorecards_snap: Optional[Any] = snapshot.get("geometry_scorecards")
    scoreboard_snap: Optional[Any] = snapshot.get("global_geometry_scoreboard_v2")
    toy3d_snap: Any = snapshot.get("toy3d_integer_geometry_v1")
    yukawa_data_snap: Any = snapshot.get("yukawa_data")

    # ----------------------------------------------------------------------
    # 2. Presence summary
    # ----------------------------------------------------------------------
    print("=" * 80)
    print(" SNAPSHOT CONTENT SUMMARY ")
    print("=" * 80)
    print()

    def _present_label(x: Any) -> str:
        return "present" if x is not None else "missing"

    print(f"  • global_locks_v4              : {_present_label(global_locks_snap)}")
    print(f"  • geom_evidence                : {_present_label(geom_evidence_snap)}")
    print(f"  • geometry_scorecards          : {_present_label(scorecards_snap)}")
    print(f"  • global_geometry_scoreboard_v2: {_present_label(scoreboard_snap)}")
    print(f"  • toy3d_integer_geometry_v1    : {_present_label(toy3d_snap)}")
    print(f"  • yukawa_data                  : {_present_label(yukawa_data_snap)}")
    print()

    # Sizes / counts where applicable
    if isinstance(geom_evidence_snap, dict):
        print(f"  geom_evidence entries          : {len(geom_evidence_snap)}")
    if isinstance(scorecards_snap, list):
        print(f"  geometry_scorecards entries    : {len(scorecards_snap)}")
    if isinstance(scoreboard_snap, list):
        print(f"  scoreboard rows                : {len(scoreboard_snap)}")
    print()

    # ----------------------------------------------------------------------
    # 3. Compare snapshot GLOBAL_LOCKS_v4 vs in-memory GLOBAL_LOCKS_v4
    # ----------------------------------------------------------------------
    print("=" * 80)
    print(" GLOBAL LOCKS CONSISTENCY CHECK ")
    print("=" * 80)
    print()

    global_locks_mem = _safe_get("GLOBAL_LOCKS_v4", None)

    if global_locks_snap is None:
        print("Snapshot has no 'global_locks_v4' key.")
        print("→ This snapshot may be incomplete or from an earlier phase.")
    else:
        sha_snap = _canonical_sha256(global_locks_snap)
        print(f"Snapshot GLOBAL_LOCKS_v4 SHA256 : {sha_snap}")

        if global_locks_mem is None:
            print("In-memory GLOBAL_LOCKS_v4        : not present.")
            print("→ You can restore it by loading this snapshot into the")
            print("  interpreter (not done automatically here).")
        else:
            sha_mem = _canonical_sha256(global_locks_mem)
            print(f"In-memory GLOBAL_LOCKS_v4 SHA256: {sha_mem}")

            if sha_mem == sha_snap:
                print("→ In-memory contract matches snapshot (SHA identical).")
            else:
                print("→ WARNING: In-memory contract differs from snapshot.")
                print("   This is not necessarily an error, but you should be")
                print("   aware of which version you treat as authoritative.")
    print()

    # ----------------------------------------------------------------------
    # 4. Very brief Yukawa data sanity (if present)
    # ----------------------------------------------------------------------
    print("=" * 80)
    print(" YUKAWA DATA QUICK CHECK ")
    print("=" * 80)
    print()

    if isinstance(yukawa_data_snap, dict):
        names = list(yukawa_data_snap.keys())
        print(f"Yukawa entries in snapshot: {len(names)}")
        if names:
            preview = ", ".join(names[:5])
            if len(names) > 5:
                preview += ", ..."
            print(f"  Example keys: {preview}")
    else:
        print("No structured Yukawa data found in snapshot.")
    print()

    # ----------------------------------------------------------------------
    # 5. Closing notes
    # ----------------------------------------------------------------------
    print("INTERPRETATION:")
    print("  • This inspector is purely diagnostic: it reads the saved file and")
    print("    tells you what is inside, and whether it matches your current")
    print("    session's GLOBAL_LOCKS_v4 (if any).")
    print("  • It does NOT mutate your current in-memory state.")
    print("  • Use this to:")
    print("      - Verify archival integrity (via SHA256).")
    print("      - Confirm that future work is built on a known contract.")
    print()
    print("Next steps you *could* take after this:")
    print("  • Write a small loader module that restores GLOBAL_LOCKS_v4,")
    print("    GEOM_EVIDENCE, and GEOMETRY_SCORECARDS from a chosen snapshot.")
    print("  • Keep exporting periodic snapshots (PHASE 26) as you develop")
    print("    new candidate geometries.")
    print()
    print("PHASE28_GLOBAL_GEOMETRY_SNAPSHOT_INSPECTOR_v1 COMPLETE")
    print("=" * 80)


# Auto-run if executed as a script / cell
if __name__ == "__main__":
    run_phase28_global_geometry_snapshot_inspector()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PHASE 29 – MODULE 1: GLOBAL GEOMETRY SNAPSHOT LOADER (v1)

Purpose
-------
Given a JSON snapshot created by PHASE 26 (e.g.
  global_geometry_snapshot_phase26.json),
this module:

  1) Loads the snapshot from disk.
  2) Computes SHA256 of the raw file and of the JSON object.
  3) Optionally REPLACES or MERGES the current in-memory globals:
       - GLOBAL_LOCKS_v4
       - GEOM_EVIDENCE
       - GEOMETRY_SCORECARDS
       - GLOBAL_GEOMETRY_SCOREBOARD_V2
       - TOY3D_INTEGER_GEOMETRY_V1
       - YUKAWA_DATA
  4) Prints a summary of what was restored.

This is the inverse of PHASE 26 (snapshot exporter) plus PHASE 28
(inspector). It lets you resume work in a fresh Python session using
a previously archived state.

It does NOT change the logical content of the evidence; it just
restores what you already had.
"""

import json
import hashlib
from datetime import datetime
from typing import Any, Dict, List, Optional, Union

# Type aliases for clarity
JSONType = Union[Dict[str, Any], List[Any], str, int, float, bool, None]


# ---------------------------------------------------------------------------
# Helper utilities
# ---------------------------------------------------------------------------

def _file_sha256(path: str) -> str:
    """
    Compute SHA256 hash of a file given by `path`.
    """
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(65536), b""):
            h.update(chunk)
    return h.hexdigest()


def _canonical_sha256(obj: JSONType) -> str:
    """
    Compute SHA256 of a JSON-serializable object using a canonical
    representation (sorted keys, compact separators).
    """
    s = json.dumps(obj, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


def _present_label(x: Any) -> str:
    return "present" if x is not None else "missing"


def _ensure_list(x: Any) -> List[Any]:
    """
    Ensure x is a list; if dict, wrap it; if None, return [].
    """
    if x is None:
        return []
    if isinstance(x, list):
        return x
    # If someone accidentally saved a single scorecard dict, wrap it
    return [x]


# ---------------------------------------------------------------------------
# Core loader
# ---------------------------------------------------------------------------

def load_global_geometry_snapshot(
    snapshot_path: str = "global_geometry_snapshot_phase26.json",
    *,
    mode: str = "replace",
) -> None:
    """
    Load a saved global geometry snapshot and populate globals.

    Parameters
    ----------
    snapshot_path : str
        Path to the JSON snapshot file generated by PHASE 26.
    mode : {"replace", "merge"}
        - "replace": overwrite existing globals with snapshot contents.
        - "merge"  : keep existing data and update/extend from snapshot
                     when sensible (e.g. merge GEOM_EVIDENCE dicts,
                     extend GEOMETRY_SCORECARDS list).
    """
    timestamp = datetime.now().isoformat()

    print("=" * 80)
    print(" PHASE 29 – MODULE 1: GLOBAL GEOMETRY SNAPSHOT LOADER (v1) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"Snapshot path         : {snapshot_path}")
    print(f"Load mode             : {mode}")
    print()

    # ----------------------------------------------------------------------
    # 1. Load file and compute hashes
    # ----------------------------------------------------------------------
    try:
        file_sha = _file_sha256(snapshot_path)
    except FileNotFoundError:
        print("ERROR: Snapshot file not found.")
        print("       Make sure the path is correct or re-run PHASE 26.")
        print()
        print("PHASE29_GLOBAL_GEOMETRY_SNAPSHOT_LOADER_v1 ABORTED (NO FILE)")
        print("=" * 80)
        return

    print(f"Snapshot file SHA256  : {file_sha}")

    with open(snapshot_path, "r", encoding="utf-8") as f:
        snapshot: Dict[str, JSONType] = json.load(f)

    obj_sha = _canonical_sha256(snapshot)
    print(f"Snapshot JSON SHA256  : {obj_sha}")
    print()

    # Expected keys from PHASE 26 exporter
    global_locks_snap = snapshot.get("global_locks_v4")
    geom_evidence_snap = snapshot.get("geom_evidence")
    scorecards_snap = snapshot.get("geometry_scorecards")
    scoreboard_snap = snapshot.get("global_geometry_scoreboard_v2")
    toy3d_snap = snapshot.get("toy3d_integer_geometry_v1")
    yukawa_snap = snapshot.get("yukawa_data")

    print("=" * 80)
    print(" SNAPSHOT CONTENTS (BEFORE LOAD) ")
    print("=" * 80)
    print()
    print(f"  • global_locks_v4              : {_present_label(global_locks_snap)}")
    print(f"  • geom_evidence                : {_present_label(geom_evidence_snap)}")
    print(f"  • geometry_scorecards          : {_present_label(scorecards_snap)}")
    print(f"  • global_geometry_scoreboard_v2: {_present_label(scoreboard_snap)}")
    print(f"  • toy3d_integer_geometry_v1    : {_present_label(toy3d_snap)}")
    print(f"  • yukawa_data                  : {_present_label(yukawa_snap)}")
    print()

    # ----------------------------------------------------------------------
    # 2. Load / merge into globals
    # ----------------------------------------------------------------------
    # We will modify these globals if present / needed
    global GLOBAL_LOCKS_v4
    global GEOM_EVIDENCE
    global GEOMETRY_SCORECARDS
    global GLOBAL_GEOMETRY_SCOREBOARD_V2
    global TOY3D_INTEGER_GEOMETRY_V1
    global YUKAWA_DATA

    # 2a. GLOBAL_LOCKS_v4 (usually completely replaced)
    if global_locks_snap is not None:
        if mode == "replace" or "GLOBAL_LOCKS_v4" not in globals():
            GLOBAL_LOCKS_v4 = global_locks_snap  # type: ignore[assignment]
            print("  • GLOBAL_LOCKS_v4 set from snapshot.")
        else:
            # Merge is trivial here; we prefer snapshot as canonical
            GLOBAL_LOCKS_v4 = global_locks_snap  # type: ignore[assignment]
            print("  • GLOBAL_LOCKS_v4 replaced from snapshot (merge mode).")
    else:
        print("  • GLOBAL_LOCKS_v4 not found in snapshot (unchanged).")

    # 2b. GEOM_EVIDENCE (dict)
    if isinstance(geom_evidence_snap, dict):
        if mode == "replace" or "GEOM_EVIDENCE" not in globals():
            GEOM_EVIDENCE = dict(geom_evidence_snap)  # shallow copy
            print("  • GEOM_EVIDENCE set from snapshot.")
        else:
            # Merge: existing entries stay unless overwritten by snapshot
            existing = globals().get("GEOM_EVIDENCE", {})
            if not isinstance(existing, dict):
                existing = {}
            merged = dict(existing)
            merged.update(geom_evidence_snap)
            GEOM_EVIDENCE = merged  # type: ignore[assignment]
            print("  • GEOM_EVIDENCE merged with snapshot contents.")
    else:
        print("  • GEOM_EVIDENCE not found or not a dict in snapshot (unchanged).")

    # 2c. GEOMETRY_SCORECARDS (list of scorecard dicts)
    if scorecards_snap is not None:
        snap_list = _ensure_list(scorecards_snap)
        if mode == "replace" or "GEOMETRY_SCORECARDS" not in globals():
            GEOMETRY_SCORECARDS = list(snap_list)  # type: ignore[assignment]
            print("  • GEOMETRY_SCORECARDS set from snapshot "
                  f"({len(snap_list)} entries).")
        else:
            existing_sc = globals().get("GEOMETRY_SCORECARDS", [])
            if not isinstance(existing_sc, list):
                existing_sc = _ensure_list(existing_sc)
            combined = list(existing_sc) + snap_list
            GEOMETRY_SCORECARDS = combined  # type: ignore[assignment]
            print("  • GEOMETRY_SCORECARDS extended with snapshot entries "
                  f"(+{len(snap_list)}).")
    else:
        print("  • GEOMETRY_SCORECARDS not found in snapshot (unchanged).")

    # 2d. GLOBAL_GEOMETRY_SCOREBOARD_V2 (list of rows)
    if scoreboard_snap is not None:
        rows = _ensure_list(scoreboard_snap)
        if mode == "replace" or "GLOBAL_GEOMETRY_SCOREBOARD_V2" not in globals():
            GLOBAL_GEOMETRY_SCOREBOARD_V2 = rows  # type: ignore[assignment]
            print("  • GLOBAL_GEOMETRY_SCOREBOARD_V2 set from snapshot "
                  f"({len(rows)} rows).")
        else:
            existing_sb = globals().get("GLOBAL_GEOMETRY_SCOREBOARD_V2", [])
            if not isinstance(existing_sb, list):
                existing_sb = _ensure_list(existing_sb)
            combined_sb = list(existing_sb) + rows
            GLOBAL_GEOMETRY_SCOREBOARD_V2 = combined_sb  # type: ignore[assignment]
            print("  • GLOBAL_GEOMETRY_SCOREBOARD_V2 extended with snapshot rows "
                  f"(+{len(rows)}).")
    else:
        print("  • GLOBAL_GEOMETRY_SCOREBOARD_V2 not found in snapshot (unchanged).")

    # 2e. TOY3D_INTEGER_GEOMETRY_V1 (structured object or None)
    if toy3d_snap is not None:
        TOY3D_INTEGER_GEOMETRY_V1 = toy3d_snap  # type: ignore[assignment]
        print("  • TOY3D_INTEGER_GEOMETRY_V1 set from snapshot.")
    else:
        print("  • TOY3D_INTEGER_GEOMETRY_V1 not found in snapshot (unchanged).")

    # 2f. YUKAWA_DATA (dict with names / z_real / sigma_log10)
    if yukawa_snap is not None:
        if mode == "replace" or "YUKAWA_DATA" not in globals():
            YUKAWA_DATA = yukawa_snap  # type: ignore[assignment]
            print("  • YUKAWA_DATA set from snapshot.")
        else:
            # Merge keys if both are dicts; otherwise snapshot wins
            existing_y = globals().get("YUKAWA_DATA", {})
            if isinstance(existing_y, dict) and isinstance(yukawa_snap, dict):
                merged_y = dict(existing_y)
                merged_y.update(yukawa_snap)
                YUKAWA_DATA = merged_y  # type: ignore[assignment]
                print("  • YUKAWA_DATA merged with snapshot contents.")
            else:
                YUKAWA_DATA = yukawa_snap  # type: ignore[assignment]
                print("  • YUKAWA_DATA replaced from snapshot (non-dict merge).")
    else:
        print("  • YUKAWA_DATA not found in snapshot (unchanged).")

    print()

    # ----------------------------------------------------------------------
    # 3. Post-load summary
    # ----------------------------------------------------------------------
    print("=" * 80)
    print(" POST-LOAD IN-MEMORY SUMMARY ")
    print("=" * 80)
    print()

    # GLOBAL_LOCKS_v4
    if "GLOBAL_LOCKS_v4" in globals():
        sha_gl = _canonical_sha256(globals()["GLOBAL_LOCKS_v4"])  # type: ignore[index]
        print(f"GLOBAL_LOCKS_v4 present, SHA256: {sha_gl}")
    else:
        print("GLOBAL_LOCKS_v4 not present in memory.")

    # GEOM_EVIDENCE
    ge = globals().get("GEOM_EVIDENCE", None)
    if isinstance(ge, dict):
        print(f"GEOM_EVIDENCE present with {len(ge)} entries.")
    else:
        print("GEOM_EVIDENCE not present or not a dict.")

    # GEOMETRY_SCORECARDS
    sc = globals().get("GEOMETRY_SCORECARDS", None)
    if isinstance(sc, list):
        print(f"GEOMETRY_SCORECARDS present with {len(sc)} entries.")
    else:
        print("GEOMETRY_SCORECARDS not present or not a list.")

    # GLOBAL_GEOMETRY_SCOREBOARD_V2
    sb2 = globals().get("GLOBAL_GEOMETRY_SCOREBOARD_V2", None)
    if isinstance(sb2, list):
        print(f"GLOBAL_GEOMETRY_SCOREBOARD_V2 present with {len(sb2)} rows.")
    else:
        print("GLOBAL_GEOMETRY_SCOREBOARD_V2 not present or not a list.")

    # TOY3D_INTEGER_GEOMETRY_V1
    if "TOY3D_INTEGER_GEOMETRY_V1" in globals():
        print("TOY3D_INTEGER_GEOMETRY_V1 present in memory.")
    else:
        print("TOY3D_INTEGER_GEOMETRY_V1 not present in memory.")

    # YUKAWA_DATA
    if "YUKAWA_DATA" in globals():
        y = globals()["YUKAWA_DATA"]
        if isinstance(y, dict):
            print("YUKAWA_DATA present (dict). Keys:", ", ".join(list(y.keys())[:5]))
        else:
            print("YUKAWA_DATA present but not a dict.")
    else:
        print("YUKAWA_DATA not present in memory.")

    print()
    print("INTERPRETATION:")
    print("  • Snapshot has been loaded according to the chosen mode "
          f"('{mode}').")
    print("  • Use 'replace' when you want to fully restore a past state.")
    print("  • Use 'merge' if you want to accumulate evidence and scorecards")
    print("    from multiple snapshots in one session.")
    print()
    print("PHASE29_GLOBAL_GEOMETRY_SNAPSHOT_LOADER_v1 COMPLETE")
    print("=" * 80)


# Auto-run if executed as a script / cell
if __name__ == "__main__":
    load_global_geometry_snapshot()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PHASE 30 – MODULE 1: 3-SPURION FN-LIKE YUKAWA GEOMETRY SEARCH (v1)

Goal
----
Search for a *true* 3-spurion Froggatt–Nielsen-like geometry that:

  • Uses 3 spurions λ_j with log10(λ_j) = q_j < 0 (all spurions < 1).
  • Assigns NON-NEGATIVE integer charges C_{ij} to each Yukawa i, j=1..3.
  • Enforces the (-4,4,3) lock at the *coefficient* level:
        -4 row(me) + 4 row(tau) + 3 row(d) = 0  (vector equation)
    so that the triple arises structurally, not by tuning q.
  • Fits all 9 Yukawas as z_i ≈ (C_i · q) with small RMS.

This is a “from-scratch” FN-style search with small charges, *not*
just a basis transform of Toy3D. It’s a real test of whether a simple
3-spurion FN picture can exist with small, non-negative charges.
"""

import numpy as np
import itertools
import json
import hashlib
from datetime import datetime
from numpy.linalg import LinAlgError


def _sha256_payload(obj) -> str:
    s = json.dumps(obj, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


def run_phase30_yukawa_3spurion_fn_search(
    C_basis_max: int = 4,
    C_other_max: int = 4,
    q_neg_only: bool = True,
) -> None:
    """
    Main driver for PHASE 30 – FN-like 3-spurion search.

    Parameters
    ----------
    C_basis_max : int
        Max charge for basis Yukawas (me, mtau, d) in each spurion.
    C_other_max : int
        Max charge for the other six Yukawas in each spurion.
    q_neg_only : bool
        If True, require q_j < 0 (spurions λ_j < 1).
    """
    timestamp = datetime.now().isoformat()

    print("=" * 80)
    print(" PHASE 30 – MODULE 1: 3-SPURION FN-LIKE YUKAWA GEOMETRY SEARCH (v1) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"C_basis_max           : {C_basis_max}")
    print(f"C_other_max           : {C_other_max}")
    print(f"q_neg_only            : {q_neg_only}")
    print()

    # ------------------------------------------------------------------ #
    # 0. Check we have YUKAWA_DATA restored from snapshot
    # ------------------------------------------------------------------ #
    if "YUKAWA_DATA" not in globals():
        print("ERROR: YUKAWA_DATA not found in globals.")
        print("       Make sure you loaded a snapshot or defined YUKAWA_DATA.")
        print()
        print("PHASE30_YUKAWA_3SPURION_FN_SEARCH_v1 ABORTED")
        print("=" * 80)
        return

    yuk = YUKAWA_DATA  # type: ignore[name-defined]
    names = list(yuk["names"])
    z_real = np.array(yuk["z_real"], dtype=float)

    # Find indices of me, tau, d
    try:
        idx_me = names.index("me_over_v")
        idx_tau = names.index("mtau_over_v")
        idx_d = names.index("md_over_v")
    except ValueError as e:
        print("ERROR: me_over_v, mtau_over_v, or md_over_v not found in YUKAWA_DATA['names'].")
        print("       Names present:", names)
        print()
        print("PHASE30_YUKAWA_3SPURION_FN_SEARCH_v1 ABORTED")
        print("=" * 80)
        return

    # Triple lock from real data
    z_me = z_real[idx_me]
    z_tau = z_real[idx_tau]
    z_d = z_real[idx_d]
    S_real = abs(-4 * z_me + 4 * z_tau + 3 * z_d)

    print("Real Yukawa logs (subset):")
    print(f"  me_over_v   z_me   = {z_me: .6f}")
    print(f"  mtau_over_v z_tau  = {z_tau: .6f}")
    print(f"  md_over_v   z_d    = {z_d: .6f}")
    print(f"  S_real = |-4 z_me + 4 z_tau + 3 z_d| = {S_real: .6e}")
    print()

    # ------------------------------------------------------------------ #
    # 1. Build basis candidates for (me, tau, d) with FN-like constraints
    # ------------------------------------------------------------------ #
    print("=" * 80)
    print(" BUILDING FN-LIKE BASIS CANDIDATES FOR (me, tau, d) ")
    print("=" * 80)
    print()

    charges_range = range(0, C_basis_max + 1)
    basis_candidates = []

    # We construct:
    #   row(me) = A
    #   row(tau) = B
    #   row(d) = C = (4*(A - B))/3
    # with all entries in [0, C_basis_max] and integer.
    for a in itertools.product(charges_range, repeat=3):
        A = np.array(a, dtype=int)
        for b in itertools.product(charges_range, repeat=3):
            B = np.array(b, dtype=int)
            diff = A - B
            # Check integrality of C = 4*(A-B)/3
            if np.any((4 * diff) % 3 != 0):
                continue
            C = (4 * diff) // 3
            # Require non-negative and within bounds
            if np.any(C < 0) or np.any(C > C_basis_max):
                continue
            # 3×3 basis matrix (rows in order me, tau, d)
            C_basis = np.vstack([A, B, C])
            # Check invertibility (need to solve for q)
            det = round(np.linalg.det(C_basis))
            if det == 0:
                continue
            basis_candidates.append(C_basis)

    basis_candidates = list(basis_candidates)
    num_basis = len(basis_candidates)
    print(f"  C_basis_max             : {C_basis_max}")
    print(f"  Non-negative FN basis candidates found: {num_basis}")
    print("  (All satisfy -4 row(me) + 4 row(tau) + 3 row(d) = 0 by construction.)")
    print()

    if num_basis == 0:
        print("No FN-compatible basis for (me, tau, d) found within given bounds.")
        print("→ Within C_basis_max and non-negative charges, there is no 3-spurion")
        print("  structure that enforces the (-4,4,3) triple at coefficient level.")
        print()
        payload = {
            "module": "PHASE30_YUKAWA_3SPURION_FN_SEARCH_v1",
            "timestamp": timestamp,
            "C_basis_max": C_basis_max,
            "C_other_max": C_other_max,
            "q_neg_only": q_neg_only,
            "num_basis_candidates": 0,
            "result": "no_basis_candidates_found",
        }
        sha = _sha256_payload(payload)
        print(f"Run SHA256 payload    : {sha}")
        print()
        print("PHASE30_YUKAWA_3SPURION_FN_SEARCH_v1 COMPLETE")
        print("=" * 80)
        return

    # ------------------------------------------------------------------ #
    # 2. For each basis candidate, solve for q and assign rows to others
    # ------------------------------------------------------------------ #
    print("=" * 80)
    print(" SEARCHING OVER BASIS CANDIDATES AND ASSIGNING OTHER YUKAWAS ")
    print("=" * 80)
    print()

    all_indices = list(range(len(names)))
    other_indices = [i for i in all_indices if i not in (idx_me, idx_tau, idx_d)]

    best_result = None

    for k, C_basis in enumerate(basis_candidates, start=1):
        # Solve C_basis * q = [z_me, z_tau, z_d]
        z_basis = np.array([z_me, z_tau, z_d], dtype=float)
        try:
            q = np.linalg.solve(C_basis.astype(float), z_basis)
        except LinAlgError:
            continue

        if q_neg_only and not np.all(q < 0.0):
            # Spurions not all < 1; skip if we want strict FN
            continue

        # Build full 9×3 C matrix
        C_full = np.zeros((len(names), 3), dtype=int)
        C_full[idx_me, :] = C_basis[0]
        C_full[idx_tau, :] = C_basis[1]
        C_full[idx_d, :] = C_basis[2]

        # Assign charges for other Yukawas by brute-force search
        charges_range_other = range(0, C_other_max + 1)
        z_pred = np.zeros_like(z_real)
        z_pred[idx_me] = z_me
        z_pred[idx_tau] = z_tau
        z_pred[idx_d] = z_d

        ok = True

        for i in other_indices:
            best_row = None
            best_res = np.inf
            for c_tuple in itertools.product(charges_range_other, repeat=3):
                c_vec = np.array(c_tuple, dtype=float)
                # allow zero row; it's just "no spurion" for that Yukawa
                z_est = float(c_vec @ q)
                res = abs(z_est - z_real[i])
                if res < best_res:
                    best_res = res
                    best_row = c_vec
            if best_row is None:
                ok = False
                break
            C_full[i, :] = best_row.astype(int)
            z_pred[i] = float(best_row @ q)

        if not ok:
            continue

        residuals = z_pred - z_real
        RMS_all = float(np.sqrt(np.mean(residuals**2)))
        max_resid = float(np.max(np.abs(residuals)))
        C_max_full = int(np.max(np.abs(C_full)))

        # Geometry triple from z_pred
        S_geom = abs(-4 * z_pred[idx_me] + 4 * z_pred[idx_tau] + 3 * z_pred[idx_d])
        ratio = S_geom / S_real if S_real > 0 else np.nan

        candidate = {
            "C_basis": C_basis.tolist(),
            "C_full": C_full.tolist(),
            "q": q.tolist(),
            "RMS_all": RMS_all,
            "max_resid": max_resid,
            "C_max_full": C_max_full,
            "S_geom": S_geom,
            "S_geom_over_S_real": ratio,
            "basis_index": k,
        }

        if best_result is None or RMS_all < best_result["RMS_all"]:
            best_result = candidate

    # ------------------------------------------------------------------ #
    # 3. Report results
    # ------------------------------------------------------------------ #
    if best_result is None:
        print("No FN-like 3-spurion geometry found that fits all 9 Yukawas")
        print("within the explored charge bounds and q_neg_only constraints.")
        print()
        payload = {
            "module": "PHASE30_YUKAWA_3SPURION_FN_SEARCH_v1",
            "timestamp": timestamp,
            "C_basis_max": C_basis_max,
            "C_other_max": C_other_max,
            "q_neg_only": q_neg_only,
            "num_basis_candidates": num_basis,
            "result": "no_geometry_found",
        }
        sha = _sha256_payload(payload)
        print(f"Run SHA256 payload    : {sha}")
        print()
        print("PHASE30_YUKAWA_3SPURION_FN_SEARCH_v1 COMPLETE")
        print("=" * 80)
        return

    # If we get here, we have a best_result
    C_basis_best = np.array(best_result["C_basis"], dtype=int)
    C_full_best = np.array(best_result["C_full"], dtype=int)
    q_best = np.array(best_result["q"], dtype=float)
    RMS_best = best_result["RMS_all"]
    max_resid_best = best_result["max_resid"]
    C_max_best = best_result["C_max_full"]
    S_geom_best = best_result["S_geom"]
    ratio_best = best_result["S_geom_over_S_real"]

    print("=" * 80)
    print(" BEST 3-SPURION FN-LIKE GEOMETRY FOUND (WITHIN BOUNDS) ")
    print("=" * 80)
    print()
    print("Basis coefficient rows for (me, tau, d):")
    print(f"  row(me)  = {C_basis_best[0].tolist()}")
    print(f"  row(tau) = {C_basis_best[1].tolist()}")
    print(f"  row(d)   = {C_basis_best[2].tolist()}")
    print()
    print("Fitted spurion logs q (log10 λ_j):")
    print(f"  q1 = {q_best[0]: .6f}")
    print(f"  q2 = {q_best[1]: .6f}")
    print(f"  q3 = {q_best[2]: .6f}")
    print()
    print("Fit quality over all 9 Yukawas:")
    print(f"  RMS_all (dex)        : {RMS_best: .6f}")
    print(f"  Max |residual| (dex) : {max_resid_best: .6f}")
    print(f"  Max |integer coeff|  : {C_max_best}")
    print()
    print("Triple lock on geometry (using z_pred):")
    print(f"  S_real               : {S_real: .6e}")
    print(f"  S_geom               : {S_geom_best: .6e}")
    print(f"  S_geom / S_real      : {ratio_best: .3e}")
    print()

    # Per-Yukawa table
    print("Per-Yukawa integer coefficients and residuals (geom - real):")
    print("  name         (c1,c2,c3)      z_real       z_geom       resid")
    print("  -----------  ----------    ----------   ----------   ----------")
    z_pred_best = C_full_best @ q_best
    for i, name in enumerate(names):
        c1, c2, c3 = C_full_best[i]
        zr = z_real[i]
        zg = z_pred_best[i]
        resid = zg - zr
        print(f"  {name:11s}  ({c1:2d},{c2:2d},{c3:2d})"
              f"    {zr: .6f}    {zg: .6f}    {resid: .6f}")
    print()

    # ------------------------------------------------------------------ #
    # 4. Interpretation + hash payload
    # ------------------------------------------------------------------ #
    if RMS_best <= 0.01:
        verdict = "FN_candidate_found_good_fit"
    else:
        verdict = "FN_candidate_found_but_poor_fit"

    payload = {
        "module": "PHASE30_YUKAWA_3SPURION_FN_SEARCH_v1",
        "timestamp": timestamp,
        "C_basis_max": C_basis_max,
        "C_other_max": C_other_max,
        "q_neg_only": q_neg_only,
        "num_basis_candidates": num_basis,
        "best_result": {
            "C_basis": best_result["C_basis"],
            "C_full": best_result["C_full"],
            "q": best_result["q"],
            "RMS_all": RMS_best,
            "max_resid": max_resid_best,
            "C_max_full": C_max_best,
            "S_geom": S_geom_best,
            "S_geom_over_S_real": ratio_best,
        },
        "verdict": verdict,
    }
    sha = _sha256_payload(payload)

    print("=" * 80)
    print(" INTERPRETATION (STRUCTURAL, NOT NEW LOCK) ")
    print("=" * 80)
    print()
    print(f"  • Verdict: {verdict}")
    print("  • This module asks: does a simple 3-spurion FN model with")
    print("       – non-negative integer charges,")
    print("       – λ_j < 1 (q_j < 0), and")
    print("       – the (-4,4,3) triple enforced in coefficient space")
    print("    exist within small charge bounds and give a good fit?")
    print("  • Whatever the outcome, this is *shape* information only;")
    print("    it does NOT change the global DNA + Yukawa triple bit")
    print("    contract (~20–27 bits).")
    print()
    print(f"Run SHA256 payload    : {sha}")
    print()
    print("PHASE30_YUKAWA_3SPURION_FN_SEARCH_v1 COMPLETE")
    print("=" * 80)


# Auto-run if executed as a script
if __name__ == "__main__":
    run_phase30_yukawa_3spurion_fn_search()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PHASE 30 – MODULE 2: 3-SPURION FN-COMPATIBILITY EVIDENCE (v1)

Takes the outcome of PHASE 30 – MODULE 1 (from-scratch FN-like 3-spurion
search with non-negative charges) and records it in GEOM_EVIDENCE as a
STRUCTURAL constraint, not as extra bits.

Assumes:
  • The search was run with C_basis_max, C_other_max, q_neg_only.
  • In your last run, num_basis_candidates = 0 for C_basis_max=4.
"""

import json
import hashlib
from datetime import datetime

def _sha256_payload(obj) -> str:
    s = json.dumps(obj, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


def run_phase30_yukawa_3spurion_fn_evidence(
    C_basis_max: int = 4,
    C_other_max: int = 4,
    q_neg_only: bool = True,
    num_basis_candidates: int = 0,
) -> None:
    """
    Summarize the FN-like 3-spurion search as evidence.

    Parameters
    ----------
    C_basis_max : int
        Max charge used for (me, tau, d) in the search.
    C_other_max : int
        Max charge used for the other Yukawas.
    q_neg_only : bool
        Whether the search enforced q_j < 0.
    num_basis_candidates : int
        Number of non-negative basis candidates found that
        satisfy the coefficient-level (-4,4,3) triple.
        For your last run, this was 0.
    """
    timestamp = datetime.now().isoformat()

    print("=" * 80)
    print(" PHASE 30 – MODULE 2: 3-SPURION FN-COMPATIBILITY EVIDENCE (v1) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"C_basis_max           : {C_basis_max}")
    print(f"C_other_max           : {C_other_max}")
    print(f"q_neg_only            : {q_neg_only}")
    print(f"num_basis_candidates  : {num_basis_candidates}")
    print()

    # Interpretation
    if num_basis_candidates == 0:
        classification = "supporting_structure_shape"
        reason = (
            "Within small non-negative charges (<= C_basis_max) and strictly sub-unity "
            "spurions (q_j<0), no 3×3 integer basis for (me,mtau,md) exists that "
            "enforces the (-4,4,3) triple at coefficient level. Any realistic FN-like "
            "geometry must therefore relax at least one of these conditions "
            "(larger charges, negative charges, more spurions, etc.)."
        )
    else:
        classification = "supporting_structure_shape"
        reason = (
            "Some FN-like 3-spurion bases exist within the searched region; this "
            "constrains but does not on its own establish a new statistical lock."
        )

    # Bits are zero by design: this is a finite combinatorial / structural result
    bits = 0.0

    payload = {
        "module": "PHASE30_YUKAWA_3SPURION_FN_EVIDENCE_v1",
        "timestamp": timestamp,
        "C_basis_max": C_basis_max,
        "C_other_max": C_other_max,
        "q_neg_only": q_neg_only,
        "num_basis_candidates": num_basis_candidates,
        "bits": bits,
        "classification": classification,
        "reason": reason,
    }
    sha = _sha256_payload(payload)

    print("=" * 80)
    print(" INTERPRETATION & VERDICT ")
    print("=" * 80)
    print()
    print(f"  • classification : {classification}")
    print(f"  • bits           : {bits:.2f} (by design: structural, not probabilistic)")
    print()
    print("  Summary:")
    print(f"    {reason}")
    print()
    print("  Evidence-budget status:")
    print("    → This result is a SHAPE constraint on possible FN models.")
    print("    → It does NOT add bits to the global DNA + Yukawa triple contract.")
    print("    → Primary locks remain:")
    print("         1) DNA backbone / locks (~12.29 bits).")
    print("         2) me–mtau–md (-4,4,3) triple (7–14 bits).")
    print()

    # Update GEOM_EVIDENCE if present
    global GEOM_EVIDENCE
    try:
        GEOM_EVIDENCE  # type: ignore[name-defined]
    except NameError:
        GEOM_EVIDENCE = {}  # type: ignore[assignment]
        print("GEOM_EVIDENCE not found; creating new dict.")
        print()

    GEOM_EVIDENCE["yukawa_3spurion_fn_search"] = {
        "C_basis_max": C_basis_max,
        "C_other_max": C_other_max,
        "q_neg_only": q_neg_only,
        "num_basis_candidates": num_basis_candidates,
        "bits": bits,
        "classification": classification,
        "reason": reason,
        "timestamp": timestamp,
        "sha256": sha,
        "status": "supporting_structure_shape",
        "description": (
            "From-scratch search for 3-spurion FN-like geometry with non-negative "
            "charges and q_j<0 that enforces the (-4,4,3) triple at coefficient level; "
            "here num_basis_candidates=0 for C_basis_max<=4."
        ),
    }

    print("=" * 80)
    print(" GEOM_EVIDENCE UPDATE ")
    print("=" * 80)
    print()
    print("GEOM_EVIDENCE['yukawa_3spurion_fn_search'] =")
    print(json.dumps(GEOM_EVIDENCE["yukawa_3spurion_fn_search"], indent=2))
    print()
    print(f"Run SHA256 payload    : {sha}")
    print()
    print("PHASE30_YUKAWA_3SPURION_FN_EVIDENCE_v1 COMPLETE")
    print("=" * 80)


if __name__ == "__main__":
    # For your last run: num_basis_candidates was 0
    run_phase30_yukawa_3spurion_fn_evidence(
        C_basis_max=4,
        C_other_max=4,
        q_neg_only=True,
        num_basis_candidates=0,
    )

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PHASE 31 – MODULE 1: 3-SPURION FN-LIKE YUKAWA GEOMETRY SEARCH (MIXED-SIGN) v1

Idea:
  • Look for 3×3 integer basis for (me, tau, d) with entries in [-C_basis_max, C_basis_max].
  • Enforce the (-4,4,3) relation at coefficient level:
        -4 row(me) + 4 row(tau) + 3 row(d) = 0
  • Require the basis to be invertible (true 3-spurion structure).
  • Solve C_basis · q = z_basis for q = (log10 λ1, log10 λ2, log10 λ3).
  • Impose FN-like condition: q_j < 0 (all spurions < 1).
  • Count how many such bases exist for given C_basis_max.

Comparison to PHASE 30 – Module 1:
  • PHASE 30 enforced non-negative charges only (C_ij >= 0) and found 0 bases.
  • Here we allow mixed-sign charges in a small box, to test whether FN can be
    rescued by permitting negative charges without huge exponents.
"""

import numpy as np
import json
import hashlib
from datetime import datetime

def _sha256_payload(obj) -> str:
    s = json.dumps(obj, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


def run_phase31_yukawa_3spurion_fn_mixed_sign_search(
    C_basis_max: int = 4,
    q_neg_only: bool = True,
) -> None:
    """
    Search for 3-spurion FN-like bases for (me, tau, d) with mixed-sign charges.

    Charges for (me, tau, d) are allowed in [-C_basis_max, C_basis_max].
    row(me) = m, row(tau) = t, row(d) = d must satisfy:

        -4 m + 4 t + 3 d = 0

    We build candidates by choosing m and d, then deriving t.
    """

    timestamp = datetime.now().isoformat()
    print("=" * 80)
    print(" PHASE 31 – MODULE 1: 3-SPURION FN-LIKE SEARCH (MIXED-SIGN) v1 ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print(f"C_basis_max           : {C_basis_max}")
    print(f"q_neg_only            : {q_neg_only}")
    print()

    # Real Yukawa logs for (me, tau, d)
    # (Hard-coded here for self-containment; these match earlier phases.)
    z_me   = -5.683401
    z_tau  = -2.141781
    z_d    = -4.722162
    z_basis = np.array([z_me, z_tau, z_d], dtype=float)

    # We enforce -4 m + 4 t + 3 d = 0.
    # Writing this as 4 t = 4 m - 3 d, we take m,d integer and define:
    #   t = m - (3/4) d
    # For t to be integer, each component of d must be a multiple of 4.
    # With |d_j| <= C_basis_max, d_j ∈ { -4, 0, +4 } when C_basis_max >= 4.
    d_values = []
    for x in (-4, 0, 4):
        if abs(x) <= C_basis_max:
            d_values.append(x)
    d_values = tuple(d_values)

    num_candidates_total = 0
    num_invertible = 0
    fn_like_solutions = []

    # Enumerate row(d) in the restricted set with components multiple of 4.
    for d1 in d_values:
        for d2 in d_values:
            for d3 in d_values:
                row_d = np.array([d1, d2, d3], dtype=int)

                # Enumerate row(me) over full box [-C_basis_max, C_basis_max]^3
                for m1 in range(-C_basis_max, C_basis_max + 1):
                    for m2 in range(-C_basis_max, C_basis_max + 1):
                        for m3 in range(-C_basis_max, C_basis_max + 1):
                            row_m = np.array([m1, m2, m3], dtype=int)

                            # Compute row(tau) = row_m - (3/4) row_d
                            # Using integer arithmetic: 3 * row_d / 4 is always integer for d_j ∈ {-4,0,4}.
                            row_t = row_m - (3 * row_d // 4)

                            # Check that row_t lies within the same bounds
                            if not np.all(np.abs(row_t) <= C_basis_max):
                                continue

                            num_candidates_total += 1

                            # Form the basis matrix C_basis
                            C_basis = np.vstack([row_m, row_t, row_d])  # shape (3,3)

                            # Check invertibility
                            det = np.linalg.det(C_basis.astype(float))
                            if abs(det) < 1e-8:
                                continue
                            num_invertible += 1

                            # Solve for q: C_basis · q = z_basis
                            try:
                                q = np.linalg.solve(C_basis.astype(float), z_basis)
                            except np.linalg.LinAlgError:
                                continue

                            if q_neg_only and not np.all(q < 0.0):
                                continue

                            fn_like_solutions.append({
                                "row_me": row_m.tolist(),
                                "row_tau": row_t.tolist(),
                                "row_d": row_d.tolist(),
                                "C_basis": C_basis.tolist(),
                                "q": q.tolist(),
                                "det": float(det),
                            })

    num_fn_like = len(fn_like_solutions)

    print("=" * 80)
    print(" SEARCH SUMMARY ")
    print("=" * 80)
    print()
    print(f"  C_basis_max                   : {C_basis_max}")
    print(f"  d_j allowed values            : {d_values}")
    print(f"  Total (me,d) basis attempts   : {num_candidates_total}")
    print(f"  Invertible bases (3×3)        : {num_invertible}")
    print(f"  FN-like bases with q_j<0      : {num_fn_like}")
    print()

    if num_fn_like > 0:
        print("  Example FN-like basis (first solution):")
        sol = fn_like_solutions[0]
        print(f"    row(me)  = {sol['row_me']}")
        print(f"    row(tau) = {sol['row_tau']}")
        print(f"    row(d)   = {sol['row_d']}")
        print(f"    q (log10 λ) ≈ {sol['q']}")
        print(f"    det(C_basis) = {sol['det']:.1f}")
        print()
    else:
        print("  No FN-like 3-spurion basis with q_j<0 was found in this mixed-sign")
        print("  search region (charges in [-C_basis_max, C_basis_max], with d_j ∈ multiples")
        print("  of 4 to enforce the (-4,4,3) relation at coefficient level).")
        print()

    # Evidence bookkeeping: structural only (no p-values, bits=0)
    if num_fn_like == 0:
        classification = "supporting_structure_shape"
        reason = (
            "Within mixed-sign charges |C_ij| <= C_basis_max and strictly sub-unity "
            "spurions (q_j<0), no invertible 3×3 integer basis for (me,mtau,md) "
            "enforcing the (-4,4,3) triple at coefficient level was found. This "
            "further constrains simple 3-spurion FN-like interpretations."
        )
    else:
        classification = "supporting_structure_shape"
        reason = (
            "Some 3-spurion FN-like bases with q_j<0 exist in the mixed-sign "
            "charge box |C_ij| <= C_basis_max while enforcing the (-4,4,3) triple "
            "at coefficient level. This shapes possible FN-like explanations but "
            "does not by itself constitute a new statistical lock."
        )

    bits = 0.0  # structural constraint only

    payload = {
        "module": "PHASE31_YUKAWA_3SPURION_FN_MIXED_SIGN_v1",
        "timestamp": timestamp,
        "C_basis_max": C_basis_max,
        "q_neg_only": q_neg_only,
        "num_candidates_total": num_candidates_total,
        "num_invertible": num_invertible,
        "num_fn_like": num_fn_like,
        "bits": bits,
        "classification": classification,
        "reason": reason,
    }
    sha = _sha256_payload(payload)

    print("=" * 80)
    print(" INTERPRETATION & VERDICT ")
    print("=" * 80)
    print()
    print(f"  classification : {classification}")
    print(f"  bits           : {bits:.2f} (by design: structural, not probabilistic)")
    print()
    print("  Summary:")
    print(f"    {reason}")
    print()
    print("  Evidence-budget status:")
    print("    → This is a SHAPE constraint on possible FN-like 3-spurion models.")
    print("    → It does NOT alter the global DNA + Yukawa triple contract (~20–27 bits).")
    print("    → Primary locks remain:")
    print("         1) DNA backbone / locks (~12.29 bits).")
    print("         2) me–mtau–md (-4,4,3) triple (7–14 bits).")
    print()

    # Update GEOM_EVIDENCE if present
    global GEOM_EVIDENCE
    try:
        GEOM_EVIDENCE  # type: ignore[name-defined]
    except NameError:
        GEOM_EVIDENCE = {}  # type: ignore[assignment]
        print("GEOM_EVIDENCE not found; creating new dict.")
        print()

    GEOM_EVIDENCE["yukawa_3spurion_fn_mixed_sign"] = {
        "C_basis_max": C_basis_max,
        "q_neg_only": q_neg_only,
        "num_candidates_total": num_candidates_total,
        "num_invertible": num_invertible,
        "num_fn_like": num_fn_like,
        "bits": bits,
        "classification": classification,
        "reason": reason,
        "timestamp": timestamp,
        "sha256": sha,
        "status": "supporting_structure_shape",
        "description": (
            "Search for 3-spurion FN-like bases with mixed-sign charges |C_ij| <= "
            "C_basis_max and q_j<0, enforcing the (-4,4,3) triple at coefficient "
            "level for (me,mtau,md). Structural constraint, not a new lock."
        ),
    }

    print("=" * 80)
    print(" GEOM_EVIDENCE UPDATE ")
    print("=" * 80)
    print()
    print("GEOM_EVIDENCE['yukawa_3spurion_fn_mixed_sign'] =")
    print(json.dumps(GEOM_EVIDENCE["yukawa_3spurion_fn_mixed_sign"], indent=2))
    print()
    print(f"Run SHA256 payload    : {sha}")
    print()
    print("PHASE31_YUKAWA_3SPURION_FN_MIXED_SIGN_v1 COMPLETE")
    print("=" * 80)


if __name__ == "__main__":
    run_phase31_yukawa_3spurion_fn_mixed_sign_search(
        C_basis_max=4,
        q_neg_only=True,
    )

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PHASE 31 – MODULE 2: 3-SPURION FN MODEL-SPACE SUMMARY & EVIDENCE (v1)

This module consolidates all the FN-related structural constraints we’ve
found so far for 3-spurion models tied to the (-4,4,3) Yukawa triple:

  • PHASE 23 – MODULE 1/2:
      - Toy3D FN-compatibility under small unimodular basis changes.
      - Result: no simple 3-spurion FN with non-negative charges equivalent
        to the Toy3D integer geometry within U ∈ {-1,0,1}^{3×3}.

  • PHASE 30 – MODULE 1/2:
      - From-scratch 3-spurion FN-like search with non-negative charges
        and q_j < 0 that enforces the (-4,4,3) triple for (me, mtau, md).
      - Result: num_basis_candidates = 0 for C_basis_max <= 4.

  • PHASE 31 – MODULE 1:
      - 3-spurion FN-like search with mixed-sign charges |C_ij| <= C_basis_max
        and q_j < 0, still enforcing (-4,4,3) at coefficient level.
      - Result: no invertible 3×3 basis found for C_basis_max = 4.

All of these are STRUCTURAL constraints (no null-model p-values), so they
contribute 0 bits to the global evidence budget, but significantly restrict
what a realistic FN-like geometry is allowed to look like.
"""

import json
import hashlib
from datetime import datetime

def _sha256_payload(obj) -> str:
    s = json.dumps(obj, sort_keys=True, separators=(",", ":")).encode("utf-8")
    return hashlib.sha256(s).hexdigest()


def run_phase31_3spurion_fn_summary() -> None:
    timestamp = datetime.now().isoformat()

    print("=" * 80)
    print(" PHASE 31 – MODULE 2: 3-SPURION FN MODEL-SPACE SUMMARY (v1) ")
    print("=" * 80)
    print()
    print(f"Run timestamp (local) : {timestamp}")
    print()

    # Try to read existing GEOM_EVIDENCE entries if present.
    global GEOM_EVIDENCE
    try:
        GEOM_EVIDENCE  # type: ignore[name-defined]
    except NameError:
        GEOM_EVIDENCE = {}  # type: ignore[assignment]

    toy3d_fn = GEOM_EVIDENCE.get("toy3d_fn_compatibility")
    fn_nonneg = GEOM_EVIDENCE.get("yukawa_3spurion_fn_search")
    fn_mixed = GEOM_EVIDENCE.get("yukawa_3spurion_fn_mixed_sign")

    print("=" * 80)
    print(" INPUT FN-LIKE CONSTRAINTS ")
    print("=" * 80)
    print()

    # 1) Toy3D FN-compatibility (Phase 23)
    print("1) Toy3D FN-compatibility (PHASE 23):")
    if toy3d_fn is None:
        print("   • GEOM_EVIDENCE['toy3d_fn_compatibility'] not found in memory.")
    else:
        print("   • status       :", toy3d_fn.get("status", "unknown"))
        print("   • bits         :", toy3d_fn.get("bits", 0.0))
        print("   • reason       :", toy3d_fn.get("reason", "<no reason stored>"))
    print()

    # 2) 3-spurion FN search with non-negative charges (Phase 30)
    print("2) 3-spurion FN search (non-negative charges, PHASE 30):")
    if fn_nonneg is None:
        print("   • GEOM_EVIDENCE['yukawa_3spurion_fn_search'] not found in memory.")
    else:
        print("   • C_basis_max         :", fn_nonneg.get("C_basis_max"))
        print("   • C_other_max         :", fn_nonneg.get("C_other_max"))
        print("   • q_neg_only          :", fn_nonneg.get("q_neg_only"))
        print("   • num_basis_candidates:", fn_nonneg.get("num_basis_candidates"))
        print("   • classification      :", fn_nonneg.get("classification"))
        print("   • bits                :", fn_nonneg.get("bits"))
        print("   • reason              :", fn_nonneg.get("reason"))
    print()

    # 3) 3-spurion FN search with mixed-sign charges (Phase 31 – M1)
    print("3) 3-spurion FN search (mixed-sign charges, PHASE 31 – M1):")
    if fn_mixed is None:
        print("   • GEOM_EVIDENCE['yukawa_3spurion_fn_mixed_sign'] not found in memory.")
    else:
        print("   • C_basis_max         :", fn_mixed.get("C_basis_max"))
        print("   • q_neg_only          :", fn_mixed.get("q_neg_only"))
        print("   • num_candidates_total:", fn_mixed.get("num_candidates_total"))
        print("   • num_invertible      :", fn_mixed.get("num_invertible"))
        print("   • num_fn_like         :", fn_mixed.get("num_fn_like"))
        print("   • classification      :", fn_mixed.get("classification"))
        print("   • bits                :", fn_mixed.get("bits"))
        print("   • reason              :", fn_mixed.get("reason"))
    print()

    # High-level qualitative summary
    print("=" * 80)
    print(" QUALITATIVE SUMMARY OF 3-SPURION FN SPACE ")
    print("=" * 80)
    print()
    print("  • Toy3D geometry cannot be mapped to a simple 3-spurion FN model")
    print("    with small unimodular basis changes, λ_j<1, and non-negative")
    print("    charges (PHASE 23).")
    print()
    print("  • From-scratch 3-spurion FN search with non-negative charges")
    print("    |C_ij| <= C_basis_max and q_j<0 found NO basis for (me, mtau, md)")
    print("    that enforces the (-4,4,3) triple at coefficient level (PHASE 30).")
    print()
    print("  • Even allowing mixed-sign charges within the same small box")
    print("    |C_ij| <= C_basis_max and q_j<0 (PHASE 31 – M1), we still found")
    print("    NO invertible 3×3 basis for (me, mtau, md) that enforces the")
    print("    (-4,4,3) relation at the coefficient level.")
    print()
    print("  Overall implication for model-building:")
    print("    • A naive 3-spurion Froggatt–Nielsen picture with small integer")
    print("      charges is strongly disfavored as an explanation of the")
    print("      (-4,4,3) Yukawa triple and Toy3D structure.")
    print("    • Any successful FN-like geometry will likely need more spurions,")
    print("      larger/integer charges, or additional discrete / combinatorial")
    print("      structure beyond textbook 3-spurion FN.")
    print()

    # Evidence-budget status (structural only)
    bits = 0.0
    classification = "supporting_structure_shape"
    reason = (
        "Combined 3-spurion FN constraints (Toy3D FN-compatibility, non-negative "
        "charge search, and mixed-sign small-charge search) show that simple "
        "3-spurion FN models with small integer charges and q_j<0 are incompatible "
        "with the (-4,4,3) Yukawa triple and the Toy3D geometry. This is a "
        "structural restriction, not a new probabilistic anomaly, so bits=0."
    )

    payload = {
        "module": "PHASE31_YUKAWA_3SPURION_FN_SUMMARY_v1",
        "timestamp": timestamp,
        "bits": bits,
        "classification": classification,
        "reason": reason,
        "sources_present": {
            "toy3d_fn_compatibility": toy3d_fn is not None,
            "yukawa_3spurion_fn_search": fn_nonneg is not None,
            "yukawa_3spurion_fn_mixed_sign": fn_mixed is not None,
        },
    }
    sha = _sha256_payload(payload)

    print("=" * 80)
    print(" EVIDENCE-BUDGET STATUS ")
    print("=" * 80)
    print()
    print(f"  classification : {classification}")
    print(f"  bits           : {bits:.2f} (by design: structural, not probabilistic)")
    print()
    print("  Summary:")
    print(f"    {reason}")
    print()
    print("  Global contract reminder:")
    print("    → PRIMARY LOCKS remain:")
    print("         1) DNA backbone / locks (~12.29 bits).")
    print("         2) me–mtau–md (-4,4,3) triple (7–14 bits).")
    print("    → These FN constraints only shape the space of candidate models;")
    print("      they do NOT change the ~20–27 bit target any geometry must hit.")
    print()

    # Update GEOM_EVIDENCE with a consolidated FN summary entry
    GEOM_EVIDENCE["yukawa_3spurion_fn_summary"] = {
        "bits": bits,
        "classification": classification,
        "reason": reason,
        "timestamp": timestamp,
        "sha256": sha,
        "status": "supporting_structure_shape",
        "description": (
            "Consolidated summary of 3-spurion FN constraints from Toy3D "
            "FN-compatibility (PHASE 23), non-negative charge search (PHASE 30), "
            "and mixed-sign small-charge search (PHASE 31 – M1). Shows that simple "
            "3-spurion FN models with small integer charges and q_j<0 are strongly "
            "disfavored as explanations of the (-4,4,3) Yukawa triple."
        ),
    }

    print("=" * 80)
    print(" GEOM_EVIDENCE UPDATE ")
    print("=" * 80)
    print()
    print("GEOM_EVIDENCE['yukawa_3spurion_fn_summary'] =")
    print(json.dumps(GEOM_EVIDENCE["yukawa_3spurion_fn_summary"], indent=2))
    print()
    print(f"Run SHA256 payload    : {sha}")
    print()
    print("PHASE31_YUKAWA_3SPURION_FN_SUMMARY_v1 COMPLETE")
    print("=" * 80)


if __name__ == "__main__":
    run_phase31_3spurion_fn_summary()
